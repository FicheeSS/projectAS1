; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Debug\Univers.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG262473 DB	'invalid argument', 00H
___asan_rrz_$SG262473 DD 0f9H
	ORG $+43
$SG262474 DB	'%s', 00H
___asan_rrz_$SG262474 DD 0f9H
	ORG $+57
$SG262475 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xmemory', 00H
___asan_rrz_$SG262475 DD 0f9H
	ORG $+52
$SG262476 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
___asan_rrz_$SG262476 DD 0f9H
	ORG $+44
$SG262477 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
___asan_rrz_$SG262477 DD 0f9H
	ORG $+46
$SG262478 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
___asan_rrz_$SG262478 DD 0f9H
	ORG $+54
$SG231304 DB	'Current Viewport : %d x %d', 00H
___asan_rrz_$SG231304 DD 0f9H
	ORG $+33
$SG231380 DB	'\Ressources\img', 00H
___asan_rrz_$SG231380 DD 0f9H
	ORG $+44
$SG231381 DB	'\Ressources\audio', 00H
___asan_rrz_$SG231381 DD 0f9H
	ORG $+42
$SG231382 DB	'\Ressources\img\backgrounds', 00H
___asan_rrz_$SG231382 DD 0f9H
	ORG $+32
$SG258354 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xlocale', 00H
___asan_rrz_$SG258354 DD 0f9H
	ORG $+52
$SG250660 DB	'Unable to open message catalog: ', 00H
___asan_rrz_$SG250660 DD 0f9H
	ORG $+59
$SG250667 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
___asan_rrz_$SG250667 DD 0f9H
	ORG $+86
$SG250668 DB	'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H
___asan_rrz_$SG250668 DD 0f9H
	ORG $+46
$SG250670 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
___asan_rrz_$SG250670 DD 0f9H
	ORG $+86
$SG250671 DB	'0', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'r', 00H
	DB	00H, 00H
___asan_rrz_$SG250671 DD 0f9H
CONST	ENDS
ASAN$GL	SEGMENT
_L___asan_global_$SG250671 DD FLAT:$SG250671
	DD	0eH
	DD	040H
	DD	FLAT:_L___asan_gen_.34
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.35
	DD	00H
_L___asan_global_$SG250670 DD FLAT:$SG250670
	DD	0106H
	DD	0160H
	DD	FLAT:_L___asan_gen_.32
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.33
	DD	00H
_L___asan_global_$SG250668 DD FLAT:$SG250668
	DD	0eH
	DD	040H
	DD	FLAT:_L___asan_gen_.30
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.31
	DD	00H
_L___asan_global_$SG250667 DD FLAT:$SG250667
	DD	0106H
	DD	0160H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
_L___asan_global_$SG250660 DD FLAT:$SG250660
	DD	021H
	DD	060H
	DD	FLAT:_L___asan_gen_.26
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.27
	DD	00H
_L___asan_global_$SG258354 DD FLAT:$SG258354
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.23
	DD	FLAT:_L___asan_gen_.22
	DD	00H
	DD	FLAT:_L___asan_gen_.24
	DD	00H
_L___asan_global_$SG231382 DD FLAT:$SG231382
	DD	01cH
	DD	040H
	DD	FLAT:_L___asan_gen_.20
	DD	FLAT:_L___asan_gen_.13
	DD	00H
	DD	FLAT:_L___asan_gen_.21
	DD	00H
_L___asan_global_$SG231381 DD FLAT:$SG231381
	DD	012H
	DD	040H
	DD	FLAT:_L___asan_gen_.18
	DD	FLAT:_L___asan_gen_.13
	DD	00H
	DD	FLAT:_L___asan_gen_.19
	DD	00H
_L___asan_global_$SG231380 DD FLAT:$SG231380
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.16
	DD	FLAT:_L___asan_gen_.13
	DD	00H
	DD	FLAT:_L___asan_gen_.17
	DD	00H
_L___asan_global_$SG231304 DD FLAT:$SG231304
	DD	01bH
	DD	040H
	DD	FLAT:_L___asan_gen_.14
	DD	FLAT:_L___asan_gen_.13
	DD	00H
	DD	FLAT:_L___asan_gen_.15
	DD	00H
_L___asan_global_$SG262478 DD FLAT:$SG262478
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.11
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.12
	DD	00H
_L___asan_global_$SG262477 DD FLAT:$SG262477
	DD	04eH
	DD	080H
	DD	FLAT:_L___asan_gen_.9
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.10
	DD	00H
_L___asan_global_$SG262476 DD FLAT:$SG262476
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.7
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.8
	DD	00H
_L___asan_global_$SG262475 DD FLAT:$SG262475
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.5
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.6
	DD	00H
_L___asan_global_$SG262474 DD FLAT:$SG262474
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
_L___asan_global_$SG262473 DD FLAT:$SG262473
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
CONST	SEGMENT
	ORG $+46
_L___asan_gen_.0 DB 'xmemory', 00H
_L___asan_gen_.1 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.3 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.5 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.6 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.7 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.8 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.9 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.10 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.11 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.12 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.13 DB 'Univers.cpp', 00H
_L___asan_gen_.14 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.15 DD FLAT:_L___asan_gen_.13
	DD	097H
	DD	010H
_L___asan_gen_.16 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.17 DD FLAT:_L___asan_gen_.13
	DD	0a3H
	DD	018H
_L___asan_gen_.18 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.19 DD FLAT:_L___asan_gen_.13
	DD	0a4H
	DD	01eH
_L___asan_gen_.20 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.21 DD FLAT:_L___asan_gen_.13
	DD	0a5H
	DD	020H
_L___asan_gen_.22 DB 'xlocale', 00H
_L___asan_gen_.23 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.24 DD FLAT:_L___asan_gen_.22
	DD	020eH
	DD	059H
_L___asan_gen_.25 DB 'w32_regex_traits.hpp', 00H
	ORG $+3
_L___asan_gen_.26 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.27 DD FLAT:_L___asan_gen_.25
	DD	02c1H
	DD	01aH
_L___asan_gen_.28 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.25
	DD	02f7H
	DD	06H
_L___asan_gen_.30 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.31 DD FLAT:_L___asan_gen_.25
	DD	02f7H
	DD	06H
_L___asan_gen_.32 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.33 DD FLAT:_L___asan_gen_.25
	DD	0314H
	DD	06H
_L___asan_gen_.34 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.35 DD FLAT:_L___asan_gen_.25
	DD	0314H
	DD	06H
CONST	ENDS
msvcjmc	SEGMENT
__B3577796_RenderStates@hpp DB 01H
__705FE7F9_iostream DB 01H
__59466570_predefined C++ types (compiler internal) DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__47F37C5A_xtr1common DB 01H
__81812A28_cstddef DB 01H
__7FE5F402_limits DB 01H
__97D3638F_vcruntime_new@h DB 01H
__589FA321_type_traits DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__A751F051_corecrt_memory@h DB 01H
__32E5F013_string@h DB 01H
__DD5FCA34_compare DB 01H
__12269DE6_xutility DB 01H
__C69F69CF_tuple DB 01H
__79D216CD_xmemory DB 01H
__374A57BA_xpolymorphic_allocator@h DB 01H
__0D019051_xstring DB 01H
__B2D2BA86_ctype@h DB 01H
__B7987E10_string DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__C34BF88C_memory DB 01H
__60BC708E_cmath DB 01H
__68B92D9D_xbit_ops@h DB 01H
__0F13B0E8_xhash DB 01H
__BFE0F84B_functional DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__1B354CA2_system_error DB 01H
__3A667B81_error_category@hpp DB 01H
__25339F4A_generic_category_message@hpp DB 01H
__A4E336F0_generic_category@hpp DB 01H
__2DD6F2A3_error_condition@hpp DB 01H
__C6D9B9B2_system_category@hpp DB 01H
__1B11AAFA_snprintf@hpp DB 01H
__6767E947_error_handling@hpp DB 01H
__EE1D0242_system_category_message_win32@hpp DB 01H
__F4D1038E_system_category_condition_win32@hpp DB 01H
__1D2FDE06_system_category_impl@hpp DB 01H
__13E3B269_interop_category@hpp DB 01H
__EF0EAF83_xfacet DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__F4A89B3F_error_code@hpp DB 01H
__C655F023_std_category@hpp DB 01H
__51E12D41_error_category_impl@hpp DB 01H
__FE33131C_xlocmes DB 01H
__67DA974F_xlocmon DB 01H
__D96D2425_xloctime DB 01H
__147DD91B_path_traits@hpp DB 01H
__CE27CDA6_facade_iterator_category@hpp DB 01H
__FCD69F0E_ios_state@hpp DB 01H
__32E57CF6_path@hpp DB 01H
__0269C046_errc@hpp DB 01H
__38C7FDF2_throws@hpp DB 01H
__B76B1A2C_system_error@hpp DB 01H
__8868518C_atomic_count_std_atomic@hpp DB 01H
__BFCE1B3F_intrusive_ref_counter@hpp DB 01H
__203D301F_exception@hpp DB 01H
__6D84B491_file_status@hpp DB 01H
__9E7B425B_directory@hpp DB 01H
__994C2822_operations@hpp DB 01H
__85CA39D3_convenience@hpp DB 01H
__54B77B77_fstream DB 01H
__819F9458_fstream@hpp DB 01H
__807252DF_string_file@hpp DB 01H
__1589CDA2_algorithm DB 01H
__2B558C5C_implementation_help@hpp DB 01H
__53FD89EC_noncopyable@hpp DB 01H
__249AC1FF_as_literal@hpp DB 01H
__CCA81496_classification@hpp DB 01H
__9E8302C5_classification@hpp DB 01H
__291069DD_compare@hpp DB 01H
__6E0894BC_finder@hpp DB 01H
__6005BCF8_finder@hpp DB 01H
__876C1A82_exception@hpp DB 01H
__C6048E53_current_function@hpp DB 01H
__550A1F1C_source_location@hpp DB 01H
__78E6F2C5_throw_exception@hpp DB 01H
__36989B12_demangle@hpp DB 01H
__DBA21239_stl_type_index@hpp DB 01H
__DFD8B503_function_base@hpp DB 01H
__0C0FE920_ratio DB 01H
__2D75401A___msvc_tzdb@hpp DB 01H
__7BF231E7_optional DB 01H
__324884E2_vector DB 01H
__1347750E_utility DB 01H
__20D3AEFC_forward_list DB 01H
__1B08F288_chrono DB 01H
__491EF713_xfilesystem_abi@h DB 01H
__2B6093AE_list DB 01H
__B111E740_filesystem DB 01H
__B26BA995_regex DB 01H
__B2A9EE53_InputStream@hpp DB 01H
__62DD75E3_NonCopyable@hpp DB 01H
__FC4CDF9C_Thread@inl DB 01H
__69958C8C_xtree DB 01H
__C78A343B_SoundFileReader@hpp DB 01H
__5D3957BC_SoundFileWriter@hpp DB 01H
__A5341E86_regex_workaround@hpp DB 01H
__84A6C509_regex_traits_defaults@hpp DB 01H
__C72864EE_pattern_except@hpp DB 01H
__8A32E06C_stop_token DB 01H
__1806803A_thread DB 01H
__1EA2E370_mutex DB 01H
__BC8232E2_cpp_regex_traits@hpp DB 01H
__EF9A24B2_c_regex_traits@hpp DB 01H
__79C7FC57_basetsd@h DB 01H
__D545DD43_guiddef@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__D4435474_winerror@h DB 01H
__B3ED30D4_winbase@h DB 01H
__DB057BA3_winuser@h DB 01H
__A118E6DC_stralign@h DB 01H
__43AE03FC_w32_regex_traits@hpp DB 01H
__ED044598_match_flags@hpp DB 01H
__9829EA86_regex_raw_buffer@hpp DB 01H
__BA42420E_basic_regex@hpp DB 01H
__F162022C_set DB 01H
__3C41319C_indexed_bit_flag@hpp DB 01H
__A750400E_basic_regex_creator@hpp DB 01H
__CFA0C522_basic_regex_parser@hpp DB 01H
__23D98615_mem_block_cache@hpp DB 01H
__0A52C9A5_perl_matcher_non_recursive@hpp DB 01H
__C1A77E9F_perl_matcher@hpp DB 01H
__28BBFA9C_RessourcePack@h DB 01H
__3C1C7D88_ContextSettings@hpp DB 01H
__8D991C03_Drawable@hpp DB 01H
__896EE8A8_Glyph@hpp DB 01H
__E3A1A8C3_Font@hpp DB 01H
__0D6BD463_Character@h DB 01H
__372D2D08_initializer_list DB 01H
__E458E21C_xstddef DB 01H
__218DFE2C_Levels@h DB 01H
__9344C8DF_Block@h DB 01H
__7385D044_any DB 01H
__78BC29F0_TerrainConstructor@h DB 01H
__9D99E827_Terrain@h DB 01H
__B4613F23_Sprite@hpp DB 01H
__4FA62C6D_Univers@h DB 01H
__91E4D184_Univers@cpp DB 01H
__A2FF0B9E_istream DB 01H
__FA839AC8_operator_bool@hpp DB 01H
__0FFFED91_intrusive_ptr@hpp DB 01H
__B38B2551_iterator_facade@hpp DB 01H
__68A60A21_locale DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__038A2AA6_iterator DB 01H
__B30C2184_iosfwd DB 01H
__0A631FEE_Vector2@inl DB 01H
__CBE11649_Vector2@hpp DB 01H
__C23CD225_Rect@inl DB 01H
__03BEDB82_Rect@hpp DB 01H
__F1CBF088_type_index@hpp DB 01H
__68C17CDA_primary_transform@hpp DB 01H
__F54903A0_xatomic@h DB 01H
__1CB4EB11_addressof@hpp DB 01H
__1EB17C13_integral_constant@hpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_wmemcpy
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0?$tuple@$$V@std@@QAE@ABV01@@Z		; std::tuple<>::tuple<>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked
PUBLIC	?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Char_traits@DH@std@@SAPADQADID@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??1invalid_argument@std@@UAE@XZ			; std::invalid_argument::~invalid_argument
PUBLIC	??$forward@ABI@std@@YAABIABI@Z			; std::forward<unsigned int const &>
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z	; sf::Rect<int>::Rect<int>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
PUBLIC	?deallocate@?$allocator@I@std@@QAEXQAII@Z	; std::allocator<unsigned int>::deallocate
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
PUBLIC	?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
PUBLIC	?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
PUBLIC	?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
PUBLIC	?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range
PUBLIC	?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
PUBLIC	?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
PUBLIC	?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xran
PUBLIC	?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::__autoclassinit2
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
PUBLIC	??0?$initializer_list@H@std@@QAE@PBH0@Z		; std::initializer_list<int>::initializer_list<int>
PUBLIC	?begin@?$initializer_list@H@std@@QBEPBHXZ	; std::initializer_list<int>::begin
PUBLIC	?end@?$initializer_list@H@std@@QBEPBHXZ		; std::initializer_list<int>::end
PUBLIC	??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
PUBLIC	?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
PUBLIC	??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
PUBLIC	?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
PUBLIC	?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
PUBLIC	??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z ; RessourcePack::getImgBackground
PUBLIC	?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z ; RessourcePack::getLevelMusic
PUBLIC	?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
PUBLIC	?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
PUBLIC	?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
PUBLIC	?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
PUBLIC	?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange
PUBLIC	??0?$Rect@M@sf@@QAE@MMMM@Z			; sf::Rect<float>::Rect<float>
PUBLIC	??_GSprite@sf@@UAEPAXI@Z			; sf::Sprite::`scalar deleting destructor'
PUBLIC	?show@Character@@QAEXPAVRenderWindow@sf@@@Z	; Character::show
PUBLIC	?getRect@Character@@QAE?AV?$Rect@H@sf@@XZ	; Character::getRect
PUBLIC	?getX@Character@@QAEMXZ				; Character::getX
PUBLIC	?getY@Character@@QAEMXZ				; Character::getY
PUBLIC	?setMaxX@Character@@QAEXH@Z			; Character::setMaxX
PUBLIC	?getSize@Character@@QAE?AV?$Vector2@I@sf@@XZ	; Character::getSize
PUBLIC	?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
PUBLIC	?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
PUBLIC	??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
PUBLIC	?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
PUBLIC	?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
PUBLIC	?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
PUBLIC	?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
PUBLIC	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
PUBLIC	??$distance@PBH@std@@YAHPBH0@Z			; std::distance<int const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z	; std::_Get_unwrapped<int const * const &>
PUBLIC	??$to_address@$$CBH@std@@YAPBHQBH@Z		; std::to_address<int const >
PUBLIC	??$to_address@H@std@@YAPAHQAH@Z			; std::to_address<int>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z	; std::_Copy_memmove<int const *,int *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$construct_at@HABHX@std@@YAPAHQAHABH@Z	; std::construct_at<int,int const &,void>
PUBLIC	??$_Voidify_iter@PAH@std@@YAPAXPAH@Z		; std::_Voidify_iter<int *>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
PUBLIC	??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
PUBLIC	??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
PUBLIC	??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
PUBLIC	??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
PUBLIC	??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
PUBLIC	??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z	; std::construct_at<int,int &,void>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
PUBLIC	?getX@Block@@QAEMXZ				; Block::getX
PUBLIC	?getY@Block@@QAEMXZ				; Block::getY
PUBLIC	?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ	; TerrainConstructor::getPlayer
PUBLIC	?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
PUBLIC	?getPlayer@Terrain@@QAEPAVPlayer@@XZ		; Terrain::getPlayer
PUBLIC	?getElementAtPos@Terrain@@QAEPAVBlock@@H@Z	; Terrain::getElementAtPos
PUBLIC	?getSizeX@Terrain@@QAEIXZ			; Terrain::getSizeX
PUBLIC	?getSizeY@Terrain@@QAEIXZ			; Terrain::getSizeY
PUBLIC	?__autoclassinit2@Terrain@@QAEXI@Z		; Terrain::__autoclassinit2
PUBLIC	??_GTerrain@@QAEPAXI@Z				; Terrain::`scalar deleting destructor'
PUBLIC	?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z ; std::vector<Block *,std::allocator<Block *> >::erase
PUBLIC	?begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@XZ ; std::vector<Block *,std::allocator<Block *> >::begin
PUBLIC	?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
PUBLIC	?size@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QBEIXZ ; std::vector<Block *,std::allocator<Block *> >::size
PUBLIC	?at@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEAAPAVBlock@@I@Z ; std::vector<Block *,std::allocator<Block *> >::at
PUBLIC	?_Xrange@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@CAXXZ ; std::vector<Block *,std::allocator<Block *> >::_Xrange
PUBLIC	?_Orphan_range_unlocked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@AAEAAV?$allocator@PAVBlock@@@2@XZ ; std::vector<Block *,std::allocator<Block *> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVBlock@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVBlock@@@2@XZ ; std::_Compressed_pair<std::allocator<Block *>,std::_Vector_val<std::_Simple_types<Block *> >,1>::_Get_first
PUBLIC	??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z		; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>
PUBLIC	?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ; std::tuple<enum DIRDEP>::_Get_rest
PUBLIC	??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z	; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>
PUBLIC	?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
PUBLIC	??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z ; Univers::Univers
PUBLIC	?animate@Univers@@QAEXXZ			; Univers::animate
PUBLIC	?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z ; Univers::collision
PUBLIC	?loadTerrain@Univers@@QAEXH@Z			; Univers::loadTerrain
PUBLIC	??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
PUBLIC	??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP>
PUBLIC	??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
PUBLIC	??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
PUBLIC	??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
PUBLIC	??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::__autoclassinit2
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	??0?$Vector2@H@sf@@QAE@HH@Z			; sf::Vector2<int>::Vector2<int>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Block *> > >
PUBLIC	??$_Move_unchecked@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z ; std::_Move_unchecked<Block * *,Block * *>
PUBLIC	??$_Unfancy@PAVBlock@@@std@@YAPAPAVBlock@@PAPAV1@@Z ; std::_Unfancy<Block *>
PUBLIC	??$destroy@PAVBlock@@@?$_Default_allocator_traits@V?$allocator@PAVBlock@@@std@@@std@@SAXAAV?$allocator@PAVBlock@@@1@QAPAVBlock@@@Z ; std::_Default_allocator_traits<std::allocator<Block *> >::destroy<Block *>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YAII@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::__autoclassinit2
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
PUBLIC	??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2
PUBLIC	??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
PUBLIC	??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z	; std::_Move_unchecked<unsigned int *,unsigned int *>
PUBLIC	??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >
PUBLIC	??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
PUBLIC	??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>
PUBLIC	??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$construct_at@DABDX@std@@YAPADQADABD@Z	; std::construct_at<char,char const &,void>
PUBLIC	??$_Voidify_iter@PAD@std@@YAPAXPAD@Z		; std::_Voidify_iter<char *>
PUBLIC	??$forward@ABD@std@@YAABDABD@Z			; std::forward<char const &>
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
PUBLIC	??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z	; std::_Unfancy_maybe_null<unsigned int>
PUBLIC	??$_To_address@PBH@std@@YA?A_PABQBH@Z		; std::_To_address<int const *>
PUBLIC	??$_To_address@PAH@std@@YA?A_PABQAH@Z		; std::_To_address<int *>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
PUBLIC	??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z ; std::forward<std::tuple<enum DIRDEP> >
PUBLIC	??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>
PUBLIC	??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>
PUBLIC	??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
PUBLIC	??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>
PUBLIC	??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>
PUBLIC	??$move@AAPAVBlock@@@std@@YA$$QAPAVBlock@@AAPAV1@@Z ; std::move<Block * &>
PUBLIC	??$to_address@PAVBlock@@@std@@YAPAPAVBlock@@QAPAV1@@Z ; std::to_address<Block *>
PUBLIC	??$_Copy_memmove@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z ; std::_Copy_memmove<Block * *,Block * *>
PUBLIC	??$destroy_at@PAVBlock@@@std@@YAXQAPAVBlock@@@Z	; std::destroy_at<Block *>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$move@AAI@std@@YA$$QAIAAI@Z			; std::move<unsigned int &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &,void>
PUBLIC	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$to_address@I@std@@YAPAIQAI@Z			; std::to_address<unsigned int>
PUBLIC	??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z	; std::_Copy_memmove<unsigned int *,unsigned int *>
PUBLIC	??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ; std::forward<std::allocator<unsigned int> >
PUBLIC	??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z ; std::forward<std::allocator<unsigned int> const &>
PUBLIC	??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>
PUBLIC	??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>
PUBLIC	??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>
PUBLIC	??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z ; std::_To_address<Block * *>
PUBLIC	??$_To_address@PAI@std@@YA?A_PABQAI@Z		; std::_To_address<unsigned int *>
PUBLIC	??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z	; std::_Get_unwrapped<unsigned int * const &>
PUBLIC	??$_Unfancy@I@std@@YAPAIPAI@Z			; std::_Unfancy<unsigned int>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::__autoclassinit2
PUBLIC	??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>
PUBLIC	??$_Is_all_bits_zero@I@std@@YA_NABI@Z		; std::_Is_all_bits_zero<unsigned int>
PUBLIC	??$_Fill_zero_memset@PAI@std@@YAXPAII@Z		; std::_Fill_zero_memset<unsigned int *>
PUBLIC	??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>
PUBLIC	??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
PUBLIC	??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
PUBLIC	??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
PUBLIC	??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>
PUBLIC	??$forward@AAI@std@@YAAAIAAI@Z			; std::forward<unsigned int &>
PUBLIC	??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>
PUBLIC	??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$construct_at@IABIX@std@@YAPAIQAIABI@Z	; std::construct_at<unsigned int,unsigned int const &,void>
PUBLIC	??$_Voidify_iter@PAI@std@@YAPAXPAI@Z		; std::_Voidify_iter<unsigned int *>
PUBLIC	??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z	; std::construct_at<unsigned int,unsigned int &,void>
PUBLIC	??_ESprite@sf@@W3AEPAXI@Z			; [thunk]:sf::Sprite::`vector deleting destructor'
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_SSprite@sf@@6BDrawable@1@@			; sf::Sprite::`local vftable'
PUBLIC	??_SSprite@sf@@6BTransformable@1@@		; sf::Sprite::`local vftable'
PUBLIC	?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
PUBLIC	??_R0?AVBlock@@@8				; Block `RTTI Type Descriptor'
PUBLIC	??_R0?AVInteractiveObject@@@8			; InteractiveObject `RTTI Type Descriptor'
PUBLIC	??_R0?AVinvalid_argument@std@@@8		; std::invalid_argument `RTTI Type Descriptor'
PUBLIC	??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ ; `string'
PUBLIC	??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@ ; `string'
PUBLIC	??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
PUBLIC	??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ ; `string'
PUBLIC	??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ ; `string'
PUBLIC	??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ ; `string'
PUBLIC	??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ ; `string'
PUBLIC	??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ ; `string'
PUBLIC	??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@ ; `string'
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@ ; `string'
PUBLIC	??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@ ; `string'
PUBLIC	??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@ ; `string'
PUBLIC	??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ ; `string'
PUBLIC	??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@ ; `string'
PUBLIC	??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ ; `string'
PUBLIC	??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Sprite@sf@@6BDrawable@1@@			; sf::Sprite::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSprite@sf@@@8				; sf::Sprite `RTTI Type Descriptor'
PUBLIC	??_R3Sprite@sf@@8				; sf::Sprite::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Sprite@sf@@8				; sf::Sprite::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Sprite@sf@@8			; sf::Sprite::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Drawable@sf@@8			; sf::Drawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDrawable@sf@@@8				; sf::Drawable `RTTI Type Descriptor'
PUBLIC	??_R3Drawable@sf@@8				; sf::Drawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Drawable@sf@@8				; sf::Drawable::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@Transformable@sf@@8		; sf::Transformable::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVTransformable@sf@@@8			; sf::Transformable `RTTI Type Descriptor'
PUBLIC	??_R3Transformable@sf@@8			; sf::Transformable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Transformable@sf@@8			; sf::Transformable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Transformable@sf@@8		; sf::Transformable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Sprite@sf@@6BTransformable@1@@		; sf::Sprite::`RTTI Complete Object Locator'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?uncaught_exceptions@std@@YAHXZ:PROC		; std::uncaught_exceptions
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_??0Color@sf@@QAE@EEEE@Z:PROC
EXTRN	__imp_??0Clock@sf@@QAE@XZ:PROC
EXTRN	__imp_?setLoop@SoundStream@sf@@QAEX_N@Z:PROC
EXTRN	?generateImg@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; RessourcePack::generateImg
EXTRN	?generateBackgrounds@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; RessourcePack::generateBackgrounds
EXTRN	?generateAudioData@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; RessourcePack::generateAudioData
EXTRN	__imp_?close@Window@sf@@QAEXXZ:PROC
EXTRN	__imp_?isOpen@Window@sf@@QBE_NXZ:PROC
EXTRN	__imp_?pollEvent@Window@sf@@QAE_NAAVEvent@2@@Z:PROC
EXTRN	__imp_?display@Window@sf@@QAEXXZ:PROC
EXTRN	__imp_??0Texture@sf@@QAE@XZ:PROC
EXTRN	__imp_?loadFromImage@Texture@sf@@QAE_NABVImage@2@ABV?$Rect@H@2@@Z:PROC
EXTRN	__imp_?setSmooth@Texture@sf@@QAEX_N@Z:PROC
EXTRN	__imp_?setRepeated@Texture@sf@@QAEX_N@Z:PROC
EXTRN	__imp_??0View@sf@@QAE@ABV?$Rect@M@1@@Z:PROC
EXTRN	__imp_?clear@RenderTarget@sf@@QAEXABVColor@2@@Z:PROC
EXTRN	__imp_?setView@RenderTarget@sf@@QAEXABVView@2@@Z:PROC
EXTRN	__imp_?draw@RenderTarget@sf@@QAEXABVDrawable@2@ABVRenderStates@2@@Z:PROC
EXTRN	__imp_??0Sprite@sf@@QAE@ABVTexture@1@@Z:PROC
EXTRN	__imp_??1Sprite@sf@@UAE@XZ:PROC
EXTRN	??_ESprite@sf@@UAEPAXI@Z:PROC			; sf::Sprite::`vector deleting destructor'
EXTRN	?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z:PROC ; Character::move
EXTRN	?show@Block@@QAEXPAVRenderWindow@sf@@@Z:PROC	; Block::show
EXTRN	?collide@Block@@QAE_NV?$Rect@H@sf@@@Z:PROC	; Block::collide
EXTRN	??0Terrain@@QAE@PAVRessourcePack@@@Z:PROC	; Terrain::Terrain
EXTRN	?loadTerrain@Terrain@@QAEXH@Z:PROC		; Terrain::loadTerrain
EXTRN	??1Terrain@@QAE@XZ:PROC				; Terrain::~Terrain
EXTRN	?draw@Sprite@sf@@EBEXAAVRenderTarget@2@VRenderStates@2@@Z:PROC ; sf::Sprite::draw
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___RTDynamicCast:PROC
EXTRN	___asan_load4:PROC
EXTRN	___asan_loadN:PROC
EXTRN	___asan_memcpy:PROC
EXTRN	___asan_memset:PROC
EXTRN	___asan_report_load1:PROC
EXTRN	___asan_report_load16:PROC
EXTRN	___asan_report_load4:PROC
EXTRN	___asan_report_load8:PROC
EXTRN	___asan_report_store1:PROC
EXTRN	___asan_report_store16:PROC
EXTRN	___asan_report_store2:PROC
EXTRN	___asan_report_store4:PROC
EXTRN	___asan_report_store8:PROC
EXTRN	___asan_set_shadow_00:PROC
EXTRN	___asan_set_shadow_f8:PROC
EXTRN	___asan_store4:PROC
EXTRN	___asan_storeN:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?Default@RenderStates@sf@@2V12@B:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
___asan_rrz_?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DB 038H DUP (?)
_BSS	ENDS
;	COMDAT ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A
_BSS	SEGMENT
?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 010H DUP (?) ; level1
___asan_rrz_?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 030H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
___asan_rrz_??_C@_0BC@EOODALEL@Unknown?5exception@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
___asan_rrz_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
___asan_rrz_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
___asan_rrz_??_C@_02DKCKIIND@?$CFs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xmemory', 00H	; `string'
___asan_rrz_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
___asan_rrz_??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
CONST	SEGMENT
??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'I', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '_', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '1', 00H
	DB	'2', 00H, ':', 00H, ':', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'p'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, '_', 00H, 'm', 00H, 'e', 00H
	DB	'_', 00H, 'u', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, 'e', 00H, 'd', 00H, '_', 00H, 'v', 00H, '3', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
___asan_rrz_??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
___asan_rrz_??_C@_0BA@JFNIOLAK@string?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocale', 00H	; `string'
___asan_rrz_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocnum', 00H	; `string'
___asan_rrz_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
CONST	SEGMENT
??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ DB 'vector erase '
	DB	'iterator outside range', 00H		; `string'
___asan_rrz_??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\vector', 00H	; `string'
___asan_rrz_??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@
CONST	SEGMENT
??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'B', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, '*', 00H, ',', 00H, 'c'
	DB	00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H, ' '
	DB	00H, 'B', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H
	DB	'*', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
___asan_rrz_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
___asan_rrz_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
___asan_rrz_??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized vector<bool> iterator', 00H ; `string'
___asan_rrz_??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'b', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, '<', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'W', 00H
	DB	'r', 00H, 'a', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'G', 00H
	DB	'e', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'"', 00H, 00H, 00H				; `string'
___asan_rrz_??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
CONST	SEGMENT
??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DB 'vector<b'
	DB	'ool> iterator not dereferenceable', 00H	; `string'
___asan_rrz_??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '"', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
CONST	SEGMENT
??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DB 'invalid ve'
	DB	'ctor<bool> subscript', 00H			; `string'
___asan_rrz_??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
CONST	SEGMENT
??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DB 'vector<'
	DB	'bool> subscript out of range', 00H		; `string'
___asan_rrz_??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
CONST	SEGMENT
??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H
	DB	':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' '
	DB	00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
CONST	SEGMENT
??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'W', 00H, 'r', 00H
	DB	'a', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n', 00H, 's'
	DB	00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*'
	DB	00H, 00H, 00H				; `string'
___asan_rrz_??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@ DB 'vector<bool> too lo'
	DB	'ng', 00H					; `string'
___asan_rrz_??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
___asan_rrz_??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
CONST	SEGMENT
??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'[', 00H, ']', 00H, 00H, 00H			; `string'
___asan_rrz_??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
CONST	SEGMENT
??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 's', 00H, 'e', 00H, 00H, 00H		; `string'
___asan_rrz_??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@
CONST	SEGMENT
??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@ DB 'cannot seek v'
	DB	'alue-initialized vector iterator', 00H	; `string'
___asan_rrz_??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 'B', 00H, 'l', 00H
	DB	'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, '*', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'V', 00H, 'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_'
	DB	00H, 'o', 00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H
	DB	00H, 00H					; `string'
___asan_rrz_??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@
CONST	SEGMENT
??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'e', 00H, 'k', 00H, ' ', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'"', 00H, 00H, 00H				; `string'
___asan_rrz_??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@
CONST	SEGMENT
??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@ DB 'cannot seek v'
	DB	'ector iterator before begin', 00H		; `string'
___asan_rrz_??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
CONST	SEGMENT
??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'e', 00H, 'k', 00H, ' ', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'g', 00H, 'i'
	DB	00H, 'n', 00H, '"', 00H, 00H, 00H		; `string'
___asan_rrz_??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@
CONST	SEGMENT
??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@ DB 'cannot seek v'
	DB	'ector iterator after end', 00H		; `string'
___asan_rrz_??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
CONST	SEGMENT
??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'e', 00H, 'k', 00H, ' ', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'a', 00H, 'f', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'd', 00H, '"', 00H, 00H
	DB	00H						; `string'
___asan_rrz_??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD 0f9H
CONST	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?level1$initializer$@@3P6AXXZA DD FLAT:??__Elevel1@@YAXXZ ; level1$initializer$
CRT$XCU	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	DD	01aH
	DD	040H
	DD	FLAT:_L___asan_gen_.100
	DD	FLAT:_L___asan_gen_.49
	DD	00H
	DD	FLAT:_L___asan_gen_.101
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.101 DD FLAT:_L___asan_gen_.49
	DD	0b4H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.100 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DD FLAT:??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
	DD	0deH
	DD	0100H
	DD	FLAT:_L___asan_gen_.98
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.99
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.99 DD FLAT:_L___asan_gen_.36
	DD	06eH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.98 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DD FLAT:??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
	DD	050H
	DD	080H
	DD	FLAT:_L___asan_gen_.96
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.97
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.97 DD FLAT:_L___asan_gen_.36
	DD	074H
	DD	0cH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.96 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@ DD FLAT:??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.94
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.95
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.95 DD FLAT:_L___asan_gen_.36
	DD	074H
	DD	0cH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.94 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DD FLAT:??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
	DD	056H
	DD	080H
	DD	FLAT:_L___asan_gen_.92
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.93
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.93 DD FLAT:_L___asan_gen_.36
	DD	070H
	DD	0cH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.92 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@ DD FLAT:??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@
	DD	029H
	DD	060H
	DD	FLAT:_L___asan_gen_.90
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.91
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.91 DD FLAT:_L___asan_gen_.36
	DD	070H
	DD	0cH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.90 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@ DD FLAT:??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@
	DD	060H
	DD	080H
	DD	FLAT:_L___asan_gen_.88
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.89
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.89 DD FLAT:_L___asan_gen_.36
	DD	06eH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.88 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DD FLAT:??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
	DD	0e0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.86
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.87
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.87 DD FLAT:_L___asan_gen_.36
	DD	06eH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.86 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@ DD FLAT:??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@
	DD	02eH
	DD	060H
	DD	FLAT:_L___asan_gen_.84
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.85
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.85 DD FLAT:_L___asan_gen_.36
	DD	06eH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.84 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DD FLAT:??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
	DD	08aH
	DD	0c0H
	DD	FLAT:_L___asan_gen_.82
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.83
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.83 DD FLAT:_L___asan_gen_.36
	DD	059bH
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.82 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DD FLAT:??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
	DD	040H
	DD	060H
	DD	FLAT:_L___asan_gen_.80
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.81
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.81 DD FLAT:_L___asan_gen_.36
	DD	061dH
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.80 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DD FLAT:??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
	DD	096H
	DD	0c0H
	DD	FLAT:_L___asan_gen_.78
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.79
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.79 DD FLAT:_L___asan_gen_.36
	DD	061eH
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.78 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DD FLAT:??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
	DD	01eH
	DD	040H
	DD	FLAT:_L___asan_gen_.76
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.77
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.77 DD FLAT:_L___asan_gen_.36
	DD	061dH
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.76 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@ DD FLAT:??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@
	DD	016H
	DD	040H
	DD	FLAT:_L___asan_gen_.74
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.75
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.75 DD FLAT:_L___asan_gen_.36
	DD	0c15H
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.74 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DD FLAT:??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
	DD	0baH
	DD	0e0H
	DD	FLAT:_L___asan_gen_.72
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.73
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.73 DD FLAT:_L___asan_gen_.36
	DD	091cH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.72 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DD FLAT:??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
	DD	04cH
	DD	080H
	DD	FLAT:_L___asan_gen_.70
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.71
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.71 DD FLAT:_L___asan_gen_.36
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.70 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DD FLAT:??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
	DD	076H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.68
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.69
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.69 DD FLAT:_L___asan_gen_.36
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.68 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DD FLAT:??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
	DD	024H
	DD	060H
	DD	FLAT:_L___asan_gen_.66
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.67
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.67 DD FLAT:_L___asan_gen_.36
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.66 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DD FLAT:??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
	DD	01fH
	DD	040H
	DD	FLAT:_L___asan_gen_.64
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.65
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.65 DD FLAT:_L___asan_gen_.36
	DD	0c19H
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.64 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DD FLAT:??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
	DD	058H
	DD	080H
	DD	FLAT:_L___asan_gen_.62
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.63
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.63 DD FLAT:_L___asan_gen_.36
	DD	0824H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.62 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DD FLAT:??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
	DD	02aH
	DD	060H
	DD	FLAT:_L___asan_gen_.60
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.61
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.61 DD FLAT:_L___asan_gen_.36
	DD	0824H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.60 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DD FLAT:??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
	DD	07aH
	DD	0a0H
	DD	FLAT:_L___asan_gen_.58
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.59
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.59 DD FLAT:_L___asan_gen_.36
	DD	0823H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.58 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DD FLAT:??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	DD	0b6H
	DD	0e0H
	DD	FLAT:_L___asan_gen_.56
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.57
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.57 DD FLAT:_L___asan_gen_.36
	DD	0823H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.56 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DD FLAT:??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
	DD	03bH
	DD	060H
	DD	FLAT:_L___asan_gen_.54
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.55
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.55 DD FLAT:_L___asan_gen_.36
	DD	0823H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.54 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DD FLAT:??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
	DD	019H
	DD	040H
	DD	FLAT:_L___asan_gen_.52
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.53
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.53 DD FLAT:_L___asan_gen_.36
	DD	06f2H
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.52 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	DD	0dH
	DD	040H
	DD	FLAT:_L___asan_gen_.50
	DD	FLAT:_L___asan_gen_.49
	DD	00H
	DD	FLAT:_L___asan_gen_.51
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.51 DD FLAT:_L___asan_gen_.49
	DD	01b7H
	DD	030H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.50 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.49 DB 'xloctime', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.47
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.48
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.48 DD FLAT:_L___asan_gen_.36
	DD	06eeH
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.47 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ DD FLAT:??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
	DD	04cH
	DD	080H
	DD	FLAT:_L___asan_gen_.45
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.46
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.46 DD FLAT:_L___asan_gen_.36
	DD	0585H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.45 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@ DD FLAT:??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@
	DD	08eH
	DD	0c0H
	DD	FLAT:_L___asan_gen_.43
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.44
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.44 DD FLAT:_L___asan_gen_.36
	DD	0587H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.43 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0ceH
	DD	0100H
	DD	FLAT:_L___asan_gen_.41
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.42
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.42 DD FLAT:_L___asan_gen_.36
	DD	0585H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.41 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	067H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.39
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.40
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.40 DD FLAT:_L___asan_gen_.36
	DD	0585H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.39 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ DD FLAT:??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
	DD	024H
	DD	060H
	DD	FLAT:_L___asan_gen_.37
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.38
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.38 DD FLAT:_L___asan_gen_.36
	DD	0585H
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.37 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.36 DB 'vector', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.34
	DD	FLAT:_L___asan_gen_.33
	DD	00H
	DD	FLAT:_L___asan_gen_.35
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.35 DD FLAT:_L___asan_gen_.33
	DD	05dH
	DD	05fH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.34 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.33 DB 'xlocnum', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.31
	DD	FLAT:_L___asan_gen_.30
	DD	00H
	DD	FLAT:_L___asan_gen_.32
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.32 DD FLAT:_L___asan_gen_.30
	DD	049H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.31 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.30 DB 'xlocale', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BA@JFNIOLAK@string?5too?5long@ DD FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.27
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.27
	DD	0946H
	DD	013H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.28 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.27 DB 'xstring', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DD FLAT:??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
	DD	036H
	DD	060H
	DD	FLAT:_L___asan_gen_.25
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.26
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.26 DD FLAT:_L___asan_gen_.8
	DD	04c8H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.25 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DD FLAT:??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
	DD	05cH
	DD	080H
	DD	FLAT:_L___asan_gen_.23
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.24
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.24 DD FLAT:_L___asan_gen_.8
	DD	04c8H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.23 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DD FLAT:??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
	DD	019H
	DD	040H
	DD	FLAT:_L___asan_gen_.21
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.22
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.22 DD FLAT:_L___asan_gen_.8
	DD	04c8H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.21 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.19
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.20
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.20 DD FLAT:_L___asan_gen_.8
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.19 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD FLAT:??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	DD	04aH
	DD	080H
	DD	FLAT:_L___asan_gen_.17
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.18
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.18 DD FLAT:_L___asan_gen_.8
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.17 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.15
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.16
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.16 DD FLAT:_L___asan_gen_.8
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.15 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.13
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.14
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.14 DD FLAT:_L___asan_gen_.8
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.13 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_02DKCKIIND@?$CFs@ DD FLAT:??_C@_02DKCKIIND@?$CFs@
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.11
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.12
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.12 DD FLAT:_L___asan_gen_.8
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.11 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.9
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.10
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.10 DD FLAT:_L___asan_gen_.8
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.9 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.8 DB 'xmemory', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	DD	015H
	DD	040H
	DD	FLAT:_L___asan_gen_.6
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.7
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.7 DD FLAT:_L___asan_gen_.3
	DD	08cH
	DD	014H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.6 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BC@EOODALEL@Unknown?5exception@ DD FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	DD	012H
	DD	040H
	DD	FLAT:_L___asan_gen_.4
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.5
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.5 DD FLAT:_L___asan_gen_.3
	DD	05fH
	DD	02bH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.4 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.3 DB 'vcruntime_exception.h', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DD FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
	DD	08H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	05bH
	DD	020H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.1 DB '`__local_stdio_printf_options''::`2''::_OptionsStora'
	DB	'ge', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.0 DB 'corecrt_stdio_config.h', 00H
CONST	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R4Sprite@sf@@6BTransformable@1@@
rdata$r	SEGMENT
??_R4Sprite@sf@@6BTransformable@1@@ DD 00H		; sf::Sprite::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVSprite@sf@@@8
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Transformable@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Transformable@sf@@8 DD FLAT:??_R0?AVTransformable@sf@@@8 ; sf::Transformable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Transformable@sf@@8
rdata$r	SEGMENT
??_R2Transformable@sf@@8 DD FLAT:??_R1A@?0A@EA@Transformable@sf@@8 ; sf::Transformable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Transformable@sf@@8
rdata$r	SEGMENT
??_R3Transformable@sf@@8 DD 00H				; sf::Transformable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTransformable@sf@@@8
data$rs	SEGMENT
??_R0?AVTransformable@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Transformable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTransformable@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@Transformable@sf@@8
rdata$r	SEGMENT
??_R13?0A@EA@Transformable@sf@@8 DD FLAT:??_R0?AVTransformable@sf@@@8 ; sf::Transformable::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Drawable@sf@@8
rdata$r	SEGMENT
??_R2Drawable@sf@@8 DD FLAT:??_R1A@?0A@EA@Drawable@sf@@8 ; sf::Drawable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Drawable@sf@@8
rdata$r	SEGMENT
??_R3Drawable@sf@@8 DD 00H				; sf::Drawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Drawable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawable@sf@@@8
data$rs	SEGMENT
??_R0?AVDrawable@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Drawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawable@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Drawable@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Drawable@sf@@8 DD FLAT:??_R0?AVDrawable@sf@@@8 ; sf::Drawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Drawable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Sprite@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Sprite@sf@@8 DD FLAT:??_R0?AVSprite@sf@@@8 ; sf::Sprite::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Sprite@sf@@8
rdata$r	SEGMENT
??_R2Sprite@sf@@8 DD FLAT:??_R1A@?0A@EA@Sprite@sf@@8	; sf::Sprite::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Drawable@sf@@8
	DD	FLAT:??_R13?0A@EA@Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R3Sprite@sf@@8
rdata$r	SEGMENT
??_R3Sprite@sf@@8 DD 00H				; sf::Sprite::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSprite@sf@@@8
data$rs	SEGMENT
??_R0?AVSprite@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Sprite `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSprite@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Sprite@sf@@6BDrawable@1@@
rdata$r	SEGMENT
??_R4Sprite@sf@@6BDrawable@1@@ DD 00H			; sf::Sprite::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSprite@sf@@@8
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
data$r	SEGMENT
??_R0?AVinvalid_argument@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::invalid_argument `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVinvalid_argument@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVInteractiveObject@@@8
data$r	SEGMENT
??_R0?AVInteractiveObject@@@8 DD FLAT:??_7type_info@@6B@ ; InteractiveObject `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVInteractiveObject@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVBlock@@@8
data$r	SEGMENT
??_R0?AVBlock@@@8 DD FLAT:??_7type_info@@6B@		; Block `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVBlock@@', 00H
data$r	ENDS
;	COMDAT ??_SSprite@sf@@6BTransformable@1@@
CONST	SEGMENT
??_SSprite@sf@@6BTransformable@1@@ DD FLAT:??_R4Sprite@sf@@6BTransformable@1@@ ; sf::Sprite::`local vftable'
	DD	FLAT:??_ESprite@sf@@W3AEPAXI@Z
CONST	ENDS
;	COMDAT ??_SSprite@sf@@6BDrawable@1@@
CONST	SEGMENT
??_SSprite@sf@@6BDrawable@1@@ DD FLAT:??_R4Sprite@sf@@6BDrawable@1@@ ; sf::Sprite::`local vftable'
	DD	FLAT:??_ESprite@sf@@UAEPAXI@Z
	DD	FLAT:?draw@Sprite@sf@@EBEXAAVRenderTarget@2@VRenderStates@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	020H
	DW	0106H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Is_all_bits_zero@I@std@@YA_NABI@Z DB '1 16 4 5 _Zero'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02fH
	DW	0187H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z$0
__ehfuncinfo$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	02eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0255H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$1
__ehfuncinfo$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z DB '3'
	DB	' 16 1 4 $S48 32 8 6 _Proxy 48 4 6 _Guard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	030dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z DB '1'
	DB	' 16 4 8 _New_ptr'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0d3H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z DB '1'
	DB	' 16 12 4 _Tmp'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z DB '1'
	DB	' 16 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	07e9H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DB '5'
	DB	' 16 8 3 _Ok 32 4 18 compiler temporary 48 4 18 compiler tempo'
	DB	'rary 64 4 18 compiler temporary 80 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0d3H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z DB '1'
	DB	' 16 12 4 _Tmp'
CONST	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$0
	DD	047H
	DD	054H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?loadTerrain@Univers@@QAEXH@Z
	DD	032H
	DD	08c9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z
	DD	023H
	DD	0b85H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?animate@Univers@@QAEXXZ$2
	DD	019H
	DD	026H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?animate@Univers@@QAEXXZ
	DD	033H
	DD	0c3eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$2
	DD	02bH
	DD	038H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
	DD	033H
	DD	06faH
voltbl	ENDS
xdata$x	SEGMENT
__catchsym$?animate@Univers@@QAEXXZ$4 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0fffffd90H
	DD	FLAT:__catch$?animate@Univers@@QAEXXZ$0
__catchsym$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$7 DD 00H
	DD	FLAT:??_R0?AVinvalid_argument@std@@@8
	DD	0ffffff00H
	DD	FLAT:__catch$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$0
__tryblocktable$?animate@Univers@@QAEXXZ DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?animate@Univers@@QAEXXZ$4
__tryblocktable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DD 01H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$7
__unwindtable$?loadTerrain@Univers@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$2
__unwindtable$?animate@Univers@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?animate@Univers@@QAEXXZ$2
__unwindtable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$6
__ehfuncinfo$?loadTerrain@Univers@@QAEXH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?loadTerrain@Univers@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?animate@Univers@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?animate@Univers@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?animate@Univers@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CONST	SEGMENT
	ORG $+4
__L__asan_gen_.??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DB '4'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary 48 1 1'
	DB	'8 compiler temporary 64 12 1 e'
	ORG $+4
__L__asan_gen_.?animate@Univers@@QAEXXZ DB '20 16 8 5 clock 32 12 1 e 48 '
	DB	'4 18 compiler temporary 64 20 5 event 80 4 18 compiler tempor'
	DB	'ary 96 8 18 compiler temporary 112 4 18 compiler temporary 12'
	DB	'8 8 18 compiler temporary 144 4 18 compiler temporary 160 8 1'
	DB	'8 compiler temporary 176 4 18 compiler temporary 192 8 18 com'
	DB	'piler temporary 208 4 18 compiler temporary 224 8 18 compiler'
	DB	' temporary 240 4 18 compiler temporary 256 8 18 compiler temp'
	DB	'orary 272 4 18 compiler temporary 288 8 18 compiler temporary'
	DB	' 304 4 18 compiler temporary 320 8 18 compiler temporary'
__L__asan_gen_.?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z DB '1'
	DB	'1 16 16 18 compiler temporary 32 16 18 compiler temporary 48 '
	DB	'12 18 compiler temporary 64 12 18 compiler temporary 80 12 18'
	DB	' compiler temporary 96 8 4 size 112 16 18 compiler temporary '
	DB	'128 16 18 compiler temporary 144 16 18 compiler temporary 160'
	DB	' 16 18 compiler temporary 176 16 18 compiler temporary'
	ORG $+5
__L__asan_gen_.?loadTerrain@Univers@@QAEXH@Z DB '5 16 168 4 View 32 8 2 s'
	DB	'i 48 16 18 compiler temporary 64 8 18 compiler temporary 80 1'
	DB	'6 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
	DB	021H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02fH
	DB	0f6H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0b3H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__Elevel1@@YAXXZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$??__Elevel1@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__Elevel1@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$14
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??__Elevel1@@YAXXZ DB '45 16 224 18 compiler temporary 32 '
	DB	'36 18 compiler temporary 48 36 18 compiler temporary 64 36 18'
	DB	' compiler temporary 80 36 18 compiler temporary 96 36 18 comp'
	DB	'iler temporary 112 36 18 compiler temporary 128 36 18 compile'
	DB	'r temporary 144 36 18 compiler temporary 160 36 18 compiler t'
	DB	'emporary 176 36 18 compiler temporary 192 36 18 compiler temp'
	DB	'orary 208 36 18 compiler temporary 224 36 18 compiler tempora'
	DB	'ry 240 36 18 compiler temporary 256 1 18 compiler temporary 2'
	DB	'72 1 18 compiler temporary 288 8 18 compiler temporary 304 1 '
	DB	'18 compiler temporary 320 8 18 compiler temporary 336 1 18 co'
	DB	'mpiler temporary 352 8 18 compiler temporary 368 1 18 compile'
	DB	'r temporary 384 8 18 compiler temporary 400 1 18 compiler tem'
	DB	'porary 416 8 18 compiler temporary 432 1 18 compiler temporar'
	DB	'y 448 8 18 compiler temporary 464 1 18 compiler temporary 480'
	DB	' 8 18 compiler temporary 496 1 18 compiler temporary 512 8 18'
	DB	' compiler temporary 528 1 18 compiler temporary 544 8 18 comp'
	DB	'iler temporary 560 1 18 compiler temporary 576 8 18 compiler '
	DB	'temporary 592 1 18 compiler temporary 608 8 18 compiler tempo'
	DB	'rary 624 1 18 compiler temporary 640 8 18 compiler temporary '
	DB	'656 1 18 compiler temporary 672 8 18 compiler temporary 688 1'
	DB	' 18 compiler temporary 704 8 18 compiler temporary 720 8 18 c'
	DB	'ompiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02fH
	DW	0137H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0268H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DB '1'
	DB	' 16 4 6 _Guard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0268H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DB '1'
	DB	' 16 4 6 _Guard'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z DB '1'
	DB	' 16 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ DB '2'
	DB	' 16 1 4 $S10 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01d2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DB '3'
	DB	' 16 1 3 $S8 32 8 6 _Proxy 48 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DB '2 16 1 4'
	DB	' $S13 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	03f7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DB '4 '
	DB	'16 1 18 compiler temporary 32 1 3 $S9 48 8 6 _Proxy 64 4 6 _G'
	DB	'uard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01d2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DB '3'
	DB	' 16 1 3 $S7 32 8 6 _Proxy 48 1 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z DB '4'
	DB	' 16 12 18 compiler temporary 32 12 18 compiler temporary 48 1'
	DB	'2 18 compiler temporary 64 12 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0172H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z DB '1'
	DB	' 16 16 3 _It'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z$0
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
	DB	021H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02fH
	DB	0f6H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DB '2 16 1 4'
	DB	' $S42 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	03f7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DB '4 '
	DB	'16 1 18 compiler temporary 32 1 4 $S43 48 8 6 _Proxy 64 4 6 _'
	DB	'Guard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	013eH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ DB '2 16 1 '
	DB	'4 $S39 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z$0
__ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z DB '3'
	DB	' 16 1 18 compiler temporary 32 4 18 compiler temporary 48 1 1'
	DB	'8 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	022dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z DB '3 16'
	DB	' 8 6 _Mbst1 32 2 3 _Wc 48 8 6 _Mbst2'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0253H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z DB '2'
	DB	' 16 4 7 _Masked 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	02c7H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ DB '4'
	DB	' 16 4 10 _Alloc_max 32 4 18 compiler temporary 48 4 18 compil'
	DB	'er temporary 64 4 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0153H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DB '2'
	DB	' 16 1 4 $S36 32 8 6 _Proxy'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ DB '1 1'
	DB	'6 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0c0H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0c0H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z DB '1 1'
	DB	'6 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ DB '1 16 12 18 com'
	DB	'piler temporary'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odsp /RTCu
;	COMDAT ??_ESprite@sf@@W3AEPAXI@Z
_TEXT	SEGMENT
??_ESprite@sf@@W3AEPAXI@Z PROC				; [thunk]:sf::Sprite::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_ESprite@sf@@UAEPAXI@Z
??_ESprite@sf@@W3AEPAXI@Z ENDP				; [thunk]:sf::Sprite::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z PROC		; std::construct_at<unsigned int,unsigned int &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z ENDP		; std::construct_at<unsigned int,unsigned int &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAI@std@@YAPAXPAI@Z PROC		; std::_Voidify_iter<unsigned int *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ENDP		; std::_Voidify_iter<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@IABIX@std@@YAPAIQAIABI@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@IABIX@std@@YAPAIQAIABI@Z PROC		; std::construct_at<unsigned int,unsigned int const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@IABIX@std@@YAPAIQAIABI@Z ENDP		; std::construct_at<unsigned int,unsigned int const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 226  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@IABIX@std@@YAPAIQAIABI@Z ; std::construct_at<unsigned int,unsigned int const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z ; std::construct_at<unsigned int,unsigned int &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAI@std@@YAAAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAI@std@@YAAAIAAI@Z PROC			; std::forward<unsigned int &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@AAI@std@@YAAAIAAI@Z ENDP			; std::forward<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z
_TEXT	SEGMENT
tv77 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z PROC ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  00017	50		 push	 eax
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	89 4d f4	 mov	 DWORD PTR tv77[ebp], ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0002f	83 c4 04	 add	 esp, 4
  00032	50		 push	 eax
  00033	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  00036	e8 00 00 00 00	 call	 ??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z ENDP ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv65 = -20						; size = 4
tv64 = -16						; size = 4
tv72 = -12						; size = 4
tv82 = -8						; size = 4
tv75 = -2						; size = 1
tv85 = -1						; size = 1
__Arg$ = 8						; size = 4
??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z PROC ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>, COMDAT
; _this$ = ecx

; 170  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00022	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 4d f0	 mov	 DWORD PTR tv64[ebp], ecx
  00028	8b 55 ec	 mov	 edx, DWORD PTR tv65[ebp]
  0002b	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0002e	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00031	c1 e8 03	 shr	 eax, 3
  00034	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003a	88 4d ff	 mov	 BYTE PTR tv85[ebp], cl
  0003d	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00041	74 1a		 je	 SHORT $LN4@Tuple_val
  00043	8a 55 f8	 mov	 dl, BYTE PTR tv82[ebp]
  00046	80 e2 07	 and	 dl, 7
  00049	80 c2 03	 add	 dl, 3
  0004c	3a 55 ff	 cmp	 dl, BYTE PTR tv85[ebp]
  0004f	7c 0c		 jl	 SHORT $LN4@Tuple_val
  00051	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___asan_report_load4
  0005a	83 c4 04	 add	 esp, 4
$LN4@Tuple_val:
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  00060	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
  00063	8b 55 f4	 mov	 edx, DWORD PTR tv72[ebp]
  00066	c1 ea 03	 shr	 edx, 3
  00069	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0006f	88 45 fe	 mov	 BYTE PTR tv75[ebp], al
  00072	80 7d fe 00	 cmp	 BYTE PTR tv75[ebp], 0
  00076	74 1a		 je	 SHORT $LN3@Tuple_val
  00078	8a 4d f4	 mov	 cl, BYTE PTR tv72[ebp]
  0007b	80 e1 07	 and	 cl, 7
  0007e	80 c1 03	 add	 cl, 3
  00081	3a 4d fe	 cmp	 cl, BYTE PTR tv75[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Tuple_val
  00086	8b 55 f4	 mov	 edx, DWORD PTR tv72[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Tuple_val:
  00092	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00095	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 10		 mov	 DWORD PTR [eax], edx
  0009c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ENDP ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv65 = -20						; size = 4
tv64 = -16						; size = 4
tv72 = -12						; size = 4
tv82 = -8						; size = 4
tv75 = -2						; size = 1
tv85 = -1						; size = 1
__Arg$ = 8						; size = 4
??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z PROC ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>, COMDAT
; _this$ = ecx

; 170  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00022	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 4d f0	 mov	 DWORD PTR tv64[ebp], ecx
  00028	8b 55 ec	 mov	 edx, DWORD PTR tv65[ebp]
  0002b	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0002e	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00031	c1 e8 03	 shr	 eax, 3
  00034	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003a	88 4d ff	 mov	 BYTE PTR tv85[ebp], cl
  0003d	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00041	74 1a		 je	 SHORT $LN4@Tuple_val
  00043	8a 55 f8	 mov	 dl, BYTE PTR tv82[ebp]
  00046	80 e2 07	 and	 dl, 7
  00049	80 c2 03	 add	 dl, 3
  0004c	3a 55 ff	 cmp	 dl, BYTE PTR tv85[ebp]
  0004f	7c 0c		 jl	 SHORT $LN4@Tuple_val
  00051	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___asan_report_load4
  0005a	83 c4 04	 add	 esp, 4
$LN4@Tuple_val:
  0005d	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  00060	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
  00063	8b 55 f4	 mov	 edx, DWORD PTR tv72[ebp]
  00066	c1 ea 03	 shr	 edx, 3
  00069	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0006f	88 45 fe	 mov	 BYTE PTR tv75[ebp], al
  00072	80 7d fe 00	 cmp	 BYTE PTR tv75[ebp], 0
  00076	74 1a		 je	 SHORT $LN3@Tuple_val
  00078	8a 4d f4	 mov	 cl, BYTE PTR tv72[ebp]
  0007b	80 e1 07	 and	 cl, 7
  0007e	80 c1 03	 add	 cl, 3
  00081	3a 4d fe	 cmp	 cl, BYTE PTR tv75[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Tuple_val
  00086	8b 55 f4	 mov	 edx, DWORD PTR tv72[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Tuple_val:
  00092	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00095	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 10		 mov	 DWORD PTR [eax], edx
  0009c	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c2 04 00	 ret	 4
??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ENDP ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z
_TEXT	SEGMENT
tv77 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z PROC ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	0f b6 45 ff	 movzx	 eax, BYTE PTR $T1[ebp]
  00017	50		 push	 eax
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	89 4d f4	 mov	 DWORD PTR tv77[ebp], ecx
  00026	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0002f	83 c4 04	 add	 esp, 4
  00032	50		 push	 eax
  00033	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  00036	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c2 08 00	 ret	 8
??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ENDP ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Fill_zero_memset@PAI@std@@YAXPAII@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Fill_zero_memset@PAI@std@@YAXPAII@Z PROC		; std::_Fill_zero_memset<unsigned int *>, COMDAT

; 4558 : void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4559 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00010	c1 e0 02	 shl	 eax, 2
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	8d 4d 08	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4560 : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
??$_Fill_zero_memset@PAI@std@@YAXPAII@Z ENDP		; std::_Fill_zero_memset<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Is_all_bits_zero@I@std@@YA_NABI@Z
_TEXT	SEGMENT
__asan_gen_0$ = -88					; size = 4
__asan_gen_1$ = -84					; size = 4
__asan_gen_2$ = -80					; size = 4
__Zero$ = -72						; size = 4
tv87 = -26						; size = 1
tv72 = -25						; size = 1
tv77 = -24						; size = 4
tv84 = -20						; size = 4
tv69 = -16						; size = 4
tv75 = -12						; size = 4
tv80 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Val$ = 8						; size = 4
??$_Is_all_bits_zero@I@std@@YA_NABI@Z PROC		; std::_Is_all_bits_zero<unsigned int>, COMDAT

; 4563 : _NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	c7 45 a8 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002a	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Is_all_bits_zero@I@std@@YA_NABI@Z
  00031	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Is_all_bits_zero@I@std@@YA_NABI@Z ; std::_Is_all_bits_zero<unsigned int>
  00038	8d 45 a8	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003b	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	c1 e9 03	 shr	 ecx, 3
  00044	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004a	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  0004d	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00050	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00056	83 45 e8 04	 add	 DWORD PTR tv77[ebp], 4
  0005a	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR tv77[ebp]
  00062	66 89 01	 mov	 WORD PTR [ecx], ax
  00065	83 45 e8 02	 add	 DWORD PTR tv77[ebp], 2
  00069	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  0006c	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006f	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00074	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4564 :     // checks if scalar type has all bits set to zero
; 4565 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 4566 :     constexpr _Ty _Zero{};

  00079	8d 45 b8	 lea	 eax, DWORD PTR __Zero$[ebp]
  0007c	89 45 ec	 mov	 DWORD PTR tv84[ebp], eax
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR tv84[ebp]
  00082	c1 e9 03	 shr	 ecx, 3
  00085	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0008b	88 55 e6	 mov	 BYTE PTR tv87[ebp], dl
  0008e	80 7d e6 00	 cmp	 BYTE PTR tv87[ebp], 0
  00092	74 18		 je	 SHORT $LN5@Is_all_bit
  00094	8a 45 ec	 mov	 al, BYTE PTR tv84[ebp]
  00097	24 07		 and	 al, 7
  00099	04 03		 add	 al, 3
  0009b	3a 45 e6	 cmp	 al, BYTE PTR tv87[ebp]
  0009e	7c 0c		 jl	 SHORT $LN5@Is_all_bit
  000a0	8b 4d ec	 mov	 ecx, DWORD PTR tv84[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ___asan_report_store4
  000a9	83 c4 04	 add	 esp, 4
$LN5@Is_all_bit:
  000ac	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __Zero$[ebp], 0

; 4567 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

  000b3	6a 04		 push	 4
  000b5	8d 55 b8	 lea	 edx, DWORD PTR __Zero$[ebp]
  000b8	52		 push	 edx
  000b9	8b 43 08	 mov	 eax, DWORD PTR __Val$[ebx]
  000bc	50		 push	 eax
  000bd	e8 00 00 00 00	 call	 _memcmp
  000c2	83 c4 0c	 add	 esp, 12			; 0000000cH
  000c5	85 c0		 test	 eax, eax
  000c7	75 09		 jne	 SHORT $LN3@Is_all_bit
  000c9	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  000d0	eb 07		 jmp	 SHORT $LN4@Is_all_bit
$LN3@Is_all_bit:
  000d2	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Is_all_bit:
  000d9	8a 4d f0	 mov	 cl, BYTE PTR tv69[ebp]
  000dc	88 4d e7	 mov	 BYTE PTR tv72[ebp], cl
  000df	c7 45 a8 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000e6	8d 55 a8	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000e9	c1 ea 03	 shr	 edx, 3
  000ec	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000f2	89 55 f8	 mov	 DWORD PTR tv80[ebp], edx
  000f5	6a 07		 push	 7
  000f7	8b 45 f8	 mov	 eax, DWORD PTR tv80[ebp]
  000fa	50		 push	 eax
  000fb	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00100	83 c4 08	 add	 esp, 8
  00103	8a 45 e7	 mov	 al, BYTE PTR tv72[ebp]

; 4568 : }

  00106	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00109	33 cd		 xor	 ecx, ebp
  0010b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00110	8b e5		 mov	 esp, ebp
  00112	5d		 pop	 ebp
  00113	8b e3		 mov	 esp, ebx
  00115	5b		 pop	 ebx
  00116	c3		 ret	 0
??$_Is_all_bits_zero@I@std@@YA_NABI@Z ENDP		; std::_Is_all_bits_zero<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@I@std@@YAPAIPAI@Z PROC			; std::_Unfancy<unsigned int>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@I@std@@YAPAIPAI@Z ENDP			; std::_Unfancy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z PROC		; std::_Get_unwrapped<unsigned int * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z ENDP		; std::_Get_unwrapped<unsigned int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAI@std@@YA?A_PABQAI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAI@std@@YA?A_PABQAI@Z PROC		; std::_To_address<unsigned int *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@I@std@@YAPAIQAI@Z ; std::to_address<unsigned int>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAI@std@@YA?A_PABQAI@Z ENDP		; std::_To_address<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z PROC ; std::_To_address<Block * *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@PAVBlock@@@std@@YAPAPAVBlock@@QAPAV1@@Z ; std::to_address<Block *>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z ENDP ; std::_To_address<Block * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 10	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00022	6a 01		 push	 1
  00024	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	8d 55 ff	 lea	 edx, DWORD PTR $T2[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___asan_memcpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00037	50		 push	 eax
  00038	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>
  00045	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00048	83 c2 04	 add	 edx, 4
  0004b	89 55 f0	 mov	 DWORD PTR tv83[ebp], edx
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00057	83 c4 04	 add	 esp, 4
  0005a	50		 push	 eax
  0005b	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  0005e	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
  00063	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 10	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00022	6a 01		 push	 1
  00024	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	8d 55 ff	 lea	 edx, DWORD PTR $T2[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___asan_memcpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00037	50		 push	 eax
  00038	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
  00045	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00048	83 c2 04	 add	 edx, 4
  0004b	89 55 f0	 mov	 DWORD PTR tv83[ebp], edx
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00057	83 c4 04	 add	 esp, 4
  0005a	50		 push	 eax
  0005b	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  0005e	e8 00 00 00 00	 call	 ??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
  00063	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -2						; size = 1
$T2 = -1						; size = 1
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 10	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00022	6a 01		 push	 1
  00024	8d 4d fe	 lea	 ecx, DWORD PTR $T1[ebp]
  00027	51		 push	 ecx
  00028	8d 55 ff	 lea	 edx, DWORD PTR $T2[ebp]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ___asan_memcpy
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH
  00034	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00037	50		 push	 eax
  00038	0f b6 4d ff	 movzx	 ecx, BYTE PTR $T2[ebp]
  0003c	51		 push	 ecx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
  00045	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00048	83 c2 04	 add	 edx, 4
  0004b	89 55 f0	 mov	 DWORD PTR tv83[ebp], edx
  0004e	8b 45 0c	 mov	 eax, DWORD PTR __This_arg$[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00057	83 c4 04	 add	 esp, 4
  0005a	50		 push	 eax
  0005b	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  0005e	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
  00063	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 693  :     static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 694  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 695  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 696  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN2@deallocate

; 697  :             _Al.deallocate(_Ptr, _Count);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00024	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 698  :         } else

  00029	eb 13		 jmp	 SHORT $LN1@deallocate
$LN2@deallocate:

; 699  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 700  :         {
; 701  :             (void) _Al;
; 702  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	c1 e0 03	 shl	 eax, 3
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003b	83 c4 08	 add	 esp, 8
$LN1@deallocate:

; 703  :         }
; 704  :     }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
__Backout$ = -112					; size = 12
tv128 = -64						; size = 4
tv94 = -60						; size = 4
tv131 = -56						; size = 4
tv80 = -52						; size = 4
$T3 = -48						; size = 4
tv137 = -44						; size = 4
tv93 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z PROC ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >, COMDAT

; 1741 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00043	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
  0004a	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
  00051	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00054	89 45 c4	 mov	 DWORD PTR tv94[ebp], eax
  00057	8b 4d c4	 mov	 ecx, DWORD PTR tv94[ebp]
  0005a	c1 e9 03	 shr	 ecx, 3
  0005d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00063	89 4d c0	 mov	 DWORD PTR tv128[ebp], ecx
  00066	8b 55 c0	 mov	 edx, DWORD PTR tv128[ebp]
  00069	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0006f	83 45 c0 04	 add	 DWORD PTR tv128[ebp], 4
  00073	8b 45 c0	 mov	 eax, DWORD PTR tv128[ebp]
  00076	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00081	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1742 :     // copy _Count copies of _Val to raw _First, using _Al
; 1743 :     using _Ty = typename _Alloc::value_type;
; 1744 :     if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1745 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1746 :         if (!_STD is_constant_evaluated())
; 1747 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1748 :         {
; 1749 :             _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
; 1750 :             return _First + _Count;
; 1751 :         }
; 1752 :     } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1753 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1754 :         if (!_STD is_constant_evaluated())

  00086	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0008b	0f b6 c8	 movzx	 ecx, al
  0008e	85 c9		 test	 ecx, ecx
  00090	75 63		 jne	 SHORT $LN5@Uninitiali

; 1755 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1756 :         {
; 1757 :             if (_Is_all_bits_zero(_Val)) {

  00092	8b 53 10	 mov	 edx, DWORD PTR __Val$[ebx]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ??$_Is_all_bits_zero@I@std@@YA_NABI@Z ; std::_Is_all_bits_zero<unsigned int>
  0009b	83 c4 04	 add	 esp, 4
  0009e	0f b6 c0	 movzx	 eax, al
  000a1	85 c0		 test	 eax, eax
  000a3	74 50		 je	 SHORT $LN5@Uninitiali

; 1758 :                 _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));

  000a5	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  000a8	51		 push	 ecx
  000a9	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  000ac	52		 push	 edx
  000ad	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  000b2	83 c4 04	 add	 esp, 4
  000b5	50		 push	 eax
  000b6	e8 00 00 00 00	 call	 ??$_Fill_zero_memset@PAI@std@@YAXPAII@Z ; std::_Fill_zero_memset<unsigned int *>
  000bb	83 c4 08	 add	 esp, 8

; 1759 :                 return _First + _Count;

  000be	8b 43 0c	 mov	 eax, DWORD PTR __Count$[ebx]
  000c1	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000c4	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000c7	89 55 cc	 mov	 DWORD PTR tv80[ebp], edx
  000ca	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000d1	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000d4	c1 e8 03	 shr	 eax, 3
  000d7	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000dc	89 45 c8	 mov	 DWORD PTR tv131[ebp], eax
  000df	6a 08		 push	 8
  000e1	8b 4d c8	 mov	 ecx, DWORD PTR tv131[ebp]
  000e4	51		 push	 ecx
  000e5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000ea	83 c4 08	 add	 esp, 8
  000ed	8b 45 cc	 mov	 eax, DWORD PTR tv80[ebp]
  000f0	e9 87 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1760 :             }
; 1761 :         }
; 1762 :     }
; 1763 : 
; 1764 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  000f5	6a 0c		 push	 12			; 0000000cH
  000f7	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000fa	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z
  000ff	8b 53 14	 mov	 edx, DWORD PTR __Al$[ebx]
  00102	52		 push	 edx
  00103	8b 43 08	 mov	 eax, DWORD PTR __First$[ebx]
  00106	50		 push	 eax
  00107	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0010a	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
  0010f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1765 :     for (; 0 < _Count; --_Count) {

  00116	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00118	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  0011b	83 e9 01	 sub	 ecx, 1
  0011e	89 4b 0c	 mov	 DWORD PTR __Count$[ebx], ecx
$LN4@Uninitiali:
  00121	83 7b 0c 00	 cmp	 DWORD PTR __Count$[ebx], 0
  00125	76 0e		 jbe	 SHORT $LN3@Uninitiali

; 1766 :         _Backout._Emplace_back(_Val);

  00127	8b 53 10	 mov	 edx, DWORD PTR __Val$[ebx]
  0012a	52		 push	 edx
  0012b	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0012e	e8 00 00 00 00	 call	 ??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>

; 1767 :     }

  00133	eb e3		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1768 : 
; 1769 :     return _Backout._Release();

  00135	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
  0013d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00140	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00147	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0014a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  0014f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00152	89 45 d8	 mov	 DWORD PTR tv93[ebp], eax
  00155	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 4d 80	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 e9 03	 shr	 ecx, 3
  00162	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00168	89 4d d4	 mov	 DWORD PTR tv137[ebp], ecx
  0016b	6a 08		 push	 8
  0016d	8b 55 d4	 mov	 edx, DWORD PTR tv137[ebp]
  00170	52		 push	 edx
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 d8	 mov	 eax, DWORD PTR tv93[ebp]
$LN1@Uninitiali:

; 1770 : }

  0017c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0017f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00186	59		 pop	 ecx
  00187	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0018a	33 cd		 xor	 ecx, ebp
  0018c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00191	8b e5		 mov	 esp, ebp
  00193	5d		 pop	 ebp
  00194	8b e3		 mov	 esp, ebx
  00196	5b		 pop	 ebx
  00197	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z$0:
  00000	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ENDP ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z PROC ; std::forward<std::allocator<unsigned int> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z ENDP ; std::forward<std::allocator<unsigned int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z PROC ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z ; std::_Get_unwrapped<unsigned int * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z ; std::_Get_unwrapped<unsigned int * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_memmove<unsigned int *,unsigned int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ENDP ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z PROC ; std::forward<std::allocator<unsigned int> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ENDP ; std::forward<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z PROC		; std::_Copy_memmove<unsigned int *,unsigned int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ENDP		; std::_Copy_memmove<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@I@std@@YAPAIQAI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@I@std@@YAPAIQAI@Z PROC			; std::to_address<unsigned int>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@I@std@@YAPAIQAI@Z ENDP			; std::to_address<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z PROC		; std::_Voidify_iter<char * *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ENDP		; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z PROC	; std::construct_at<char *,char * const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ENDP	; std::construct_at<char *,char * const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAI@std@@YA$$QAIAAI@Z PROC			; std::move<unsigned int &>, COMDAT

; 1455 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1457 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::move<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
tv90 = -32						; size = 4
tv88 = -28						; size = 4
__Block_size$ = -24					; size = 4
__Ptr$ = -20						; size = 4
tv128 = -16						; size = 4
__Ptr_container$ = -12					; size = 4
tv138 = -8						; size = 4
tv131 = -2						; size = 1
tv141 = -1						; size = 1
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	83 c0 27	 add	 eax, 39			; 00000027H
  00016	89 45 e8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 137  :     if (_Block_size <= _Bytes) {

  00019	8b 4d e8	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  0001c	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  0001f	77 05		 ja	 SHORT $LN8@Allocate_m

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00021	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00026	8b 55 e8	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f4	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00035	83 7d f4 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00039	74 02		 je	 SHORT $LN7@Allocate_m
  0003b	eb 4a		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  0003d	68 00 00 00 00	 push	 OFFSET $SG262473
  00042	68 00 00 00 00	 push	 OFFSET $SG262474
  00047	6a 00		 push	 0
  00049	68 8e 00 00 00	 push	 142			; 0000008eH
  0004e	68 00 00 00 00	 push	 OFFSET $SG262475
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN12@Allocate_m
  00063	cc		 int	 3
$LN12@Allocate_m:
  00064	6a 00		 push	 0
  00066	68 8e 00 00 00	 push	 142			; 0000008eH
  0006b	68 00 00 00 00	 push	 OFFSET $SG262476
  00070	68 00 00 00 00	 push	 OFFSET $SG262477
  00075	68 00 00 00 00	 push	 OFFSET $SG262478
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	33 c9		 xor	 ecx, ecx
  00085	75 b6		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00087	33 d2		 xor	 edx, edx
  00089	75 aa		 jne	 SHORT $LN4@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0008e	83 c0 27	 add	 eax, 39			; 00000027H
  00091	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00094	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00097	b9 04 00 00 00	 mov	 ecx, 4
  0009c	6b d1 ff	 imul	 edx, ecx, -1
  0009f	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a2	03 c2		 add	 eax, edx
  000a4	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR tv88[ebp]
  000aa	89 4d f8	 mov	 DWORD PTR tv138[ebp], ecx
  000ad	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000b0	c1 ea 03	 shr	 edx, 3
  000b3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b9	88 45 ff	 mov	 BYTE PTR tv141[ebp], al
  000bc	80 7d ff 00	 cmp	 BYTE PTR tv141[ebp], 0
  000c0	74 1a		 je	 SHORT $LN14@Allocate_m
  000c2	8a 4d f8	 mov	 cl, BYTE PTR tv138[ebp]
  000c5	80 e1 07	 and	 cl, 7
  000c8	80 c1 03	 add	 cl, 3
  000cb	3a 4d ff	 cmp	 cl, BYTE PTR tv141[ebp]
  000ce	7c 0c		 jl	 SHORT $LN14@Allocate_m
  000d0	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ___asan_report_store4
  000d9	83 c4 04	 add	 esp, 4
$LN14@Allocate_m:
  000dc	8b 45 e4	 mov	 eax, DWORD PTR tv88[ebp]
  000df	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e4	ba 04 00 00 00	 mov	 edx, 4
  000e9	6b c2 fe	 imul	 eax, edx, -2
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ef	03 c8		 add	 ecx, eax
  000f1	89 4d e0	 mov	 DWORD PTR tv90[ebp], ecx
  000f4	8b 55 e0	 mov	 edx, DWORD PTR tv90[ebp]
  000f7	89 55 f0	 mov	 DWORD PTR tv128[ebp], edx
  000fa	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  000fd	c1 e8 03	 shr	 eax, 3
  00100	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00106	88 4d fe	 mov	 BYTE PTR tv131[ebp], cl
  00109	80 7d fe 00	 cmp	 BYTE PTR tv131[ebp], 0
  0010d	74 1a		 je	 SHORT $LN13@Allocate_m
  0010f	8a 55 f0	 mov	 dl, BYTE PTR tv128[ebp]
  00112	80 e2 07	 and	 dl, 7
  00115	80 c2 03	 add	 dl, 3
  00118	3a 55 fe	 cmp	 dl, BYTE PTR tv131[ebp]
  0011b	7c 0c		 jl	 SHORT $LN13@Allocate_m
  0011d	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ___asan_report_store4
  00126	83 c4 04	 add	 esp, 4
$LN13@Allocate_m:
  00129	8b 4d e0	 mov	 ecx, DWORD PTR tv90[ebp]
  0012c	c7 01 fa fa fa
	fa		 mov	 DWORD PTR [ecx], -84215046 ; fafafafaH

; 148  : #endif // _DEBUG
; 149  :     return _Ptr;

  00132	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 150  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy_at@PAVBlock@@@std@@YAXQAPAVBlock@@@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
??$destroy_at@PAVBlock@@@std@@YAXQAPAVBlock@@@Z PROC	; std::destroy_at<Block *>, COMDAT

; 318  : _CONSTEXPR20_DYNALLOC void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 319  : #if _HAS_CXX20
; 320  :     if constexpr (is_array_v<_Ty>) {
; 321  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 322  :     } else
; 323  : #endif // _HAS_CXX20
; 324  :     {
; 325  :         _Location->~_Ty();
; 326  :     }
; 327  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$destroy_at@PAVBlock@@@std@@YAXQAPAVBlock@@@Z ENDP	; std::destroy_at<Block *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z PROC ; std::_Copy_memmove<Block * *,Block * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z ; std::_To_address<Block * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z ; std::_To_address<Block * *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAPAVBlock@@@std@@YA?A_PABQAPAVBlock@@@Z ; std::_To_address<Block * *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z ENDP ; std::_Copy_memmove<Block * *,Block * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@PAVBlock@@@std@@YAPAPAVBlock@@QAPAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@PAVBlock@@@std@@YAPAPAVBlock@@QAPAV1@@Z PROC ; std::to_address<Block *>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@PAVBlock@@@std@@YAPAPAVBlock@@QAPAV1@@Z ENDP ; std::to_address<Block *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVBlock@@@std@@YA$$QAPAVBlock@@AAPAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVBlock@@@std@@YA$$QAPAVBlock@@AAPAV1@@Z PROC ; std::move<Block * &>, COMDAT

; 1455 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1457 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$move@AAPAVBlock@@@std@@YA$$QAPAVBlock@@AAPAV1@@Z ENDP ; std::move<Block * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z
_TEXT	SEGMENT
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -15						; size = 1
$T3 = -14						; size = 1
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>, COMDAT
; _this$ = ecx

; 340  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	8b 45 0c	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR __This_arg$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00050	6a 01		 push	 1
  00052	8d 55 f1	 lea	 edx, DWORD PTR $T2[ebp]
  00055	52		 push	 edx
  00056	8d 45 f3	 lea	 eax, DWORD PTR $T4[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ___asan_memcpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	6a 01		 push	 1
  00064	8d 4d f3	 lea	 ecx, DWORD PTR $T4[ebp]
  00067	51		 push	 ecx
  00068	8d 55 f2	 lea	 edx, DWORD PTR $T3[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ___asan_memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv78[ebp]
  00077	50		 push	 eax
  00078	8b 4d e4	 mov	 ecx, DWORD PTR tv75[ebp]
  0007b	51		 push	 ecx
  0007c	0f b6 55 f2	 movzx	 edx, BYTE PTR $T3[ebp]
  00080	52		 push	 edx
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>
  00089	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
  0009d	cc		 int	 3
  0009e	cc		 int	 3
  0009f	cc		 int	 3
  000a0	cc		 int	 3
  000a1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z
_TEXT	SEGMENT
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -15						; size = 1
$T3 = -14						; size = 1
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 340  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	8b 45 0c	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR __This_arg$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00050	6a 01		 push	 1
  00052	8d 55 f1	 lea	 edx, DWORD PTR $T2[ebp]
  00055	52		 push	 edx
  00056	8d 45 f3	 lea	 eax, DWORD PTR $T4[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ___asan_memcpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	6a 01		 push	 1
  00064	8d 4d f3	 lea	 ecx, DWORD PTR $T4[ebp]
  00067	51		 push	 ecx
  00068	8d 55 f2	 lea	 edx, DWORD PTR $T3[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ___asan_memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv78[ebp]
  00077	50		 push	 eax
  00078	8b 4d e4	 mov	 ecx, DWORD PTR tv75[ebp]
  0007b	51		 push	 ecx
  0007c	0f b6 55 f2	 movzx	 edx, BYTE PTR $T3[ebp]
  00080	52		 push	 edx
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>
  00089	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
  0009d	cc		 int	 3
  0009e	cc		 int	 3
  0009f	cc		 int	 3
  000a0	cc		 int	 3
  000a1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z PROC ; std::forward<enum DIRDEP &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ENDP ; std::forward<enum DIRDEP &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z
_TEXT	SEGMENT
tv75 = -28						; size = 4
tv78 = -24						; size = 4
_this$ = -20						; size = 4
$T2 = -15						; size = 1
$T3 = -14						; size = 1
$T4 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 340  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	8b 45 0c	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR __This_arg$[ebp]
  00044	51		 push	 ecx
  00045	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0004a	83 c4 04	 add	 esp, 4
  0004d	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00050	6a 01		 push	 1
  00052	8d 55 f1	 lea	 edx, DWORD PTR $T2[ebp]
  00055	52		 push	 edx
  00056	8d 45 f3	 lea	 eax, DWORD PTR $T4[ebp]
  00059	50		 push	 eax
  0005a	e8 00 00 00 00	 call	 ___asan_memcpy
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00062	6a 01		 push	 1
  00064	8d 4d f3	 lea	 ecx, DWORD PTR $T4[ebp]
  00067	51		 push	 ecx
  00068	8d 55 f2	 lea	 edx, DWORD PTR $T3[ebp]
  0006b	52		 push	 edx
  0006c	e8 00 00 00 00	 call	 ___asan_memcpy
  00071	83 c4 0c	 add	 esp, 12			; 0000000cH
  00074	8b 45 e8	 mov	 eax, DWORD PTR tv78[ebp]
  00077	50		 push	 eax
  00078	8b 4d e4	 mov	 ecx, DWORD PTR tv75[ebp]
  0007b	51		 push	 ecx
  0007c	0f b6 55 f2	 movzx	 edx, BYTE PTR $T3[ebp]
  00080	52		 push	 edx
  00081	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00084	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>
  00089	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00096	59		 pop	 ecx
  00097	8b e5		 mov	 esp, ebp
  00099	5d		 pop	 ebp
  0009a	c2 08 00	 ret	 8
  0009d	cc		 int	 3
  0009e	cc		 int	 3
  0009f	cc		 int	 3
  000a0	cc		 int	 3
  000a1	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
tv66 = -24						; size = 4
tv65 = -20						; size = 4
_this$ = -16						; size = 4
tv79 = -12						; size = 4
tv89 = -8						; size = 4
tv82 = -2						; size = 1
tv92 = -1						; size = 1
__Right$ = 8						; size = 4
??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 623  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 624  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 e8	 mov	 DWORD PTR tv66[ebp], eax
  00022	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  00028	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0002b	89 55 f8	 mov	 DWORD PTR tv89[ebp], edx
  0002e	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]
  00031	c1 e8 03	 shr	 eax, 3
  00034	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003a	88 4d ff	 mov	 BYTE PTR tv92[ebp], cl
  0003d	80 7d ff 00	 cmp	 BYTE PTR tv92[ebp], 0
  00041	74 1a		 je	 SHORT $LN4@operator
  00043	8a 55 f8	 mov	 dl, BYTE PTR tv89[ebp]
  00046	80 e2 07	 and	 dl, 7
  00049	80 c2 03	 add	 dl, 3
  0004c	3a 55 ff	 cmp	 dl, BYTE PTR tv92[ebp]
  0004f	7c 0c		 jl	 SHORT $LN4@operator
  00051	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___asan_report_load4
  0005a	83 c4 04	 add	 esp, 4
$LN4@operator:
  0005d	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00060	89 4d f4	 mov	 DWORD PTR tv79[ebp], ecx
  00063	8b 55 f4	 mov	 edx, DWORD PTR tv79[ebp]
  00066	c1 ea 03	 shr	 edx, 3
  00069	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0006f	88 45 fe	 mov	 BYTE PTR tv82[ebp], al
  00072	80 7d fe 00	 cmp	 BYTE PTR tv82[ebp], 0
  00076	74 1a		 je	 SHORT $LN3@operator
  00078	8a 4d f4	 mov	 cl, BYTE PTR tv79[ebp]
  0007b	80 e1 07	 and	 cl, 7
  0007e	80 c1 03	 add	 cl, 3
  00081	3a 4d fe	 cmp	 cl, BYTE PTR tv82[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@operator
  00086	8b 55 f4	 mov	 edx, DWORD PTR tv79[ebp]
  00089	52		 push	 edx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@operator:
  00092	8b 45 ec	 mov	 eax, DWORD PTR tv65[ebp]
  00095	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 10		 mov	 DWORD PTR [eax], edx

; 625  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());

  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009f	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ; std::tuple<enum DIRDEP>::_Get_rest
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
  000aa	83 c4 04	 add	 esp, 4
  000ad	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000b0	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ; std::tuple<enum DIRDEP>::_Get_rest

; 626  :         return *this;

  000b5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 627  :     }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z PROC ; std::forward<std::tuple<enum DIRDEP> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z ENDP ; std::forward<std::tuple<enum DIRDEP> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z PROC ; std::forward<enum DIRDEP>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ENDP ; std::forward<enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::destroy_at<std::vector<int,std::allocator<int> > >, COMDAT

; 318  : _CONSTEXPR20_DYNALLOC void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 319  : #if _HAS_CXX20
; 320  :     if constexpr (is_array_v<_Ty>) {
; 321  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 322  :     } else
; 323  : #endif // _HAS_CXX20
; 324  :     {
; 325  :         _Location->~_Ty();

  0000d	6a 00		 push	 0
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Location$[ebp]
  00012	e8 00 00 00 00	 call	 ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z

; 326  :     }
; 327  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::destroy_at<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 985  : _CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 986  :     // deallocate a plain pointer using an allocator
; 987  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 988  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 989  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  0002c	6a 01		 push	 1
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 990  :     } else {
; 991  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 992  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 993  :     }
; 994  : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAH@std@@YA?A_PABQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAH@std@@YA?A_PABQAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@H@std@@YAPAHQAH@Z ; std::to_address<int>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAH@std@@YA?A_PABQAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PBH@std@@YA?A_PABQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PBH@std@@YA?A_PABQBH@Z PROC		; std::_To_address<int const *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@$$CBH@std@@YAPBHQBH@Z ; std::to_address<int const >
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PBH@std@@YA?A_PABQBH@Z ENDP		; std::_To_address<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z PROC		; std::_Unfancy_maybe_null<unsigned int>, COMDAT

; 437  : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 438  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 439  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ENDP		; std::_Unfancy_maybe_null<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABD@std@@YAABDABD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABD@std@@YAABDABD@Z PROC			; std::forward<char const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABD@std@@YAABDABD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAD@std@@YAPAXPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAD@std@@YAPAXPAD@Z PROC		; std::_Voidify_iter<char *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAD@std@@YAPAXPAD@Z ENDP		; std::_Voidify_iter<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@DABDX@std@@YAPADQADABD@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@DABDX@std@@YAPADQADABD@Z PROC		; std::construct_at<char,char const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAD@std@@YAPAXPAD@Z ; std::_Voidify_iter<char *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 01		 push	 1
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABD@std@@YAABDABD@Z ; std::forward<char const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 17		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  0005d	7c 0c		 jl	 SHORT $LN4@construct_
  0005f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ___asan_report_load1
  00068	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0006e	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00071	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00074	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  00077	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007a	c1 e8 03	 shr	 eax, 3
  0007d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00083	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00086	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008a	74 17		 je	 SHORT $LN3@construct_
  0008c	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  0008f	80 e2 07	 and	 dl, 7
  00092	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  00095	7c 0c		 jl	 SHORT $LN3@construct_
  00097	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ___asan_report_store1
  000a0	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000a6	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000a9	8a 02		 mov	 al, BYTE PTR [edx]
  000ab	88 01		 mov	 BYTE PTR [ecx], al
  000ad	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
??$construct_at@DABDX@std@@YAPADQADABD@Z ENDP		; std::construct_at<char,char const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00009	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0000e	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 64   :         if (_Count > _Max_possible) {
; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 70   : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
_TEXT	SEGMENT
__asan_gen_0$ = -176					; size = 4
__asan_gen_1$ = -172					; size = 4
__asan_gen_2$ = -168					; size = 4
_$S48$ = -160						; size = 1
__Proxy$ = -144						; size = 8
__Guard$3 = -128					; size = 4
tv173 = -83						; size = 1
tv163 = -82						; size = 1
tv153 = -81						; size = 1
tv137 = -80						; size = 4
_this$ = -76						; size = 4
tv170 = -72						; size = 4
__My_data$ = -68					; size = 4
tv160 = -64						; size = 4
tv150 = -60						; size = 4
tv83 = -56						; size = 4
tv135 = -52						; size = 4
__Alproxy$ = -48					; size = 4
tv85 = -44						; size = 4
tv146 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>, COMDAT
; _this$ = ecx

; 486  :     _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 50 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
  00056	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>
  00060	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  00069	8b 4d cc	 mov	 ecx, DWORD PTR tv135[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b0	 mov	 DWORD PTR tv137[ebp], ecx
  00078	8b 55 b0	 mov	 edx, DWORD PTR tv137[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b0 04	 add	 DWORD PTR tv137[ebp], 4
  00085	8b 45 b0	 mov	 eax, DWORD PTR tv137[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b0 04	 add	 DWORD PTR tv137[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b0	 mov	 edx, DWORD PTR tv137[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b0 02	 add	 DWORD PTR tv137[ebp], 2
  000a1	8b 45 b0	 mov	 eax, DWORD PTR tv137[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000ac	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 487  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000b1	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  000b9	50		 push	 eax
  000ba	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _$S48$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  000c5	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _$S48$[ebp]
  000cb	89 4d d0	 mov	 DWORD PTR __Alproxy$[ebp], ecx

; 488  :         auto& _My_data  = _Mypair._Myval2;

  000ce	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  000d1	89 55 bc	 mov	 DWORD PTR __My_data$[ebp], edx

; 489  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  000d4	8b 45 bc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d d0	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000db	51		 push	 ecx
  000dc	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000e2	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 490  :         if (_Count != 0) {

  000ee	83 7b 08 00	 cmp	 DWORD PTR __Count$[ebx], 0
  000f2	0f 84 0b 01 00
	00		 je	 $LN2@Construct_
  000f8	8d 55 80	 lea	 edx, DWORD PTR __Guard$3[ebp]
  000fb	c1 ea 03	 shr	 edx, 3
  000fe	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 491  :             _Buy_nonzero(_Count);

  00105	8b 43 08	 mov	 eax, DWORD PTR __Count$[ebx]
  00108	50		 push	 eax
  00109	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero

; 492  :             _Tidy_guard<vector> _Guard{this};

  00111	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00114	89 4d b8	 mov	 DWORD PTR tv170[ebp], ecx
  00117	8b 55 b8	 mov	 edx, DWORD PTR tv170[ebp]
  0011a	c1 ea 03	 shr	 edx, 3
  0011d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00123	88 45 ad	 mov	 BYTE PTR tv173[ebp], al
  00126	80 7d ad 00	 cmp	 BYTE PTR tv173[ebp], 0
  0012a	74 1a		 je	 SHORT $LN8@Construct_
  0012c	8a 4d b8	 mov	 cl, BYTE PTR tv170[ebp]
  0012f	80 e1 07	 and	 cl, 7
  00132	80 c1 03	 add	 cl, 3
  00135	3a 4d ad	 cmp	 cl, BYTE PTR tv173[ebp]
  00138	7c 0c		 jl	 SHORT $LN8@Construct_
  0013a	8b 55 b8	 mov	 edx, DWORD PTR tv170[ebp]
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 ___asan_report_store4
  00143	83 c4 04	 add	 esp, 4
$LN8@Construct_:
  00146	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00149	89 45 80	 mov	 DWORD PTR __Guard$3[ebp], eax
  0014c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 493  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);

  00150	8b 4b 0c	 mov	 ecx, DWORD PTR __Val$[ebx]
  00153	51		 push	 ecx
  00154	8b 53 08	 mov	 edx, DWORD PTR __Count$[ebx]
  00157	52		 push	 edx
  00158	8b 45 bc	 mov	 eax, DWORD PTR __My_data$[ebp]
  0015b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0015e	51		 push	 ecx
  0015f	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00162	e8 00 00 00 00	 call	 ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
  00167	89 45 d4	 mov	 DWORD PTR tv85[ebp], eax
  0016a	8b 55 bc	 mov	 edx, DWORD PTR __My_data$[ebp]
  0016d	83 c2 08	 add	 edx, 8
  00170	89 55 c8	 mov	 DWORD PTR tv83[ebp], edx
  00173	8b 45 c8	 mov	 eax, DWORD PTR tv83[ebp]
  00176	89 45 c0	 mov	 DWORD PTR tv160[ebp], eax
  00179	8b 4d c0	 mov	 ecx, DWORD PTR tv160[ebp]
  0017c	c1 e9 03	 shr	 ecx, 3
  0017f	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00185	88 55 ae	 mov	 BYTE PTR tv163[ebp], dl
  00188	80 7d ae 00	 cmp	 BYTE PTR tv163[ebp], 0
  0018c	74 18		 je	 SHORT $LN7@Construct_
  0018e	8a 45 c0	 mov	 al, BYTE PTR tv160[ebp]
  00191	24 07		 and	 al, 7
  00193	04 03		 add	 al, 3
  00195	3a 45 ae	 cmp	 al, BYTE PTR tv163[ebp]
  00198	7c 0c		 jl	 SHORT $LN7@Construct_
  0019a	8b 4d c0	 mov	 ecx, DWORD PTR tv160[ebp]
  0019d	51		 push	 ecx
  0019e	e8 00 00 00 00	 call	 ___asan_report_store4
  001a3	83 c4 04	 add	 esp, 4
$LN7@Construct_:
  001a6	8b 55 c8	 mov	 edx, DWORD PTR tv83[ebp]
  001a9	8b 45 d4	 mov	 eax, DWORD PTR tv85[ebp]
  001ac	89 02		 mov	 DWORD PTR [edx], eax

; 494  :             _Guard._Target   = nullptr;

  001ae	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  001b1	89 4d c4	 mov	 DWORD PTR tv150[ebp], ecx
  001b4	8b 55 c4	 mov	 edx, DWORD PTR tv150[ebp]
  001b7	c1 ea 03	 shr	 edx, 3
  001ba	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001c0	88 45 af	 mov	 BYTE PTR tv153[ebp], al
  001c3	80 7d af 00	 cmp	 BYTE PTR tv153[ebp], 0
  001c7	74 1a		 je	 SHORT $LN6@Construct_
  001c9	8a 4d c4	 mov	 cl, BYTE PTR tv150[ebp]
  001cc	80 e1 07	 and	 cl, 7
  001cf	80 c1 03	 add	 cl, 3
  001d2	3a 4d af	 cmp	 cl, BYTE PTR tv153[ebp]
  001d5	7c 0c		 jl	 SHORT $LN6@Construct_
  001d7	8b 55 c4	 mov	 edx, DWORD PTR tv150[ebp]
  001da	52		 push	 edx
  001db	e8 00 00 00 00	 call	 ___asan_report_store4
  001e0	83 c4 04	 add	 esp, 4
$LN6@Construct_:
  001e3	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __Guard$3[ebp], 0

; 495  :         }

  001ea	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001ee	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  001f1	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
  001f6	8d 45 80	 lea	 eax, DWORD PTR __Guard$3[ebp]
  001f9	c1 e8 03	 shr	 eax, 3
  001fc	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
$LN2@Construct_:

; 496  : 
; 497  :         _Proxy._Release();

  00203	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00209	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 498  :     }

  0020e	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00215	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0021b	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00220	c7 85 50 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0022a	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00230	c1 e9 03	 shr	 ecx, 3
  00233	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00239	89 4d d8	 mov	 DWORD PTR tv146[ebp], ecx
  0023c	6a 0b		 push	 11			; 0000000bH
  0023e	8b 55 d8	 mov	 edx, DWORD PTR tv146[ebp]
  00241	52		 push	 edx
  00242	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00247	83 c4 08	 add	 esp, 8
  0024a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0024d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00254	59		 pop	 ecx
  00255	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00258	33 cd		 xor	 ecx, ebp
  0025a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025f	8b e5		 mov	 esp, ebp
  00261	5d		 pop	 ebp
  00262	8b e3		 mov	 esp, ebx
  00264	5b		 pop	 ebx
  00265	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$0:
  00000	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$1:
  0000b	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z ; std::forward<std::allocator<unsigned int> const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ; std::forward<std::allocator<unsigned int> >
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
tv79 = -20						; size = 4
tv74 = -16						; size = 4
tv82 = -12						; size = 4
tv92 = -8						; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z PROC	; std::_Move_unchecked<unsigned int *,unsigned int *>, COMDAT

; 4417 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4418 :     // move [_First, _Last) to [_Dest, ...)
; 4419 :     // note: _Move_unchecked has callers other than the move family
; 4420 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4421 : #ifdef __cpp_lib_is_constant_evaluated
; 4422 :         if (!_STD is_constant_evaluated())

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	75 19		 jne	 SHORT $LN5@Move_unche

; 4423 : #endif // __cpp_lib_is_constant_evaluated
; 4424 :         {
; 4425 :             return _Copy_memmove(_First, _Last, _Dest);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_memmove<unsigned int *,unsigned int *>
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	e9 b1 00 00 00	 jmp	 $LN1@Move_unche
$LN5@Move_unche:

; 4426 :         }
; 4427 :     }
; 4428 : 
; 4429 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00035	eb 12		 jmp	 SHORT $LN4@Move_unche
$LN2@Move_unche:
  00037	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00043	83 c2 04	 add	 edx, 4
  00046	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@Move_unche:
  00049	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004f	0f 84 8e 00 00
	00		 je	 $LN3@Move_unche

; 4430 :         *_Dest = _STD move(*_First);

  00055	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$move@AAI@std@@YA$$QAIAAI@Z ; std::move<unsigned int &>
  0005e	83 c4 04	 add	 esp, 4
  00061	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00064	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  00067	89 55 f8	 mov	 DWORD PTR tv92[ebp], edx
  0006a	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  0006d	c1 e8 03	 shr	 eax, 3
  00070	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00076	88 4d ff	 mov	 BYTE PTR tv95[ebp], cl
  00079	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  0007d	74 1a		 je	 SHORT $LN8@Move_unche
  0007f	8a 55 f8	 mov	 dl, BYTE PTR tv92[ebp]
  00082	80 e2 07	 and	 dl, 7
  00085	80 c2 03	 add	 dl, 3
  00088	3a 55 ff	 cmp	 dl, BYTE PTR tv95[ebp]
  0008b	7c 0c		 jl	 SHORT $LN8@Move_unche
  0008d	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ___asan_report_load4
  00096	83 c4 04	 add	 esp, 4
$LN8@Move_unche:
  00099	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0009c	89 4d ec	 mov	 DWORD PTR tv79[ebp], ecx
  0009f	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000a2	89 55 f4	 mov	 DWORD PTR tv82[ebp], edx
  000a5	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  000a8	c1 e8 03	 shr	 eax, 3
  000ab	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b1	88 4d fe	 mov	 BYTE PTR tv85[ebp], cl
  000b4	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  000b8	74 1a		 je	 SHORT $LN7@Move_unche
  000ba	8a 55 f4	 mov	 dl, BYTE PTR tv82[ebp]
  000bd	80 e2 07	 and	 dl, 7
  000c0	80 c2 03	 add	 dl, 3
  000c3	3a 55 fe	 cmp	 dl, BYTE PTR tv85[ebp]
  000c6	7c 0c		 jl	 SHORT $LN7@Move_unche
  000c8	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ___asan_report_store4
  000d1	83 c4 04	 add	 esp, 4
$LN7@Move_unche:
  000d4	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000d7	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  000da	8b 02		 mov	 eax, DWORD PTR [edx]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax

; 4431 :     }

  000de	e9 54 ff ff ff	 jmp	 $LN2@Move_unche
$LN3@Move_unche:

; 4432 : 
; 4433 :     return _Dest;

  000e3	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN1@Move_unche:

; 4434 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ENDP	; std::_Move_unchecked<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
tv92 = -32						; size = 4
tv75 = -28						; size = 4
tv77 = -24						; size = 4
tv87 = -20						; size = 4
$T1 = -16						; size = 4
tv95 = -12						; size = 4
tv137 = -8						; size = 4
tv130 = -2						; size = 1
tv140 = -1						; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 33		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 e8	 mov	 DWORD PTR tv77[ebp], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  0003a	8b 45 e8	 mov	 eax, DWORD PTR tv77[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d e4	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &,void>
  00047	83 c4 08	 add	 esp, 8

; 155  :     } else

  0004a	e9 ac 00 00 00	 jmp	 $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0004f	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
  00061	83 c4 04	 add	 esp, 4
  00064	50		 push	 eax
  00065	6a 04		 push	 4
  00067	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0006c	83 c4 08	 add	 esp, 8
  0006f	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00072	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  0007b	83 c4 04	 add	 esp, 4
  0007e	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
  00081	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  00084	89 4d f8	 mov	 DWORD PTR tv137[ebp], ecx
  00087	8b 55 f8	 mov	 edx, DWORD PTR tv137[ebp]
  0008a	c1 ea 03	 shr	 edx, 3
  0008d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00093	88 45 ff	 mov	 BYTE PTR tv140[ebp], al
  00096	80 7d ff 00	 cmp	 BYTE PTR tv140[ebp], 0
  0009a	74 1a		 je	 SHORT $LN6@Construct_
  0009c	8a 4d f8	 mov	 cl, BYTE PTR tv137[ebp]
  0009f	80 e1 07	 and	 cl, 7
  000a2	80 c1 03	 add	 cl, 3
  000a5	3a 4d ff	 cmp	 cl, BYTE PTR tv140[ebp]
  000a8	7c 0c		 jl	 SHORT $LN6@Construct_
  000aa	8b 55 f8	 mov	 edx, DWORD PTR tv137[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 ___asan_report_load4
  000b3	83 c4 04	 add	 esp, 4
$LN6@Construct_:
  000b6	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  000b9	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  000bc	8b 4d e0	 mov	 ecx, DWORD PTR tv92[ebp]
  000bf	89 4d f4	 mov	 DWORD PTR tv95[ebp], ecx
  000c2	8b 55 f4	 mov	 edx, DWORD PTR tv95[ebp]
  000c5	c1 ea 03	 shr	 edx, 3
  000c8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000ce	88 45 fe	 mov	 BYTE PTR tv130[ebp], al
  000d1	80 7d fe 00	 cmp	 BYTE PTR tv130[ebp], 0
  000d5	74 1a		 je	 SHORT $LN5@Construct_
  000d7	8a 4d f4	 mov	 cl, BYTE PTR tv95[ebp]
  000da	80 e1 07	 and	 cl, 7
  000dd	80 c1 03	 add	 cl, 3
  000e0	3a 4d fe	 cmp	 cl, BYTE PTR tv130[ebp]
  000e3	7c 0c		 jl	 SHORT $LN5@Construct_
  000e5	8b 55 f4	 mov	 edx, DWORD PTR tv95[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 ___asan_report_store4
  000ee	83 c4 04	 add	 esp, 4
$LN5@Construct_:
  000f1	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000f7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f9	89 10		 mov	 DWORD PTR [eax], edx
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
_TEXT	SEGMENT
__asan_gen_0$ = -144					; size = 4
__asan_gen_1$ = -140					; size = 4
__asan_gen_2$ = -136					; size = 4
__New_ptr$ = -128					; size = 4
tv241 = -86						; size = 1
tv231 = -85						; size = 1
tv221 = -84						; size = 1
tv211 = -83						; size = 1
tv201 = -82						; size = 1
tv191 = -81						; size = 1
_this$ = -80						; size = 4
tv181 = -76						; size = 4
tv238 = -72						; size = 4
tv228 = -68						; size = 4
tv218 = -64						; size = 4
tv208 = -60						; size = 4
__New_capacity$ = -56					; size = 4
tv198 = -52						; size = 4
tv188 = -48						; size = 4
tv69 = -44						; size = 4
tv136 = -40						; size = 4
tv139 = -36						; size = 4
__Old_capacity$ = -32					; size = 4
__Al$ = -28						; size = 4
tv158 = -24						; size = 4
tv179 = -20						; size = 4
tv75 = -16						; size = 4
tv184 = -12						; size = 4
tv166 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT
; _this$ = ecx

; 4505 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 85 70 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00033	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
  0003d	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
  00047	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004d	89 45 ec	 mov	 DWORD PTR tv179[ebp], eax
  00050	8b 4d ec	 mov	 ecx, DWORD PTR tv179[ebp]
  00053	c1 e9 03	 shr	 ecx, 3
  00056	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0005c	89 4d b4	 mov	 DWORD PTR tv181[ebp], ecx
  0005f	8b 55 b4	 mov	 edx, DWORD PTR tv181[ebp]
  00062	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00068	83 45 b4 04	 add	 DWORD PTR tv181[ebp], 4
  0006c	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00071	8b 4d b4	 mov	 ecx, DWORD PTR tv181[ebp]
  00074	66 89 01	 mov	 WORD PTR [ecx], ax
  00077	83 45 b4 02	 add	 DWORD PTR tv181[ebp], 2
  0007b	8b 55 b4	 mov	 edx, DWORD PTR tv181[ebp]
  0007e	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00086	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4506 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4507 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4508 :         if (_New_size > max_size()) {

  0008b	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00093	39 43 08	 cmp	 DWORD PTR __New_size$[ebx], eax
  00096	76 05		 jbe	 SHORT $LN2@Reallocate

; 4509 :             _Xlen_string(); // result too long

  00098	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4510 :         }
; 4511 : 
; 4512 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0009d	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	83 c0 18	 add	 eax, 24			; 00000018H
  000a3	89 45 d4	 mov	 DWORD PTR tv69[ebp], eax
  000a6	8b 4d d4	 mov	 ecx, DWORD PTR tv69[ebp]
  000a9	89 4d b8	 mov	 DWORD PTR tv238[ebp], ecx
  000ac	8b 55 b8	 mov	 edx, DWORD PTR tv238[ebp]
  000af	c1 ea 03	 shr	 edx, 3
  000b2	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b8	88 45 aa	 mov	 BYTE PTR tv241[ebp], al
  000bb	80 7d aa 00	 cmp	 BYTE PTR tv241[ebp], 0
  000bf	74 1a		 je	 SHORT $LN12@Reallocate
  000c1	8a 4d b8	 mov	 cl, BYTE PTR tv238[ebp]
  000c4	80 e1 07	 and	 cl, 7
  000c7	80 c1 03	 add	 cl, 3
  000ca	3a 4d aa	 cmp	 cl, BYTE PTR tv241[ebp]
  000cd	7c 0c		 jl	 SHORT $LN12@Reallocate
  000cf	8b 55 b8	 mov	 edx, DWORD PTR tv238[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 ___asan_report_load4
  000d8	83 c4 04	 add	 esp, 4
$LN12@Reallocate:
  000db	8b 45 d4	 mov	 eax, DWORD PTR tv69[ebp]
  000de	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e0	89 4d e0	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4513 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  000e3	8b 53 08	 mov	 edx, DWORD PTR __New_size$[ebx]
  000e6	52		 push	 edx
  000e7	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000ef	89 45 c8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4514 :         auto& _Al                     = _Getal();

  000f2	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000fa	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000fd	33 c0		 xor	 eax, eax
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00102	83 c1 01	 add	 ecx, 1
  00105	0f 92 c0	 setb	 al
  00108	f7 d8		 neg	 eax
  0010a	0b c1		 or	 eax, ecx
  0010c	50		 push	 eax
  0010d	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00110	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  00115	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
  00118	8d 55 80	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  0011b	89 55 bc	 mov	 DWORD PTR tv228[ebp], edx
  0011e	8b 45 bc	 mov	 eax, DWORD PTR tv228[ebp]
  00121	c1 e8 03	 shr	 eax, 3
  00124	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012a	88 4d ab	 mov	 BYTE PTR tv231[ebp], cl
  0012d	80 7d ab 00	 cmp	 BYTE PTR tv231[ebp], 0
  00131	74 1a		 je	 SHORT $LN11@Reallocate
  00133	8a 55 bc	 mov	 dl, BYTE PTR tv228[ebp]
  00136	80 e2 07	 and	 dl, 7
  00139	80 c2 03	 add	 dl, 3
  0013c	3a 55 ab	 cmp	 dl, BYTE PTR tv231[ebp]
  0013f	7c 0c		 jl	 SHORT $LN11@Reallocate
  00141	8b 45 bc	 mov	 eax, DWORD PTR tv228[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ___asan_report_store4
  0014a	83 c4 04	 add	 esp, 4
$LN11@Reallocate:
  0014d	8b 4d f0	 mov	 ecx, DWORD PTR tv75[ebp]
  00150	89 4d 80	 mov	 DWORD PTR __New_ptr$[ebp], ecx

; 4516 : 
; 4517 : #ifdef __cpp_lib_constexpr_string
; 4518 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  00153	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00158	0f b6 d0	 movzx	 edx, al
  0015b	85 d2		 test	 edx, edx
  0015d	74 1e		 je	 SHORT $LN3@Reallocate

; 4519 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  0015f	6a 00		 push	 0
  00161	8b 45 c8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00164	83 c0 01	 add	 eax, 1
  00167	50		 push	 eax
  00168	8b 4d 80	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00171	83 c4 04	 add	 esp, 4
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Reallocate:

; 4520 :         }
; 4521 : #endif // __cpp_lib_constexpr_string
; 4522 :         _Mypair._Myval2._Orphan_all();

  0017d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  00185	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00188	83 c2 14	 add	 edx, 20			; 00000014H
  0018b	89 55 d8	 mov	 DWORD PTR tv136[ebp], edx
  0018e	8b 45 d8	 mov	 eax, DWORD PTR tv136[ebp]
  00191	89 45 c0	 mov	 DWORD PTR tv218[ebp], eax
  00194	8b 4d c0	 mov	 ecx, DWORD PTR tv218[ebp]
  00197	c1 e9 03	 shr	 ecx, 3
  0019a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001a0	88 55 ac	 mov	 BYTE PTR tv221[ebp], dl
  001a3	80 7d ac 00	 cmp	 BYTE PTR tv221[ebp], 0
  001a7	74 18		 je	 SHORT $LN10@Reallocate
  001a9	8a 45 c0	 mov	 al, BYTE PTR tv218[ebp]
  001ac	24 07		 and	 al, 7
  001ae	04 03		 add	 al, 3
  001b0	3a 45 ac	 cmp	 al, BYTE PTR tv221[ebp]
  001b3	7c 0c		 jl	 SHORT $LN10@Reallocate
  001b5	8b 4d c0	 mov	 ecx, DWORD PTR tv218[ebp]
  001b8	51		 push	 ecx
  001b9	e8 00 00 00 00	 call	 ___asan_report_store4
  001be	83 c4 04	 add	 esp, 4
$LN10@Reallocate:
  001c1	8b 55 d8	 mov	 edx, DWORD PTR tv136[ebp]
  001c4	8b 43 08	 mov	 eax, DWORD PTR __New_size$[ebx]
  001c7	89 02		 mov	 DWORD PTR [edx], eax

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  001c9	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	83 c1 18	 add	 ecx, 24			; 00000018H
  001cf	89 4d dc	 mov	 DWORD PTR tv139[ebp], ecx
  001d2	8b 55 dc	 mov	 edx, DWORD PTR tv139[ebp]
  001d5	89 55 c4	 mov	 DWORD PTR tv208[ebp], edx
  001d8	8b 45 c4	 mov	 eax, DWORD PTR tv208[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d ad	 mov	 BYTE PTR tv211[ebp], cl
  001e7	80 7d ad 00	 cmp	 BYTE PTR tv211[ebp], 0
  001eb	74 1a		 je	 SHORT $LN9@Reallocate
  001ed	8a 55 c4	 mov	 dl, BYTE PTR tv208[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 ad	 cmp	 dl, BYTE PTR tv211[ebp]
  001f9	7c 0c		 jl	 SHORT $LN9@Reallocate
  001fb	8b 45 c4	 mov	 eax, DWORD PTR tv208[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN9@Reallocate:
  00207	8b 4d dc	 mov	 ecx, DWORD PTR tv139[ebp]
  0020a	8b 55 c8	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  0020d	89 11		 mov	 DWORD PTR [ecx], edx

; 4525 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  0020f	8b 43 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebx]
  00212	50		 push	 eax
  00213	8b 4b 08	 mov	 ecx, DWORD PTR __New_size$[ebx]
  00216	51		 push	 ecx
  00217	8b 55 80	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00220	83 c4 04	 add	 esp, 4
  00223	50		 push	 eax
  00224	8d 4b 0c	 lea	 ecx, DWORD PTR __Fn$[ebx]
  00227	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  0022c	83 7d e0 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00230	0f 82 91 00 00
	00		 jb	 $LN4@Reallocate

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00236	8b 45 e0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00239	83 c0 01	 add	 eax, 1
  0023c	50		 push	 eax
  0023d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00243	52		 push	 edx
  00244	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00247	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4528 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  0024c	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0024f	83 c0 04	 add	 eax, 4
  00252	89 45 e8	 mov	 DWORD PTR tv158[ebp], eax
  00255	8d 4d 80	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00258	89 4d cc	 mov	 DWORD PTR tv198[ebp], ecx
  0025b	8b 55 cc	 mov	 edx, DWORD PTR tv198[ebp]
  0025e	c1 ea 03	 shr	 edx, 3
  00261	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00267	88 45 ae	 mov	 BYTE PTR tv201[ebp], al
  0026a	80 7d ae 00	 cmp	 BYTE PTR tv201[ebp], 0
  0026e	74 1a		 je	 SHORT $LN8@Reallocate
  00270	8a 4d cc	 mov	 cl, BYTE PTR tv198[ebp]
  00273	80 e1 07	 and	 cl, 7
  00276	80 c1 03	 add	 cl, 3
  00279	3a 4d ae	 cmp	 cl, BYTE PTR tv201[ebp]
  0027c	7c 0c		 jl	 SHORT $LN8@Reallocate
  0027e	8b 55 cc	 mov	 edx, DWORD PTR tv198[ebp]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 ___asan_report_load4
  00287	83 c4 04	 add	 esp, 4
$LN8@Reallocate:
  0028a	8b 45 e8	 mov	 eax, DWORD PTR tv158[ebp]
  0028d	89 45 d0	 mov	 DWORD PTR tv188[ebp], eax
  00290	8b 4d d0	 mov	 ecx, DWORD PTR tv188[ebp]
  00293	c1 e9 03	 shr	 ecx, 3
  00296	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0029c	88 55 af	 mov	 BYTE PTR tv191[ebp], dl
  0029f	80 7d af 00	 cmp	 BYTE PTR tv191[ebp], 0
  002a3	74 18		 je	 SHORT $LN7@Reallocate
  002a5	8a 45 d0	 mov	 al, BYTE PTR tv188[ebp]
  002a8	24 07		 and	 al, 7
  002aa	04 03		 add	 al, 3
  002ac	3a 45 af	 cmp	 al, BYTE PTR tv191[ebp]
  002af	7c 0c		 jl	 SHORT $LN7@Reallocate
  002b1	8b 4d d0	 mov	 ecx, DWORD PTR tv188[ebp]
  002b4	51		 push	 ecx
  002b5	e8 00 00 00 00	 call	 ___asan_report_store4
  002ba	83 c4 04	 add	 esp, 4
$LN7@Reallocate:
  002bd	8b 55 e8	 mov	 edx, DWORD PTR tv158[ebp]
  002c0	8b 45 80	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  002c3	89 02		 mov	 DWORD PTR [edx], eax

; 4529 :         } else {

  002c5	eb 13		 jmp	 SHORT $LN5@Reallocate
$LN4@Reallocate:

; 4530 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  002c7	8d 4d 80	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  002ca	51		 push	 ecx
  002cb	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  002ce	83 c2 04	 add	 edx, 4
  002d1	52		 push	 edx
  002d2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  002d7	83 c4 08	 add	 esp, 8
$LN5@Reallocate:

; 4531 :         }
; 4532 : 
; 4533 :         return *this;

  002da	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  002dd	89 45 f8	 mov	 DWORD PTR tv166[ebp], eax
  002e0	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  002ea	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  002f0	c1 e9 03	 shr	 ecx, 3
  002f3	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  002f9	89 4d f4	 mov	 DWORD PTR tv184[ebp], ecx
  002fc	6a 07		 push	 7
  002fe	8b 55 f4	 mov	 edx, DWORD PTR tv184[ebp]
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00307	83 c4 08	 add	 esp, 8
  0030a	8b 45 f8	 mov	 eax, DWORD PTR tv166[ebp]
$LN6@Reallocate:

; 4534 :     }

  0030d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00310	33 cd		 xor	 ecx, ebp
  00312	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00317	8b e5		 mov	 esp, ebp
  00319	5d		 pop	 ebp
  0031a	8b e3		 mov	 esp, ebx
  0031c	5b		 pop	 ebx
  0031d	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 1
tv89 = -21						; size = 1
tv76 = -20						; size = 4
tv86 = -16						; size = 4
tv74 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT
; _this$ = ecx

; 3259 :             },

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00023	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
  00031	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00043	89 4d ec	 mov	 DWORD PTR tv76[ebp], ecx
  00046	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00049	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0004f	83 45 ec 04	 add	 DWORD PTR tv76[ebp], 4
  00053	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00058	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  0005b	66 89 01	 mov	 WORD PTR [ecx], ax
  0005e	83 45 ec 02	 add	 DWORD PTR tv76[ebp], 2
  00062	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00065	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0006d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3257 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00072	8b 43 0c	 mov	 eax, DWORD PTR __Count$[ebx]
  00075	50		 push	 eax
  00076	8b 4b 10	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  00079	51		 push	 ecx
  0007a	8b 53 08	 mov	 edx, DWORD PTR __New_ptr$[ebx]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00086	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  00089	89 45 f0	 mov	 DWORD PTR tv86[ebp], eax
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR tv86[ebp]
  0008f	c1 e9 03	 shr	 ecx, 3
  00092	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00098	88 55 eb	 mov	 BYTE PTR tv89[ebp], dl
  0009b	80 7d eb 00	 cmp	 BYTE PTR tv89[ebp], 0
  0009f	74 16		 je	 SHORT $LN3@operator
  000a1	8a 45 f0	 mov	 al, BYTE PTR tv86[ebp]
  000a4	24 07		 and	 al, 7
  000a6	3a 45 eb	 cmp	 al, BYTE PTR tv89[ebp]
  000a9	7c 0c		 jl	 SHORT $LN3@operator
  000ab	8b 4d f0	 mov	 ecx, DWORD PTR tv86[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ___asan_report_store1
  000b4	83 c4 04	 add	 esp, 4
$LN3@operator:
  000b7	c6 45 c0 00	 mov	 BYTE PTR $T2[ebp], 0
  000bb	8d 55 c0	 lea	 edx, DWORD PTR $T2[ebp]
  000be	52		 push	 edx
  000bf	8b 43 08	 mov	 eax, DWORD PTR __New_ptr$[ebx]
  000c2	03 43 0c	 add	 eax, DWORD PTR __Count$[ebx]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000cb	83 c4 08	 add	 esp, 8
  000ce	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  000d1	c1 e9 03	 shr	 ecx, 3
  000d4	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 3259 :             },

  000db	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000e2	8d 55 b0	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000e5	c1 ea 03	 shr	 edx, 3
  000e8	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000ee	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  000f1	6a 07		 push	 7
  000f3	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000fc	83 c4 08	 add	 esp, 8
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	8b e3		 mov	 esp, ebx
  00104	5b		 pop	 ebx
  00105	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::allocator<unsigned int>::allocator<unsigned int><bool>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::allocator<unsigned int>::allocator<unsigned int><bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ
_TEXT	SEGMENT
tv128 = -24						; size = 4
tv130 = -20						; size = 4
_this$ = -16						; size = 4
tv162 = -12						; size = 4
__Cont$ = -8						; size = 4
tv165 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 2329 :     _NODISCARD _CONSTEXPR20_CONTAINER reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2330 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2331 :         const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());

  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 f8	 mov	 DWORD PTR __Cont$[ebp], eax
$LN4@operator:

; 2332 :         _STL_VERIFY(_Cont, "cannot dereference value-initialized vector<bool> iterator");

  0001e	83 7d f8 00	 cmp	 DWORD PTR __Cont$[ebp], 0
  00022	74 02		 je	 SHORT $LN7@operator
  00024	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00030	6a 00		 push	 0
  00032	68 1c 09 00 00	 push	 2332			; 0000091cH
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0003c	6a 02		 push	 2
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	83 f8 01	 cmp	 eax, 1
  0004a	75 01		 jne	 SHORT $LN19@operator
  0004c	cc		 int	 3
$LN19@operator:
  0004d	6a 00		 push	 0
  0004f	68 1c 09 00 00	 push	 2332			; 0000091cH
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	33 c9		 xor	 ecx, ecx
  0006e	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  00070	33 d2		 xor	 edx, edx
  00072	75 aa		 jne	 SHORT $LN4@operator
$LN10@operator:

; 2333 :         _STL_VERIFY(this->_Total_off(_Cont) < static_cast<_Difference_type>(_Cont->_Mysize),

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Cont$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
  00080	89 45 e8	 mov	 DWORD PTR tv128[ebp], eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Cont$[ebp]
  00086	83 c1 14	 add	 ecx, 20			; 00000014H
  00089	89 4d ec	 mov	 DWORD PTR tv130[ebp], ecx
  0008c	8b 55 ec	 mov	 edx, DWORD PTR tv130[ebp]
  0008f	89 55 f4	 mov	 DWORD PTR tv162[ebp], edx
  00092	8b 45 f4	 mov	 eax, DWORD PTR tv162[ebp]
  00095	c1 e8 03	 shr	 eax, 3
  00098	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0009e	88 4d ff	 mov	 BYTE PTR tv165[ebp], cl
  000a1	80 7d ff 00	 cmp	 BYTE PTR tv165[ebp], 0
  000a5	74 1a		 je	 SHORT $LN21@operator
  000a7	8a 55 f4	 mov	 dl, BYTE PTR tv162[ebp]
  000aa	80 e2 07	 and	 dl, 7
  000ad	80 c2 03	 add	 dl, 3
  000b0	3a 55 ff	 cmp	 dl, BYTE PTR tv165[ebp]
  000b3	7c 0c		 jl	 SHORT $LN21@operator
  000b5	8b 45 f4	 mov	 eax, DWORD PTR tv162[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ___asan_report_load4
  000be	83 c4 04	 add	 esp, 4
$LN21@operator:
  000c1	8b 4d ec	 mov	 ecx, DWORD PTR tv130[ebp]
  000c4	8b 55 e8	 mov	 edx, DWORD PTR tv128[ebp]
  000c7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000c9	7d 02		 jge	 SHORT $LN13@operator
  000cb	eb 4a		 jmp	 SHORT $LN8@operator
$LN13@operator:
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000d7	6a 00		 push	 0
  000d9	68 1e 09 00 00	 push	 2334			; 0000091eH
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000e3	6a 02		 push	 2
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	75 01		 jne	 SHORT $LN20@operator
  000f3	cc		 int	 3
$LN20@operator:
  000f4	6a 00		 push	 0
  000f6	68 1e 09 00 00	 push	 2334			; 0000091eH
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	33 c9		 xor	 ecx, ecx
  00115	75 b6		 jne	 SHORT $LN13@operator
$LN8@operator:
  00117	33 d2		 xor	 edx, edx
  00119	0f 85 55 ff ff
	ff		 jne	 $LN10@operator

; 2334 :             "vector<bool> iterator not dereferenceable");
; 2335 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2336 : 
; 2337 :         return _Reft(*this);

  0011f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00122	50		 push	 eax
  00123	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00126	e8 00 00 00 00	 call	 ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
  0012b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2338 :     }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Mypvbool$ = 12					; size = 4
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2124 :     _CONSTEXPR20_CONTAINER _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2125 :         : _Mybase(_Ptr, 0, _Mypvbool) {}

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Mypvbool$[ebp]
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__asan_gen_0$ = -88					; size = 4
__asan_gen_1$ = -84					; size = 4
__asan_gen_2$ = -80					; size = 4
__Tmp$ = -72						; size = 12
tv79 = -24						; size = 4
tv77 = -20						; size = 4
_this$ = -16						; size = 4
tv82 = -12						; size = 4
tv67 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 310  :     _NODISCARD _CONSTEXPR20_CONTAINER _Vector_iterator operator+(const difference_type _Off) const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 a8 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
  00034	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
  0003b	8d 45 a8	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR tv77[ebp], eax
  00041	8b 4d ec	 mov	 ecx, DWORD PTR tv77[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d e8	 mov	 DWORD PTR tv79[ebp], ecx
  00050	8b 55 e8	 mov	 edx, DWORD PTR tv79[ebp]
  00053	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  00059	83 45 e8 04	 add	 DWORD PTR tv79[ebp], 4
  0005d	8b 45 e8	 mov	 eax, DWORD PTR tv79[ebp]
  00060	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00066	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 311  :         _Vector_iterator _Tmp = *this;

  00070	6a 0c		 push	 12			; 0000000cH
  00072	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00075	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	51		 push	 ecx
  0007e	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00081	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z

; 312  :         _Tmp += _Off; // TRANSITION, LLVM-49342

  00086	8b 53 0c	 mov	 edx, DWORD PTR __Off$[ebx]
  00089	52		 push	 edx
  0008a	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0008d	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=

; 313  :         return _Tmp;

  00092	8d 45 b8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00095	50		 push	 eax
  00096	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00099	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  0009e	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  000a6	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  000a9	89 4d f8	 mov	 DWORD PTR tv67[ebp], ecx
  000ac	c7 45 a8 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000b3	8d 55 a8	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000b6	c1 ea 03	 shr	 edx, 3
  000b9	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000bf	89 55 f4	 mov	 DWORD PTR tv82[ebp], edx
  000c2	6a 08		 push	 8
  000c4	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000cd	83 c4 08	 add	 esp, 8
  000d0	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]

; 314  :     }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	8b e3		 mov	 esp, ebx
  000e2	5b		 pop	 ebx
  000e3	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 305  :     _CONSTEXPR20_CONTAINER _Vector_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 306  :         _Mybase::operator+=(_Off);

  00011	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=

; 307  :         return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv81 = -24						; size = 4
tv80 = -20						; size = 4
_this$ = -16						; size = 4
tv85 = -12						; size = 4
tv95 = -8						; size = 4
tv88 = -2						; size = 1
tv130 = -1						; size = 1
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00018	83 c1 08	 add	 ecx, 8
  0001b	89 4d e8	 mov	 DWORD PTR tv81[ebp], ecx
  0001e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00021	83 c2 08	 add	 edx, 8
  00024	89 55 ec	 mov	 DWORD PTR tv80[ebp], edx
  00027	8b 45 e8	 mov	 eax, DWORD PTR tv81[ebp]
  0002a	89 45 f8	 mov	 DWORD PTR tv95[ebp], eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR tv95[ebp]
  00030	c1 e9 03	 shr	 ecx, 3
  00033	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00039	88 55 ff	 mov	 BYTE PTR tv130[ebp], dl
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv130[ebp], 0
  00040	74 18		 je	 SHORT $LN4@Vector_con
  00042	8a 45 f8	 mov	 al, BYTE PTR tv95[ebp]
  00045	24 07		 and	 al, 7
  00047	04 03		 add	 al, 3
  00049	3a 45 ff	 cmp	 al, BYTE PTR tv130[ebp]
  0004c	7c 0c		 jl	 SHORT $LN4@Vector_con
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR tv95[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ___asan_report_load4
  00057	83 c4 04	 add	 esp, 4
$LN4@Vector_con:
  0005a	8b 55 ec	 mov	 edx, DWORD PTR tv80[ebp]
  0005d	89 55 f4	 mov	 DWORD PTR tv85[ebp], edx
  00060	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00063	c1 e8 03	 shr	 eax, 3
  00066	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006c	88 4d fe	 mov	 BYTE PTR tv88[ebp], cl
  0006f	80 7d fe 00	 cmp	 BYTE PTR tv88[ebp], 0
  00073	74 1a		 je	 SHORT $LN3@Vector_con
  00075	8a 55 f4	 mov	 dl, BYTE PTR tv85[ebp]
  00078	80 e2 07	 and	 dl, 7
  0007b	80 c2 03	 add	 dl, 3
  0007e	3a 55 fe	 cmp	 dl, BYTE PTR tv88[ebp]
  00081	7c 0c		 jl	 SHORT $LN3@Vector_con
  00083	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN3@Vector_con:
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR tv80[ebp]
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv81[ebp]
  00095	8b 02		 mov	 eax, DWORD PTR [edx]
  00097	89 01		 mov	 DWORD PTR [ecx], eax
  00099	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
tv69 = -32						; size = 4
tv67 = -28						; size = 4
tv68 = -24						; size = 4
tv66 = -20						; size = 4
tv75 = -16						; size = 4
tv85 = -12						; size = 4
_this$ = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 121  :     _CONSTEXPR20_CONTAINER _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  :         _Verify_offset(_Off);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00016	50		 push	 eax
  00017	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset

; 123  :         _Ptr += _Off;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00022	c1 e1 02	 shl	 ecx, 2
  00025	89 4d e4	 mov	 DWORD PTR tv67[ebp], ecx
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	83 c2 08	 add	 edx, 8
  0002e	89 55 ec	 mov	 DWORD PTR tv66[ebp], edx
  00031	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv85[ebp], eax
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00043	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00046	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  0004a	74 18		 je	 SHORT $LN4@operator
  0004c	8a 45 f4	 mov	 al, BYTE PTR tv85[ebp]
  0004f	24 07		 and	 al, 7
  00051	04 03		 add	 al, 3
  00053	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00056	7c 0c		 jl	 SHORT $LN4@operator
  00058	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ___asan_report_load4
  00061	83 c4 04	 add	 esp, 4
$LN4@operator:
  00064	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	03 45 e4	 add	 eax, DWORD PTR tv67[ebp]
  0006c	89 45 e0	 mov	 DWORD PTR tv69[ebp], eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	83 c1 08	 add	 ecx, 8
  00075	89 4d e8	 mov	 DWORD PTR tv68[ebp], ecx
  00078	8b 55 e8	 mov	 edx, DWORD PTR tv68[ebp]
  0007b	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  0007e	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00081	c1 e8 03	 shr	 eax, 3
  00084	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0008a	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  0008d	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00091	74 1a		 je	 SHORT $LN3@operator
  00093	8a 55 f0	 mov	 dl, BYTE PTR tv75[ebp]
  00096	80 e2 07	 and	 dl, 7
  00099	80 c2 03	 add	 dl, 3
  0009c	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  0009f	7c 0c		 jl	 SHORT $LN3@operator
  000a1	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ___asan_report_store4
  000aa	83 c4 04	 add	 esp, 4
$LN3@operator:
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR tv68[ebp]
  000b0	8b 55 e0	 mov	 edx, DWORD PTR tv69[ebp]
  000b3	89 11		 mov	 DWORD PTR [ecx], edx

; 124  :         return *this;

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 125  :     }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
tv149 = -56						; size = 4
tv148 = -52						; size = 4
__Mycont$ = -48						; size = 4
tv95 = -44						; size = 4
tv94 = -40						; size = 4
tv75 = -36						; size = 4
tv180 = -32						; size = 4
tv190 = -28						; size = 4
tv200 = -24						; size = 4
tv210 = -20						; size = 4
tv220 = -16						; size = 4
_this$ = -12						; size = 4
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
__Off$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset, COMDAT
; _this$ = ecx

; 105  :     _CONSTEXPR20_CONTAINER void _Verify_offset(const difference_type _Off) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 106  : #if _ITERATOR_DEBUG_LEVEL == 0
; 107  :         (void) _Off;
; 108  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 109  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 d0	 mov	 DWORD PTR __Mycont$[ebp], eax
$LN4@Verify_off:

; 110  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");

  0001e	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  00022	74 46		 je	 SHORT $LN22@Verify_off
  00024	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c0 08	 add	 eax, 8
  0002a	89 45 dc	 mov	 DWORD PTR tv75[ebp], eax
  0002d	8b 4d dc	 mov	 ecx, DWORD PTR tv75[ebp]
  00030	89 4d f0	 mov	 DWORD PTR tv220[ebp], ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR tv220[ebp]
  00036	c1 ea 03	 shr	 edx, 3
  00039	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0003f	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  00042	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00046	74 1a		 je	 SHORT $LN37@Verify_off
  00048	8a 4d f0	 mov	 cl, BYTE PTR tv220[ebp]
  0004b	80 e1 07	 and	 cl, 7
  0004e	80 c1 03	 add	 cl, 3
  00051	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00054	7c 0c		 jl	 SHORT $LN37@Verify_off
  00056	8b 55 f0	 mov	 edx, DWORD PTR tv220[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ___asan_report_load4
  0005f	83 c4 04	 add	 esp, 4
$LN37@Verify_off:
  00062	8b 45 dc	 mov	 eax, DWORD PTR tv75[ebp]
  00065	83 38 00	 cmp	 DWORD PTR [eax], 0
  00068	74 02		 je	 SHORT $LN7@Verify_off
$LN22@Verify_off:
  0006a	eb 44		 jmp	 SHORT $LN2@Verify_off
$LN7@Verify_off:
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00076	6a 00		 push	 0
  00078	6a 6e		 push	 110			; 0000006eH
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0007f	6a 02		 push	 2
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00087	83 c4 18	 add	 esp, 24			; 00000018H
  0008a	83 f8 01	 cmp	 eax, 1
  0008d	75 01		 jne	 SHORT $LN30@Verify_off
  0008f	cc		 int	 3
$LN30@Verify_off:
  00090	6a 00		 push	 0
  00092	6a 6e		 push	 110			; 0000006eH
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000a9	83 c4 14	 add	 esp, 20			; 00000014H
  000ac	33 d2		 xor	 edx, edx
  000ae	75 bc		 jne	 SHORT $LN7@Verify_off
$LN2@Verify_off:
  000b0	33 c0		 xor	 eax, eax
  000b2	0f 85 66 ff ff
	ff		 jne	 $LN4@Verify_off

; 111  :         if (_Off < 0) {

  000b8	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  000bc	0f 8d da 00 00
	00		 jge	 $LN23@Verify_off
$LN10@Verify_off:

; 112  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");

  000c2	8b 4d d0	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  000c5	83 c1 04	 add	 ecx, 4
  000c8	89 4d d8	 mov	 DWORD PTR tv94[ebp], ecx
  000cb	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 08	 add	 edx, 8
  000d1	89 55 d4	 mov	 DWORD PTR tv95[ebp], edx
  000d4	8b 45 d8	 mov	 eax, DWORD PTR tv94[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv210[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv210[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fe	 mov	 BYTE PTR tv213[ebp], dl
  000e9	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  000ed	74 18		 je	 SHORT $LN36@Verify_off
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv210[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fe	 cmp	 al, BYTE PTR tv213[ebp]
  000f9	7c 0c		 jl	 SHORT $LN36@Verify_off
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv210[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN36@Verify_off:
  00107	8b 55 d4	 mov	 edx, DWORD PTR tv95[ebp]
  0010a	89 55 e8	 mov	 DWORD PTR tv200[ebp], edx
  0010d	8b 45 e8	 mov	 eax, DWORD PTR tv200[ebp]
  00110	c1 e8 03	 shr	 eax, 3
  00113	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00119	88 4d fd	 mov	 BYTE PTR tv203[ebp], cl
  0011c	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  00120	74 1a		 je	 SHORT $LN35@Verify_off
  00122	8a 55 e8	 mov	 dl, BYTE PTR tv200[ebp]
  00125	80 e2 07	 and	 dl, 7
  00128	80 c2 03	 add	 dl, 3
  0012b	3a 55 fd	 cmp	 dl, BYTE PTR tv203[ebp]
  0012e	7c 0c		 jl	 SHORT $LN35@Verify_off
  00130	8b 45 e8	 mov	 eax, DWORD PTR tv200[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ___asan_report_load4
  00139	83 c4 04	 add	 esp, 4
$LN35@Verify_off:
  0013c	8b 4d d8	 mov	 ecx, DWORD PTR tv94[ebp]
  0013f	8b 55 d4	 mov	 edx, DWORD PTR tv95[ebp]
  00142	8b 01		 mov	 eax, DWORD PTR [ecx]
  00144	2b 02		 sub	 eax, DWORD PTR [edx]
  00146	c1 f8 02	 sar	 eax, 2
  00149	39 45 08	 cmp	 DWORD PTR __Off$[ebp], eax
  0014c	7c 02		 jl	 SHORT $LN13@Verify_off
  0014e	eb 44		 jmp	 SHORT $LN8@Verify_off
$LN13@Verify_off:
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0015a	6a 00		 push	 0
  0015c	6a 70		 push	 112			; 00000070H
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00163	6a 02		 push	 2
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0016b	83 c4 18	 add	 esp, 24			; 00000018H
  0016e	83 f8 01	 cmp	 eax, 1
  00171	75 01		 jne	 SHORT $LN31@Verify_off
  00173	cc		 int	 3
$LN31@Verify_off:
  00174	6a 00		 push	 0
  00176	6a 70		 push	 112			; 00000070H
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0018d	83 c4 14	 add	 esp, 20			; 00000014H
  00190	33 d2		 xor	 edx, edx
  00192	75 bc		 jne	 SHORT $LN13@Verify_off
$LN8@Verify_off:
  00194	33 c0		 xor	 eax, eax
  00196	0f 85 26 ff ff
	ff		 jne	 $LN10@Verify_off
$LN23@Verify_off:

; 113  :         }
; 114  : 
; 115  :         if (_Off > 0) {

  0019c	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  001a0	0f 8e da 00 00
	00		 jle	 $LN29@Verify_off
$LN16@Verify_off:

; 116  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");

  001a6	8b 4d d0	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  001a9	83 c1 08	 add	 ecx, 8
  001ac	89 4d cc	 mov	 DWORD PTR tv148[ebp], ecx
  001af	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001b2	83 c2 08	 add	 edx, 8
  001b5	89 55 c8	 mov	 DWORD PTR tv149[ebp], edx
  001b8	8b 45 cc	 mov	 eax, DWORD PTR tv148[ebp]
  001bb	89 45 e4	 mov	 DWORD PTR tv190[ebp], eax
  001be	8b 4d e4	 mov	 ecx, DWORD PTR tv190[ebp]
  001c1	c1 e9 03	 shr	 ecx, 3
  001c4	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001ca	88 55 fc	 mov	 BYTE PTR tv193[ebp], dl
  001cd	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  001d1	74 18		 je	 SHORT $LN34@Verify_off
  001d3	8a 45 e4	 mov	 al, BYTE PTR tv190[ebp]
  001d6	24 07		 and	 al, 7
  001d8	04 03		 add	 al, 3
  001da	3a 45 fc	 cmp	 al, BYTE PTR tv193[ebp]
  001dd	7c 0c		 jl	 SHORT $LN34@Verify_off
  001df	8b 4d e4	 mov	 ecx, DWORD PTR tv190[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ___asan_report_load4
  001e8	83 c4 04	 add	 esp, 4
$LN34@Verify_off:
  001eb	8b 55 c8	 mov	 edx, DWORD PTR tv149[ebp]
  001ee	89 55 e0	 mov	 DWORD PTR tv180[ebp], edx
  001f1	8b 45 e0	 mov	 eax, DWORD PTR tv180[ebp]
  001f4	c1 e8 03	 shr	 eax, 3
  001f7	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001fd	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  00200	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00204	74 1a		 je	 SHORT $LN33@Verify_off
  00206	8a 55 e0	 mov	 dl, BYTE PTR tv180[ebp]
  00209	80 e2 07	 and	 dl, 7
  0020c	80 c2 03	 add	 dl, 3
  0020f	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  00212	7c 0c		 jl	 SHORT $LN33@Verify_off
  00214	8b 45 e0	 mov	 eax, DWORD PTR tv180[ebp]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ___asan_report_load4
  0021d	83 c4 04	 add	 esp, 4
$LN33@Verify_off:
  00220	8b 4d cc	 mov	 ecx, DWORD PTR tv148[ebp]
  00223	8b 55 c8	 mov	 edx, DWORD PTR tv149[ebp]
  00226	8b 01		 mov	 eax, DWORD PTR [ecx]
  00228	2b 02		 sub	 eax, DWORD PTR [edx]
  0022a	c1 f8 02	 sar	 eax, 2
  0022d	39 45 08	 cmp	 DWORD PTR __Off$[ebp], eax
  00230	7f 02		 jg	 SHORT $LN19@Verify_off
  00232	eb 44		 jmp	 SHORT $LN14@Verify_off
$LN19@Verify_off:
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0023e	6a 00		 push	 0
  00240	6a 74		 push	 116			; 00000074H
  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00247	6a 02		 push	 2
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0024f	83 c4 18	 add	 esp, 24			; 00000018H
  00252	83 f8 01	 cmp	 eax, 1
  00255	75 01		 jne	 SHORT $LN32@Verify_off
  00257	cc		 int	 3
$LN32@Verify_off:
  00258	6a 00		 push	 0
  0025a	6a 74		 push	 116			; 00000074H
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  00266	68 00 00 00 00	 push	 OFFSET ??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00271	83 c4 14	 add	 esp, 20			; 00000014H
  00274	33 d2		 xor	 edx, edx
  00276	75 bc		 jne	 SHORT $LN19@Verify_off
$LN14@Verify_off:
  00278	33 c0		 xor	 eax, eax
  0027a	0f 85 26 ff ff
	ff		 jne	 $LN16@Verify_off
$LN29@Verify_off:

; 117  :         }
; 118  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 119  :     }

  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c2 04 00	 ret	 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
tv75 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
tv87 = -1						; size = 1
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 08	 add	 eax, 8
  00021	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
  00024	8b 4d f0	 mov	 ecx, DWORD PTR tv75[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0003d	74 1a		 je	 SHORT $LN3@Vector_con
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0004b	7c 0c		 jl	 SHORT $LN3@Vector_con
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN3@Vector_con:
  00059	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00061	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00064	52		 push	 edx
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 44   :     }

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 251  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  0002c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4

; 256  :     } else

  00044	eb 29		 jmp	 SHORT $LN5@Deallocate
$LN2@Deallocate:

; 257  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00046	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0004d	72 10		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004f	8d 55 0c	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00052	52		 push	 edx
  00053	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0005c	83 c4 08	 add	 esp, 8
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006c	83 c4 08	 add	 esp, 8
$LN5@Deallocate:

; 265  :     }
; 266  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1390 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 124  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 125  :             return _Ok;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 17		 je	 SHORT $LN3@operator
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@operator
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load1
  0004b	83 c4 04	 add	 esp, 4
$LN3@operator:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8a 00		 mov	 al, BYTE PTR [eax]

; 126  :         }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__Zero_uncaught_exceptions$ = -14			; size = 1
tv71 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

  00032	e8 00 00 00 00	 call	 ?uncaught_exceptions@std@@YAHXZ ; std::uncaught_exceptions
  00037	85 c0		 test	 eax, eax
  00039	75 06		 jne	 SHORT $LN4@sentry
  0003b	c6 45 f3 01	 mov	 BYTE PTR tv71[ebp], 1
  0003f	eb 04		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  00041	c6 45 f3 00	 mov	 BYTE PTR tv71[ebp], 0
$LN5@sentry:
  00045	8a 45 f3	 mov	 al, BYTE PTR tv71[ebp]
  00048	88 45 f2	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], al

; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0004b	0f b6 4d f2	 movzx	 ecx, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  0004f	85 c9		 test	 ecx, ecx
  00051	74 0b		 je	 SHORT $LN1@sentry

; 119  :                 this->_Myostr._Osfx();

  00053	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00056	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN1@sentry:

; 120  :             }
; 121  :         }

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00066	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00069	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00070	59		 pop	 ecx
  00071	8b e5		 mov	 esp, ebp
  00073	5d		 pop	 ebp
  00074	c3		 ret	 0
  00075	cc		 int	 3
  00076	cc		 int	 3
  00077	cc		 int	 3
  00078	cc		 int	 3
  00079	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv164 = -104						; size = 4
tv157 = -100						; size = 4
tv69 = -96						; size = 4
tv137 = -92						; size = 4
tv145 = -88						; size = 4
tv135 = -84						; size = 4
tv129 = -80						; size = 4
tv89 = -76						; size = 4
tv83 = -72						; size = 4
tv171 = -68						; size = 4
tv181 = -64						; size = 4
tv191 = -60						; size = 4
__Tied$ = -56						; size = 4
tv201 = -52						; size = 4
tv211 = -48						; size = 4
tv221 = -44						; size = 4
tv231 = -40						; size = 4
tv241 = -36						; size = 4
tv251 = -32						; size = 4
_this$ = -28						; size = 4
tv148 = -22						; size = 1
tv174 = -21						; size = 1
tv184 = -20						; size = 1
tv194 = -19						; size = 1
tv204 = -18						; size = 1
tv214 = -17						; size = 1
tv224 = -16						; size = 1
tv234 = -15						; size = 1
tv244 = -14						; size = 1
tv254 = -13						; size = 1
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00035	50		 push	 eax
  00036	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0003e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 93   :             if (!_Ostr.good()) {

  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00048	89 4d a0	 mov	 DWORD PTR tv69[ebp], ecx
  0004b	8b 55 a0	 mov	 edx, DWORD PTR tv69[ebp]
  0004e	89 55 e0	 mov	 DWORD PTR tv251[ebp], edx
  00051	8b 45 e0	 mov	 eax, DWORD PTR tv251[ebp]
  00054	c1 e8 03	 shr	 eax, 3
  00057	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0005d	88 4d f3	 mov	 BYTE PTR tv254[ebp], cl
  00060	80 7d f3 00	 cmp	 BYTE PTR tv254[ebp], 0
  00064	74 1a		 je	 SHORT $LN15@sentry
  00066	8a 55 e0	 mov	 dl, BYTE PTR tv251[ebp]
  00069	80 e2 07	 and	 dl, 7
  0006c	80 c2 03	 add	 dl, 3
  0006f	3a 55 f3	 cmp	 dl, BYTE PTR tv254[ebp]
  00072	7c 0c		 jl	 SHORT $LN15@sentry
  00074	8b 45 e0	 mov	 eax, DWORD PTR tv251[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___asan_report_load4
  0007d	83 c4 04	 add	 esp, 4
$LN15@sentry:
  00080	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00083	8b 11		 mov	 edx, DWORD PTR [ecx]
  00085	83 c2 04	 add	 edx, 4
  00088	89 55 b8	 mov	 DWORD PTR tv83[ebp], edx
  0008b	8b 45 b8	 mov	 eax, DWORD PTR tv83[ebp]
  0008e	89 45 dc	 mov	 DWORD PTR tv241[ebp], eax
  00091	8b 4d dc	 mov	 ecx, DWORD PTR tv241[ebp]
  00094	c1 e9 03	 shr	 ecx, 3
  00097	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0009d	88 55 f2	 mov	 BYTE PTR tv244[ebp], dl
  000a0	80 7d f2 00	 cmp	 BYTE PTR tv244[ebp], 0
  000a4	74 18		 je	 SHORT $LN14@sentry
  000a6	8a 45 dc	 mov	 al, BYTE PTR tv241[ebp]
  000a9	24 07		 and	 al, 7
  000ab	04 03		 add	 al, 3
  000ad	3a 45 f2	 cmp	 al, BYTE PTR tv244[ebp]
  000b0	7c 0c		 jl	 SHORT $LN14@sentry
  000b2	8b 4d dc	 mov	 ecx, DWORD PTR tv241[ebp]
  000b5	51		 push	 ecx
  000b6	e8 00 00 00 00	 call	 ___asan_report_load4
  000bb	83 c4 04	 add	 esp, 4
$LN14@sentry:
  000be	8b 55 b8	 mov	 edx, DWORD PTR tv83[ebp]
  000c1	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000c4	03 0a		 add	 ecx, DWORD PTR [edx]
  000c6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000cc	0f b6 c0	 movzx	 eax, al
  000cf	85 c0		 test	 eax, eax
  000d1	75 46		 jne	 SHORT $LN2@sentry

; 94   :                 _Ok = false;

  000d3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	83 c1 04	 add	 ecx, 4
  000d9	89 4d b4	 mov	 DWORD PTR tv89[ebp], ecx
  000dc	8b 55 b4	 mov	 edx, DWORD PTR tv89[ebp]
  000df	89 55 d8	 mov	 DWORD PTR tv231[ebp], edx
  000e2	8b 45 d8	 mov	 eax, DWORD PTR tv231[ebp]
  000e5	c1 e8 03	 shr	 eax, 3
  000e8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000ee	88 4d f1	 mov	 BYTE PTR tv234[ebp], cl
  000f1	80 7d f1 00	 cmp	 BYTE PTR tv234[ebp], 0
  000f5	74 17		 je	 SHORT $LN13@sentry
  000f7	8a 55 d8	 mov	 dl, BYTE PTR tv231[ebp]
  000fa	80 e2 07	 and	 dl, 7
  000fd	3a 55 f1	 cmp	 dl, BYTE PTR tv234[ebp]
  00100	7c 0c		 jl	 SHORT $LN13@sentry
  00102	8b 45 d8	 mov	 eax, DWORD PTR tv231[ebp]
  00105	50		 push	 eax
  00106	e8 00 00 00 00	 call	 ___asan_report_store1
  0010b	83 c4 04	 add	 esp, 4
$LN13@sentry:
  0010e	8b 4d b4	 mov	 ecx, DWORD PTR tv89[ebp]
  00111	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 95   :                 return;

  00114	e9 b7 01 00 00	 jmp	 $LN1@sentry
$LN2@sentry:

; 96   :             }
; 97   : 
; 98   :             const auto _Tied = _Ostr.tie();

  00119	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0011c	89 55 9c	 mov	 DWORD PTR tv157[ebp], edx
  0011f	8b 45 9c	 mov	 eax, DWORD PTR tv157[ebp]
  00122	89 45 d4	 mov	 DWORD PTR tv221[ebp], eax
  00125	8b 4d d4	 mov	 ecx, DWORD PTR tv221[ebp]
  00128	c1 e9 03	 shr	 ecx, 3
  0012b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00131	88 55 f0	 mov	 BYTE PTR tv224[ebp], dl
  00134	80 7d f0 00	 cmp	 BYTE PTR tv224[ebp], 0
  00138	74 18		 je	 SHORT $LN12@sentry
  0013a	8a 45 d4	 mov	 al, BYTE PTR tv221[ebp]
  0013d	24 07		 and	 al, 7
  0013f	04 03		 add	 al, 3
  00141	3a 45 f0	 cmp	 al, BYTE PTR tv224[ebp]
  00144	7c 0c		 jl	 SHORT $LN12@sentry
  00146	8b 4d d4	 mov	 ecx, DWORD PTR tv221[ebp]
  00149	51		 push	 ecx
  0014a	e8 00 00 00 00	 call	 ___asan_report_load4
  0014f	83 c4 04	 add	 esp, 4
$LN12@sentry:
  00152	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00155	8b 02		 mov	 eax, DWORD PTR [edx]
  00157	83 c0 04	 add	 eax, 4
  0015a	89 45 b0	 mov	 DWORD PTR tv129[ebp], eax
  0015d	8b 4d b0	 mov	 ecx, DWORD PTR tv129[ebp]
  00160	89 4d d0	 mov	 DWORD PTR tv211[ebp], ecx
  00163	8b 55 d0	 mov	 edx, DWORD PTR tv211[ebp]
  00166	c1 ea 03	 shr	 edx, 3
  00169	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0016f	88 45 ef	 mov	 BYTE PTR tv214[ebp], al
  00172	80 7d ef 00	 cmp	 BYTE PTR tv214[ebp], 0
  00176	74 1a		 je	 SHORT $LN11@sentry
  00178	8a 4d d0	 mov	 cl, BYTE PTR tv211[ebp]
  0017b	80 e1 07	 and	 cl, 7
  0017e	80 c1 03	 add	 cl, 3
  00181	3a 4d ef	 cmp	 cl, BYTE PTR tv214[ebp]
  00184	7c 0c		 jl	 SHORT $LN11@sentry
  00186	8b 55 d0	 mov	 edx, DWORD PTR tv211[ebp]
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 ___asan_report_load4
  0018f	83 c4 04	 add	 esp, 4
$LN11@sentry:
  00192	8b 45 b0	 mov	 eax, DWORD PTR tv129[ebp]
  00195	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00198	03 08		 add	 ecx, DWORD PTR [eax]
  0019a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  001a0	89 45 c8	 mov	 DWORD PTR __Tied$[ebp], eax

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  001a3	83 7d c8 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  001a7	74 08		 je	 SHORT $LN4@sentry
  001a9	8b 4d c8	 mov	 ecx, DWORD PTR __Tied$[ebp]
  001ac	3b 4d 08	 cmp	 ecx, DWORD PTR __Ostr$[ebp]
  001af	75 45		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

  001b1	8b 55 e4	 mov	 edx, DWORD PTR _this$[ebp]
  001b4	83 c2 04	 add	 edx, 4
  001b7	89 55 ac	 mov	 DWORD PTR tv135[ebp], edx
  001ba	8b 45 ac	 mov	 eax, DWORD PTR tv135[ebp]
  001bd	89 45 cc	 mov	 DWORD PTR tv201[ebp], eax
  001c0	8b 4d cc	 mov	 ecx, DWORD PTR tv201[ebp]
  001c3	c1 e9 03	 shr	 ecx, 3
  001c6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001cc	88 55 ee	 mov	 BYTE PTR tv204[ebp], dl
  001cf	80 7d ee 00	 cmp	 BYTE PTR tv204[ebp], 0
  001d3	74 16		 je	 SHORT $LN10@sentry
  001d5	8a 45 cc	 mov	 al, BYTE PTR tv201[ebp]
  001d8	24 07		 and	 al, 7
  001da	3a 45 ee	 cmp	 al, BYTE PTR tv204[ebp]
  001dd	7c 0c		 jl	 SHORT $LN10@sentry
  001df	8b 4d cc	 mov	 ecx, DWORD PTR tv201[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ___asan_report_store1
  001e8	83 c4 04	 add	 esp, 4
$LN10@sentry:
  001eb	8b 55 ac	 mov	 edx, DWORD PTR tv135[ebp]
  001ee	c6 02 01	 mov	 BYTE PTR [edx], 1

; 101  :                 return;

  001f1	e9 da 00 00 00	 jmp	 $LN1@sentry
$LN3@sentry:

; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  001f6	8b 4d c8	 mov	 ecx, DWORD PTR __Tied$[ebp]
  001f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  001ff	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00202	89 45 98	 mov	 DWORD PTR tv164[ebp], eax
  00205	8b 4d 98	 mov	 ecx, DWORD PTR tv164[ebp]
  00208	89 4d c4	 mov	 DWORD PTR tv191[ebp], ecx
  0020b	8b 55 c4	 mov	 edx, DWORD PTR tv191[ebp]
  0020e	c1 ea 03	 shr	 edx, 3
  00211	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00217	88 45 ed	 mov	 BYTE PTR tv194[ebp], al
  0021a	80 7d ed 00	 cmp	 BYTE PTR tv194[ebp], 0
  0021e	74 1a		 je	 SHORT $LN9@sentry
  00220	8a 4d c4	 mov	 cl, BYTE PTR tv191[ebp]
  00223	80 e1 07	 and	 cl, 7
  00226	80 c1 03	 add	 cl, 3
  00229	3a 4d ed	 cmp	 cl, BYTE PTR tv194[ebp]
  0022c	7c 0c		 jl	 SHORT $LN9@sentry
  0022e	8b 55 c4	 mov	 edx, DWORD PTR tv191[ebp]
  00231	52		 push	 edx
  00232	e8 00 00 00 00	 call	 ___asan_report_load4
  00237	83 c4 04	 add	 esp, 4
$LN9@sentry:
  0023a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0023d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0023f	83 c1 04	 add	 ecx, 4
  00242	89 4d a8	 mov	 DWORD PTR tv145[ebp], ecx
  00245	8b 55 a8	 mov	 edx, DWORD PTR tv145[ebp]
  00248	89 55 c0	 mov	 DWORD PTR tv181[ebp], edx
  0024b	8b 45 c0	 mov	 eax, DWORD PTR tv181[ebp]
  0024e	c1 e8 03	 shr	 eax, 3
  00251	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00257	88 4d ec	 mov	 BYTE PTR tv184[ebp], cl
  0025a	80 7d ec 00	 cmp	 BYTE PTR tv184[ebp], 0
  0025e	74 1a		 je	 SHORT $LN8@sentry
  00260	8a 55 c0	 mov	 dl, BYTE PTR tv181[ebp]
  00263	80 e2 07	 and	 dl, 7
  00266	80 c2 03	 add	 dl, 3
  00269	3a 55 ec	 cmp	 dl, BYTE PTR tv184[ebp]
  0026c	7c 0c		 jl	 SHORT $LN8@sentry
  0026e	8b 45 c0	 mov	 eax, DWORD PTR tv181[ebp]
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 ___asan_report_load4
  00277	83 c4 04	 add	 esp, 4
$LN8@sentry:
  0027a	8b 4d a8	 mov	 ecx, DWORD PTR tv145[ebp]
  0027d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00280	03 11		 add	 edx, DWORD PTR [ecx]
  00282	8b ca		 mov	 ecx, edx
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  0028a	88 45 ea	 mov	 BYTE PTR tv148[ebp], al
  0028d	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00290	83 c0 04	 add	 eax, 4
  00293	89 45 a4	 mov	 DWORD PTR tv137[ebp], eax
  00296	8b 4d a4	 mov	 ecx, DWORD PTR tv137[ebp]
  00299	89 4d bc	 mov	 DWORD PTR tv171[ebp], ecx
  0029c	8b 55 bc	 mov	 edx, DWORD PTR tv171[ebp]
  0029f	c1 ea 03	 shr	 edx, 3
  002a2	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  002a8	88 45 eb	 mov	 BYTE PTR tv174[ebp], al
  002ab	80 7d eb 00	 cmp	 BYTE PTR tv174[ebp], 0
  002af	74 17		 je	 SHORT $LN7@sentry
  002b1	8a 4d bc	 mov	 cl, BYTE PTR tv171[ebp]
  002b4	80 e1 07	 and	 cl, 7
  002b7	3a 4d eb	 cmp	 cl, BYTE PTR tv174[ebp]
  002ba	7c 0c		 jl	 SHORT $LN7@sentry
  002bc	8b 55 bc	 mov	 edx, DWORD PTR tv171[ebp]
  002bf	52		 push	 edx
  002c0	e8 00 00 00 00	 call	 ___asan_report_store1
  002c5	83 c4 04	 add	 esp, 4
$LN7@sentry:
  002c8	8b 45 a4	 mov	 eax, DWORD PTR tv137[ebp]
  002cb	8a 4d ea	 mov	 cl, BYTE PTR tv148[ebp]
  002ce	88 08		 mov	 BYTE PTR [eax], cl
$LN1@sentry:

; 106  :         }

  002d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  002d7	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  002da	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002dd	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002e4	59		 pop	 ecx
  002e5	8b e5		 mov	 esp, ebp
  002e7	5d		 pop	 ebp
  002e8	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a a0	 mov	 ecx, DWORD PTR [edx-96]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv88 = -56						; size = 4
_this$ = -52						; size = 4
tv73 = -48						; size = 4
tv70 = -44						; size = 4
tv91 = -40						; size = 4
tv72 = -36						; size = 4
tv133 = -32						; size = 4
tv143 = -28						; size = 4
tv153 = -24						; size = 4
__Rdbuf$ = -20						; size = 4
tv94 = -16						; size = 1
tv136 = -15						; size = 1
tv146 = -14						; size = 1
tv156 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 2c	 sub	 esp, 44			; 0000002cH
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00032	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 d4	 mov	 DWORD PTR tv70[ebp], eax
  00038	8b 4d d4	 mov	 ecx, DWORD PTR tv70[ebp]
  0003b	89 4d e8	 mov	 DWORD PTR tv153[ebp], ecx
  0003e	8b 55 e8	 mov	 edx, DWORD PTR tv153[ebp]
  00041	c1 ea 03	 shr	 edx, 3
  00044	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0004a	88 45 f3	 mov	 BYTE PTR tv156[ebp], al
  0004d	80 7d f3 00	 cmp	 BYTE PTR tv156[ebp], 0
  00051	74 1a		 je	 SHORT $LN7@Sentry_bas
  00053	8a 4d e8	 mov	 cl, BYTE PTR tv153[ebp]
  00056	80 e1 07	 and	 cl, 7
  00059	80 c1 03	 add	 cl, 3
  0005c	3a 4d f3	 cmp	 cl, BYTE PTR tv156[ebp]
  0005f	7c 0c		 jl	 SHORT $LN7@Sentry_bas
  00061	8b 55 e8	 mov	 edx, DWORD PTR tv153[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ___asan_report_load4
  0006a	83 c4 04	 add	 esp, 4
$LN7@Sentry_bas:
  0006d	8b 45 d4	 mov	 eax, DWORD PTR tv70[ebp]
  00070	8b 08		 mov	 ecx, DWORD PTR [eax]
  00072	89 4d dc	 mov	 DWORD PTR tv72[ebp], ecx
  00075	8b 55 dc	 mov	 edx, DWORD PTR tv72[ebp]
  00078	89 55 e4	 mov	 DWORD PTR tv143[ebp], edx
  0007b	8b 45 e4	 mov	 eax, DWORD PTR tv143[ebp]
  0007e	c1 e8 03	 shr	 eax, 3
  00081	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00087	88 4d f2	 mov	 BYTE PTR tv146[ebp], cl
  0008a	80 7d f2 00	 cmp	 BYTE PTR tv146[ebp], 0
  0008e	74 1a		 je	 SHORT $LN6@Sentry_bas
  00090	8a 55 e4	 mov	 dl, BYTE PTR tv143[ebp]
  00093	80 e2 07	 and	 dl, 7
  00096	80 c2 03	 add	 dl, 3
  00099	3a 55 f2	 cmp	 dl, BYTE PTR tv146[ebp]
  0009c	7c 0c		 jl	 SHORT $LN6@Sentry_bas
  0009e	8b 45 e4	 mov	 eax, DWORD PTR tv143[ebp]
  000a1	50		 push	 eax
  000a2	e8 00 00 00 00	 call	 ___asan_report_load4
  000a7	83 c4 04	 add	 esp, 4
$LN6@Sentry_bas:
  000aa	8b 4d dc	 mov	 ecx, DWORD PTR tv72[ebp]
  000ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  000af	83 c2 04	 add	 edx, 4
  000b2	89 55 d0	 mov	 DWORD PTR tv73[ebp], edx
  000b5	8b 45 d0	 mov	 eax, DWORD PTR tv73[ebp]
  000b8	89 45 e0	 mov	 DWORD PTR tv133[ebp], eax
  000bb	8b 4d e0	 mov	 ecx, DWORD PTR tv133[ebp]
  000be	c1 e9 03	 shr	 ecx, 3
  000c1	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c7	88 55 f1	 mov	 BYTE PTR tv136[ebp], dl
  000ca	80 7d f1 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ce	74 18		 je	 SHORT $LN5@Sentry_bas
  000d0	8a 45 e0	 mov	 al, BYTE PTR tv133[ebp]
  000d3	24 07		 and	 al, 7
  000d5	04 03		 add	 al, 3
  000d7	3a 45 f1	 cmp	 al, BYTE PTR tv136[ebp]
  000da	7c 0c		 jl	 SHORT $LN5@Sentry_bas
  000dc	8b 4d e0	 mov	 ecx, DWORD PTR tv133[ebp]
  000df	51		 push	 ecx
  000e0	e8 00 00 00 00	 call	 ___asan_report_load4
  000e5	83 c4 04	 add	 esp, 4
$LN5@Sentry_bas:
  000e8	8b 55 d0	 mov	 edx, DWORD PTR tv73[ebp]
  000eb	8b 4d dc	 mov	 ecx, DWORD PTR tv72[ebp]
  000ee	03 0a		 add	 ecx, DWORD PTR [edx]
  000f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  000f6	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 80   :             if (_Rdbuf) {

  000f9	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  000fd	74 48		 je	 SHORT $LN3@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  000ff	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00102	89 45 c8	 mov	 DWORD PTR tv88[ebp], eax
  00105	8b 4d c8	 mov	 ecx, DWORD PTR tv88[ebp]
  00108	89 4d d8	 mov	 DWORD PTR tv91[ebp], ecx
  0010b	8b 55 d8	 mov	 edx, DWORD PTR tv91[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00117	88 45 f0	 mov	 BYTE PTR tv94[ebp], al
  0011a	80 7d f0 00	 cmp	 BYTE PTR tv94[ebp], 0
  0011e	74 1a		 je	 SHORT $LN4@Sentry_bas
  00120	8a 4d d8	 mov	 cl, BYTE PTR tv91[ebp]
  00123	80 e1 07	 and	 cl, 7
  00126	80 c1 03	 add	 cl, 3
  00129	3a 4d f0	 cmp	 cl, BYTE PTR tv94[ebp]
  0012c	7c 0c		 jl	 SHORT $LN4@Sentry_bas
  0012e	8b 55 d8	 mov	 edx, DWORD PTR tv91[ebp]
  00131	52		 push	 edx
  00132	e8 00 00 00 00	 call	 ___asan_report_load4
  00137	83 c4 04	 add	 esp, 4
$LN4@Sentry_bas:
  0013a	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00142	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00145	ff d0		 call	 eax
$LN3@Sentry_bas:

; 82   :             }
; 83   :         }

  00147	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00151	59		 pop	 ecx
  00152	8b e5		 mov	 esp, ebp
  00154	5d		 pop	 ebp
  00155	c3		 ret	 0
  00156	cc		 int	 3
  00157	cc		 int	 3
  00158	cc		 int	 3
  00159	cc		 int	 3
  0015a	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a d0	 mov	 ecx, DWORD PTR [edx-48]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv91 = -56						; size = 4
tv74 = -52						; size = 4
tv71 = -48						; size = 4
tv64 = -44						; size = 4
_this$ = -40						; size = 4
tv94 = -36						; size = 4
tv73 = -32						; size = 4
tv136 = -28						; size = 4
tv146 = -24						; size = 4
tv156 = -20						; size = 4
tv166 = -16						; size = 4
__Rdbuf$ = -12						; size = 4
tv129 = -5						; size = 1
tv139 = -4						; size = 1
tv149 = -3						; size = 1
tv159 = -2						; size = 1
tv169 = -1						; size = 1
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f0	 mov	 DWORD PTR tv166[ebp], ecx
  0001f	8b 55 f0	 mov	 edx, DWORD PTR tv166[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv169[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv169[ebp], 0
  00032	74 1a		 je	 SHORT $LN8@Sentry_bas
  00034	8a 4d f0	 mov	 cl, BYTE PTR tv166[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv169[ebp]
  00040	7c 0c		 jl	 SHORT $LN8@Sentry_bas
  00042	8b 55 f0	 mov	 edx, DWORD PTR tv166[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN8@Sentry_bas:
  0004e	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  00056	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	89 55 d0	 mov	 DWORD PTR tv71[ebp], edx
  0005c	8b 45 d0	 mov	 eax, DWORD PTR tv71[ebp]
  0005f	89 45 ec	 mov	 DWORD PTR tv156[ebp], eax
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv156[ebp]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006e	88 55 fe	 mov	 BYTE PTR tv159[ebp], dl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv159[ebp], 0
  00075	74 18		 je	 SHORT $LN7@Sentry_bas
  00077	8a 45 ec	 mov	 al, BYTE PTR tv156[ebp]
  0007a	24 07		 and	 al, 7
  0007c	04 03		 add	 al, 3
  0007e	3a 45 fe	 cmp	 al, BYTE PTR tv159[ebp]
  00081	7c 0c		 jl	 SHORT $LN7@Sentry_bas
  00083	8b 4d ec	 mov	 ecx, DWORD PTR tv156[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ___asan_report_load4
  0008c	83 c4 04	 add	 esp, 4
$LN7@Sentry_bas:
  0008f	8b 55 d0	 mov	 edx, DWORD PTR tv71[ebp]
  00092	8b 02		 mov	 eax, DWORD PTR [edx]
  00094	89 45 e0	 mov	 DWORD PTR tv73[ebp], eax
  00097	8b 4d e0	 mov	 ecx, DWORD PTR tv73[ebp]
  0009a	89 4d e8	 mov	 DWORD PTR tv146[ebp], ecx
  0009d	8b 55 e8	 mov	 edx, DWORD PTR tv146[ebp]
  000a0	c1 ea 03	 shr	 edx, 3
  000a3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000a9	88 45 fd	 mov	 BYTE PTR tv149[ebp], al
  000ac	80 7d fd 00	 cmp	 BYTE PTR tv149[ebp], 0
  000b0	74 1a		 je	 SHORT $LN6@Sentry_bas
  000b2	8a 4d e8	 mov	 cl, BYTE PTR tv146[ebp]
  000b5	80 e1 07	 and	 cl, 7
  000b8	80 c1 03	 add	 cl, 3
  000bb	3a 4d fd	 cmp	 cl, BYTE PTR tv149[ebp]
  000be	7c 0c		 jl	 SHORT $LN6@Sentry_bas
  000c0	8b 55 e8	 mov	 edx, DWORD PTR tv146[ebp]
  000c3	52		 push	 edx
  000c4	e8 00 00 00 00	 call	 ___asan_report_load4
  000c9	83 c4 04	 add	 esp, 4
$LN6@Sentry_bas:
  000cc	8b 45 e0	 mov	 eax, DWORD PTR tv73[ebp]
  000cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d1	83 c1 04	 add	 ecx, 4
  000d4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000d7	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  000da	89 55 e4	 mov	 DWORD PTR tv136[ebp], edx
  000dd	8b 45 e4	 mov	 eax, DWORD PTR tv136[ebp]
  000e0	c1 e8 03	 shr	 eax, 3
  000e3	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000e9	88 4d fc	 mov	 BYTE PTR tv139[ebp], cl
  000ec	80 7d fc 00	 cmp	 BYTE PTR tv139[ebp], 0
  000f0	74 1a		 je	 SHORT $LN5@Sentry_bas
  000f2	8a 55 e4	 mov	 dl, BYTE PTR tv136[ebp]
  000f5	80 e2 07	 and	 dl, 7
  000f8	80 c2 03	 add	 dl, 3
  000fb	3a 55 fc	 cmp	 dl, BYTE PTR tv139[ebp]
  000fe	7c 0c		 jl	 SHORT $LN5@Sentry_bas
  00100	8b 45 e4	 mov	 eax, DWORD PTR tv136[ebp]
  00103	50		 push	 eax
  00104	e8 00 00 00 00	 call	 ___asan_report_load4
  00109	83 c4 04	 add	 esp, 4
$LN5@Sentry_bas:
  0010c	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  0010f	8b 55 e0	 mov	 edx, DWORD PTR tv73[ebp]
  00112	03 11		 add	 edx, DWORD PTR [ecx]
  00114	8b ca		 mov	 ecx, edx
  00116	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0011c	89 45 f4	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 73   :             if (_Rdbuf) {

  0011f	83 7d f4 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00123	74 48		 je	 SHORT $LN1@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

  00125	8b 45 f4	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00128	89 45 c8	 mov	 DWORD PTR tv91[ebp], eax
  0012b	8b 4d c8	 mov	 ecx, DWORD PTR tv91[ebp]
  0012e	89 4d dc	 mov	 DWORD PTR tv94[ebp], ecx
  00131	8b 55 dc	 mov	 edx, DWORD PTR tv94[ebp]
  00134	c1 ea 03	 shr	 edx, 3
  00137	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0013d	88 45 fb	 mov	 BYTE PTR tv129[ebp], al
  00140	80 7d fb 00	 cmp	 BYTE PTR tv129[ebp], 0
  00144	74 1a		 je	 SHORT $LN4@Sentry_bas
  00146	8a 4d dc	 mov	 cl, BYTE PTR tv94[ebp]
  00149	80 e1 07	 and	 cl, 7
  0014c	80 c1 03	 add	 cl, 3
  0014f	3a 4d fb	 cmp	 cl, BYTE PTR tv129[ebp]
  00152	7c 0c		 jl	 SHORT $LN4@Sentry_bas
  00154	8b 55 dc	 mov	 edx, DWORD PTR tv94[ebp]
  00157	52		 push	 edx
  00158	e8 00 00 00 00	 call	 ___asan_report_load4
  0015d	83 c4 04	 add	 esp, 4
$LN4@Sentry_bas:
  00160	8b 45 f4	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00163	8b 10		 mov	 edx, DWORD PTR [eax]
  00165	8b 4d f4	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00168	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0016b	ff d0		 call	 eax
$LN1@Sentry_bas:

; 75   :             }
; 76   :         }

  0016d	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00170	8b e5		 mov	 esp, ebp
  00172	5d		 pop	 ebp
  00173	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 02	 shl	 eax, 2
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
$T2 = -88						; size = 4
tv153 = -43						; size = 1
tv143 = -42						; size = 1
tv133 = -41						; size = 1
tv85 = -40						; size = 4
tv150 = -36						; size = 4
tv140 = -32						; size = 4
__New_proxy$ = -28					; size = 4
tv130 = -24						; size = 4
_this$ = -20						; size = 4
tv74 = -16						; size = 4
tv75 = -12						; size = 4
tv83 = -8						; size = 4
tv94 = -4						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
  0002d	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
  00034	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d8	 mov	 DWORD PTR tv85[ebp], ecx
  00049	8b 55 d8	 mov	 edx, DWORD PTR tv85[ebp]
  0004c	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00052	83 45 d8 04	 add	 DWORD PTR tv85[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d d8	 mov	 ecx, DWORD PTR tv85[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 d8 02	 add	 DWORD PTR tv85[ebp], 2
  00065	8b 55 d8	 mov	 edx, DWORD PTR tv85[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  0006e	c1 e8 03	 shr	 eax, 3
  00071	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0007d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00082	6a 01		 push	 1
  00084	8b 4b 08	 mov	 ecx, DWORD PTR __Al$[ebx]
  00087	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00092	83 c4 04	 add	 esp, 4
  00095	89 45 e4	 mov	 DWORD PTR __New_proxy$[ebp], eax

; 1075 :         _Construct_in_place(*_New_proxy, this);

  00098	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009b	89 4d dc	 mov	 DWORD PTR tv150[ebp], ecx
  0009e	8b 55 dc	 mov	 edx, DWORD PTR tv150[ebp]
  000a1	c1 ea 03	 shr	 edx, 3
  000a4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000aa	88 45 d5	 mov	 BYTE PTR tv153[ebp], al
  000ad	80 7d d5 00	 cmp	 BYTE PTR tv153[ebp], 0
  000b1	74 1a		 je	 SHORT $LN5@Alloc_prox
  000b3	8a 4d dc	 mov	 cl, BYTE PTR tv150[ebp]
  000b6	80 e1 07	 and	 cl, 7
  000b9	80 c1 03	 add	 cl, 3
  000bc	3a 4d d5	 cmp	 cl, BYTE PTR tv153[ebp]
  000bf	7c 0c		 jl	 SHORT $LN5@Alloc_prox
  000c1	8b 55 dc	 mov	 edx, DWORD PTR tv150[ebp]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ___asan_report_store4
  000ca	83 c4 04	 add	 esp, 4
$LN5@Alloc_prox:
  000cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  000d3	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 e4	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  000e0	83 c4 08	 add	 esp, 8
  000e3	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  000e6	c1 e8 03	 shr	 eax, 3
  000e9	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 1076 :         _Myproxy            = _New_proxy;

  000f0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  000f6	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  000f9	89 55 e0	 mov	 DWORD PTR tv140[ebp], edx
  000fc	8b 45 e0	 mov	 eax, DWORD PTR tv140[ebp]
  000ff	c1 e8 03	 shr	 eax, 3
  00102	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00108	88 4d d6	 mov	 BYTE PTR tv143[ebp], cl
  0010b	80 7d d6 00	 cmp	 BYTE PTR tv143[ebp], 0
  0010f	74 1a		 je	 SHORT $LN4@Alloc_prox
  00111	8a 55 e0	 mov	 dl, BYTE PTR tv140[ebp]
  00114	80 e2 07	 and	 dl, 7
  00117	80 c2 03	 add	 dl, 3
  0011a	3a 55 d6	 cmp	 dl, BYTE PTR tv143[ebp]
  0011d	7c 0c		 jl	 SHORT $LN4@Alloc_prox
  0011f	8b 45 e0	 mov	 eax, DWORD PTR tv140[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ___asan_report_store4
  00128	83 c4 04	 add	 esp, 4
$LN4@Alloc_prox:
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0012e	8b 55 e4	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  00131	89 11		 mov	 DWORD PTR [ecx], edx

; 1077 :         _New_proxy->_Mycont = this;

  00133	8b 45 e4	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  00136	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00139	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0013c	89 4d e8	 mov	 DWORD PTR tv130[ebp], ecx
  0013f	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  00142	c1 ea 03	 shr	 edx, 3
  00145	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0014b	88 45 d7	 mov	 BYTE PTR tv133[ebp], al
  0014e	80 7d d7 00	 cmp	 BYTE PTR tv133[ebp], 0
  00152	74 1a		 je	 SHORT $LN3@Alloc_prox
  00154	8a 4d e8	 mov	 cl, BYTE PTR tv130[ebp]
  00157	80 e1 07	 and	 cl, 7
  0015a	80 c1 03	 add	 cl, 3
  0015d	3a 4d d7	 cmp	 cl, BYTE PTR tv133[ebp]
  00160	7c 0c		 jl	 SHORT $LN3@Alloc_prox
  00162	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 ___asan_report_store4
  0016b	83 c4 04	 add	 esp, 4
$LN3@Alloc_prox:
  0016e	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00171	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	89 08		 mov	 DWORD PTR [eax], ecx

; 1078 :     }

  00176	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0017d	8d 55 98	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00180	c1 ea 03	 shr	 edx, 3
  00183	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00189	89 55 fc	 mov	 DWORD PTR tv94[ebp], edx
  0018c	6a 07		 push	 7
  0018e	8b 45 fc	 mov	 eax, DWORD PTR tv94[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00197	83 c4 08	 add	 esp, 8
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	8b e3		 mov	 esp, ebx
  0019f	5b		 pop	 ebx
  001a0	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BA@@std@@YAII@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 04	 shl	 eax, 4
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -32					; size = 4
tv71 = -28						; size = 4
tv68 = -24						; size = 4
tv65 = -20						; size = 4
tv74 = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 614  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0002f	74 1a		 je	 SHORT $LN5@exchange
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv94[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  0003d	7c 0c		 jl	 SHORT $LN5@exchange
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN5@exchange:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	89 4d e0	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00053	8b 55 0c	 mov	 edx, DWORD PTR __New_val$[ebp]
  00056	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00062	c1 e9 03	 shr	 ecx, 3
  00065	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006b	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  0006e	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00072	74 18		 je	 SHORT $LN4@exchange
  00074	8a 45 f4	 mov	 al, BYTE PTR tv84[ebp]
  00077	24 07		 and	 al, 7
  00079	04 03		 add	 al, 3
  0007b	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@exchange
  00080	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ___asan_report_load4
  00089	83 c4 04	 add	 esp, 4
$LN4@exchange:
  0008c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0008f	89 55 e4	 mov	 DWORD PTR tv71[ebp], edx
  00092	8b 45 e4	 mov	 eax, DWORD PTR tv71[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00098	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0009b	c1 e9 03	 shr	 ecx, 3
  0009e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a4	88 55 fd	 mov	 BYTE PTR tv77[ebp], dl
  000a7	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000ab	74 18		 je	 SHORT $LN3@exchange
  000ad	8a 45 f0	 mov	 al, BYTE PTR tv74[ebp]
  000b0	24 07		 and	 al, 7
  000b2	04 03		 add	 al, 3
  000b4	3a 45 fd	 cmp	 al, BYTE PTR tv77[ebp]
  000b7	7c 0c		 jl	 SHORT $LN3@exchange
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ___asan_report_store4
  000c2	83 c4 04	 add	 esp, 4
$LN3@exchange:
  000c5	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 0a		 mov	 DWORD PTR [edx], ecx

; 618  :     return _Old_val;

  000cf	8b 45 e0	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 619  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 17		 jne	 SHORT $LN2@Allocate

; 235  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00020	72 0e		 jb	 SHORT $LN2@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0002b	83 c4 04	 add	 esp, 4
  0002e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00030	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00034	74 0e		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00036	8b 55 08	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003f	83 c4 04	 add	 esp, 4
  00042	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00044	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@PAVBlock@@@?$_Default_allocator_traits@V?$allocator@PAVBlock@@@std@@@std@@SAXAAV?$allocator@PAVBlock@@@1@QAPAVBlock@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVBlock@@@?$_Default_allocator_traits@V?$allocator@PAVBlock@@@std@@@std@@SAXAAV?$allocator@PAVBlock@@@1@QAPAVBlock@@@Z PROC ; std::_Default_allocator_traits<std::allocator<Block *> >::destroy<Block *>, COMDAT

; 719  :     static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 720  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 721  :         _STD destroy_at(_Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$destroy_at@PAVBlock@@@std@@YAXQAPAVBlock@@@Z ; std::destroy_at<Block *>
  00016	83 c4 04	 add	 esp, 4

; 722  : #else // __cpp_lib_constexpr_dynamic_alloc
; 723  :         _Ptr->~_Uty();
; 724  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 725  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$destroy@PAVBlock@@@?$_Default_allocator_traits@V?$allocator@PAVBlock@@@std@@@std@@SAXAAV?$allocator@PAVBlock@@@1@QAPAVBlock@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<Block *> >::destroy<Block *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVBlock@@@std@@YAPAPAVBlock@@PAPAV1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAVBlock@@@std@@YAPAPAVBlock@@PAPAV1@@Z PROC ; std::_Unfancy<Block *>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@PAVBlock@@@std@@YAPAPAVBlock@@PAPAV1@@Z ENDP ; std::_Unfancy<Block *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z
_TEXT	SEGMENT
tv79 = -20						; size = 4
tv74 = -16						; size = 4
tv82 = -12						; size = 4
tv92 = -8						; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z PROC ; std::_Move_unchecked<Block * *,Block * *>, COMDAT

; 4417 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4418 :     // move [_First, _Last) to [_Dest, ...)
; 4419 :     // note: _Move_unchecked has callers other than the move family
; 4420 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4421 : #ifdef __cpp_lib_is_constant_evaluated
; 4422 :         if (!_STD is_constant_evaluated())

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	75 19		 jne	 SHORT $LN5@Move_unche

; 4423 : #endif // __cpp_lib_is_constant_evaluated
; 4424 :         {
; 4425 :             return _Copy_memmove(_First, _Last, _Dest);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00023	52		 push	 edx
  00024	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z ; std::_Copy_memmove<Block * *,Block * *>
  0002d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00030	e9 b1 00 00 00	 jmp	 $LN1@Move_unche
$LN5@Move_unche:

; 4426 :         }
; 4427 :     }
; 4428 : 
; 4429 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  00035	eb 12		 jmp	 SHORT $LN4@Move_unche
$LN2@Move_unche:
  00037	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0003a	83 c1 04	 add	 ecx, 4
  0003d	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  00040	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00043	83 c2 04	 add	 edx, 4
  00046	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@Move_unche:
  00049	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0004c	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  0004f	0f 84 8e 00 00
	00		 je	 $LN3@Move_unche

; 4430 :         *_Dest = _STD move(*_First);

  00055	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$move@AAPAVBlock@@@std@@YA$$QAPAVBlock@@AAPAV1@@Z ; std::move<Block * &>
  0005e	83 c4 04	 add	 esp, 4
  00061	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00064	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  00067	89 55 f8	 mov	 DWORD PTR tv92[ebp], edx
  0006a	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  0006d	c1 e8 03	 shr	 eax, 3
  00070	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00076	88 4d ff	 mov	 BYTE PTR tv95[ebp], cl
  00079	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  0007d	74 1a		 je	 SHORT $LN8@Move_unche
  0007f	8a 55 f8	 mov	 dl, BYTE PTR tv92[ebp]
  00082	80 e2 07	 and	 dl, 7
  00085	80 c2 03	 add	 dl, 3
  00088	3a 55 ff	 cmp	 dl, BYTE PTR tv95[ebp]
  0008b	7c 0c		 jl	 SHORT $LN8@Move_unche
  0008d	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 ___asan_report_load4
  00096	83 c4 04	 add	 esp, 4
$LN8@Move_unche:
  00099	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0009c	89 4d ec	 mov	 DWORD PTR tv79[ebp], ecx
  0009f	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000a2	89 55 f4	 mov	 DWORD PTR tv82[ebp], edx
  000a5	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  000a8	c1 e8 03	 shr	 eax, 3
  000ab	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b1	88 4d fe	 mov	 BYTE PTR tv85[ebp], cl
  000b4	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  000b8	74 1a		 je	 SHORT $LN7@Move_unche
  000ba	8a 55 f4	 mov	 dl, BYTE PTR tv82[ebp]
  000bd	80 e2 07	 and	 dl, 7
  000c0	80 c2 03	 add	 dl, 3
  000c3	3a 55 fe	 cmp	 dl, BYTE PTR tv85[ebp]
  000c6	7c 0c		 jl	 SHORT $LN7@Move_unche
  000c8	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ___asan_report_store4
  000d1	83 c4 04	 add	 esp, 4
$LN7@Move_unche:
  000d4	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000d7	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  000da	8b 02		 mov	 eax, DWORD PTR [edx]
  000dc	89 01		 mov	 DWORD PTR [ecx], eax

; 4431 :     }

  000de	e9 54 ff ff ff	 jmp	 $LN2@Move_unche
$LN3@Move_unche:

; 4432 : 
; 4433 :     return _Dest;

  000e3	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN1@Move_unche:

; 4434 : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
??$_Move_unchecked@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z ENDP ; std::_Move_unchecked<Block * *,Block * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
tv79 = -24						; size = 4
tv82 = -20						; size = 4
tv73 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 978  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 979  :     _Ostr.put(_Ostr.widen('\n'));

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv82[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv82[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv129[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv132[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0002f	74 1a		 je	 SHORT $LN4@endl
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv129[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv132[ebp]
  0003d	7c 0c		 jl	 SHORT $LN4@endl
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv129[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN4@endl:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	83 c1 04	 add	 ecx, 4
  00053	89 4d f0	 mov	 DWORD PTR tv73[ebp], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR tv73[ebp]
  00059	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  0005c	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  0005f	c1 e8 03	 shr	 eax, 3
  00062	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00068	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  0006b	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  0006f	74 1a		 je	 SHORT $LN3@endl
  00071	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00074	80 e2 07	 and	 dl, 7
  00077	80 c2 03	 add	 dl, 3
  0007a	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  0007d	7c 0c		 jl	 SHORT $LN3@endl
  0007f	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00082	50		 push	 eax
  00083	e8 00 00 00 00	 call	 ___asan_report_load4
  00088	83 c4 04	 add	 esp, 4
$LN3@endl:
  0008b	8b 4d f0	 mov	 ecx, DWORD PTR tv73[ebp]
  0008e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00091	03 11		 add	 edx, DWORD PTR [ecx]
  00093	89 55 e8	 mov	 DWORD PTR tv79[ebp], edx
  00096	6a 0a		 push	 10			; 0000000aH
  00098	8b 4d e8	 mov	 ecx, DWORD PTR tv79[ebp]
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  000a1	0f b6 c0	 movzx	 eax, al
  000a4	50		 push	 eax
  000a5	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z

; 980  :     _Ostr.flush();

  000ae	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ

; 981  :     return _Ostr;

  000b7	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 982  : }

  000ba	8b e5		 mov	 esp, ebp
  000bc	5d		 pop	 ebp
  000bd	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__asan_gen_0$ = -392					; size = 4
__asan_gen_1$ = -388					; size = 4
__asan_gen_2$ = -384					; size = 4
__Ok$ = -376						; size = 8
$T3 = -360						; size = 4
$T4 = -344						; size = 4
$T5 = -328						; size = 4
$T6 = -312						; size = 4
tv301 = -268						; size = 1
tv187 = -267						; size = 1
tv306 = -266						; size = 1
tv246 = -265						; size = 1
tv379 = -264						; size = 4
__State$ = -260						; size = 4
tv74 = -256						; size = 4
tv86 = -252						; size = 4
tv130 = -248						; size = 4
tv152 = -244						; size = 4
tv168 = -240						; size = 4
tv181 = -236						; size = 4
tv204 = -232						; size = 4
tv227 = -228						; size = 4
tv240 = -224						; size = 4
tv262 = -220						; size = 4
tv275 = -216						; size = 4
tv289 = -212						; size = 4
tv377 = -208						; size = 4
tv309 = -204						; size = 4
tv314 = -200						; size = 4
tv319 = -196						; size = 4
tv324 = -192						; size = 4
tv137 = -188						; size = 4
tv329 = -184						; size = 4
tv300 = -180						; size = 4
tv334 = -176						; size = 4
tv189 = -172						; size = 4
tv302 = -168						; size = 4
tv191 = -164						; size = 4
tv343 = -160						; size = 4
tv303 = -156						; size = 4
tv213 = -152						; size = 4
tv348 = -148						; size = 4
tv305 = -144						; size = 4
tv353 = -140						; size = 4
tv248 = -136						; size = 4
tv307 = -132						; size = 4
tv250 = -128						; size = 4
tv362 = -124						; size = 4
tv268 = -120						; size = 4
tv367 = -116						; size = 4
tv281 = -112						; size = 4
tv372 = -108						; size = 4
tv295 = -104						; size = 4
$T7 = -100						; size = 4
tv394 = -96						; size = 4
tv308 = -92						; size = 4
__Pad$ = -88						; size = 8
__Count$ = -80						; size = 8
tv135 = -72						; size = 8
tv440 = -64						; size = 8
tv459 = -56						; size = 8
tv304 = -48						; size = 8
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 734  :     const char* _Val) { // insert NTBS into char stream

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	53		 push	 ebx
  00026	81 c4 80 fe ff
	ff		 add	 esp, -384		; fffffe80H
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00045	c7 85 78 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004f	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00059	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00063	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00069	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv377[ebp], eax
  0006f	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv377[ebp]
  00075	c1 e9 03	 shr	 ecx, 3
  00078	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0007e	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv379[ebp], ecx
  00084	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv379[ebp]
  0008a	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00090	83 85 f8 fe ff
	ff 04		 add	 DWORD PTR tv379[ebp], 4
  00097	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv379[ebp]
  0009d	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  000a3	83 85 f8 fe ff
	ff 04		 add	 DWORD PTR tv379[ebp], 4
  000aa	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv379[ebp]
  000b0	c7 01 f8 f2 f8
	f3		 mov	 DWORD PTR [ecx], -201788680 ; f3f8f2f8H
  000b6	83 85 f8 fe ff
	ff 04		 add	 DWORD PTR tv379[ebp], 4
  000bd	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  000c2	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv379[ebp]
  000c8	66 89 10	 mov	 WORD PTR [eax], dx
  000cb	83 85 f8 fe ff
	ff 02		 add	 DWORD PTR tv379[ebp], 2
  000d2	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv379[ebp]
  000d8	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  000db	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  000e0	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 735  :     using _Elem = char;
; 736  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 737  : 
; 738  :     ios_base::iostate _State = ios_base::goodbit;

  000e5	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __State$[ebp], 0

; 739  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  000ef	8b 53 0c	 mov	 edx, DWORD PTR __Val$[ebx]
  000f2	52		 push	 edx
  000f3	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  000f8	83 c4 04	 add	 esp, 4
  000fb	33 c9		 xor	 ecx, ecx
  000fd	89 45 b0	 mov	 DWORD PTR __Count$[ebp], eax
  00100	89 4d b4	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00103	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00106	89 95 34 ff ff
	ff		 mov	 DWORD PTR tv309[ebp], edx
  0010c	8b 85 34 ff ff
	ff		 mov	 eax, DWORD PTR tv309[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_load4
  00118	83 c4 04	 add	 esp, 4
  0011b	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  0011e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00120	83 c2 04	 add	 edx, 4
  00123	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv74[ebp], edx
  00129	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv74[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ___asan_load4
  00135	83 c4 04	 add	 esp, 4
  00138	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  0013e	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00141	03 11		 add	 edx, DWORD PTR [ecx]
  00143	8b ca		 mov	 ecx, edx
  00145	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0014b	89 45 c0	 mov	 DWORD PTR tv440[ebp], eax
  0014e	89 55 c4	 mov	 DWORD PTR tv440[ebp+4], edx
  00151	83 7d c4 00	 cmp	 DWORD PTR tv440[ebp+4], 0
  00155	0f 8c c0 00 00
	00		 jl	 $LN17@operator
  0015b	7f 0a		 jg	 SHORT $LN24@operator
  0015d	83 7d c0 00	 cmp	 DWORD PTR tv440[ebp], 0
  00161	0f 86 b4 00 00
	00		 jbe	 $LN17@operator
$LN24@operator:
  00167	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  0016a	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv314[ebp], eax
  00170	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv314[ebp]
  00176	51		 push	 ecx
  00177	e8 00 00 00 00	 call	 ___asan_load4
  0017c	83 c4 04	 add	 esp, 4
  0017f	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00182	8b 02		 mov	 eax, DWORD PTR [edx]
  00184	83 c0 04	 add	 eax, 4
  00187	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
  0018d	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv86[ebp]
  00193	51		 push	 ecx
  00194	e8 00 00 00 00	 call	 ___asan_load4
  00199	83 c4 04	 add	 esp, 4
  0019c	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv86[ebp]
  001a2	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  001a5	03 0a		 add	 ecx, DWORD PTR [edx]
  001a7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  001ad	89 45 c8	 mov	 DWORD PTR tv459[ebp], eax
  001b0	89 55 cc	 mov	 DWORD PTR tv459[ebp+4], edx
  001b3	8b 45 cc	 mov	 eax, DWORD PTR tv459[ebp+4]
  001b6	3b 45 b4	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  001b9	7c 60		 jl	 SHORT $LN17@operator
  001bb	7f 08		 jg	 SHORT $LN25@operator
  001bd	8b 4d c8	 mov	 ecx, DWORD PTR tv459[ebp]
  001c0	3b 4d b0	 cmp	 ecx, DWORD PTR __Count$[ebp]
  001c3	76 56		 jbe	 SHORT $LN17@operator
$LN25@operator:
  001c5	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  001c8	89 95 3c ff ff
	ff		 mov	 DWORD PTR tv319[ebp], edx
  001ce	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv319[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ___asan_load4
  001da	83 c4 04	 add	 esp, 4
  001dd	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  001e0	8b 11		 mov	 edx, DWORD PTR [ecx]
  001e2	83 c2 04	 add	 edx, 4
  001e5	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv130[ebp], edx
  001eb	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv130[ebp]
  001f1	50		 push	 eax
  001f2	e8 00 00 00 00	 call	 ___asan_load4
  001f7	83 c4 04	 add	 esp, 4
  001fa	8b 8d 08 ff ff
	ff		 mov	 ecx, DWORD PTR tv130[ebp]
  00200	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00203	03 11		 add	 edx, DWORD PTR [ecx]
  00205	8b ca		 mov	 ecx, edx
  00207	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0020d	2b 45 b0	 sub	 eax, DWORD PTR __Count$[ebp]
  00210	1b 55 b4	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  00213	89 45 b8	 mov	 DWORD PTR tv135[ebp], eax
  00216	89 55 bc	 mov	 DWORD PTR tv135[ebp+4], edx
  00219	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0021b	0f 57 c0	 xorps	 xmm0, xmm0
  0021e	66 0f 13 45 b8	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  00223	8b 45 b8	 mov	 eax, DWORD PTR tv135[ebp]
  00226	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp+4]
  00229	89 45 a8	 mov	 DWORD PTR __Pad$[ebp], eax
  0022c	89 4d ac	 mov	 DWORD PTR __Pad$[ebp+4], ecx

; 741  :     const typename _Myos::sentry _Ok(_Ostr);

  0022f	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00232	52		 push	 edx
  00233	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR __Ok$[ebp]
  00239	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  0023e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 742  : 
; 743  :     if (!_Ok) {

  00245	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR __Ok$[ebp]
  0024b	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00250	0f b6 c0	 movzx	 eax, al
  00253	85 c0		 test	 eax, eax
  00255	75 14		 jne	 SHORT $LN8@operator

; 744  :         _State |= ios_base::badbit;

  00257	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR __State$[ebp]
  0025d	83 c9 04	 or	 ecx, 4
  00260	89 8d fc fe ff
	ff		 mov	 DWORD PTR __State$[ebp], ecx

; 745  :     } else { // state okay, insert

  00266	e9 d7 04 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 746  :         _TRY_IO_BEGIN

  0026b	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  0026f	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00272	89 95 40 ff ff
	ff		 mov	 DWORD PTR tv324[ebp], edx
  00278	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv324[ebp]
  0027e	50		 push	 eax
  0027f	e8 00 00 00 00	 call	 ___asan_load4
  00284	83 c4 04	 add	 esp, 4
  00287	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  0028a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0028c	83 c2 04	 add	 edx, 4
  0028f	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv152[ebp], edx
  00295	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv152[ebp]
  0029b	50		 push	 eax
  0029c	e8 00 00 00 00	 call	 ___asan_load4
  002a1	83 c4 04	 add	 esp, 4
  002a4	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv152[ebp]
  002aa	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  002ad	03 11		 add	 edx, DWORD PTR [ecx]
  002af	8b ca		 mov	 ecx, edx
  002b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  002b7	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  002bd	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv137[ebp]
  002c3	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  002c8	83 f8 40	 cmp	 eax, 64			; 00000040H
  002cb	0f 84 8a 01 00
	00		 je	 $LN11@operator

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  002d1	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  002d3	8b 4d a8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  002d6	83 e9 01	 sub	 ecx, 1
  002d9	8b 55 ac	 mov	 edx, DWORD PTR __Pad$[ebp+4]
  002dc	83 da 00	 sbb	 edx, 0
  002df	89 4d a8	 mov	 DWORD PTR __Pad$[ebp], ecx
  002e2	89 55 ac	 mov	 DWORD PTR __Pad$[ebp+4], edx
$LN4@operator:
  002e5	83 7d ac 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  002e9	0f 8c 6c 01 00
	00		 jl	 $LN11@operator
  002ef	7f 0a		 jg	 SHORT $LN26@operator
  002f1	83 7d a8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002f5	0f 86 60 01 00
	00		 jbe	 $LN11@operator
$LN26@operator:
  002fb	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00301	c1 e8 03	 shr	 eax, 3
  00304	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  0030b	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00311	c1 e9 03	 shr	 ecx, 3
  00314	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  0031b	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  0031e	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv329[ebp], edx
  00324	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv329[ebp]
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 ___asan_load4
  00330	83 c4 04	 add	 esp, 4
  00333	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  00336	8b 11		 mov	 edx, DWORD PTR [ecx]
  00338	83 c2 04	 add	 edx, 4
  0033b	89 95 10 ff ff
	ff		 mov	 DWORD PTR tv168[ebp], edx
  00341	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv168[ebp]
  00347	50		 push	 eax
  00348	e8 00 00 00 00	 call	 ___asan_load4
  0034d	83 c4 04	 add	 esp, 4
  00350	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv168[ebp]
  00356	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00359	03 11		 add	 edx, DWORD PTR [ecx]
  0035b	8b ca		 mov	 ecx, edx
  0035d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00363	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv300[ebp], eax
  00369	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv300[ebp]
  0036f	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv189[ebp], eax
  00375	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  00378	89 8d 50 ff ff
	ff		 mov	 DWORD PTR tv334[ebp], ecx
  0037e	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv334[ebp]
  00384	52		 push	 edx
  00385	e8 00 00 00 00	 call	 ___asan_load4
  0038a	83 c4 04	 add	 esp, 4
  0038d	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  00390	8b 08		 mov	 ecx, DWORD PTR [eax]
  00392	83 c1 04	 add	 ecx, 4
  00395	89 8d 14 ff ff
	ff		 mov	 DWORD PTR tv181[ebp], ecx
  0039b	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv181[ebp]
  003a1	52		 push	 edx
  003a2	e8 00 00 00 00	 call	 ___asan_load4
  003a7	83 c4 04	 add	 esp, 4
  003aa	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv181[ebp]
  003b0	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  003b3	03 08		 add	 ecx, DWORD PTR [eax]
  003b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  003bb	88 85 f4 fe ff
	ff		 mov	 BYTE PTR tv301[ebp], al
  003c1	8a 8d f4 fe ff
	ff		 mov	 cl, BYTE PTR tv301[ebp]
  003c7	88 8d f5 fe ff
	ff		 mov	 BYTE PTR tv187[ebp], cl
  003cd	0f b6 95 f5 fe
	ff ff		 movzx	 edx, BYTE PTR tv187[ebp]
  003d4	52		 push	 edx
  003d5	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv189[ebp]
  003db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  003e1	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv302[ebp], eax
  003e7	8d 85 98 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003ed	50		 push	 eax
  003ee	e8 00 00 00 00	 call	 ___asan_store4
  003f3	83 c4 04	 add	 esp, 4
  003f6	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv302[ebp]
  003fc	89 8d 98 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], ecx
  00402	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00407	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv191[ebp], eax
  0040d	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00413	52		 push	 edx
  00414	e8 00 00 00 00	 call	 ___asan_store4
  00419	83 c4 04	 add	 esp, 4
  0041c	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv191[ebp]
  00422	89 85 a8 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], eax
  00428	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0042e	51		 push	 ecx
  0042f	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00435	52		 push	 edx
  00436	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0043b	83 c4 08	 add	 esp, 8
  0043e	0f b6 c0	 movzx	 eax, al
  00441	85 c0		 test	 eax, eax
  00443	74 11		 je	 SHORT $LN12@operator

; 750  :                     _State |= ios_base::badbit; // insertion failed, quit

  00445	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR __State$[ebp]
  0044b	83 c9 04	 or	 ecx, 4
  0044e	89 8d fc fe ff
	ff		 mov	 DWORD PTR __State$[ebp], ecx

; 751  :                     break;

  00454	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 752  :                 }
; 753  :             }

  00456	e9 78 fe ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 754  :         }
; 755  : 
; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0045b	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR __State$[ebp], 0
  00462	0f 85 97 00 00
	00		 jne	 $LN13@operator
  00468	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  0046b	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv343[ebp], edx
  00471	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv343[ebp]
  00477	50		 push	 eax
  00478	e8 00 00 00 00	 call	 ___asan_load4
  0047d	83 c4 04	 add	 esp, 4
  00480	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  00483	8b 11		 mov	 edx, DWORD PTR [ecx]
  00485	83 c2 04	 add	 edx, 4
  00488	89 95 18 ff ff
	ff		 mov	 DWORD PTR tv204[ebp], edx
  0048e	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv204[ebp]
  00494	50		 push	 eax
  00495	e8 00 00 00 00	 call	 ___asan_load4
  0049a	83 c4 04	 add	 esp, 4
  0049d	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv204[ebp]
  004a3	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  004a6	03 11		 add	 edx, DWORD PTR [ecx]
  004a8	8b ca		 mov	 ecx, edx
  004aa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  004b0	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv303[ebp], eax
  004b6	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv303[ebp]
  004bc	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], eax
  004c2	8b 4d b4	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  004c5	51		 push	 ecx
  004c6	8b 55 b0	 mov	 edx, DWORD PTR __Count$[ebp]
  004c9	52		 push	 edx
  004ca	8b 43 0c	 mov	 eax, DWORD PTR __Val$[ebx]
  004cd	50		 push	 eax
  004ce	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv213[ebp]
  004d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  004da	89 45 d0	 mov	 DWORD PTR tv304[ebp], eax
  004dd	89 55 d4	 mov	 DWORD PTR tv304[ebp+4], edx
  004e0	8b 4d d0	 mov	 ecx, DWORD PTR tv304[ebp]
  004e3	3b 4d b0	 cmp	 ecx, DWORD PTR __Count$[ebp]
  004e6	75 08		 jne	 SHORT $LN27@operator
  004e8	8b 55 d4	 mov	 edx, DWORD PTR tv304[ebp+4]
  004eb	3b 55 b4	 cmp	 edx, DWORD PTR __Count$[ebp+4]
  004ee	74 0f		 je	 SHORT $LN13@operator
$LN27@operator:

; 757  :             _State |= ios_base::badbit;

  004f0	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR __State$[ebp]
  004f6	83 c8 04	 or	 eax, 4
  004f9	89 85 fc fe ff
	ff		 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {

  004ff	83 bd fc fe ff
	ff 00		 cmp	 DWORD PTR __State$[ebp], 0
  00506	0f 85 84 01 00
	00		 jne	 $LN14@operator

; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  0050c	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  0050e	8b 4d a8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  00511	83 e9 01	 sub	 ecx, 1
  00514	8b 55 ac	 mov	 edx, DWORD PTR __Pad$[ebp+4]
  00517	83 da 00	 sbb	 edx, 0
  0051a	89 4d a8	 mov	 DWORD PTR __Pad$[ebp], ecx
  0051d	89 55 ac	 mov	 DWORD PTR __Pad$[ebp+4], edx
$LN7@operator:
  00520	83 7d ac 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00524	0f 8c 66 01 00
	00		 jl	 $LN14@operator
  0052a	7f 0a		 jg	 SHORT $LN28@operator
  0052c	83 7d a8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00530	0f 86 5a 01 00
	00		 jbe	 $LN14@operator
$LN28@operator:
  00536	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0053c	c1 e8 03	 shr	 eax, 3
  0053f	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  00546	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0054c	c1 e9 03	 shr	 ecx, 3
  0054f	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00556	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00559	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv348[ebp], edx
  0055f	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv348[ebp]
  00565	50		 push	 eax
  00566	e8 00 00 00 00	 call	 ___asan_load4
  0056b	83 c4 04	 add	 esp, 4
  0056e	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  00571	8b 11		 mov	 edx, DWORD PTR [ecx]
  00573	83 c2 04	 add	 edx, 4
  00576	89 95 1c ff ff
	ff		 mov	 DWORD PTR tv227[ebp], edx
  0057c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv227[ebp]
  00582	50		 push	 eax
  00583	e8 00 00 00 00	 call	 ___asan_load4
  00588	83 c4 04	 add	 esp, 4
  0058b	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv227[ebp]
  00591	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00594	03 11		 add	 edx, DWORD PTR [ecx]
  00596	8b ca		 mov	 ecx, edx
  00598	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0059e	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv305[ebp], eax
  005a4	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv305[ebp]
  005aa	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv248[ebp], eax
  005b0	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  005b3	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv353[ebp], ecx
  005b9	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv353[ebp]
  005bf	52		 push	 edx
  005c0	e8 00 00 00 00	 call	 ___asan_load4
  005c5	83 c4 04	 add	 esp, 4
  005c8	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  005cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  005cd	83 c1 04	 add	 ecx, 4
  005d0	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv240[ebp], ecx
  005d6	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv240[ebp]
  005dc	52		 push	 edx
  005dd	e8 00 00 00 00	 call	 ___asan_load4
  005e2	83 c4 04	 add	 esp, 4
  005e5	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv240[ebp]
  005eb	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  005ee	03 08		 add	 ecx, DWORD PTR [eax]
  005f0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  005f6	88 85 f6 fe ff
	ff		 mov	 BYTE PTR tv306[ebp], al
  005fc	8a 8d f6 fe ff
	ff		 mov	 cl, BYTE PTR tv306[ebp]
  00602	88 8d f7 fe ff
	ff		 mov	 BYTE PTR tv246[ebp], cl
  00608	0f b6 95 f7 fe
	ff ff		 movzx	 edx, BYTE PTR tv246[ebp]
  0060f	52		 push	 edx
  00610	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv248[ebp]
  00616	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0061c	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv307[ebp], eax
  00622	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00628	50		 push	 eax
  00629	e8 00 00 00 00	 call	 ___asan_store4
  0062e	83 c4 04	 add	 esp, 4
  00631	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv307[ebp]
  00637	89 8d b8 fe ff
	ff		 mov	 DWORD PTR $T5[ebp], ecx
  0063d	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00642	89 45 80	 mov	 DWORD PTR tv250[ebp], eax
  00645	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  0064b	52		 push	 edx
  0064c	e8 00 00 00 00	 call	 ___asan_store4
  00651	83 c4 04	 add	 esp, 4
  00654	8b 45 80	 mov	 eax, DWORD PTR tv250[ebp]
  00657	89 85 c8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  0065d	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00663	51		 push	 ecx
  00664	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  0066a	52		 push	 edx
  0066b	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00670	83 c4 08	 add	 esp, 8
  00673	0f b6 c0	 movzx	 eax, al
  00676	85 c0		 test	 eax, eax
  00678	74 11		 je	 SHORT $LN15@operator

; 763  :                     _State |= ios_base::badbit; // insertion failed, quit

  0067a	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR __State$[ebp]
  00680	83 c9 04	 or	 ecx, 4
  00683	89 8d fc fe ff
	ff		 mov	 DWORD PTR __State$[ebp], ecx

; 764  :                     break;

  00689	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 765  :                 }
; 766  :             }

  0068b	e9 7e fe ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 767  :         }
; 768  : 
; 769  :         _Ostr.width(0);

  00690	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  00693	89 55 84	 mov	 DWORD PTR tv362[ebp], edx
  00696	8b 45 84	 mov	 eax, DWORD PTR tv362[ebp]
  00699	50		 push	 eax
  0069a	e8 00 00 00 00	 call	 ___asan_load4
  0069f	83 c4 04	 add	 esp, 4
  006a2	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  006a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  006a7	83 c2 04	 add	 edx, 4
  006aa	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv262[ebp], edx
  006b0	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv262[ebp]
  006b6	50		 push	 eax
  006b7	e8 00 00 00 00	 call	 ___asan_load4
  006bc	83 c4 04	 add	 esp, 4
  006bf	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv262[ebp]
  006c5	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  006c8	03 11		 add	 edx, DWORD PTR [ecx]
  006ca	89 55 88	 mov	 DWORD PTR tv268[ebp], edx
  006cd	6a 00		 push	 0
  006cf	6a 00		 push	 0
  006d1	8b 4d 88	 mov	 ecx, DWORD PTR tv268[ebp]
  006d4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  006da	eb 53		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:
  006dc	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  006df	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  006e2	89 45 8c	 mov	 DWORD PTR tv367[ebp], eax
  006e5	8b 4d 8c	 mov	 ecx, DWORD PTR tv367[ebp]
  006e8	51		 push	 ecx
  006e9	e8 00 00 00 00	 call	 ___asan_load4
  006ee	83 c4 04	 add	 esp, 4
  006f1	8b 53 08	 mov	 edx, DWORD PTR __Ostr$[ebx]
  006f4	8b 02		 mov	 eax, DWORD PTR [edx]
  006f6	83 c0 04	 add	 eax, 4
  006f9	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv275[ebp], eax
  006ff	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv275[ebp]
  00705	51		 push	 ecx
  00706	e8 00 00 00 00	 call	 ___asan_load4
  0070b	83 c4 04	 add	 esp, 4
  0070e	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv275[ebp]
  00714	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  00717	03 02		 add	 eax, DWORD PTR [edx]
  00719	89 45 90	 mov	 DWORD PTR tv281[ebp], eax
  0071c	6a 01		 push	 1
  0071e	6a 04		 push	 4
  00720	8b 4d 90	 mov	 ecx, DWORD PTR tv281[ebp]
  00723	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00729	b8 00 00 00 00	 mov	 eax, $LN30@operator
  0072e	c3		 ret	 0
$LN19@operator:
  0072f	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00736	eb 0a		 jmp	 SHORT $LN9@operator
$LN30@operator:
  00738	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]
  0073b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 771  :     }
; 772  : 
; 773  :     _Ostr.setstate(_State);

  00742	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  00745	89 4d 94	 mov	 DWORD PTR tv372[ebp], ecx
  00748	8b 55 94	 mov	 edx, DWORD PTR tv372[ebp]
  0074b	52		 push	 edx
  0074c	e8 00 00 00 00	 call	 ___asan_load4
  00751	83 c4 04	 add	 esp, 4
  00754	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  00757	8b 08		 mov	 ecx, DWORD PTR [eax]
  00759	83 c1 04	 add	 ecx, 4
  0075c	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv289[ebp], ecx
  00762	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv289[ebp]
  00768	52		 push	 edx
  00769	e8 00 00 00 00	 call	 ___asan_load4
  0076e	83 c4 04	 add	 esp, 4
  00771	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv289[ebp]
  00777	8b 4b 08	 mov	 ecx, DWORD PTR __Ostr$[ebx]
  0077a	03 08		 add	 ecx, DWORD PTR [eax]
  0077c	89 4d 98	 mov	 DWORD PTR tv295[ebp], ecx
  0077f	6a 00		 push	 0
  00781	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR __State$[ebp]
  00787	52		 push	 edx
  00788	8b 4d 98	 mov	 ecx, DWORD PTR tv295[ebp]
  0078b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 774  :     return _Ostr;

  00791	8b 43 08	 mov	 eax, DWORD PTR __Ostr$[ebx]
  00794	89 45 9c	 mov	 DWORD PTR $T7[ebp], eax
  00797	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0079e	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR __Ok$[ebp]
  007a4	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  007a9	8b 4d 9c	 mov	 ecx, DWORD PTR $T7[ebp]
  007ac	89 4d a4	 mov	 DWORD PTR tv308[ebp], ecx
  007af	c7 85 78 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  007b9	8d 95 78 fe ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  007bf	c1 ea 03	 shr	 edx, 3
  007c2	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  007c8	89 55 a0	 mov	 DWORD PTR tv394[ebp], edx
  007cb	6a 0f		 push	 15			; 0000000fH
  007cd	8b 45 a0	 mov	 eax, DWORD PTR tv394[ebp]
  007d0	50		 push	 eax
  007d1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  007d6	83 c4 08	 add	 esp, 8
  007d9	8b 45 a4	 mov	 eax, DWORD PTR tv308[ebp]

; 775  : }

  007dc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  007df	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  007e6	59		 pop	 ecx
  007e7	5f		 pop	 edi
  007e8	5e		 pop	 esi
  007e9	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  007ec	33 cd		 xor	 ecx, ebp
  007ee	e8 00 00 00 00	 call	 @__security_check_cookie@4
  007f3	8b e5		 mov	 esp, ebp
  007f5	5d		 pop	 ebp
  007f6	8b e3		 mov	 esp, ebx
  007f8	5b		 pop	 ebx
  007f9	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR __Ok$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 6c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-404]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\System\Vector2.inl
;	COMDAT ??0?$Vector2@H@sf@@QAE@HH@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
??0?$Vector2@H@sf@@QAE@HH@Z PROC			; sf::Vector2<int>::Vector2<int>, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0A631FEE_Vector2@inl
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   : x(X),

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Vector2
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Vector2
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Vector2:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 40   : y(Y)

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@Vector2
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Vector2
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Vector2:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR _Y$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax

; 42   : 
; 43   : }

  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$Vector2@H@sf@@QAE@HH@Z ENDP			; sf::Vector2<int>::Vector2<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000e	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z
  00013	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c2 04 00	 ret	 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__asan_gen_0$ = -88					; size = 4
__asan_gen_1$ = -84					; size = 4
__asan_gen_2$ = -80					; size = 4
__Tmp$ = -72						; size = 12
tv79 = -24						; size = 4
tv77 = -20						; size = 4
_this$ = -16						; size = 4
tv82 = -12						; size = 4
tv67 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+, COMDAT
; _this$ = ecx

; 310  :     _NODISCARD _CONSTEXPR20_CONTAINER _Vector_iterator operator+(const difference_type _Off) const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 a8 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z
  00034	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+
  0003b	8d 45 a8	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 ec	 mov	 DWORD PTR tv77[ebp], eax
  00041	8b 4d ec	 mov	 ecx, DWORD PTR tv77[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d e8	 mov	 DWORD PTR tv79[ebp], ecx
  00050	8b 55 e8	 mov	 edx, DWORD PTR tv79[ebp]
  00053	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  00059	83 45 e8 04	 add	 DWORD PTR tv79[ebp], 4
  0005d	8b 45 e8	 mov	 eax, DWORD PTR tv79[ebp]
  00060	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00066	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 311  :         _Vector_iterator _Tmp = *this;

  00070	6a 0c		 push	 12			; 0000000cH
  00072	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00075	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEXI@Z
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	51		 push	 ecx
  0007e	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00081	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z

; 312  :         _Tmp += _Off; // TRANSITION, LLVM-49342

  00086	8b 53 0c	 mov	 edx, DWORD PTR __Off$[ebx]
  00089	52		 push	 edx
  0008a	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0008d	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=

; 313  :         return _Tmp;

  00092	8d 45 b8	 lea	 eax, DWORD PTR __Tmp$[ebp]
  00095	50		 push	 eax
  00096	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  00099	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z
  0009e	8d 4d b8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
  000a6	8b 4b 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebx]
  000a9	89 4d f8	 mov	 DWORD PTR tv67[ebp], ecx
  000ac	c7 45 a8 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000b3	8d 55 a8	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000b6	c1 ea 03	 shr	 edx, 3
  000b9	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000bf	89 55 f4	 mov	 DWORD PTR tv82[ebp], edx
  000c2	6a 08		 push	 8
  000c4	8b 45 f4	 mov	 eax, DWORD PTR tv82[ebp]
  000c7	50		 push	 eax
  000c8	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000cd	83 c4 08	 add	 esp, 8
  000d0	8b 45 f8	 mov	 eax, DWORD PTR tv67[ebp]

; 314  :     }

  000d3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000d6	33 cd		 xor	 ecx, ebp
  000d8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	8b e3		 mov	 esp, ebx
  000e2	5b		 pop	 ebx
  000e3	c2 08 00	 ret	 8
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=, COMDAT
; _this$ = ecx

; 305  :     _CONSTEXPR20_CONTAINER _Vector_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 306  :         _Mybase::operator+=(_Off);

  00011	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=

; 307  :         return *this;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  :     }

  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv81 = -24						; size = 4
tv80 = -20						; size = 4
_this$ = -16						; size = 4
tv85 = -12						; size = 4
tv95 = -8						; size = 4
tv88 = -2						; size = 1
tv130 = -1						; size = 1
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  00015	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00018	83 c1 08	 add	 ecx, 8
  0001b	89 4d e8	 mov	 DWORD PTR tv81[ebp], ecx
  0001e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00021	83 c2 08	 add	 edx, 8
  00024	89 55 ec	 mov	 DWORD PTR tv80[ebp], edx
  00027	8b 45 e8	 mov	 eax, DWORD PTR tv81[ebp]
  0002a	89 45 f8	 mov	 DWORD PTR tv95[ebp], eax
  0002d	8b 4d f8	 mov	 ecx, DWORD PTR tv95[ebp]
  00030	c1 e9 03	 shr	 ecx, 3
  00033	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00039	88 55 ff	 mov	 BYTE PTR tv130[ebp], dl
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv130[ebp], 0
  00040	74 18		 je	 SHORT $LN4@Vector_con
  00042	8a 45 f8	 mov	 al, BYTE PTR tv95[ebp]
  00045	24 07		 and	 al, 7
  00047	04 03		 add	 al, 3
  00049	3a 45 ff	 cmp	 al, BYTE PTR tv130[ebp]
  0004c	7c 0c		 jl	 SHORT $LN4@Vector_con
  0004e	8b 4d f8	 mov	 ecx, DWORD PTR tv95[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ___asan_report_load4
  00057	83 c4 04	 add	 esp, 4
$LN4@Vector_con:
  0005a	8b 55 ec	 mov	 edx, DWORD PTR tv80[ebp]
  0005d	89 55 f4	 mov	 DWORD PTR tv85[ebp], edx
  00060	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00063	c1 e8 03	 shr	 eax, 3
  00066	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006c	88 4d fe	 mov	 BYTE PTR tv88[ebp], cl
  0006f	80 7d fe 00	 cmp	 BYTE PTR tv88[ebp], 0
  00073	74 1a		 je	 SHORT $LN3@Vector_con
  00075	8a 55 f4	 mov	 dl, BYTE PTR tv85[ebp]
  00078	80 e2 07	 and	 dl, 7
  0007b	80 c2 03	 add	 dl, 3
  0007e	3a 55 fe	 cmp	 dl, BYTE PTR tv88[ebp]
  00081	7c 0c		 jl	 SHORT $LN3@Vector_con
  00083	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00086	50		 push	 eax
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN3@Vector_con:
  0008f	8b 4d ec	 mov	 ecx, DWORD PTR tv80[ebp]
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv81[ebp]
  00095	8b 02		 mov	 eax, DWORD PTR [edx]
  00097	89 01		 mov	 DWORD PTR [ecx], eax
  00099	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
tv69 = -32						; size = 4
tv67 = -28						; size = 4
tv68 = -24						; size = 4
tv66 = -20						; size = 4
tv75 = -16						; size = 4
tv85 = -12						; size = 4
_this$ = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=, COMDAT
; _this$ = ecx

; 121  :     _CONSTEXPR20_CONTAINER _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  :         _Verify_offset(_Off);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  00016	50		 push	 eax
  00017	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Verify_offset

; 123  :         _Ptr += _Off;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Off$[ebp]
  00022	c1 e1 02	 shl	 ecx, 2
  00025	89 4d e4	 mov	 DWORD PTR tv67[ebp], ecx
  00028	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002b	83 c2 08	 add	 edx, 8
  0002e	89 55 ec	 mov	 DWORD PTR tv66[ebp], edx
  00031	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv85[ebp], eax
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00043	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00046	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  0004a	74 18		 je	 SHORT $LN4@operator
  0004c	8a 45 f4	 mov	 al, BYTE PTR tv85[ebp]
  0004f	24 07		 and	 al, 7
  00051	04 03		 add	 al, 3
  00053	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00056	7c 0c		 jl	 SHORT $LN4@operator
  00058	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ___asan_report_load4
  00061	83 c4 04	 add	 esp, 4
$LN4@operator:
  00064	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	03 45 e4	 add	 eax, DWORD PTR tv67[ebp]
  0006c	89 45 e0	 mov	 DWORD PTR tv69[ebp], eax
  0006f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	83 c1 08	 add	 ecx, 8
  00075	89 4d e8	 mov	 DWORD PTR tv68[ebp], ecx
  00078	8b 55 e8	 mov	 edx, DWORD PTR tv68[ebp]
  0007b	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  0007e	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00081	c1 e8 03	 shr	 eax, 3
  00084	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0008a	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  0008d	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00091	74 1a		 je	 SHORT $LN3@operator
  00093	8a 55 f0	 mov	 dl, BYTE PTR tv75[ebp]
  00096	80 e2 07	 and	 dl, 7
  00099	80 c2 03	 add	 dl, 3
  0009c	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  0009f	7c 0c		 jl	 SHORT $LN3@operator
  000a1	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  000a4	50		 push	 eax
  000a5	e8 00 00 00 00	 call	 ___asan_report_store4
  000aa	83 c4 04	 add	 esp, 4
$LN3@operator:
  000ad	8b 4d e8	 mov	 ecx, DWORD PTR tv68[ebp]
  000b0	8b 55 e0	 mov	 edx, DWORD PTR tv69[ebp]
  000b3	89 11		 mov	 DWORD PTR [ecx], edx

; 124  :         return *this;

  000b5	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 125  :     }

  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
tv149 = -56						; size = 4
tv148 = -52						; size = 4
__Mycont$ = -48						; size = 4
tv95 = -44						; size = 4
tv94 = -40						; size = 4
tv75 = -36						; size = 4
tv180 = -32						; size = 4
tv190 = -28						; size = 4
tv200 = -24						; size = 4
tv210 = -20						; size = 4
tv220 = -16						; size = 4
_this$ = -12						; size = 4
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
__Off$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Verify_offset, COMDAT
; _this$ = ecx

; 105  :     _CONSTEXPR20_CONTAINER void _Verify_offset(const difference_type _Off) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 106  : #if _ITERATOR_DEBUG_LEVEL == 0
; 107  :         (void) _Off;
; 108  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 109  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 d0	 mov	 DWORD PTR __Mycont$[ebp], eax
$LN4@Verify_off:

; 110  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");

  0001e	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  00022	74 46		 je	 SHORT $LN22@Verify_off
  00024	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c0 08	 add	 eax, 8
  0002a	89 45 dc	 mov	 DWORD PTR tv75[ebp], eax
  0002d	8b 4d dc	 mov	 ecx, DWORD PTR tv75[ebp]
  00030	89 4d f0	 mov	 DWORD PTR tv220[ebp], ecx
  00033	8b 55 f0	 mov	 edx, DWORD PTR tv220[ebp]
  00036	c1 ea 03	 shr	 edx, 3
  00039	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0003f	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  00042	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00046	74 1a		 je	 SHORT $LN37@Verify_off
  00048	8a 4d f0	 mov	 cl, BYTE PTR tv220[ebp]
  0004b	80 e1 07	 and	 cl, 7
  0004e	80 c1 03	 add	 cl, 3
  00051	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00054	7c 0c		 jl	 SHORT $LN37@Verify_off
  00056	8b 55 f0	 mov	 edx, DWORD PTR tv220[ebp]
  00059	52		 push	 edx
  0005a	e8 00 00 00 00	 call	 ___asan_report_load4
  0005f	83 c4 04	 add	 esp, 4
$LN37@Verify_off:
  00062	8b 45 dc	 mov	 eax, DWORD PTR tv75[ebp]
  00065	83 38 00	 cmp	 DWORD PTR [eax], 0
  00068	74 02		 je	 SHORT $LN7@Verify_off
$LN22@Verify_off:
  0006a	eb 44		 jmp	 SHORT $LN2@Verify_off
$LN7@Verify_off:
  0006c	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00076	6a 00		 push	 0
  00078	6a 6e		 push	 110			; 0000006eH
  0007a	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0007f	6a 02		 push	 2
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00087	83 c4 18	 add	 esp, 24			; 00000018H
  0008a	83 f8 01	 cmp	 eax, 1
  0008d	75 01		 jne	 SHORT $LN30@Verify_off
  0008f	cc		 int	 3
$LN30@Verify_off:
  00090	6a 00		 push	 0
  00092	6a 6e		 push	 110			; 0000006eH
  00094	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00099	68 00 00 00 00	 push	 OFFSET ??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  0009e	68 00 00 00 00	 push	 OFFSET ??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@
  000a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000a9	83 c4 14	 add	 esp, 20			; 00000014H
  000ac	33 d2		 xor	 edx, edx
  000ae	75 bc		 jne	 SHORT $LN7@Verify_off
$LN2@Verify_off:
  000b0	33 c0		 xor	 eax, eax
  000b2	0f 85 66 ff ff
	ff		 jne	 $LN4@Verify_off

; 111  :         if (_Off < 0) {

  000b8	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  000bc	0f 8d da 00 00
	00		 jge	 $LN23@Verify_off
$LN10@Verify_off:

; 112  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");

  000c2	8b 4d d0	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  000c5	83 c1 04	 add	 ecx, 4
  000c8	89 4d d8	 mov	 DWORD PTR tv94[ebp], ecx
  000cb	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 08	 add	 edx, 8
  000d1	89 55 d4	 mov	 DWORD PTR tv95[ebp], edx
  000d4	8b 45 d8	 mov	 eax, DWORD PTR tv94[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv210[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv210[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fe	 mov	 BYTE PTR tv213[ebp], dl
  000e9	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  000ed	74 18		 je	 SHORT $LN36@Verify_off
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv210[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fe	 cmp	 al, BYTE PTR tv213[ebp]
  000f9	7c 0c		 jl	 SHORT $LN36@Verify_off
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv210[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN36@Verify_off:
  00107	8b 55 d4	 mov	 edx, DWORD PTR tv95[ebp]
  0010a	89 55 e8	 mov	 DWORD PTR tv200[ebp], edx
  0010d	8b 45 e8	 mov	 eax, DWORD PTR tv200[ebp]
  00110	c1 e8 03	 shr	 eax, 3
  00113	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00119	88 4d fd	 mov	 BYTE PTR tv203[ebp], cl
  0011c	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  00120	74 1a		 je	 SHORT $LN35@Verify_off
  00122	8a 55 e8	 mov	 dl, BYTE PTR tv200[ebp]
  00125	80 e2 07	 and	 dl, 7
  00128	80 c2 03	 add	 dl, 3
  0012b	3a 55 fd	 cmp	 dl, BYTE PTR tv203[ebp]
  0012e	7c 0c		 jl	 SHORT $LN35@Verify_off
  00130	8b 45 e8	 mov	 eax, DWORD PTR tv200[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ___asan_report_load4
  00139	83 c4 04	 add	 esp, 4
$LN35@Verify_off:
  0013c	8b 4d d8	 mov	 ecx, DWORD PTR tv94[ebp]
  0013f	8b 55 d4	 mov	 edx, DWORD PTR tv95[ebp]
  00142	8b 01		 mov	 eax, DWORD PTR [ecx]
  00144	2b 02		 sub	 eax, DWORD PTR [edx]
  00146	c1 f8 02	 sar	 eax, 2
  00149	39 45 08	 cmp	 DWORD PTR __Off$[ebp], eax
  0014c	7c 02		 jl	 SHORT $LN13@Verify_off
  0014e	eb 44		 jmp	 SHORT $LN8@Verify_off
$LN13@Verify_off:
  00150	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@
  00155	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0015a	6a 00		 push	 0
  0015c	6a 70		 push	 112			; 00000070H
  0015e	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00163	6a 02		 push	 2
  00165	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0016b	83 c4 18	 add	 esp, 24			; 00000018H
  0016e	83 f8 01	 cmp	 eax, 1
  00171	75 01		 jne	 SHORT $LN31@Verify_off
  00173	cc		 int	 3
$LN31@Verify_off:
  00174	6a 00		 push	 0
  00176	6a 70		 push	 112			; 00000070H
  00178	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0017d	68 00 00 00 00	 push	 OFFSET ??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  00182	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
  00187	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0018d	83 c4 14	 add	 esp, 20			; 00000014H
  00190	33 d2		 xor	 edx, edx
  00192	75 bc		 jne	 SHORT $LN13@Verify_off
$LN8@Verify_off:
  00194	33 c0		 xor	 eax, eax
  00196	0f 85 26 ff ff
	ff		 jne	 $LN10@Verify_off
$LN23@Verify_off:

; 113  :         }
; 114  : 
; 115  :         if (_Off > 0) {

  0019c	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  001a0	0f 8e da 00 00
	00		 jle	 $LN29@Verify_off
$LN16@Verify_off:

; 116  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");

  001a6	8b 4d d0	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  001a9	83 c1 08	 add	 ecx, 8
  001ac	89 4d cc	 mov	 DWORD PTR tv148[ebp], ecx
  001af	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001b2	83 c2 08	 add	 edx, 8
  001b5	89 55 c8	 mov	 DWORD PTR tv149[ebp], edx
  001b8	8b 45 cc	 mov	 eax, DWORD PTR tv148[ebp]
  001bb	89 45 e4	 mov	 DWORD PTR tv190[ebp], eax
  001be	8b 4d e4	 mov	 ecx, DWORD PTR tv190[ebp]
  001c1	c1 e9 03	 shr	 ecx, 3
  001c4	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001ca	88 55 fc	 mov	 BYTE PTR tv193[ebp], dl
  001cd	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  001d1	74 18		 je	 SHORT $LN34@Verify_off
  001d3	8a 45 e4	 mov	 al, BYTE PTR tv190[ebp]
  001d6	24 07		 and	 al, 7
  001d8	04 03		 add	 al, 3
  001da	3a 45 fc	 cmp	 al, BYTE PTR tv193[ebp]
  001dd	7c 0c		 jl	 SHORT $LN34@Verify_off
  001df	8b 4d e4	 mov	 ecx, DWORD PTR tv190[ebp]
  001e2	51		 push	 ecx
  001e3	e8 00 00 00 00	 call	 ___asan_report_load4
  001e8	83 c4 04	 add	 esp, 4
$LN34@Verify_off:
  001eb	8b 55 c8	 mov	 edx, DWORD PTR tv149[ebp]
  001ee	89 55 e0	 mov	 DWORD PTR tv180[ebp], edx
  001f1	8b 45 e0	 mov	 eax, DWORD PTR tv180[ebp]
  001f4	c1 e8 03	 shr	 eax, 3
  001f7	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001fd	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  00200	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00204	74 1a		 je	 SHORT $LN33@Verify_off
  00206	8a 55 e0	 mov	 dl, BYTE PTR tv180[ebp]
  00209	80 e2 07	 and	 dl, 7
  0020c	80 c2 03	 add	 dl, 3
  0020f	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  00212	7c 0c		 jl	 SHORT $LN33@Verify_off
  00214	8b 45 e0	 mov	 eax, DWORD PTR tv180[ebp]
  00217	50		 push	 eax
  00218	e8 00 00 00 00	 call	 ___asan_report_load4
  0021d	83 c4 04	 add	 esp, 4
$LN33@Verify_off:
  00220	8b 4d cc	 mov	 ecx, DWORD PTR tv148[ebp]
  00223	8b 55 c8	 mov	 edx, DWORD PTR tv149[ebp]
  00226	8b 01		 mov	 eax, DWORD PTR [ecx]
  00228	2b 02		 sub	 eax, DWORD PTR [edx]
  0022a	c1 f8 02	 sar	 eax, 2
  0022d	39 45 08	 cmp	 DWORD PTR __Off$[ebp], eax
  00230	7f 02		 jg	 SHORT $LN19@Verify_off
  00232	eb 44		 jmp	 SHORT $LN14@Verify_off
$LN19@Verify_off:
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@
  00239	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0023e	6a 00		 push	 0
  00240	6a 74		 push	 116			; 00000074H
  00242	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00247	6a 02		 push	 2
  00249	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0024f	83 c4 18	 add	 esp, 24			; 00000018H
  00252	83 f8 01	 cmp	 eax, 1
  00255	75 01		 jne	 SHORT $LN32@Verify_off
  00257	cc		 int	 3
$LN32@Verify_off:
  00258	6a 00		 push	 0
  0025a	6a 74		 push	 116			; 00000074H
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00261	68 00 00 00 00	 push	 OFFSET ??_C@_1OA@FDIBPEPP@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  00266	68 00 00 00 00	 push	 OFFSET ??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
  0026b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00271	83 c4 14	 add	 esp, 20			; 00000014H
  00274	33 d2		 xor	 edx, edx
  00276	75 bc		 jne	 SHORT $LN19@Verify_off
$LN14@Verify_off:
  00278	33 c0		 xor	 eax, eax
  0027a	0f 85 26 ff ff
	ff		 jne	 $LN16@Verify_off
$LN29@Verify_off:

; 117  :         }
; 118  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 119  :     }

  00280	8b e5		 mov	 esp, ebp
  00282	5d		 pop	 ebp
  00283	c2 04 00	 ret	 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
tv75 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
tv87 = -1						; size = 1
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >, COMDAT
; _this$ = ecx

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 08	 add	 eax, 8
  00021	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
  00024	8b 4d f0	 mov	 ecx, DWORD PTR tv75[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0003d	74 1a		 je	 SHORT $LN3@Vector_con
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0004b	7c 0c		 jl	 SHORT $LN3@Vector_con
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN3@Vector_con:
  00059	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx

; 43   :         this->_Adopt(_Pvector);

  00061	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  00064	52		 push	 edx
  00065	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 44   :     }

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Block *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z PROC ; std::make_tuple<enum DIRDEP,enum DIRDEP &>, COMDAT

; 888  : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 889  :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 890  :     return _Ttype(_STD forward<_Types>(_Args)...);

  00010	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0002e	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  00031	52		 push	 edx
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 891  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ENDP ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z PROC ; std::get<1,enum DIRDEP,enum DIRDEP>, COMDAT

; 816  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 817  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 818  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]

; 819  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ENDP ; std::get<1,enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z PROC ; std::make_tuple<enum DIRDEP &,enum DIRDEP>, COMDAT

; 888  : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 889  :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 890  :     return _Ttype(_STD forward<_Types>(_Args)...);

  00010	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0002e	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  00031	52		 push	 edx
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 891  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ENDP ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z PROC ; std::get<0,enum DIRDEP,enum DIRDEP>, COMDAT

; 816  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 817  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 818  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00010	83 c0 04	 add	 eax, 4

; 819  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ENDP ; std::get<0,enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z PROC ; std::make_tuple<enum DIRDEP,enum DIRDEP>, COMDAT

; 888  : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 889  :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 890  :     return _Ttype(_STD forward<_Types>(_Args)...);

  00010	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0001f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0002e	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  00031	52		 push	 edx
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00035	50		 push	 eax
  00036	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00039	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>
  0003e	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 891  : }

  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z ENDP ; std::make_tuple<enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
tv80 = -28						; size = 4
tv66 = -24						; size = 4
tv65 = -20						; size = 4
_this$ = -16						; size = 4
tv85 = -12						; size = 4
tv95 = -8						; size = 4
tv88 = -2						; size = 1
tv130 = -1						; size = 1
__Right$ = 8						; size = 4
??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 623  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 624  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

  00013	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 e8	 mov	 DWORD PTR tv66[ebp], eax
  00025	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	83 c1 04	 add	 ecx, 4
  0002b	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  0002e	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  00031	89 55 f8	 mov	 DWORD PTR tv95[ebp], edx
  00034	8b 45 f8	 mov	 eax, DWORD PTR tv95[ebp]
  00037	c1 e8 03	 shr	 eax, 3
  0003a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00040	88 4d ff	 mov	 BYTE PTR tv130[ebp], cl
  00043	80 7d ff 00	 cmp	 BYTE PTR tv130[ebp], 0
  00047	74 1a		 je	 SHORT $LN4@operator
  00049	8a 55 f8	 mov	 dl, BYTE PTR tv95[ebp]
  0004c	80 e2 07	 and	 dl, 7
  0004f	80 c2 03	 add	 dl, 3
  00052	3a 55 ff	 cmp	 dl, BYTE PTR tv130[ebp]
  00055	7c 0c		 jl	 SHORT $LN4@operator
  00057	8b 45 f8	 mov	 eax, DWORD PTR tv95[ebp]
  0005a	50		 push	 eax
  0005b	e8 00 00 00 00	 call	 ___asan_report_load4
  00060	83 c4 04	 add	 esp, 4
$LN4@operator:
  00063	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00066	89 4d f4	 mov	 DWORD PTR tv85[ebp], ecx
  00069	8b 55 f4	 mov	 edx, DWORD PTR tv85[ebp]
  0006c	c1 ea 03	 shr	 edx, 3
  0006f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00075	88 45 fe	 mov	 BYTE PTR tv88[ebp], al
  00078	80 7d fe 00	 cmp	 BYTE PTR tv88[ebp], 0
  0007c	74 1a		 je	 SHORT $LN3@operator
  0007e	8a 4d f4	 mov	 cl, BYTE PTR tv85[ebp]
  00081	80 e1 07	 and	 cl, 7
  00084	80 c1 03	 add	 cl, 3
  00087	3a 4d fe	 cmp	 cl, BYTE PTR tv88[ebp]
  0008a	7c 0c		 jl	 SHORT $LN3@operator
  0008c	8b 55 f4	 mov	 edx, DWORD PTR tv85[ebp]
  0008f	52		 push	 edx
  00090	e8 00 00 00 00	 call	 ___asan_report_store4
  00095	83 c4 04	 add	 esp, 4
$LN3@operator:
  00098	8b 45 ec	 mov	 eax, DWORD PTR tv65[ebp]
  0009b	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	89 10		 mov	 DWORD PTR [eax], edx

; 625  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());

  000a2	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
  000aa	50		 push	 eax
  000ab	e8 00 00 00 00	 call	 ??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z ; std::forward<std::tuple<enum DIRDEP> >
  000b0	83 c4 04	 add	 esp, 4
  000b3	89 45 e4	 mov	 DWORD PTR tv80[ebp], eax
  000b6	8b 45 e4	 mov	 eax, DWORD PTR tv80[ebp]
  000b9	50		 push	 eax
  000ba	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000bd	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
  000c2	8b c8		 mov	 ecx, eax
  000c4	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>

; 626  :         return *this;

  000c9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]

; 627  :     }

  000cc	8b e5		 mov	 esp, ebp
  000ce	5d		 pop	 ebp
  000cf	c2 04 00	 ret	 4
??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -664					; size = 4
__asan_gen_1$ = -660					; size = 4
__asan_gen_2$ = -656					; size = 4
_View$ = -648						; size = 168
_si$ = -448						; size = 8
$T3 = -432						; size = 16
$T4 = -384						; size = 8
$T5 = -368						; size = 16
_this$ = -316						; size = 4
tv330 = -312						; size = 4
$T6 = -308						; size = 4
$T7 = -304						; size = 4
tv325 = -300						; size = 4
tv326 = -296						; size = 4
tv64 = -292						; size = 4
tv66 = -288						; size = 4
$T8 = -284						; size = 4
tv86 = -280						; size = 4
tv88 = -276						; size = 4
tv72 = -272						; size = 4
tv80 = -268						; size = 4
tv94 = -264						; size = 4
tv93 = -260						; size = 4
$T9 = -256						; size = 4
tv141 = -252						; size = 4
tv129 = -248						; size = 4
tv143 = -244						; size = 4
tv148 = -240						; size = 4
tv142 = -236						; size = 4
tv161 = -232						; size = 4
tv166 = -228						; size = 4
tv178 = -224						; size = 4
tv202 = -220						; size = 4
tv204 = -216						; size = 4
tv205 = -212						; size = 4
tv201 = -208						; size = 4
tv168 = -204						; size = 4
tv209 = -200						; size = 4
tv538 = -196						; size = 4
tv215 = -192						; size = 4
tv552 = -188						; size = 4
tv228 = -184						; size = 4
tv233 = -180						; size = 4
tv245 = -176						; size = 4
tv254 = -172						; size = 4
tv257 = -168						; size = 4
tv323 = -164						; size = 4
tv71 = -160						; size = 4
$T10 = -156						; size = 4
tv92 = -152						; size = 4
tv128 = -148						; size = 4
tv336 = -144						; size = 4
$T11 = -140						; size = 4
tv156 = -136						; size = 4
tv154 = -132						; size = 4
tv160 = -128						; size = 4
tv165 = -124						; size = 4
tv183 = -120						; size = 4
tv188 = -116						; size = 4
tv186 = -112						; size = 4
tv190 = -108						; size = 4
tv345 = -104						; size = 4
tv351 = -100						; size = 4
$T12 = -96						; size = 4
tv226 = -92						; size = 4
tv224 = -88						; size = 4
tv357 = -84						; size = 4
tv242 = -80						; size = 4
tv240 = -76						; size = 4
tv250 = -72						; size = 4
tv263 = -68						; size = 4
tv265 = -64						; size = 4
tv363 = -60						; size = 4
tv541 = -56						; size = 8
tv555 = -48						; size = 8
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
_lvl$ = 8						; size = 4
?loadTerrain@Univers@@QAEXH@Z PROC			; Univers::loadTerrain
; _this$ = ecx

; 133  : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?loadTerrain@Univers@@QAEXH@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 fd ff
	ff		 add	 esp, -656		; fffffd70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 8d c4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00045	c7 85 68 fd ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004f	c7 85 6c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?loadTerrain@Univers@@QAEXH@Z
  00059	c7 85 70 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?loadTerrain@Univers@@QAEXH@Z ; Univers::loadTerrain
  00063	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00069	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  0006f	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv323[ebp]
  00075	c1 e9 03	 shr	 ecx, 3
  00078	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0007e	89 8d d4 fe ff
	ff		 mov	 DWORD PTR tv325[ebp], ecx
  00084	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  00089	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv325[ebp]
  0008f	66 89 10	 mov	 WORD PTR [eax], dx
  00092	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv325[ebp]
  00098	83 c1 02	 add	 ecx, 2
  0009b	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv326[ebp], ecx
  000a1	6a 15		 push	 21			; 00000015H
  000a3	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv326[ebp]
  000a9	52		 push	 edx
  000aa	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000af	83 c4 08	 add	 esp, 8
  000b2	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv326[ebp]
  000b8	83 c0 15	 add	 eax, 21			; 00000015H
  000bb	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv330[ebp], eax
  000c1	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv330[ebp]
  000c7	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  000cd	83 85 c8 fe ff
	ff 04		 add	 DWORD PTR tv330[ebp], 4
  000d4	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv330[ebp]
  000da	c7 02 00 f2 f8
	f8		 mov	 DWORD PTR [edx], -117902848 ; f8f8f200H
  000e0	83 85 c8 fe ff
	ff 04		 add	 DWORD PTR tv330[ebp], 4
  000e7	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR tv330[ebp]
  000ed	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  000f3	83 85 c8 fe ff
	ff 04		 add	 DWORD PTR tv330[ebp], 4
  000fa	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv330[ebp]
  00100	c7 01 f8 f2 f8
	f8		 mov	 DWORD PTR [ecx], -117902600 ; f8f8f2f8H
  00106	83 85 c8 fe ff
	ff 04		 add	 DWORD PTR tv330[ebp], 4
  0010d	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv330[ebp]
  00113	c7 02 f3 f3 f3
	f3		 mov	 DWORD PTR [edx], -202116109 ; f3f3f3f3H
  00119	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  0011e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 134  :     if (ter != nullptr) {

  00123	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00129	83 c0 08	 add	 eax, 8
  0012c	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv64[ebp], eax
  00132	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  00138	51		 push	 ecx
  00139	e8 00 00 00 00	 call	 ___asan_load4
  0013e	83 c4 04	 add	 esp, 4
  00141	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  00147	83 3a 00	 cmp	 DWORD PTR [edx], 0
  0014a	74 54		 je	 SHORT $LN5@loadTerrai

; 135  :         delete(ter);

  0014c	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00152	83 c0 08	 add	 eax, 8
  00155	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv66[ebp], eax
  0015b	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR tv66[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ___asan_load4
  00167	83 c4 04	 add	 esp, 4
  0016a	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv66[ebp]
  00170	8b 02		 mov	 eax, DWORD PTR [edx]
  00172	89 85 e4 fe ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  00178	83 bd e4 fe ff
	ff 00		 cmp	 DWORD PTR $T8[ebp], 0
  0017f	74 15		 je	 SHORT $LN4@loadTerrai
  00181	6a 01		 push	 1
  00183	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR $T8[ebp]
  00189	e8 00 00 00 00	 call	 ??_GTerrain@@QAEPAXI@Z
  0018e	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  00194	eb 0a		 jmp	 SHORT $LN5@loadTerrai
$LN4@loadTerrai:
  00196	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@loadTerrai:

; 136  :     }
; 137  :     ter = new Terrain(RP);

  001a0	6a 0c		 push	 12			; 0000000cH
  001a2	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  001a7	83 c4 04	 add	 esp, 4
  001aa	89 85 d0 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  001b0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  001b7	83 bd d0 fe ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  001be	74 47		 je	 SHORT $LN6@loadTerrai
  001c0	6a 0c		 push	 12			; 0000000cH
  001c2	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  001c8	e8 00 00 00 00	 call	 ?__autoclassinit2@Terrain@@QAEXI@Z
  001cd	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001d3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001d6	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv86[ebp], ecx
  001dc	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv86[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ___asan_load4
  001e8	83 c4 04	 add	 esp, 4
  001eb	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR tv86[ebp]
  001f1	8b 08		 mov	 ecx, DWORD PTR [eax]
  001f3	51		 push	 ecx
  001f4	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  001fa	e8 00 00 00 00	 call	 ??0Terrain@@QAE@PAVRessourcePack@@@Z ; Terrain::Terrain
  001ff	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  00205	eb 0a		 jmp	 SHORT $LN7@loadTerrai
$LN6@loadTerrai:
  00207	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv88[ebp], 0
$LN7@loadTerrai:
  00211	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv88[ebp]
  00217	89 95 64 ff ff
	ff		 mov	 DWORD PTR $T10[ebp], edx
  0021d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00224	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0022a	83 c0 08	 add	 eax, 8
  0022d	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv72[ebp], eax
  00233	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00239	51		 push	 ecx
  0023a	e8 00 00 00 00	 call	 ___asan_store4
  0023f	83 c4 04	 add	 esp, 4
  00242	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  00248	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  0024e	89 02		 mov	 DWORD PTR [edx], eax

; 138  :     ter->loadTerrain(1);

  00250	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00256	83 c1 08	 add	 ecx, 8
  00259	89 8d f4 fe ff
	ff		 mov	 DWORD PTR tv80[ebp], ecx
  0025f	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  00265	52		 push	 edx
  00266	e8 00 00 00 00	 call	 ___asan_load4
  0026b	83 c4 04	 add	 esp, 4
  0026e	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv80[ebp]
  00274	8b 08		 mov	 ecx, DWORD PTR [eax]
  00276	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv92[ebp], ecx
  0027c	6a 01		 push	 1
  0027e	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  00284	e8 00 00 00 00	 call	 ?loadTerrain@Terrain@@QAEXH@Z ; Terrain::loadTerrain

; 139  :     p = ter->getPlayer();

  00289	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0028f	83 c2 08	 add	 edx, 8
  00292	89 95 f8 fe ff
	ff		 mov	 DWORD PTR tv94[ebp], edx
  00298	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR tv94[ebp]
  0029e	50		 push	 eax
  0029f	e8 00 00 00 00	 call	 ___asan_load4
  002a4	83 c4 04	 add	 esp, 4
  002a7	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv94[ebp]
  002ad	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002af	e8 00 00 00 00	 call	 ?getPlayer@Terrain@@QAEPAVPlayer@@XZ ; Terrain::getPlayer
  002b4	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv128[ebp], eax
  002ba	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002c0	83 c2 14	 add	 edx, 20			; 00000014H
  002c3	89 95 fc fe ff
	ff		 mov	 DWORD PTR tv93[ebp], edx
  002c9	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  002cf	50		 push	 eax
  002d0	e8 00 00 00 00	 call	 ___asan_store4
  002d5	83 c4 04	 add	 esp, 4
  002d8	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR tv93[ebp]
  002de	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv128[ebp]
  002e4	89 11		 mov	 DWORD PTR [ecx], edx

; 140  :     backgroundTex = new sf::Texture();

  002e6	6a 28		 push	 40			; 00000028H
  002e8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  002ed	83 c4 04	 add	 esp, 4
  002f0	89 85 00 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  002f6	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  002fd	83 bd 00 ff ff
	ff 00		 cmp	 DWORD PTR $T9[ebp], 0
  00304	74 14		 je	 SHORT $LN8@loadTerrai
  00306	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  0030c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Texture@sf@@QAE@XZ
  00312	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  00318	eb 0a		 jmp	 SHORT $LN9@loadTerrai
$LN8@loadTerrai:
  0031a	c7 85 04 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
$LN9@loadTerrai:
  00324	8d 85 50 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0032a	c1 e8 03	 shr	 eax, 3
  0032d	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00332	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv336[ebp], eax
  00338	6a 02		 push	 2
  0033a	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv336[ebp]
  00340	51		 push	 ecx
  00341	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00346	83 c4 08	 add	 esp, 8
  00349	8d 95 80 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0034f	c1 ea 03	 shr	 edx, 3
  00352	c6 82 00 00 00
	30 00		 mov	 BYTE PTR [edx+805306368], 0
  00359	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  0035f	89 85 74 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  00365	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0036c	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00372	83 c1 24	 add	 ecx, 36			; 00000024H
  00375	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
  0037b	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR tv129[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 ___asan_store4
  00387	83 c4 04	 add	 esp, 4
  0038a	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  00390	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  00396	89 08		 mov	 DWORD PTR [eax], ecx

; 141  :     sf::Vector2i si = sf::Vector2i(ter->getSizeY() * BLOCKWIDTH, ter->getSizeX() * BLOCKHEIGHT);

  00398	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0039e	83 c2 08	 add	 edx, 8
  003a1	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv143[ebp], edx
  003a7	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  003ad	50		 push	 eax
  003ae	e8 00 00 00 00	 call	 ___asan_load4
  003b3	83 c4 04	 add	 esp, 4
  003b6	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv143[ebp]
  003bc	8b 09		 mov	 ecx, DWORD PTR [ecx]
  003be	e8 00 00 00 00	 call	 ?getSizeX@Terrain@@QAEIXZ ; Terrain::getSizeX
  003c3	6b d0 28	 imul	 edx, eax, 40
  003c6	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv156[ebp], edx
  003cc	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003d2	83 c0 08	 add	 eax, 8
  003d5	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
  003db	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  003e1	51		 push	 ecx
  003e2	e8 00 00 00 00	 call	 ___asan_load4
  003e7	83 c4 04	 add	 esp, 4
  003ea	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv148[ebp]
  003f0	8b 0a		 mov	 ecx, DWORD PTR [edx]
  003f2	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  003f7	6b c0 32	 imul	 eax, eax, 50
  003fa	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv154[ebp], eax
  00400	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv156[ebp]
  00406	51		 push	 ecx
  00407	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv154[ebp]
  0040d	52		 push	 edx
  0040e	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR _si$[ebp]
  00414	e8 00 00 00 00	 call	 ??0?$Vector2@H@sf@@QAE@HH@Z ; sf::Vector2<int>::Vector2<int>

; 142  :     backgroundTex->setSmooth(true);

  00419	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0041f	83 c0 24	 add	 eax, 36			; 00000024H
  00422	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv142[ebp], eax
  00428	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv142[ebp]
  0042e	51		 push	 ecx
  0042f	e8 00 00 00 00	 call	 ___asan_load4
  00434	83 c4 04	 add	 esp, 4
  00437	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv142[ebp]
  0043d	8b 02		 mov	 eax, DWORD PTR [edx]
  0043f	89 45 80	 mov	 DWORD PTR tv160[ebp], eax
  00442	6a 01		 push	 1
  00444	8b 4d 80	 mov	 ecx, DWORD PTR tv160[ebp]
  00447	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setSmooth@Texture@sf@@QAEX_N@Z

; 143  :     backgroundTex->setRepeated(true);

  0044d	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00453	83 c1 24	 add	 ecx, 36			; 00000024H
  00456	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv161[ebp], ecx
  0045c	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv161[ebp]
  00462	52		 push	 edx
  00463	e8 00 00 00 00	 call	 ___asan_load4
  00468	83 c4 04	 add	 esp, 4
  0046b	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv161[ebp]
  00471	8b 08		 mov	 ecx, DWORD PTR [eax]
  00473	89 4d 84	 mov	 DWORD PTR tv165[ebp], ecx
  00476	6a 01		 push	 1
  00478	8b 4d 84	 mov	 ecx, DWORD PTR tv165[ebp]
  0047b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setRepeated@Texture@sf@@QAEX_N@Z

; 144  :     backgroundTex->loadFromImage(*RP->getImgBackground(1), sf::IntRect(sf::Vector2i(0,0),si));

  00481	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00487	83 c2 24	 add	 edx, 36			; 00000024H
  0048a	89 95 1c ff ff
	ff		 mov	 DWORD PTR tv166[ebp], edx
  00490	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv166[ebp]
  00496	50		 push	 eax
  00497	e8 00 00 00 00	 call	 ___asan_load4
  0049c	83 c4 04	 add	 esp, 4
  0049f	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv166[ebp]
  004a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  004a7	89 55 94	 mov	 DWORD PTR tv190[ebp], edx
  004aa	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR _si$[ebp]
  004b0	50		 push	 eax
  004b1	6a 00		 push	 0
  004b3	6a 00		 push	 0
  004b5	8d 8d 80 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  004bb	e8 00 00 00 00	 call	 ??0?$Vector2@H@sf@@QAE@HH@Z ; sf::Vector2<int>::Vector2<int>
  004c0	50		 push	 eax
  004c1	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  004c7	e8 00 00 00 00	 call	 ??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z ; sf::Rect<int>::Rect<int>
  004cc	89 45 8c	 mov	 DWORD PTR tv188[ebp], eax
  004cf	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004d5	83 c1 0c	 add	 ecx, 12			; 0000000cH
  004d8	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv178[ebp], ecx
  004de	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv178[ebp]
  004e4	52		 push	 edx
  004e5	e8 00 00 00 00	 call	 ___asan_load4
  004ea	83 c4 04	 add	 esp, 4
  004ed	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv178[ebp]
  004f3	8b 08		 mov	 ecx, DWORD PTR [eax]
  004f5	89 4d 88	 mov	 DWORD PTR tv183[ebp], ecx
  004f8	6a 01		 push	 1
  004fa	8b 4d 88	 mov	 ecx, DWORD PTR tv183[ebp]
  004fd	e8 00 00 00 00	 call	 ?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z ; RessourcePack::getImgBackground
  00502	89 45 90	 mov	 DWORD PTR tv186[ebp], eax
  00505	8b 55 8c	 mov	 edx, DWORD PTR tv188[ebp]
  00508	52		 push	 edx
  00509	8b 45 90	 mov	 eax, DWORD PTR tv186[ebp]
  0050c	50		 push	 eax
  0050d	8b 4d 94	 mov	 ecx, DWORD PTR tv190[ebp]
  00510	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?loadFromImage@Texture@sf@@QAE_NABVImage@2@ABV?$Rect@H@2@@Z
  00516	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0051c	c1 e9 03	 shr	 ecx, 3
  0051f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00525	89 4d 98	 mov	 DWORD PTR tv345[ebp], ecx
  00528	6a 02		 push	 2
  0052a	8b 55 98	 mov	 edx, DWORD PTR tv345[ebp]
  0052d	52		 push	 edx
  0052e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00533	83 c4 08	 add	 esp, 8
  00536	8d 85 80 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0053c	c1 e8 03	 shr	 eax, 3
  0053f	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 145  :     background = new sf::Sprite(*backgroundTex);

  00546	68 10 01 00 00	 push	 272			; 00000110H
  0054b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00550	83 c4 04	 add	 esp, 4
  00553	89 85 cc fe ff
	ff		 mov	 DWORD PTR $T6[ebp], eax
  00559	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  00560	83 bd cc fe ff
	ff 00		 cmp	 DWORD PTR $T6[ebp], 0
  00567	0f 84 92 00 00
	00		 je	 $LN10@loadTerrai
  0056d	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00573	83 c1 24	 add	 ecx, 36			; 00000024H
  00576	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv202[ebp], ecx
  0057c	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv202[ebp]
  00582	52		 push	 edx
  00583	e8 00 00 00 00	 call	 ___asan_load4
  00588	83 c4 04	 add	 esp, 4
  0058b	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv202[ebp]
  00591	8b 08		 mov	 ecx, DWORD PTR [eax]
  00593	51		 push	 ecx
  00594	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR $T6[ebp]
  0059a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Sprite@sf@@QAE@ABVTexture@1@@Z
  005a0	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T6[ebp]
  005a6	89 95 28 ff ff
	ff		 mov	 DWORD PTR tv204[ebp], edx
  005ac	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv204[ebp]
  005b2	50		 push	 eax
  005b3	e8 00 00 00 00	 call	 ___asan_store4
  005b8	83 c4 04	 add	 esp, 4
  005bb	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv204[ebp]
  005c1	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_SSprite@sf@@6BDrawable@1@@
  005c7	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T6[ebp]
  005cd	83 c2 04	 add	 edx, 4
  005d0	89 95 2c ff ff
	ff		 mov	 DWORD PTR tv205[ebp], edx
  005d6	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  005dc	50		 push	 eax
  005dd	e8 00 00 00 00	 call	 ___asan_store4
  005e2	83 c4 04	 add	 esp, 4
  005e5	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv205[ebp]
  005eb	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_SSprite@sf@@6BTransformable@1@@
  005f1	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR $T6[ebp]
  005f7	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv201[ebp], edx
  005fd	eb 0a		 jmp	 SHORT $LN11@loadTerrai
$LN10@loadTerrai:
  005ff	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
$LN11@loadTerrai:
  00609	8d 85 90 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0060f	c1 e8 03	 shr	 eax, 3
  00612	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00617	89 45 9c	 mov	 DWORD PTR tv351[ebp], eax
  0061a	6a 02		 push	 2
  0061c	8b 4d 9c	 mov	 ecx, DWORD PTR tv351[ebp]
  0061f	51		 push	 ecx
  00620	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00625	83 c4 08	 add	 esp, 8
  00628	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv201[ebp]
  0062e	89 55 a0	 mov	 DWORD PTR $T12[ebp], edx
  00631	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00638	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0063e	83 c0 20	 add	 eax, 32			; 00000020H
  00641	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv168[ebp], eax
  00647	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv168[ebp]
  0064d	51		 push	 ecx
  0064e	e8 00 00 00 00	 call	 ___asan_store4
  00653	83 c4 04	 add	 esp, 4
  00656	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv168[ebp]
  0065c	8b 45 a0	 mov	 eax, DWORD PTR $T12[ebp]
  0065f	89 02		 mov	 DWORD PTR [edx], eax

; 146  :     #pragma warning( push ) 
; 147  :     #pragma warning( disable : 4244)
; 148  :     sf::View View(sf::FloatRect(0, 0, ter->getSizeY() * BLOCKWIDTH, ter->getSizeX() * BLOCKHEIGHT));

  00661	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00667	83 c1 08	 add	 ecx, 8
  0066a	89 8d 38 ff ff
	ff		 mov	 DWORD PTR tv209[ebp], ecx
  00670	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv209[ebp]
  00676	52		 push	 edx
  00677	e8 00 00 00 00	 call	 ___asan_load4
  0067c	83 c4 04	 add	 esp, 4
  0067f	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv209[ebp]
  00685	8b 08		 mov	 ecx, DWORD PTR [eax]
  00687	e8 00 00 00 00	 call	 ?getSizeX@Terrain@@QAEIXZ ; Terrain::getSizeX
  0068c	6b c8 28	 imul	 ecx, eax, 40
  0068f	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv538[ebp], ecx
  00695	f2 0f 2a 85 3c
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv538[ebp]
  0069d	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv538[ebp]
  006a3	c1 ea 1f	 shr	 edx, 31			; 0000001fH
  006a6	f2 0f 58 04 d5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[edx*8]
  006af	f2 0f 11 45 c8	 movsd	 QWORD PTR tv541[ebp], xmm0
  006b4	f2 0f 5a 45 c8	 cvtsd2ss xmm0, QWORD PTR tv541[ebp]
  006b9	f3 0f 11 45 a4	 movss	 DWORD PTR tv226[ebp], xmm0
  006be	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006c4	83 c0 08	 add	 eax, 8
  006c7	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv215[ebp], eax
  006cd	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv215[ebp]
  006d3	51		 push	 ecx
  006d4	e8 00 00 00 00	 call	 ___asan_load4
  006d9	83 c4 04	 add	 esp, 4
  006dc	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv215[ebp]
  006e2	8b 0a		 mov	 ecx, DWORD PTR [edx]
  006e4	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  006e9	6b c0 32	 imul	 eax, eax, 50
  006ec	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv552[ebp], eax
  006f2	f2 0f 2a 85 44
	ff ff ff	 cvtsi2sd xmm0, DWORD PTR tv552[ebp]
  006fa	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv552[ebp]
  00700	c1 e9 1f	 shr	 ecx, 31			; 0000001fH
  00703	f2 0f 58 04 cd
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[ecx*8]
  0070c	f2 0f 11 45 d0	 movsd	 QWORD PTR tv555[ebp], xmm0
  00711	f2 0f 5a 45 d0	 cvtsd2ss xmm0, QWORD PTR tv555[ebp]
  00716	f3 0f 11 45 a8	 movss	 DWORD PTR tv224[ebp], xmm0
  0071b	51		 push	 ecx
  0071c	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR tv226[ebp]
  00721	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00726	51		 push	 ecx
  00727	f3 0f 10 45 a8	 movss	 xmm0, DWORD PTR tv224[ebp]
  0072c	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00731	51		 push	 ecx
  00732	0f 57 c0	 xorps	 xmm0, xmm0
  00735	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  0073a	51		 push	 ecx
  0073b	0f 57 c0	 xorps	 xmm0, xmm0
  0073e	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00743	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00749	e8 00 00 00 00	 call	 ??0?$Rect@M@sf@@QAE@MMMM@Z ; sf::Rect<float>::Rect<float>
  0074e	50		 push	 eax
  0074f	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR _View$[ebp]
  00755	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0View@sf@@QAE@ABV?$Rect@M@1@@Z
  0075b	8d 95 90 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00761	c1 ea 03	 shr	 edx, 3
  00764	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0076a	89 55 ac	 mov	 DWORD PTR tv357[ebp], edx
  0076d	6a 02		 push	 2
  0076f	8b 45 ac	 mov	 eax, DWORD PTR tv357[ebp]
  00772	50		 push	 eax
  00773	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00778	83 c4 08	 add	 esp, 8

; 149  :     #pragma warning( pop ) 
; 150  : 
; 151  :     std::printf("Current Viewport : %d x %d", ter->getSizeY() * BLOCKWIDTH, ter->getSizeX() * BLOCKHEIGHT);

  0077b	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00781	83 c1 08	 add	 ecx, 8
  00784	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv228[ebp], ecx
  0078a	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv228[ebp]
  00790	52		 push	 edx
  00791	e8 00 00 00 00	 call	 ___asan_load4
  00796	83 c4 04	 add	 esp, 4
  00799	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv228[ebp]
  0079f	8b 08		 mov	 ecx, DWORD PTR [eax]
  007a1	e8 00 00 00 00	 call	 ?getSizeX@Terrain@@QAEIXZ ; Terrain::getSizeX
  007a6	6b c8 28	 imul	 ecx, eax, 40
  007a9	89 4d b0	 mov	 DWORD PTR tv242[ebp], ecx
  007ac	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007b2	83 c2 08	 add	 edx, 8
  007b5	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv233[ebp], edx
  007bb	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv233[ebp]
  007c1	50		 push	 eax
  007c2	e8 00 00 00 00	 call	 ___asan_load4
  007c7	83 c4 04	 add	 esp, 4
  007ca	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv233[ebp]
  007d0	8b 09		 mov	 ecx, DWORD PTR [ecx]
  007d2	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  007d7	6b d0 32	 imul	 edx, eax, 50
  007da	89 55 b4	 mov	 DWORD PTR tv240[ebp], edx
  007dd	8b 45 b0	 mov	 eax, DWORD PTR tv242[ebp]
  007e0	50		 push	 eax
  007e1	8b 4d b4	 mov	 ecx, DWORD PTR tv240[ebp]
  007e4	51		 push	 ecx
  007e5	68 00 00 00 00	 push	 OFFSET $SG231304
  007ea	e8 00 00 00 00	 call	 _printf
  007ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 152  :     RW->setView(View);

  007f2	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  007f8	83 c2 10	 add	 edx, 16			; 00000010H
  007fb	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], edx
  00801	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv245[ebp]
  00807	50		 push	 eax
  00808	e8 00 00 00 00	 call	 ___asan_load4
  0080d	83 c4 04	 add	 esp, 4
  00810	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv245[ebp]
  00816	8b 11		 mov	 edx, DWORD PTR [ecx]
  00818	83 c2 30	 add	 edx, 48			; 00000030H
  0081b	89 55 b8	 mov	 DWORD PTR tv250[ebp], edx
  0081e	8d 85 78 fd ff
	ff		 lea	 eax, DWORD PTR _View$[ebp]
  00824	50		 push	 eax
  00825	8b 4d b8	 mov	 ecx, DWORD PTR tv250[ebp]
  00828	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setView@RenderTarget@sf@@QAEXABVView@2@@Z

; 153  :     p->setMaxX(ter->getSizeY() * BLOCKWIDTH);

  0082e	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00834	83 c1 14	 add	 ecx, 20			; 00000014H
  00837	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv254[ebp], ecx
  0083d	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv254[ebp]
  00843	52		 push	 edx
  00844	e8 00 00 00 00	 call	 ___asan_load4
  00849	83 c4 04	 add	 esp, 4
  0084c	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv254[ebp]
  00852	8b 08		 mov	 ecx, DWORD PTR [eax]
  00854	89 4d c0	 mov	 DWORD PTR tv265[ebp], ecx
  00857	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0085d	83 c2 08	 add	 edx, 8
  00860	89 95 58 ff ff
	ff		 mov	 DWORD PTR tv257[ebp], edx
  00866	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv257[ebp]
  0086c	50		 push	 eax
  0086d	e8 00 00 00 00	 call	 ___asan_load4
  00872	83 c4 04	 add	 esp, 4
  00875	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv257[ebp]
  0087b	8b 09		 mov	 ecx, DWORD PTR [ecx]
  0087d	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  00882	6b d0 32	 imul	 edx, eax, 50
  00885	89 55 bc	 mov	 DWORD PTR tv263[ebp], edx
  00888	8b 45 bc	 mov	 eax, DWORD PTR tv263[ebp]
  0088b	50		 push	 eax
  0088c	8b 4d c0	 mov	 ecx, DWORD PTR tv265[ebp]
  0088f	e8 00 00 00 00	 call	 ?setMaxX@Character@@QAEXH@Z ; Character::setMaxX

; 154  : }

  00894	c7 85 68 fd ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0089e	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  008a4	c1 e9 03	 shr	 ecx, 3
  008a7	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  008ad	89 4d c4	 mov	 DWORD PTR tv363[ebp], ecx
  008b0	6a 2b		 push	 43			; 0000002bH
  008b2	8b 55 c4	 mov	 edx, DWORD PTR tv363[ebp]
  008b5	52		 push	 edx
  008b6	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  008bb	83 c4 08	 add	 esp, 8
  008be	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  008c1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  008c8	59		 pop	 ecx
  008c9	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  008cc	33 cd		 xor	 ecx, ebp
  008ce	e8 00 00 00 00	 call	 @__security_check_cookie@4
  008d3	8b e5		 mov	 esp, ebp
  008d5	5d		 pop	 ebp
  008d6	8b e3		 mov	 esp, ebx
  008d8	5b		 pop	 ebx
  008d9	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$0:
  00000	6a 0c		 push	 12			; 0000000cH
  00002	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$1:
  00012	6a 28		 push	 40			; 00000028H
  00014	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	83 c4 08	 add	 esp, 8
  00023	c3		 ret	 0
__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$2:
  00024	68 10 01 00 00	 push	 272			; 00000110H
  00029	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR $T6[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
  00038	c3		 ret	 0
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
__ehhandler$?loadTerrain@Univers@@QAEXH@Z:
  0003e	90		 npad	 1
  0003f	90		 npad	 1
  00040	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00044	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00047	8b 8a 68 fd ff
	ff		 mov	 ecx, DWORD PTR [edx-664]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?loadTerrain@Univers@@QAEXH@Z
  00063	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?loadTerrain@Univers@@QAEXH@Z ENDP			; Univers::loadTerrain
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -816					; size = 4
__asan_gen_1$ = -812					; size = 4
__asan_gen_2$ = -808					; size = 4
$T2 = -800						; size = 16
$T3 = -752						; size = 16
$T4 = -704						; size = 12
$T5 = -656						; size = 12
$T6 = -608						; size = 12
_size$7 = -560						; size = 8
$T8 = -544						; size = 16
$T9 = -496						; size = 16
$T10 = -448						; size = 16
$T11 = -400						; size = 16
$T12 = -352						; size = 16
tv402 = -304						; size = 4
_this$ = -300						; size = 4
_<begin>$L0$13 = -296					; size = 4
_it$14 = -292						; size = 4
_i$15 = -288						; size = 4
_i$16 = -284						; size = 4
_e$17 = -280						; size = 4
tv65 = -276						; size = 4
tv69 = -272						; size = 4
tv79 = -268						; size = 4
_<range>$L0$18 = -264					; size = 4
tv141 = -260						; size = 4
tv154 = -256						; size = 4
tv160 = -252						; size = 4
tv440 = -248						; size = 4
tv433 = -244						; size = 4
tv426 = -240						; size = 4
tv171 = -236						; size = 4
tv187 = -232						; size = 4
tv461 = -228						; size = 4
tv454 = -224						; size = 4
tv447 = -220						; size = 4
tv234 = -216						; size = 4
_yp$19 = -212						; size = 4
_yb$20 = -208						; size = 4
tv248 = -204						; size = 4
tv262 = -200						; size = 4
_xp$21 = -196						; size = 4
_xb$22 = -192						; size = 4
tv277 = -188						; size = 4
tv287 = -184						; size = 4
tv298 = -180						; size = 4
tv400 = -176						; size = 4
tv405 = -172						; size = 4
tv75 = -168						; size = 4
tv302 = -164						; size = 4
tv411 = -160						; size = 4
_<end>$L0$23 = -156					; size = 4
tv417 = -152						; size = 4
tv328 = -148						; size = 4
_t$24 = -144						; size = 4
tv331 = -140						; size = 4
tv150 = -136						; size = 4
tv165 = -132						; size = 4
tv194 = -128						; size = 4
tv304 = -124						; size = 4
tv202 = -120						; size = 4
tv306 = -116						; size = 4
tv213 = -112						; size = 4
tv229 = -108						; size = 4
tv468 = -104						; size = 4
tv240 = -100						; size = 4
tv312 = -96						; size = 4
tv474 = -92						; size = 4
tv480 = -88						; size = 4
tv254 = -84						; size = 4
tv314 = -80						; size = 4
tv486 = -76						; size = 4
tv492 = -72						; size = 4
tv268 = -68						; size = 4
tv316 = -64						; size = 4
tv498 = -60						; size = 4
tv272 = -56						; size = 4
tv504 = -52						; size = 4
tv283 = -48						; size = 4
tv318 = -44						; size = 4
tv510 = -40						; size = 4
tv516 = -36						; size = 4
tv294 = -32						; size = 4
tv320 = -28						; size = 4
tv522 = -24						; size = 4
tv528 = -20						; size = 4
tv321 = -16						; size = 4
$T25 = -12						; size = 4
tv309 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z PROC ; Univers::collision
; _this$ = ecx

; 77   : std::vector<bool>* Univers::collision(Character* p) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 3c 03 00
	00		 sub	 esp, 828		; 0000033cH
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	56		 push	 esi
  00027	89 8d d4 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0002d	c7 85 d0 fc ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00037	c7 85 d4 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z
  00041	c7 85 d8 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z ; Univers::collision
  0004b	8d 85 d0 fc ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00051	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv400[ebp], eax
  00057	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv400[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00066	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv402[ebp], ecx
  0006c	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv402[ebp]
  00072	c7 02 f1 f1 f8
	f8		 mov	 DWORD PTR [edx], -117902863 ; f8f8f1f1H
  00078	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  0007f	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv402[ebp]
  00085	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  0008b	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00092	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv402[ebp]
  00098	c7 01 f8 f8 f2
	f2		 mov	 DWORD PTR [ecx], -218957576 ; f2f2f8f8H
  0009e	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  000a5	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv402[ebp]
  000ab	c7 02 f2 f2 f8
	04		 mov	 DWORD PTR [edx], 83423986 ; 04f8f2f2H
  000b1	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  000b8	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv402[ebp]
  000be	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  000c4	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  000cb	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv402[ebp]
  000d1	c7 01 f8 04 f2
	f2		 mov	 DWORD PTR [ecx], -219020040 ; f2f204f8H
  000d7	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  000de	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv402[ebp]
  000e4	c7 02 f2 f2 f8
	04		 mov	 DWORD PTR [edx], 83423986 ; 04f8f2f2H
  000ea	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  000f1	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv402[ebp]
  000f7	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  000fd	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00104	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv402[ebp]
  0010a	c7 01 f8 f2 f8
	f8		 mov	 DWORD PTR [ecx], -117902600 ; f8f8f2f8H
  00110	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00117	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv402[ebp]
  0011d	c7 02 f2 f2 f2
	f2		 mov	 DWORD PTR [edx], -218959118 ; f2f2f2f2H
  00123	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  0012a	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv402[ebp]
  00130	c7 00 f8 f8 f2
	f2		 mov	 DWORD PTR [eax], -218957576 ; f2f2f8f8H
  00136	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  0013d	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv402[ebp]
  00143	c7 01 f2 f2 f8
	f8		 mov	 DWORD PTR [ecx], -117902606 ; f8f8f2f2H
  00149	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00150	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv402[ebp]
  00156	c7 02 f2 f2 f2
	f2		 mov	 DWORD PTR [edx], -218959118 ; f2f2f2f2H
  0015c	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00163	8b 85 d0 fe ff
	ff		 mov	 eax, DWORD PTR tv402[ebp]
  00169	c7 00 f8 f8 f2
	f2		 mov	 DWORD PTR [eax], -218957576 ; f2f2f8f8H
  0016f	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00176	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv402[ebp]
  0017c	c7 01 f2 f2 f8
	f8		 mov	 DWORD PTR [ecx], -117902606 ; f8f8f2f2H
  00182	83 85 d0 fe ff
	ff 04		 add	 DWORD PTR tv402[ebp], 4
  00189	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv402[ebp]
  0018f	c7 02 f3 f3 f3
	f3		 mov	 DWORD PTR [edx], -202116109 ; f3f3f3f3H
  00195	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  0019a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 78   :     for (uint32_t i = 0; i < res->size(); i++) {

  0019f	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$16[ebp], 0
  001a9	eb 0f		 jmp	 SHORT $LN4@collision
$LN2@collision:
  001ab	8b 85 e4 fe ff
	ff		 mov	 eax, DWORD PTR _i$16[ebp]
  001b1	83 c0 01	 add	 eax, 1
  001b4	89 85 e4 fe ff
	ff		 mov	 DWORD PTR _i$16[ebp], eax
$LN4@collision:
  001ba	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c0	83 c1 1c	 add	 ecx, 28			; 0000001cH
  001c3	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv65[ebp], ecx
  001c9	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv65[ebp]
  001cf	52		 push	 edx
  001d0	e8 00 00 00 00	 call	 ___asan_load4
  001d5	83 c4 04	 add	 esp, 4
  001d8	8b 85 ec fe ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  001de	8b 08		 mov	 ecx, DWORD PTR [eax]
  001e0	e8 00 00 00 00	 call	 ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  001e5	39 85 e4 fe ff
	ff		 cmp	 DWORD PTR _i$16[ebp], eax
  001eb	0f 83 b3 00 00
	00		 jae	 $LN3@collision
  001f1	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001f7	c1 e9 03	 shr	 ecx, 3
  001fa	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00200	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv405[ebp], ecx
  00206	6a 02		 push	 2
  00208	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv405[ebp]
  0020e	52		 push	 edx
  0020f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00214	83 c4 08	 add	 esp, 8

; 79   :         res->at(i) = false;

  00217	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0021d	83 c0 1c	 add	 eax, 28			; 0000001cH
  00220	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv69[ebp], eax
  00226	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR tv69[ebp]
  0022c	51		 push	 ecx
  0022d	e8 00 00 00 00	 call	 ___asan_load4
  00232	83 c4 04	 add	 esp, 4
  00235	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv69[ebp]
  0023b	8b 02		 mov	 eax, DWORD PTR [edx]
  0023d	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00243	6a 00		 push	 0
  00245	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$16[ebp]
  0024b	51		 push	 ecx
  0024c	8d 95 e0 fc ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  00252	52		 push	 edx
  00253	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00259	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  0025e	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv302[ebp], eax
  00264	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv302[ebp]
  0026a	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  0026f	8d 8d e0 fc ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00275	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0027a	8d 85 e0 fc ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00280	c1 e8 03	 shr	 eax, 3
  00283	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00288	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv411[ebp], eax
  0028e	6a 02		 push	 2
  00290	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv411[ebp]
  00296	51		 push	 ecx
  00297	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0029c	83 c4 08	 add	 esp, 8

; 80   :     }

  0029f	e9 07 ff ff ff	 jmp	 $LN2@collision
$LN3@collision:

; 81   :     for (auto t : *ter->getTerrain()) {

  002a4	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002aa	83 c2 08	 add	 edx, 8
  002ad	89 95 f4 fe ff
	ff		 mov	 DWORD PTR tv79[ebp], edx
  002b3	8b 85 f4 fe ff
	ff		 mov	 eax, DWORD PTR tv79[ebp]
  002b9	50		 push	 eax
  002ba	e8 00 00 00 00	 call	 ___asan_load4
  002bf	83 c4 04	 add	 esp, 4
  002c2	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  002c8	8b 09		 mov	 ecx, DWORD PTR [ecx]
  002ca	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  002cf	89 85 f8 fe ff
	ff		 mov	 DWORD PTR _<range>$L0$18[ebp], eax
  002d5	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _<range>$L0$18[ebp]
  002db	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
  002e0	89 85 d8 fe ff
	ff		 mov	 DWORD PTR _<begin>$L0$13[ebp], eax
  002e6	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR _<range>$L0$18[ebp]
  002ec	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
  002f1	89 85 64 ff ff
	ff		 mov	 DWORD PTR _<end>$L0$23[ebp], eax
  002f7	eb 0f		 jmp	 SHORT $LN7@collision
$LN5@collision:
  002f9	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _<begin>$L0$13[ebp]
  002ff	83 c2 04	 add	 edx, 4
  00302	89 95 d8 fe ff
	ff		 mov	 DWORD PTR _<begin>$L0$13[ebp], edx
$LN7@collision:
  00308	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _<begin>$L0$13[ebp]
  0030e	3b 85 64 ff ff
	ff		 cmp	 eax, DWORD PTR _<end>$L0$23[ebp]
  00314	0f 84 14 08 00
	00		 je	 $LN6@collision
  0031a	8d 8d 10 fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00320	c1 e9 03	 shr	 ecx, 3
  00323	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00329	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv417[ebp], ecx
  0032f	6a 02		 push	 2
  00331	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv417[ebp]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0033d	83 c4 08	 add	 esp, 8
  00340	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR _<begin>$L0$13[ebp]
  00346	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv328[ebp], eax
  0034c	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv328[ebp]
  00352	51		 push	 ecx
  00353	e8 00 00 00 00	 call	 ___asan_load4
  00358	83 c4 04	 add	 esp, 4
  0035b	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR _<begin>$L0$13[ebp]
  00361	8b 02		 mov	 eax, DWORD PTR [edx]
  00363	89 85 70 ff ff
	ff		 mov	 DWORD PTR _t$24[ebp], eax

; 82   : 
; 83   :         Block* e = static_cast<Block*>(t);

  00369	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR _t$24[ebp]
  0036f	89 8d e8 fe ff
	ff		 mov	 DWORD PTR _e$17[ebp], ecx

; 84   :         if (e->collide(p->getRect())) {

  00375	8d 95 10 fd ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0037b	52		 push	 edx
  0037c	8b 4b 08	 mov	 ecx, DWORD PTR _p$[ebx]
  0037f	e8 00 00 00 00	 call	 ?getRect@Character@@QAE?AV?$Rect@H@sf@@XZ ; Character::getRect
  00384	83 ec 10	 sub	 esp, 16			; 00000010H
  00387	8b cc		 mov	 ecx, esp
  00389	8b 10		 mov	 edx, DWORD PTR [eax]
  0038b	89 11		 mov	 DWORD PTR [ecx], edx
  0038d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00390	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00393	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  00396	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00399	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  0039c	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  0039f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _e$17[ebp]
  003a5	e8 00 00 00 00	 call	 ?collide@Block@@QAE_NV?$Rect@H@sf@@@Z ; Block::collide
  003aa	0f b6 c8	 movzx	 ecx, al
  003ad	85 c9		 test	 ecx, ecx
  003af	0f 84 74 07 00
	00		 je	 $LN22@collision
  003b5	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _size$7[ebp]
  003bb	c1 ea 03	 shr	 edx, 3
  003be	c6 82 00 00 00
	30 00		 mov	 BYTE PTR [edx+805306368], 0

; 85   :                 #ifdef DEBUG
; 86   :                 e->colliding = true;
; 87   :                 #endif // DEBUG
; 88   :   
; 89   :                 InteractiveObject* it = dynamic_cast<InteractiveObject*>(e);

  003c5	6a 00		 push	 0
  003c7	68 00 00 00 00	 push	 OFFSET ??_R0?AVInteractiveObject@@@8
  003cc	68 00 00 00 00	 push	 OFFSET ??_R0?AVBlock@@@8
  003d1	6a 00		 push	 0
  003d3	8b 85 e8 fe ff
	ff		 mov	 eax, DWORD PTR _e$17[ebp]
  003d9	50		 push	 eax
  003da	e8 00 00 00 00	 call	 ___RTDynamicCast
  003df	83 c4 14	 add	 esp, 20			; 00000014H
  003e2	89 85 dc fe ff
	ff		 mov	 DWORD PTR _it$14[ebp], eax

; 90   :                 if (it != nullptr) {

  003e8	83 bd dc fe ff
	ff 00		 cmp	 DWORD PTR _it$14[ebp], 0
  003ef	0f 84 03 03 00
	00		 je	 $LN12@collision

; 91   :                     if (it->effectPlayer((Player *)p)) {

  003f5	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _it$14[ebp]
  003fb	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv331[ebp], ecx
  00401	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv331[ebp]
  00407	52		 push	 edx
  00408	e8 00 00 00 00	 call	 ___asan_load4
  0040d	83 c4 04	 add	 esp, 4
  00410	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR _it$14[ebp]
  00416	8b 08		 mov	 ecx, DWORD PTR [eax]
  00418	89 8d fc fe ff
	ff		 mov	 DWORD PTR tv141[ebp], ecx
  0041e	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv141[ebp]
  00424	52		 push	 edx
  00425	e8 00 00 00 00	 call	 ___asan_load4
  0042a	83 c4 04	 add	 esp, 4
  0042d	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  00433	8b 08		 mov	 ecx, DWORD PTR [eax]
  00435	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv150[ebp], ecx
  0043b	8b 53 08	 mov	 edx, DWORD PTR _p$[ebx]
  0043e	52		 push	 edx
  0043f	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR _it$14[ebp]
  00445	ff 95 78 ff ff
	ff		 call	 DWORD PTR tv150[ebp]
  0044b	0f b6 c0	 movzx	 eax, al
  0044e	85 c0		 test	 eax, eax
  00450	0f 84 9d 02 00
	00		 je	 $LN9@collision

; 92   :                         for (uint32_t i = 0; i < ter->getTerrain()->size();i++) {

  00456	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$15[ebp], 0
  00460	eb 0f		 jmp	 SHORT $LN10@collision
$LN8@collision:
  00462	8b 8d e0 fe ff
	ff		 mov	 ecx, DWORD PTR _i$15[ebp]
  00468	83 c1 01	 add	 ecx, 1
  0046b	89 8d e0 fe ff
	ff		 mov	 DWORD PTR _i$15[ebp], ecx
$LN10@collision:
  00471	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00477	83 c2 08	 add	 edx, 8
  0047a	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv154[ebp], edx
  00480	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv154[ebp]
  00486	50		 push	 eax
  00487	e8 00 00 00 00	 call	 ___asan_load4
  0048c	83 c4 04	 add	 esp, 4
  0048f	8b 8d 00 ff ff
	ff		 mov	 ecx, DWORD PTR tv154[ebp]
  00495	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00497	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  0049c	8b c8		 mov	 ecx, eax
  0049e	e8 00 00 00 00	 call	 ?size@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QBEIXZ ; std::vector<Block *,std::allocator<Block *> >::size
  004a3	39 85 e0 fe ff
	ff		 cmp	 DWORD PTR _i$15[ebp], eax
  004a9	0f 83 44 02 00
	00		 jae	 $LN9@collision

; 93   :                             if (ter->getElementAtPos(i) == it) {

  004af	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004b5	83 c2 08	 add	 edx, 8
  004b8	89 95 04 ff ff
	ff		 mov	 DWORD PTR tv160[ebp], edx
  004be	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR tv160[ebp]
  004c4	50		 push	 eax
  004c5	e8 00 00 00 00	 call	 ___asan_load4
  004ca	83 c4 04	 add	 esp, 4
  004cd	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv160[ebp]
  004d3	8b 11		 mov	 edx, DWORD PTR [ecx]
  004d5	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv165[ebp], edx
  004db	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  004e1	50		 push	 eax
  004e2	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv165[ebp]
  004e8	e8 00 00 00 00	 call	 ?getElementAtPos@Terrain@@QAEPAVBlock@@H@Z ; Terrain::getElementAtPos
  004ed	3b 85 dc fe ff
	ff		 cmp	 eax, DWORD PTR _it$14[ebp]
  004f3	0f 85 f5 01 00
	00		 jne	 $LN14@collision
  004f9	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  004ff	c1 e9 03	 shr	 ecx, 3
  00502	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00508	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv440[ebp], ecx
  0050e	6a 01		 push	 1
  00510	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR tv440[ebp]
  00516	52		 push	 edx
  00517	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0051c	83 c4 08	 add	 esp, 8
  0051f	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv440[ebp]
  00525	c6 40 01 04	 mov	 BYTE PTR [eax+1], 4
  00529	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0052f	c1 e9 03	 shr	 ecx, 3
  00532	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00538	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv433[ebp], ecx
  0053e	6a 01		 push	 1
  00540	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv433[ebp]
  00546	52		 push	 edx
  00547	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0054c	83 c4 08	 add	 esp, 8
  0054f	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv433[ebp]
  00555	c6 40 01 04	 mov	 BYTE PTR [eax+1], 4
  00559	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  0055f	c1 e9 03	 shr	 ecx, 3
  00562	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00568	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv426[ebp], ecx
  0056e	6a 01		 push	 1
  00570	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv426[ebp]
  00576	52		 push	 edx
  00577	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0057c	83 c4 08	 add	 esp, 8
  0057f	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv426[ebp]
  00585	c6 40 01 04	 mov	 BYTE PTR [eax+1], 4

; 94   :                                 ter->getTerrain()->erase(ter->getTerrain()->begin() + i);

  00589	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0058f	83 c1 08	 add	 ecx, 8
  00592	89 8d 14 ff ff
	ff		 mov	 DWORD PTR tv171[ebp], ecx
  00598	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv171[ebp]
  0059e	52		 push	 edx
  0059f	e8 00 00 00 00	 call	 ___asan_load4
  005a4	83 c4 04	 add	 esp, 4
  005a7	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv171[ebp]
  005ad	8b 08		 mov	 ecx, DWORD PTR [eax]
  005af	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  005b4	89 45 90	 mov	 DWORD PTR tv213[ebp], eax
  005b7	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  005bd	83 c1 08	 add	 ecx, 8
  005c0	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv187[ebp], ecx
  005c6	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv187[ebp]
  005cc	52		 push	 edx
  005cd	e8 00 00 00 00	 call	 ___asan_load4
  005d2	83 c4 04	 add	 esp, 4
  005d5	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv187[ebp]
  005db	8b 08		 mov	 ecx, DWORD PTR [eax]
  005dd	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  005e2	89 45 80	 mov	 DWORD PTR tv194[ebp], eax
  005e5	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  005eb	51		 push	 ecx
  005ec	8b 4d 80	 mov	 ecx, DWORD PTR tv194[ebp]
  005ef	e8 00 00 00 00	 call	 ?begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@XZ ; std::vector<Block *,std::allocator<Block *> >::begin
  005f4	89 45 84	 mov	 DWORD PTR tv304[ebp], eax
  005f7	8b 55 84	 mov	 edx, DWORD PTR tv304[ebp]
  005fa	89 55 88	 mov	 DWORD PTR tv202[ebp], edx
  005fd	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00600	8b f4		 mov	 esi, esp
  00602	89 65 f4	 mov	 DWORD PTR $T25[ebp], esp
  00605	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR _i$15[ebp]
  0060b	50		 push	 eax
  0060c	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00612	51		 push	 ecx
  00613	8b 4d 88	 mov	 ecx, DWORD PTR tv202[ebp]
  00616	e8 00 00 00 00	 call	 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Block *> > >::operator+
  0061b	89 45 8c	 mov	 DWORD PTR tv306[ebp], eax
  0061e	8b 55 8c	 mov	 edx, DWORD PTR tv306[ebp]
  00621	52		 push	 edx
  00622	8b ce		 mov	 ecx, esi
  00624	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@ABV01@@Z
  00629	8d 85 a0 fd ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0062f	50		 push	 eax
  00630	8b 4d 90	 mov	 ecx, DWORD PTR tv213[ebp]
  00633	e8 00 00 00 00	 call	 ?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z ; std::vector<Block *,std::allocator<Block *> >::erase
  00638	89 45 f8	 mov	 DWORD PTR tv309[ebp], eax
  0063b	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00641	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
  00646	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  0064c	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
  00651	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00657	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
  0065c	8d 8d 40 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00662	c1 e9 03	 shr	 ecx, 3
  00665	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0066b	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv461[ebp], ecx
  00671	6a 01		 push	 1
  00673	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR tv461[ebp]
  00679	52		 push	 edx
  0067a	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0067f	83 c4 08	 add	 esp, 8
  00682	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv461[ebp]
  00688	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
  0068c	8d 8d 70 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00692	c1 e9 03	 shr	 ecx, 3
  00695	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0069b	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv454[ebp], ecx
  006a1	6a 01		 push	 1
  006a3	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv454[ebp]
  006a9	52		 push	 edx
  006aa	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  006af	83 c4 08	 add	 esp, 8
  006b2	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv454[ebp]
  006b8	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
  006bc	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  006c2	c1 e9 03	 shr	 ecx, 3
  006c5	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  006cb	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv447[ebp], ecx
  006d1	6a 01		 push	 1
  006d3	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv447[ebp]
  006d9	52		 push	 edx
  006da	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  006df	83 c4 08	 add	 esp, 8
  006e2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv447[ebp]
  006e8	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H

; 95   :                                 break;

  006ec	eb 05		 jmp	 SHORT $LN9@collision
$LN14@collision:

; 96   :                             }
; 97   :                         }

  006ee	e9 6f fd ff ff	 jmp	 $LN8@collision
$LN9@collision:

; 98   :                     }
; 99   :                     continue;

  006f3	e9 01 fc ff ff	 jmp	 $LN5@collision
$LN12@collision:

; 100  : 
; 101  :                 }
; 102  : 
; 103  :                 int xb = static_cast<int>(e->getX());

  006f8	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _e$17[ebp]
  006fe	e8 00 00 00 00	 call	 ?getX@Block@@QAEMXZ	; Block::getX
  00703	e8 00 00 00 00	 call	 __ftol2_sse
  00708	89 85 40 ff ff
	ff		 mov	 DWORD PTR _xb$22[ebp], eax

; 104  :                 int yb = static_cast<int>(e->getY());

  0070e	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR _e$17[ebp]
  00714	e8 00 00 00 00	 call	 ?getY@Block@@QAEMXZ	; Block::getY
  00719	e8 00 00 00 00	 call	 __ftol2_sse
  0071e	89 85 30 ff ff
	ff		 mov	 DWORD PTR _yb$20[ebp], eax

; 105  :                 int xp = static_cast<int>(p->getX());

  00724	8b 4b 08	 mov	 ecx, DWORD PTR _p$[ebx]
  00727	e8 00 00 00 00	 call	 ?getX@Character@@QAEMXZ	; Character::getX
  0072c	e8 00 00 00 00	 call	 __ftol2_sse
  00731	89 85 3c ff ff
	ff		 mov	 DWORD PTR _xp$21[ebp], eax

; 106  :                 int yp = static_cast<int>(p->getY());

  00737	8b 4b 08	 mov	 ecx, DWORD PTR _p$[ebx]
  0073a	e8 00 00 00 00	 call	 ?getY@Character@@QAEMXZ	; Character::getY
  0073f	e8 00 00 00 00	 call	 __ftol2_sse
  00744	89 85 2c ff ff
	ff		 mov	 DWORD PTR _yp$19[ebp], eax

; 107  :                 sf::Vector2u size = p->getSize();

  0074a	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _size$7[ebp]
  00750	51		 push	 ecx
  00751	8b 4b 08	 mov	 ecx, DWORD PTR _p$[ebx]
  00754	e8 00 00 00 00	 call	 ?getSize@Character@@QAE?AV?$Vector2@I@sf@@XZ ; Character::getSize

; 108  :                 if (yb + size.y <= yp + size.y / 3) {

  00759	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _size$7[ebp+4]
  0075f	52		 push	 edx
  00760	e8 00 00 00 00	 call	 ___asan_load4
  00765	83 c4 04	 add	 esp, 4
  00768	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _yb$20[ebp]
  0076e	03 85 d4 fd ff
	ff		 add	 eax, DWORD PTR _size$7[ebp+4]
  00774	89 45 94	 mov	 DWORD PTR tv229[ebp], eax
  00777	8d 8d d4 fd ff
	ff		 lea	 ecx, DWORD PTR _size$7[ebp+4]
  0077d	51		 push	 ecx
  0077e	e8 00 00 00 00	 call	 ___asan_load4
  00783	83 c4 04	 add	 esp, 4
  00786	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _size$7[ebp+4]
  0078c	33 d2		 xor	 edx, edx
  0078e	b9 03 00 00 00	 mov	 ecx, 3
  00793	f7 f1		 div	 ecx
  00795	03 85 2c ff ff
	ff		 add	 eax, DWORD PTR _yp$19[ebp]
  0079b	39 45 94	 cmp	 DWORD PTR tv229[ebp], eax
  0079e	0f 87 96 00 00
	00		 ja	 $LN15@collision
  007a4	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  007aa	c1 ea 03	 shr	 edx, 3
  007ad	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  007b3	89 55 98	 mov	 DWORD PTR tv468[ebp], edx
  007b6	6a 02		 push	 2
  007b8	8b 45 98	 mov	 eax, DWORD PTR tv468[ebp]
  007bb	50		 push	 eax
  007bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  007c1	83 c4 08	 add	 esp, 8

; 109  :                     res->at(COLDIR::TOP) = true;

  007c4	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007ca	83 c1 1c	 add	 ecx, 28			; 0000001cH
  007cd	89 8d 28 ff ff
	ff		 mov	 DWORD PTR tv234[ebp], ecx
  007d3	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv234[ebp]
  007d9	52		 push	 edx
  007da	e8 00 00 00 00	 call	 ___asan_load4
  007df	83 c4 04	 add	 esp, 4
  007e2	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv234[ebp]
  007e8	8b 08		 mov	 ecx, DWORD PTR [eax]
  007ea	89 4d 9c	 mov	 DWORD PTR tv240[ebp], ecx
  007ed	6a 01		 push	 1
  007ef	6a 00		 push	 0
  007f1	8d 95 e0 fd ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  007f7	52		 push	 edx
  007f8	8b 4d 9c	 mov	 ecx, DWORD PTR tv240[ebp]
  007fb	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00800	89 45 a0	 mov	 DWORD PTR tv312[ebp], eax
  00803	8b 4d a0	 mov	 ecx, DWORD PTR tv312[ebp]
  00806	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  0080b	8d 8d e0 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00811	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00816	8d 85 e0 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  0081c	c1 e8 03	 shr	 eax, 3
  0081f	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00824	89 45 a4	 mov	 DWORD PTR tv474[ebp], eax
  00827	6a 02		 push	 2
  00829	8b 4d a4	 mov	 ecx, DWORD PTR tv474[ebp]
  0082c	51		 push	 ecx
  0082d	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00832	83 c4 08	 add	 esp, 8

; 110  :                 }

  00835	e9 ef 02 00 00	 jmp	 $LN22@collision
$LN15@collision:

; 111  :                 else if ((unsigned int)yb >= yp + size.y / 4) {

  0083a	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _size$7[ebp+4]
  00840	52		 push	 edx
  00841	e8 00 00 00 00	 call	 ___asan_load4
  00846	83 c4 04	 add	 esp, 4
  00849	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _size$7[ebp+4]
  0084f	c1 e8 02	 shr	 eax, 2
  00852	03 85 2c ff ff
	ff		 add	 eax, DWORD PTR _yp$19[ebp]
  00858	39 85 30 ff ff
	ff		 cmp	 DWORD PTR _yb$20[ebp], eax
  0085e	0f 82 97 00 00
	00		 jb	 $LN17@collision
  00864	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0086a	c1 e9 03	 shr	 ecx, 3
  0086d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00873	89 4d a8	 mov	 DWORD PTR tv480[ebp], ecx
  00876	6a 02		 push	 2
  00878	8b 55 a8	 mov	 edx, DWORD PTR tv480[ebp]
  0087b	52		 push	 edx
  0087c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00881	83 c4 08	 add	 esp, 8

; 112  :                     res->at(COLDIR::BOTTOM) = true;

  00884	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0088a	83 c0 1c	 add	 eax, 28			; 0000001cH
  0088d	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv248[ebp], eax
  00893	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv248[ebp]
  00899	51		 push	 ecx
  0089a	e8 00 00 00 00	 call	 ___asan_load4
  0089f	83 c4 04	 add	 esp, 4
  008a2	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv248[ebp]
  008a8	8b 02		 mov	 eax, DWORD PTR [edx]
  008aa	89 45 ac	 mov	 DWORD PTR tv254[ebp], eax
  008ad	6a 01		 push	 1
  008af	6a 01		 push	 1
  008b1	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  008b7	51		 push	 ecx
  008b8	8b 4d ac	 mov	 ecx, DWORD PTR tv254[ebp]
  008bb	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  008c0	89 45 b0	 mov	 DWORD PTR tv314[ebp], eax
  008c3	8b 4d b0	 mov	 ecx, DWORD PTR tv314[ebp]
  008c6	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  008cb	8d 8d 10 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  008d1	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  008d6	8d 95 10 fe ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  008dc	c1 ea 03	 shr	 edx, 3
  008df	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  008e5	89 55 b4	 mov	 DWORD PTR tv486[ebp], edx
  008e8	6a 02		 push	 2
  008ea	8b 45 b4	 mov	 eax, DWORD PTR tv486[ebp]
  008ed	50		 push	 eax
  008ee	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  008f3	83 c4 08	 add	 esp, 8

; 113  :                 }

  008f6	e9 2e 02 00 00	 jmp	 $LN22@collision
$LN17@collision:

; 114  :                 else if ((unsigned int)xp > xb + size.x / 4) {

  008fb	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _size$7[ebp]
  00901	51		 push	 ecx
  00902	e8 00 00 00 00	 call	 ___asan_load4
  00907	83 c4 04	 add	 esp, 4
  0090a	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _size$7[ebp]
  00910	c1 ea 02	 shr	 edx, 2
  00913	03 95 40 ff ff
	ff		 add	 edx, DWORD PTR _xb$22[ebp]
  00919	39 95 3c ff ff
	ff		 cmp	 DWORD PTR _xp$21[ebp], edx
  0091f	0f 86 96 00 00
	00		 jbe	 $LN19@collision
  00925	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  0092b	c1 e8 03	 shr	 eax, 3
  0092e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00933	89 45 b8	 mov	 DWORD PTR tv492[ebp], eax
  00936	6a 02		 push	 2
  00938	8b 4d b8	 mov	 ecx, DWORD PTR tv492[ebp]
  0093b	51		 push	 ecx
  0093c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00941	83 c4 08	 add	 esp, 8

; 115  :                     res->at(COLDIR::LEFT) = true;

  00944	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0094a	83 c2 1c	 add	 edx, 28			; 0000001cH
  0094d	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv262[ebp], edx
  00953	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv262[ebp]
  00959	50		 push	 eax
  0095a	e8 00 00 00 00	 call	 ___asan_load4
  0095f	83 c4 04	 add	 esp, 4
  00962	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv262[ebp]
  00968	8b 11		 mov	 edx, DWORD PTR [ecx]
  0096a	89 55 bc	 mov	 DWORD PTR tv268[ebp], edx
  0096d	6a 01		 push	 1
  0096f	6a 02		 push	 2
  00971	8d 85 40 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00977	50		 push	 eax
  00978	8b 4d bc	 mov	 ecx, DWORD PTR tv268[ebp]
  0097b	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00980	89 45 c0	 mov	 DWORD PTR tv316[ebp], eax
  00983	8b 4d c0	 mov	 ecx, DWORD PTR tv316[ebp]
  00986	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  0098b	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00991	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00996	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0099c	c1 e9 03	 shr	 ecx, 3
  0099f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  009a5	89 4d c4	 mov	 DWORD PTR tv498[ebp], ecx
  009a8	6a 02		 push	 2
  009aa	8b 55 c4	 mov	 edx, DWORD PTR tv498[ebp]
  009ad	52		 push	 edx
  009ae	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  009b3	83 c4 08	 add	 esp, 8

; 116  :                 }

  009b6	e9 6e 01 00 00	 jmp	 $LN22@collision
$LN19@collision:

; 117  :                 else if (xp + size.x <= xb + size.x / 4) {

  009bb	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _size$7[ebp]
  009c1	50		 push	 eax
  009c2	e8 00 00 00 00	 call	 ___asan_load4
  009c7	83 c4 04	 add	 esp, 4
  009ca	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR _xp$21[ebp]
  009d0	03 8d d0 fd ff
	ff		 add	 ecx, DWORD PTR _size$7[ebp]
  009d6	89 4d c8	 mov	 DWORD PTR tv272[ebp], ecx
  009d9	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _size$7[ebp]
  009df	52		 push	 edx
  009e0	e8 00 00 00 00	 call	 ___asan_load4
  009e5	83 c4 04	 add	 esp, 4
  009e8	8b 85 d0 fd ff
	ff		 mov	 eax, DWORD PTR _size$7[ebp]
  009ee	c1 e8 02	 shr	 eax, 2
  009f1	03 85 40 ff ff
	ff		 add	 eax, DWORD PTR _xb$22[ebp]
  009f7	39 45 c8	 cmp	 DWORD PTR tv272[ebp], eax
  009fa	0f 87 97 00 00
	00		 ja	 $LN21@collision
  00a00	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00a06	c1 e9 03	 shr	 ecx, 3
  00a09	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00a0f	89 4d cc	 mov	 DWORD PTR tv504[ebp], ecx
  00a12	6a 02		 push	 2
  00a14	8b 55 cc	 mov	 edx, DWORD PTR tv504[ebp]
  00a17	52		 push	 edx
  00a18	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00a1d	83 c4 08	 add	 esp, 8

; 118  :                     res->at(COLDIR::RIGHT) = true;

  00a20	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a26	83 c0 1c	 add	 eax, 28			; 0000001cH
  00a29	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv277[ebp], eax
  00a2f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv277[ebp]
  00a35	51		 push	 ecx
  00a36	e8 00 00 00 00	 call	 ___asan_load4
  00a3b	83 c4 04	 add	 esp, 4
  00a3e	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv277[ebp]
  00a44	8b 02		 mov	 eax, DWORD PTR [edx]
  00a46	89 45 d0	 mov	 DWORD PTR tv283[ebp], eax
  00a49	6a 01		 push	 1
  00a4b	6a 03		 push	 3
  00a4d	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00a53	51		 push	 ecx
  00a54	8b 4d d0	 mov	 ecx, DWORD PTR tv283[ebp]
  00a57	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00a5c	89 45 d4	 mov	 DWORD PTR tv318[ebp], eax
  00a5f	8b 4d d4	 mov	 ecx, DWORD PTR tv318[ebp]
  00a62	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  00a67	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  00a6d	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00a72	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  00a78	c1 ea 03	 shr	 edx, 3
  00a7b	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00a81	89 55 d8	 mov	 DWORD PTR tv510[ebp], edx
  00a84	6a 02		 push	 2
  00a86	8b 45 d8	 mov	 eax, DWORD PTR tv510[ebp]
  00a89	50		 push	 eax
  00a8a	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00a8f	83 c4 08	 add	 esp, 8

; 119  :                 }

  00a92	e9 92 00 00 00	 jmp	 $LN22@collision
$LN21@collision:
  00a97	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00a9d	c1 e9 03	 shr	 ecx, 3
  00aa0	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00aa6	89 4d dc	 mov	 DWORD PTR tv516[ebp], ecx
  00aa9	6a 02		 push	 2
  00aab	8b 55 dc	 mov	 edx, DWORD PTR tv516[ebp]
  00aae	52		 push	 edx
  00aaf	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00ab4	83 c4 08	 add	 esp, 8

; 120  : 
; 121  :                 else {
; 122  :                     res->at(COLDIR::TOP) = true;

  00ab7	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00abd	83 c0 1c	 add	 eax, 28			; 0000001cH
  00ac0	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv287[ebp], eax
  00ac6	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv287[ebp]
  00acc	51		 push	 ecx
  00acd	e8 00 00 00 00	 call	 ___asan_load4
  00ad2	83 c4 04	 add	 esp, 4
  00ad5	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv287[ebp]
  00adb	8b 02		 mov	 eax, DWORD PTR [edx]
  00add	89 45 e0	 mov	 DWORD PTR tv294[ebp], eax
  00ae0	6a 01		 push	 1
  00ae2	6a 00		 push	 0
  00ae4	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00aea	51		 push	 ecx
  00aeb	8b 4d e0	 mov	 ecx, DWORD PTR tv294[ebp]
  00aee	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00af3	89 45 e4	 mov	 DWORD PTR tv320[ebp], eax
  00af6	8b 4d e4	 mov	 ecx, DWORD PTR tv320[ebp]
  00af9	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  00afe	8d 8d a0 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00b04	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00b09	8d 95 a0 fe ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00b0f	c1 ea 03	 shr	 edx, 3
  00b12	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00b18	89 55 e8	 mov	 DWORD PTR tv522[ebp], edx
  00b1b	6a 02		 push	 2
  00b1d	8b 45 e8	 mov	 eax, DWORD PTR tv522[ebp]
  00b20	50		 push	 eax
  00b21	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00b26	83 c4 08	 add	 esp, 8
$LN22@collision:

; 123  : 
; 124  :                 }
; 125  :             }
; 126  :         }

  00b29	e9 cb f7 ff ff	 jmp	 $LN5@collision
$LN6@collision:

; 127  :         // std::printf("Collision BOTTOM : %s, UP : %s ,LEFT : %s , RIGHT %s\n", res->at(COLDIR::BOTTOM) ? "true" : "false", res->at(COLDIR::TOP) ? "true" : "false", res->at(COLDIR::LEFT) ? "true" : "false", res->at(COLDIR::RIGHT) ? "true" : "false");
; 128  :         return res;

  00b2e	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b34	83 c1 1c	 add	 ecx, 28			; 0000001cH
  00b37	89 8d 4c ff ff
	ff		 mov	 DWORD PTR tv298[ebp], ecx
  00b3d	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv298[ebp]
  00b43	52		 push	 edx
  00b44	e8 00 00 00 00	 call	 ___asan_load4
  00b49	83 c4 04	 add	 esp, 4
  00b4c	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv298[ebp]
  00b52	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b54	89 4d f0	 mov	 DWORD PTR tv321[ebp], ecx
  00b57	c7 85 d0 fc ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00b61	8d 95 d0 fc ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00b67	c1 ea 03	 shr	 edx, 3
  00b6a	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00b70	89 55 ec	 mov	 DWORD PTR tv528[ebp], edx
  00b73	6a 40		 push	 64			; 00000040H
  00b75	8b 45 ec	 mov	 eax, DWORD PTR tv528[ebp]
  00b78	50		 push	 eax
  00b79	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00b7e	83 c4 08	 add	 esp, 8
  00b81	8b 45 f0	 mov	 eax, DWORD PTR tv321[ebp]

; 129  : 
; 130  : }

  00b84	5e		 pop	 esi
  00b85	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00b88	33 cd		 xor	 ecx, ebp
  00b8a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00b8f	8b e5		 mov	 esp, ebp
  00b91	5d		 pop	 ebp
  00b92	8b e3		 mov	 esp, ebx
  00b94	5b		 pop	 ebx
  00b95	c2 04 00	 ret	 4
?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z ENDP ; Univers::collision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -656					; size = 4
__asan_gen_1$ = -652					; size = 4
__asan_gen_2$ = -648					; size = 4
_clock$ = -640						; size = 8
_e$3 = -624						; size = 12
$T4 = -576						; size = 4
_event$5 = -560						; size = 20
$T6 = -504						; size = 4
$T7 = -488						; size = 8
$T8 = -472						; size = 4
$T9 = -456						; size = 8
$T10 = -440						; size = 4
$T11 = -424						; size = 8
$T12 = -408						; size = 4
$T13 = -392						; size = 8
$T14 = -376						; size = 4
$T15 = -360						; size = 8
$T16 = -344						; size = 4
$T17 = -328						; size = 8
$T18 = -312						; size = 4
$T19 = -296						; size = 8
$T20 = -280						; size = 4
$T21 = -264						; size = 8
tv460 = -224						; size = 4
_this$ = -220						; size = 4
_currentMusic$ = -216					; size = 4
_<begin>$L0$22 = -212					; size = 4
tv197 = -208						; size = 4
tv245 = -204						; size = 4
tv65 = -200						; size = 4
tv68 = -196						; size = 4
tv463 = -192						; size = 4
tv470 = -188						; size = 4
tv129 = -184						; size = 4
tv480 = -180						; size = 4
tv138 = -176						; size = 4
tv152 = -172						; size = 4
tv157 = -168						; size = 4
tv172 = -164						; size = 4
tv185 = -160						; size = 4
tv292 = -156						; size = 4
_<range>$L0$23 = -152					; size = 4
tv302 = -148						; size = 4
tv309 = -144						; size = 4
tv315 = -140						; size = 4
tv381 = -136						; size = 4
tv384 = -132						; size = 4
tv391 = -128						; size = 4
tv586 = -124						; size = 4
tv458 = -120						; size = 4
tv72 = -116						; size = 4
tv149 = -112						; size = 4
tv151 = -108						; size = 4
tv168 = -104						; size = 4
tv178 = -100						; size = 4
tv181 = -96						; size = 4
tv229 = -92						; size = 4
tv241 = -88						; size = 4
tv277 = -84						; size = 4
tv289 = -80						; size = 4
_<end>$L0$24 = -76					; size = 4
tv443 = -72						; size = 4
_t$25 = -68						; size = 4
_listCollision$26 = -64					; size = 4
tv376 = -60						; size = 4
tv387 = -56						; size = 4
tv593 = -52						; size = 4
_lastTime$ = -48					; size = 4
$T27 = -44						; size = 4
$T28 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -16						; size = 16
?animate@Univers@@QAEXXZ PROC				; Univers::animate
; _this$ = ecx

; 6    : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?animate@Univers@@QAEXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	53		 push	 ebx
  00026	81 c4 80 fd ff
	ff		 add	 esp, -640		; fffffd80H
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00045	89 8d 24 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0004b	c7 85 70 fd ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00055	c7 85 74 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?animate@Univers@@QAEXXZ
  0005f	c7 85 78 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?animate@Univers@@QAEXXZ ; Univers::animate
  00069	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0006f	89 45 88	 mov	 DWORD PTR tv458[ebp], eax
  00072	8b 4d 88	 mov	 ecx, DWORD PTR tv458[ebp]
  00075	c1 e9 03	 shr	 ecx, 3
  00078	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0007e	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv460[ebp], ecx
  00084	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv460[ebp]
  0008a	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00090	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  00097	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv460[ebp]
  0009d	c7 00 f8 04 f2
	f2		 mov	 DWORD PTR [eax], -219020040 ; f2f204f8H
  000a3	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  000aa	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  000b0	c7 01 f2 f2 f8
	f2		 mov	 DWORD PTR [ecx], -218565902 ; f2f8f2f2H
  000b6	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  000bd	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv460[ebp]
  000c3	c7 02 f8 f8 04
	f2		 mov	 DWORD PTR [edx], -234555144 ; f204f8f8H
  000c9	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  000d0	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv460[ebp]
  000d6	c7 00 f2 f2 f2
	f8		 mov	 DWORD PTR [eax], -118295822 ; f8f2f2f2H
  000dc	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  000e3	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  000e9	c7 01 f2 f8 f2
	f8		 mov	 DWORD PTR [ecx], -118294286 ; f8f2f8f2H
  000ef	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  000f6	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv460[ebp]
  000fc	c7 02 f2 f8 f2
	f8		 mov	 DWORD PTR [edx], -118294286 ; f8f2f8f2H
  00102	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  00109	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv460[ebp]
  0010f	c7 00 f2 f8 f2
	f8		 mov	 DWORD PTR [eax], -118294286 ; f8f2f8f2H
  00115	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  0011c	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  00122	c7 01 f2 f8 f2
	f8		 mov	 DWORD PTR [ecx], -118294286 ; f8f2f8f2H
  00128	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  0012f	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv460[ebp]
  00135	c7 02 f2 f8 f2
	f8		 mov	 DWORD PTR [edx], -118294286 ; f8f2f8f2H
  0013b	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  00142	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv460[ebp]
  00148	c7 00 f2 f8 f2
	f8		 mov	 DWORD PTR [eax], -118294286 ; f8f2f8f2H
  0014e	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  00155	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  0015b	c7 01 f2 f8 f2
	f8		 mov	 DWORD PTR [ecx], -118294286 ; f8f2f8f2H
  00161	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  00168	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv460[ebp]
  0016e	c7 02 f2 f8 f3
	f3		 mov	 DWORD PTR [edx], -202114830 ; f3f3f8f2H
  00174	83 85 20 ff ff
	ff 04		 add	 DWORD PTR tv460[ebp], 4
  0017b	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00180	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv460[ebp]
  00186	66 89 01	 mov	 WORD PTR [ecx], ax
  00189	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  0018e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7    :     sf::Clock clock;

  00193	8d 8d 80 fd ff
	ff		 lea	 ecx, DWORD PTR _clock$[ebp]
  00199	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Clock@sf@@QAE@XZ

; 8    :     float lastTime = 0;

  0019f	0f 57 c0	 xorps	 xmm0, xmm0
  001a2	f3 0f 11 45 d0	 movss	 DWORD PTR _lastTime$[ebp], xmm0

; 9    :     //sf::Font font;
; 10   :     //font.loadFromFile("\\Ressources\\DS-DIGI.TTF");
; 11   :     auto currentMusic = RP->getLevelMusic(lvl - 1);

  001a7	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ad	83 c2 0c	 add	 edx, 12			; 0000000cH
  001b0	89 95 38 ff ff
	ff		 mov	 DWORD PTR tv65[ebp], edx
  001b6	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv65[ebp]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 ___asan_load4
  001c2	83 c4 04	 add	 esp, 4
  001c5	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv65[ebp]
  001cb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001cd	89 55 8c	 mov	 DWORD PTR tv72[ebp], edx
  001d0	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001d6	83 c0 18	 add	 eax, 24			; 00000018H
  001d9	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  001df	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv68[ebp]
  001e5	51		 push	 ecx
  001e6	e8 00 00 00 00	 call	 ___asan_load4
  001eb	83 c4 04	 add	 esp, 4
  001ee	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv68[ebp]
  001f4	8b 02		 mov	 eax, DWORD PTR [edx]
  001f6	83 e8 01	 sub	 eax, 1
  001f9	50		 push	 eax
  001fa	8b 4d 8c	 mov	 ecx, DWORD PTR tv72[ebp]
  001fd	e8 00 00 00 00	 call	 ?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z ; RessourcePack::getLevelMusic
  00202	89 85 28 ff ff
	ff		 mov	 DWORD PTR _currentMusic$[ebp], eax

; 12   :     try{

  00208	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 13   :         currentMusic->play();

  0020f	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  00215	8b 11		 mov	 edx, DWORD PTR [ecx]
  00217	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  0021d	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00220	ff d0		 call	 eax

; 14   :         currentMusic->setLoop(true);

  00222	6a 01		 push	 1
  00224	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  0022a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setLoop@SoundStream@sf@@QAEX_N@Z
  00230	e9 8f 00 00 00	 jmp	 $LN30@animate
__catch$?animate@Univers@@QAEXXZ$0:
  00235	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]

; 15   :     }catch(std::exception e){

  00238	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _e$3[ebp]
  0023e	c1 e9 03	 shr	 ecx, 3
  00241	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00247	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv463[ebp], ecx
  0024d	6a 01		 push	 1
  0024f	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv463[ebp]
  00255	52		 push	 edx
  00256	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025b	83 c4 08	 add	 esp, 8
  0025e	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv463[ebp]
  00264	c6 40 01 04	 mov	 BYTE PTR [eax+1], 4
  00268	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 16   :         currentMusic->stop();

  0026c	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  00272	8b 11		 mov	 edx, DWORD PTR [ecx]
  00274	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  0027a	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0027d	ff d0		 call	 eax

; 17   :     }

  0027f	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  00283	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _e$3[ebp]
  00289	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0028e	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _e$3[ebp]
  00294	c1 e9 03	 shr	 ecx, 3
  00297	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0029d	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv470[ebp], ecx
  002a3	6a 01		 push	 1
  002a5	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv470[ebp]
  002ab	52		 push	 edx
  002ac	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  002b1	83 c4 08	 add	 esp, 8
  002b4	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv470[ebp]
  002ba	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
  002be	b8 00 00 00 00	 mov	 eax, $LN39@animate
  002c3	c3		 ret	 0
$LN30@animate:
  002c4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002cb	eb 0a		 jmp	 SHORT $LN34@animate
$LN39@animate:
  002cd	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]
  002d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN34@animate:

; 18   :     while (RW->isOpen()) {

  002d7	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002dd	83 c1 10	 add	 ecx, 16			; 00000010H
  002e0	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv129[ebp], ecx
  002e6	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv129[ebp]
  002ec	52		 push	 edx
  002ed	e8 00 00 00 00	 call	 ___asan_load4
  002f2	83 c4 04	 add	 esp, 4
  002f5	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv129[ebp]
  002fb	8b 08		 mov	 ecx, DWORD PTR [eax]
  002fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?isOpen@Window@sf@@QBE_NXZ
  00303	0f b6 c8	 movzx	 ecx, al
  00306	85 c9		 test	 ecx, ecx
  00308	0f 84 fa 08 00
	00		 je	 $LN3@animate
  0030e	8d 95 c0 fd ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00314	c1 ea 03	 shr	 edx, 3
  00317	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  0031e	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _event$5[ebp]
  00324	c1 e8 03	 shr	 eax, 3
  00327	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0032c	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv480[ebp], eax
  00332	6a 02		 push	 2
  00334	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv480[ebp]
  0033a	51		 push	 ecx
  0033b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00340	83 c4 08	 add	 esp, 8
  00343	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv480[ebp]
  00349	c6 42 02 04	 mov	 BYTE PTR [edx+2], 4

; 19   :         RW->clear();

  0034d	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00353	83 c0 10	 add	 eax, 16			; 00000010H
  00356	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv138[ebp], eax
  0035c	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv138[ebp]
  00362	51		 push	 ecx
  00363	e8 00 00 00 00	 call	 ___asan_load4
  00368	83 c4 04	 add	 esp, 4
  0036b	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv138[ebp]
  00371	8b 02		 mov	 eax, DWORD PTR [edx]
  00373	83 c0 30	 add	 eax, 48			; 00000030H
  00376	89 45 94	 mov	 DWORD PTR tv151[ebp], eax
  00379	68 ff 00 00 00	 push	 255			; 000000ffH
  0037e	6a 00		 push	 0
  00380	6a 00		 push	 0
  00382	6a 00		 push	 0
  00384	8d 8d c0 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0038a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Color@sf@@QAE@EEEE@Z
  00390	89 45 90	 mov	 DWORD PTR tv149[ebp], eax
  00393	8b 4d 90	 mov	 ecx, DWORD PTR tv149[ebp]
  00396	51		 push	 ecx
  00397	8b 4d 94	 mov	 ecx, DWORD PTR tv151[ebp]
  0039a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@RenderTarget@sf@@QAEXABVColor@2@@Z
  003a0	8d 95 c0 fd ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  003a6	c1 ea 03	 shr	 edx, 3
  003a9	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 20   :         if (background != nullptr) {

  003b0	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003b6	83 c0 20	 add	 eax, 32			; 00000020H
  003b9	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv152[ebp], eax
  003bf	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR tv152[ebp]
  003c5	51		 push	 ecx
  003c6	e8 00 00 00 00	 call	 ___asan_load4
  003cb	83 c4 04	 add	 esp, 4
  003ce	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv152[ebp]
  003d4	83 3a 00	 cmp	 DWORD PTR [edx], 0
  003d7	74 46		 je	 SHORT $LN16@animate

; 21   :             RW->draw(*background);

  003d9	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003df	83 c0 10	 add	 eax, 16			; 00000010H
  003e2	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], eax
  003e8	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv157[ebp]
  003ee	51		 push	 ecx
  003ef	e8 00 00 00 00	 call	 ___asan_load4
  003f4	83 c4 04	 add	 esp, 4
  003f7	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  003fd	8b 02		 mov	 eax, DWORD PTR [edx]
  003ff	83 c0 30	 add	 eax, 48			; 00000030H
  00402	89 45 98	 mov	 DWORD PTR tv168[ebp], eax
  00405	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?Default@RenderStates@sf@@2V12@B
  0040b	51		 push	 ecx
  0040c	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00412	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00415	50		 push	 eax
  00416	8b 4d 98	 mov	 ecx, DWORD PTR tv168[ebp]
  00419	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?draw@RenderTarget@sf@@QAEXABVDrawable@2@ABVRenderStates@2@@Z
$LN16@animate:

; 22   :         }
; 23   :         sf::Event event;
; 24   :         while (RW->pollEvent(event))

  0041f	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00425	83 c1 10	 add	 ecx, 16			; 00000010H
  00428	89 8d 5c ff ff
	ff		 mov	 DWORD PTR tv172[ebp], ecx
  0042e	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv172[ebp]
  00434	52		 push	 edx
  00435	e8 00 00 00 00	 call	 ___asan_load4
  0043a	83 c4 04	 add	 esp, 4
  0043d	8b 85 5c ff ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  00443	8b 08		 mov	 ecx, DWORD PTR [eax]
  00445	89 4d 9c	 mov	 DWORD PTR tv178[ebp], ecx
  00448	8d 95 d0 fd ff
	ff		 lea	 edx, DWORD PTR _event$5[ebp]
  0044e	52		 push	 edx
  0044f	8b 4d 9c	 mov	 ecx, DWORD PTR tv178[ebp]
  00452	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?pollEvent@Window@sf@@QAE_NAAVEvent@2@@Z
  00458	0f b6 c0	 movzx	 eax, al
  0045b	85 c0		 test	 eax, eax
  0045d	0f 84 b7 05 00
	00		 je	 $LN5@animate

; 25   :         {
; 26   :             switch (event.type) {

  00463	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _event$5[ebp]
  00469	51		 push	 ecx
  0046a	e8 00 00 00 00	 call	 ___asan_load4
  0046f	83 c4 04	 add	 esp, 4
  00472	8b 95 d0 fd ff
	ff		 mov	 edx, DWORD PTR _event$5[ebp]
  00478	89 55 a0	 mov	 DWORD PTR tv181[ebp], edx
  0047b	83 7d a0 00	 cmp	 DWORD PTR tv181[ebp], 0
  0047f	74 02		 je	 SHORT $LN17@animate
  00481	eb 3f		 jmp	 SHORT $LN6@animate
$LN17@animate:

; 27   :             case sf::Event::Closed: [[unlikely]];
; 28   :                 RW->close();

  00483	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00489	83 c0 10	 add	 eax, 16			; 00000010H
  0048c	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv185[ebp], eax
  00492	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv185[ebp]
  00498	51		 push	 ecx
  00499	e8 00 00 00 00	 call	 ___asan_load4
  0049e	83 c4 04	 add	 esp, 4
  004a1	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv185[ebp]
  004a7	8b 0a		 mov	 ecx, DWORD PTR [edx]
  004a9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?close@Window@sf@@QAEXXZ

; 29   :                 currentMusic->stop();

  004af	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR _currentMusic$[ebp]
  004b5	8b 10		 mov	 edx, DWORD PTR [eax]
  004b7	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  004bd	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  004c0	ff d0		 call	 eax
$LN6@animate:

; 30   :                 break;
; 31   :             }
; 32   :             if (event.type == sf::Event::KeyPressed) {

  004c2	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _event$5[ebp]
  004c8	51		 push	 ecx
  004c9	e8 00 00 00 00	 call	 ___asan_load4
  004ce	83 c4 04	 add	 esp, 4
  004d1	83 bd d0 fd ff
	ff 05		 cmp	 DWORD PTR _event$5[ebp], 5
  004d8	0f 85 90 02 00
	00		 jne	 $LN18@animate

; 33   :                 switch (event.key.code) {

  004de	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _event$5[ebp+4]
  004e4	52		 push	 edx
  004e5	e8 00 00 00 00	 call	 ___asan_load4
  004ea	83 c4 04	 add	 esp, 4
  004ed	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _event$5[ebp+4]
  004f3	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], eax
  004f9	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv197[ebp]
  004ff	83 e9 47	 sub	 ecx, 71			; 00000047H
  00502	89 8d 30 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], ecx
  00508	83 bd 30 ff ff
	ff 03		 cmp	 DWORD PTR tv197[ebp], 3
  0050f	0f 87 54 02 00
	00		 ja	 $LN8@animate
  00515	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv197[ebp]
  0051b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN36@animate[edx*4]
$LN20@animate:
  00522	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00528	c1 e8 03	 shr	 eax, 3
  0052b	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  00532	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00538	c1 e9 03	 shr	 ecx, 3
  0053b	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0

; 34   :                 case sf::Keyboard::Left:
; 35   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::LEFT);

  00542	8d 95 08 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00548	52		 push	 edx
  00549	e8 00 00 00 00	 call	 ___asan_store4
  0054e	83 c4 04	 add	 esp, 4
  00551	c7 85 08 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  0055b	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00561	50		 push	 eax
  00562	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00568	51		 push	 ecx
  00569	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  0056e	83 c4 04	 add	 esp, 4
  00571	50		 push	 eax
  00572	8d 95 18 fe ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  00578	52		 push	 edx
  00579	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  0057e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00581	50		 push	 eax
  00582	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00588	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  0058d	8d 85 08 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00593	c1 e8 03	 shr	 eax, 3
  00596	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0059d	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  005a3	c1 e9 03	 shr	 ecx, 3
  005a6	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 36   :                     break;

  005ad	e9 b7 01 00 00	 jmp	 $LN8@animate
$LN21@animate:
  005b2	8d 95 28 fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  005b8	c1 ea 03	 shr	 edx, 3
  005bb	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  005c2	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  005c8	c1 e8 03	 shr	 eax, 3
  005cb	c6 80 00 00 00
	30 00		 mov	 BYTE PTR [eax+805306368], 0

; 37   :                 case sf::Keyboard::Right:
; 38   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::RIGHT);

  005d2	8d 8d 28 fe ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  005d8	51		 push	 ecx
  005d9	e8 00 00 00 00	 call	 ___asan_store4
  005de	83 c4 04	 add	 esp, 4
  005e1	c7 85 28 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR $T8[ebp], 1
  005eb	8d 95 28 fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  005f1	52		 push	 edx
  005f2	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  005f8	50		 push	 eax
  005f9	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  005fe	83 c4 04	 add	 esp, 4
  00601	50		 push	 eax
  00602	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00608	51		 push	 ecx
  00609	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  0060e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00611	50		 push	 eax
  00612	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00618	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  0061d	8d 95 28 fe ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00623	c1 ea 03	 shr	 edx, 3
  00626	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0062d	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00633	c1 e8 03	 shr	 eax, 3
  00636	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 39   :                     break;

  0063d	e9 27 01 00 00	 jmp	 $LN8@animate
$LN22@animate:
  00642	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  00648	c1 e9 03	 shr	 ecx, 3
  0064b	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4
  00652	8d 95 58 fe ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  00658	c1 ea 03	 shr	 edx, 3
  0065b	c6 82 00 00 00
	30 00		 mov	 BYTE PTR [edx+805306368], 0

; 40   :                 case sf::Keyboard::Up:
; 41   :                     dir = std::make_tuple(DIRDEP::UP, std::get<1>(dir));

  00662	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00668	50		 push	 eax
  00669	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  0066e	83 c4 04	 add	 esp, 4
  00671	89 45 a4	 mov	 DWORD PTR tv229[ebp], eax
  00674	8d 8d 48 fe ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  0067a	51		 push	 ecx
  0067b	e8 00 00 00 00	 call	 ___asan_store4
  00680	83 c4 04	 add	 esp, 4
  00683	c7 85 48 fe ff
	ff 02 00 00 00	 mov	 DWORD PTR $T10[ebp], 2
  0068d	8b 55 a4	 mov	 edx, DWORD PTR tv229[ebp]
  00690	52		 push	 edx
  00691	8d 85 48 fe ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00697	50		 push	 eax
  00698	8d 8d 58 fe ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  0069e	51		 push	 ecx
  0069f	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  006a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  006a7	50		 push	 eax
  006a8	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006ae	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  006b3	8d 95 48 fe ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  006b9	c1 ea 03	 shr	 edx, 3
  006bc	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  006c3	8d 85 58 fe ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  006c9	c1 e8 03	 shr	 eax, 3
  006cc	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 42   :                     break;

  006d3	e9 91 00 00 00	 jmp	 $LN8@animate
$LN23@animate:
  006d8	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  006de	c1 e9 03	 shr	 ecx, 3
  006e1	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4
  006e8	8d 95 78 fe ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  006ee	c1 ea 03	 shr	 edx, 3
  006f1	c6 82 00 00 00
	30 00		 mov	 BYTE PTR [edx+805306368], 0

; 43   :                 case sf::Keyboard::Down:
; 44   :                     dir = std::make_tuple(DIRDEP::DOWN, std::get<1>(dir));

  006f8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  006fe	50		 push	 eax
  006ff	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  00704	83 c4 04	 add	 esp, 4
  00707	89 45 a8	 mov	 DWORD PTR tv241[ebp], eax
  0070a	8d 8d 68 fe ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00710	51		 push	 ecx
  00711	e8 00 00 00 00	 call	 ___asan_store4
  00716	83 c4 04	 add	 esp, 4
  00719	c7 85 68 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR $T12[ebp], 3
  00723	8b 55 a8	 mov	 edx, DWORD PTR tv241[ebp]
  00726	52		 push	 edx
  00727	8d 85 68 fe ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  0072d	50		 push	 eax
  0072e	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00734	51		 push	 ecx
  00735	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  0073a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0073d	50		 push	 eax
  0073e	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00744	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  00749	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  0074f	c1 ea 03	 shr	 edx, 3
  00752	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  00759	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  0075f	c1 e8 03	 shr	 eax, 3
  00762	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
$LN8@animate:

; 45   :                     break;
; 46   :                 }
; 47   :             }

  00769	e9 a7 02 00 00	 jmp	 $LN10@animate
$LN18@animate:

; 48   :             else if (event.type == sf::Event::KeyReleased) {

  0076e	8d 8d d0 fd ff
	ff		 lea	 ecx, DWORD PTR _event$5[ebp]
  00774	51		 push	 ecx
  00775	e8 00 00 00 00	 call	 ___asan_load4
  0077a	83 c4 04	 add	 esp, 4
  0077d	83 bd d0 fd ff
	ff 06		 cmp	 DWORD PTR _event$5[ebp], 6
  00784	0f 85 8b 02 00
	00		 jne	 $LN10@animate

; 49   :                 switch (event.key.code) {

  0078a	8d 95 d4 fd ff
	ff		 lea	 edx, DWORD PTR _event$5[ebp+4]
  00790	52		 push	 edx
  00791	e8 00 00 00 00	 call	 ___asan_load4
  00796	83 c4 04	 add	 esp, 4
  00799	8b 85 d4 fd ff
	ff		 mov	 eax, DWORD PTR _event$5[ebp+4]
  0079f	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
  007a5	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv245[ebp]
  007ab	83 e9 47	 sub	 ecx, 71			; 00000047H
  007ae	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], ecx
  007b4	83 bd 34 ff ff
	ff 03		 cmp	 DWORD PTR tv245[ebp], 3
  007bb	0f 87 54 02 00
	00		 ja	 $LN10@animate
  007c1	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv245[ebp]
  007c7	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN37@animate[edx*4]
$LN25@animate:
  007ce	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  007d4	c1 e8 03	 shr	 eax, 3
  007d7	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  007de	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  007e4	c1 e9 03	 shr	 ecx, 3
  007e7	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0

; 50   :                 case sf::Keyboard::Left:
; 51   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::NONE);

  007ee	8d 95 88 fe ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  007f4	52		 push	 edx
  007f5	e8 00 00 00 00	 call	 ___asan_store4
  007fa	83 c4 04	 add	 esp, 4
  007fd	c7 85 88 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T14[ebp], 4
  00807	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0080d	50		 push	 eax
  0080e	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00814	51		 push	 ecx
  00815	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  0081a	83 c4 04	 add	 esp, 4
  0081d	50		 push	 eax
  0081e	8d 95 98 fe ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00824	52		 push	 edx
  00825	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  0082a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0082d	50		 push	 eax
  0082e	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00834	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  00839	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  0083f	c1 e8 03	 shr	 eax, 3
  00842	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  00849	8d 8d 98 fe ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  0084f	c1 e9 03	 shr	 ecx, 3
  00852	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 52   :                     break;

  00859	e9 b7 01 00 00	 jmp	 $LN10@animate
$LN26@animate:
  0085e	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  00864	c1 ea 03	 shr	 edx, 3
  00867	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  0086e	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  00874	c1 e8 03	 shr	 eax, 3
  00877	c6 80 00 00 00
	30 00		 mov	 BYTE PTR [eax+805306368], 0

; 53   :                 case sf::Keyboard::Right:
; 54   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::NONE);

  0087e	8d 8d a8 fe ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  00884	51		 push	 ecx
  00885	e8 00 00 00 00	 call	 ___asan_store4
  0088a	83 c4 04	 add	 esp, 4
  0088d	c7 85 a8 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp], 4
  00897	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  0089d	52		 push	 edx
  0089e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  008a4	50		 push	 eax
  008a5	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  008aa	83 c4 04	 add	 esp, 4
  008ad	50		 push	 eax
  008ae	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  008b4	51		 push	 ecx
  008b5	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  008ba	83 c4 0c	 add	 esp, 12			; 0000000cH
  008bd	50		 push	 eax
  008be	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  008c4	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  008c9	8d 95 a8 fe ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  008cf	c1 ea 03	 shr	 edx, 3
  008d2	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  008d9	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  008df	c1 e8 03	 shr	 eax, 3
  008e2	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 55   :                     break;

  008e9	e9 27 01 00 00	 jmp	 $LN10@animate
$LN27@animate:
  008ee	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  008f4	c1 e9 03	 shr	 ecx, 3
  008f7	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4
  008fe	8d 95 d8 fe ff
	ff		 lea	 edx, DWORD PTR $T19[ebp]
  00904	c1 ea 03	 shr	 edx, 3
  00907	c6 82 00 00 00
	30 00		 mov	 BYTE PTR [edx+805306368], 0

; 56   :                 case sf::Keyboard::Up:
; 57   :                     dir = std::make_tuple(DIRDEP::NONE, std::get<1>(dir));

  0090e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00914	50		 push	 eax
  00915	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  0091a	83 c4 04	 add	 esp, 4
  0091d	89 45 ac	 mov	 DWORD PTR tv277[ebp], eax
  00920	8d 8d c8 fe ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  00926	51		 push	 ecx
  00927	e8 00 00 00 00	 call	 ___asan_store4
  0092c	83 c4 04	 add	 esp, 4
  0092f	c7 85 c8 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T18[ebp], 4
  00939	8b 55 ac	 mov	 edx, DWORD PTR tv277[ebp]
  0093c	52		 push	 edx
  0093d	8d 85 c8 fe ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00943	50		 push	 eax
  00944	8d 8d d8 fe ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  0094a	51		 push	 ecx
  0094b	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  00950	83 c4 0c	 add	 esp, 12			; 0000000cH
  00953	50		 push	 eax
  00954	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0095a	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  0095f	8d 95 c8 fe ff
	ff		 lea	 edx, DWORD PTR $T18[ebp]
  00965	c1 ea 03	 shr	 edx, 3
  00968	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0096f	8d 85 d8 fe ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  00975	c1 e8 03	 shr	 eax, 3
  00978	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 58   :                     break;

  0097f	e9 91 00 00 00	 jmp	 $LN10@animate
$LN28@animate:
  00984	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  0098a	c1 e9 03	 shr	 ecx, 3
  0098d	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4
  00994	8d 95 f8 fe ff
	ff		 lea	 edx, DWORD PTR $T21[ebp]
  0099a	c1 ea 03	 shr	 edx, 3
  0099d	c6 82 00 00 00
	30 00		 mov	 BYTE PTR [edx+805306368], 0

; 59   :                 case sf::Keyboard::Down:
; 60   :                     dir = std::make_tuple(DIRDEP::NONE, std::get<1>(dir));

  009a4	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009aa	50		 push	 eax
  009ab	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  009b0	83 c4 04	 add	 esp, 4
  009b3	89 45 b0	 mov	 DWORD PTR tv289[ebp], eax
  009b6	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  009bc	51		 push	 ecx
  009bd	e8 00 00 00 00	 call	 ___asan_store4
  009c2	83 c4 04	 add	 esp, 4
  009c5	c7 85 e8 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T20[ebp], 4
  009cf	8b 55 b0	 mov	 edx, DWORD PTR tv289[ebp]
  009d2	52		 push	 edx
  009d3	8d 85 e8 fe ff
	ff		 lea	 eax, DWORD PTR $T20[ebp]
  009d9	50		 push	 eax
  009da	8d 8d f8 fe ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  009e0	51		 push	 ecx
  009e1	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  009e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  009e9	50		 push	 eax
  009ea	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009f0	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
  009f5	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T20[ebp]
  009fb	c1 ea 03	 shr	 edx, 3
  009fe	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  00a05	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR $T21[ebp]
  00a0b	c1 e8 03	 shr	 eax, 3
  00a0e	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
$LN10@animate:

; 61   :                     break;
; 62   : 
; 63   :                 }
; 64   :             }
; 65   :         }

  00a15	e9 05 fa ff ff	 jmp	 $LN16@animate
$LN5@animate:

; 66   :         for (auto t : *ter->getTerrain()) {

  00a1a	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00a20	83 c1 08	 add	 ecx, 8
  00a23	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv292[ebp], ecx
  00a29	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv292[ebp]
  00a2f	52		 push	 edx
  00a30	e8 00 00 00 00	 call	 ___asan_load4
  00a35	83 c4 04	 add	 esp, 4
  00a38	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv292[ebp]
  00a3e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a40	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  00a45	89 85 68 ff ff
	ff		 mov	 DWORD PTR _<range>$L0$23[ebp], eax
  00a4b	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _<range>$L0$23[ebp]
  00a51	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
  00a56	89 85 2c ff ff
	ff		 mov	 DWORD PTR _<begin>$L0$22[ebp], eax
  00a5c	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR _<range>$L0$23[ebp]
  00a62	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
  00a67	89 45 b4	 mov	 DWORD PTR _<end>$L0$24[ebp], eax
  00a6a	eb 0f		 jmp	 SHORT $LN14@animate
$LN12@animate:
  00a6c	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR _<begin>$L0$22[ebp]
  00a72	83 c1 04	 add	 ecx, 4
  00a75	89 8d 2c ff ff
	ff		 mov	 DWORD PTR _<begin>$L0$22[ebp], ecx
$LN14@animate:
  00a7b	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _<begin>$L0$22[ebp]
  00a81	3b 55 b4	 cmp	 edx, DWORD PTR _<end>$L0$24[ebp]
  00a84	74 51		 je	 SHORT $LN13@animate
  00a86	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR _<begin>$L0$22[ebp]
  00a8c	89 45 b8	 mov	 DWORD PTR tv443[ebp], eax
  00a8f	8b 4d b8	 mov	 ecx, DWORD PTR tv443[ebp]
  00a92	51		 push	 ecx
  00a93	e8 00 00 00 00	 call	 ___asan_load4
  00a98	83 c4 04	 add	 esp, 4
  00a9b	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR _<begin>$L0$22[ebp]
  00aa1	8b 02		 mov	 eax, DWORD PTR [edx]
  00aa3	89 45 bc	 mov	 DWORD PTR _t$25[ebp], eax

; 67   :             t->show(RW);

  00aa6	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00aac	83 c1 10	 add	 ecx, 16			; 00000010H
  00aaf	89 8d 6c ff ff
	ff		 mov	 DWORD PTR tv302[ebp], ecx
  00ab5	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv302[ebp]
  00abb	52		 push	 edx
  00abc	e8 00 00 00 00	 call	 ___asan_load4
  00ac1	83 c4 04	 add	 esp, 4
  00ac4	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv302[ebp]
  00aca	8b 08		 mov	 ecx, DWORD PTR [eax]
  00acc	51		 push	 ecx
  00acd	8b 4d bc	 mov	 ecx, DWORD PTR _t$25[ebp]
  00ad0	e8 00 00 00 00	 call	 ?show@Block@@QAEXPAVRenderWindow@sf@@@Z ; Block::show

; 68   :         }

  00ad5	eb 95		 jmp	 SHORT $LN12@animate
$LN13@animate:

; 69   :             
; 70   :         std::vector<bool>* listCollision = collision(p);

  00ad7	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00add	83 c2 14	 add	 edx, 20			; 00000014H
  00ae0	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv309[ebp], edx
  00ae6	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv309[ebp]
  00aec	50		 push	 eax
  00aed	e8 00 00 00 00	 call	 ___asan_load4
  00af2	83 c4 04	 add	 esp, 4
  00af5	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv309[ebp]
  00afb	8b 11		 mov	 edx, DWORD PTR [ecx]
  00afd	52		 push	 edx
  00afe	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b04	e8 00 00 00 00	 call	 ?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVCharacter@@@Z ; Univers::collision
  00b09	89 45 c0	 mov	 DWORD PTR _listCollision$26[ebp], eax

; 71   :         p->move(dir,*listCollision);

  00b0c	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b12	83 c0 14	 add	 eax, 20			; 00000014H
  00b15	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv315[ebp], eax
  00b1b	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv315[ebp]
  00b21	51		 push	 ecx
  00b22	e8 00 00 00 00	 call	 ___asan_load4
  00b27	83 c4 04	 add	 esp, 4
  00b2a	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv315[ebp]
  00b30	8b 02		 mov	 eax, DWORD PTR [edx]
  00b32	89 45 c4	 mov	 DWORD PTR tv376[ebp], eax
  00b35	83 ec 18	 sub	 esp, 24			; 00000018H
  00b38	8b cc		 mov	 ecx, esp
  00b3a	89 65 d4	 mov	 DWORD PTR $T27[ebp], esp
  00b3d	8b 55 c0	 mov	 edx, DWORD PTR _listCollision$26[ebp]
  00b40	52		 push	 edx
  00b41	e8 00 00 00 00	 call	 ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
  00b46	83 ec 08	 sub	 esp, 8
  00b49	8b cc		 mov	 ecx, esp
  00b4b	89 65 d8	 mov	 DWORD PTR $T28[ebp], esp
  00b4e	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b54	50		 push	 eax
  00b55	e8 00 00 00 00	 call	 ??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>
  00b5a	8b 4d c4	 mov	 ecx, DWORD PTR tv376[ebp]
  00b5d	e8 00 00 00 00	 call	 ?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z ; Character::move

; 72   :         p->show(RW);

  00b62	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b68	83 c1 14	 add	 ecx, 20			; 00000014H
  00b6b	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv381[ebp], ecx
  00b71	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv381[ebp]
  00b77	52		 push	 edx
  00b78	e8 00 00 00 00	 call	 ___asan_load4
  00b7d	83 c4 04	 add	 esp, 4
  00b80	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv381[ebp]
  00b86	8b 08		 mov	 ecx, DWORD PTR [eax]
  00b88	89 4d c8	 mov	 DWORD PTR tv387[ebp], ecx
  00b8b	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00b91	83 c2 10	 add	 edx, 16			; 00000010H
  00b94	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv384[ebp], edx
  00b9a	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv384[ebp]
  00ba0	50		 push	 eax
  00ba1	e8 00 00 00 00	 call	 ___asan_load4
  00ba6	83 c4 04	 add	 esp, 4
  00ba9	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv384[ebp]
  00baf	8b 11		 mov	 edx, DWORD PTR [ecx]
  00bb1	52		 push	 edx
  00bb2	8b 4d c8	 mov	 ecx, DWORD PTR tv387[ebp]
  00bb5	e8 00 00 00 00	 call	 ?show@Character@@QAEXPAVRenderWindow@sf@@@Z ; Character::show

; 73   :         RW->display();

  00bba	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bc0	83 c0 10	 add	 eax, 16			; 00000010H
  00bc3	89 45 80	 mov	 DWORD PTR tv391[ebp], eax
  00bc6	8b 4d 80	 mov	 ecx, DWORD PTR tv391[ebp]
  00bc9	51		 push	 ecx
  00bca	e8 00 00 00 00	 call	 ___asan_load4
  00bcf	83 c4 04	 add	 esp, 4
  00bd2	8b 55 80	 mov	 edx, DWORD PTR tv391[ebp]
  00bd5	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00bd7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?display@Window@sf@@QAEXXZ

; 74   :     }

  00bdd	8d 85 d0 fd ff
	ff		 lea	 eax, DWORD PTR _event$5[ebp]
  00be3	c1 e8 03	 shr	 eax, 3
  00be6	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00beb	89 45 84	 mov	 DWORD PTR tv586[ebp], eax
  00bee	6a 02		 push	 2
  00bf0	8b 4d 84	 mov	 ecx, DWORD PTR tv586[ebp]
  00bf3	51		 push	 ecx
  00bf4	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00bf9	83 c4 08	 add	 esp, 8
  00bfc	8b 55 84	 mov	 edx, DWORD PTR tv586[ebp]
  00bff	c6 42 02 f8	 mov	 BYTE PTR [edx+2], 248	; 000000f8H
  00c03	e9 cf f6 ff ff	 jmp	 $LN34@animate
$LN3@animate:

; 75   : }

  00c08	c7 85 70 fd ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00c12	8d 85 70 fd ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00c18	c1 e8 03	 shr	 eax, 3
  00c1b	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00c20	89 45 cc	 mov	 DWORD PTR tv593[ebp], eax
  00c23	6a 36		 push	 54			; 00000036H
  00c25	8b 4d cc	 mov	 ecx, DWORD PTR tv593[ebp]
  00c28	51		 push	 ecx
  00c29	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00c2e	83 c4 08	 add	 esp, 8
  00c31	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00c34	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00c3b	59		 pop	 ecx
  00c3c	5f		 pop	 edi
  00c3d	5e		 pop	 esi
  00c3e	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00c41	33 cd		 xor	 ecx, ebp
  00c43	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00c48	8b e5		 mov	 esp, ebp
  00c4a	5d		 pop	 ebp
  00c4b	8b e3		 mov	 esp, ebx
  00c4d	5b		 pop	 ebx
  00c4e	c3		 ret	 0
  00c4f	90		 npad	 1
$LN36@animate:
  00c50	00 00 00 00	 DD	 $LN20@animate
  00c54	00 00 00 00	 DD	 $LN21@animate
  00c58	00 00 00 00	 DD	 $LN22@animate
  00c5c	00 00 00 00	 DD	 $LN23@animate
$LN37@animate:
  00c60	00 00 00 00	 DD	 $LN25@animate
  00c64	00 00 00 00	 DD	 $LN26@animate
  00c68	00 00 00 00	 DD	 $LN27@animate
  00c6c	00 00 00 00	 DD	 $LN28@animate
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?animate@Univers@@QAEXXZ$2:
  00000	8d 8d 90 fd ff
	ff		 lea	 ecx, DWORD PTR _e$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?animate@Univers@@QAEXXZ:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 6c fd ff
	ff		 mov	 ecx, DWORD PTR [edx-660]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?animate@Univers@@QAEXXZ
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?animate@Univers@@QAEXXZ ENDP				; Univers::animate
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.h
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -320					; size = 4
__asan_gen_1$ = -316					; size = 4
__asan_gen_2$ = -312					; size = 4
$T3 = -304						; size = 4
$T4 = -288						; size = 4
$T5 = -272						; size = 1
_e$6 = -256						; size = 12
tv366 = -203						; size = 1
tv356 = -202						; size = 1
tv346 = -201						; size = 1
tv336 = -200						; size = 1
tv326 = -199						; size = 1
tv316 = -198						; size = 1
tv306 = -197						; size = 1
tv296 = -196						; size = 1
tv286 = -195						; size = 1
tv276 = -194						; size = 1
tv266 = -193						; size = 1
_this$ = -192						; size = 4
tv237 = -188						; size = 4
tv363 = -184						; size = 4
tv353 = -180						; size = 4
tv343 = -176						; size = 4
$T7 = -172						; size = 4
tv333 = -168						; size = 4
tv323 = -164						; size = 4
tv313 = -160						; size = 4
tv303 = -156						; size = 4
tv293 = -152						; size = 4
tv283 = -148						; size = 4
tv273 = -144						; size = 4
tv263 = -140						; size = 4
tv64 = -136						; size = 4
tv89 = -132						; size = 4
tv69 = -128						; size = 4
tv77 = -124						; size = 4
tv90 = -120						; size = 4
tv91 = -116						; size = 4
tv92 = -112						; size = 4
tv93 = -108						; size = 4
tv143 = -104						; size = 4
tv161 = -100						; size = 4
tv252 = -96						; size = 4
tv235 = -92						; size = 4
tv88 = -88						; size = 4
$T8 = -84						; size = 4
tv141 = -80						; size = 4
tv159 = -76						; size = 4
tv177 = -72						; size = 4
tv192 = -68						; size = 4
tv190 = -64						; size = 4
tv197 = -60						; size = 4
tv259 = -56						; size = 4
tv212 = -52						; size = 4
$T9 = -48						; size = 4
$T10 = -44						; size = 4
$T11 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -16						; size = 16
_rp$ = 8						; size = 4
_rw$ = 12						; size = 4
??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z PROC ; Univers::Univers
; _this$ = ecx

; 158  : {   

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	51		 push	 ecx
  00025	53		 push	 ebx
  00026	81 c4 c0 fe ff
	ff		 add	 esp, -320		; fffffec0H
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	56		 push	 esi
  00037	57		 push	 edi
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00045	89 8d 40 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  0004b	c7 85 c0 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00055	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
  0005f	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z ; Univers::Univers
  00069	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0006f	89 45 a4	 mov	 DWORD PTR tv235[ebp], eax
  00072	8b 4d a4	 mov	 ecx, DWORD PTR tv235[ebp]
  00075	c1 e9 03	 shr	 ecx, 3
  00078	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0007e	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv237[ebp], ecx
  00084	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv237[ebp]
  0008a	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00090	83 85 44 ff ff
	ff 04		 add	 DWORD PTR tv237[ebp], 4
  00097	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv237[ebp]
  0009d	c7 00 04 f2 f8
	f2		 mov	 DWORD PTR [eax], -218566140 ; f2f8f204H
  000a3	83 85 44 ff ff
	ff 04		 add	 DWORD PTR tv237[ebp], 4
  000aa	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv237[ebp]
  000b0	c7 01 f8 04 f3
	f3		 mov	 DWORD PTR [ecx], -202177288 ; f3f304f8H
  000b6	83 85 44 ff ff
	ff 04		 add	 DWORD PTR tv237[ebp], 4
  000bd	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  000c2	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv237[ebp]
  000c8	66 89 10	 mov	 WORD PTR [eax], dx
  000cb	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  000d0	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.h

; 7    : 	std::tuple<DIRDEP, DIRDEP> dir = std::make_tuple(DIRDEP::NONE, DIRDEP::NONE); // O pour UP ou DOWN et 1 pour LEFT ou RIGHT

  000d5	8d 8d d0 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000db	89 8d 48 ff ff
	ff		 mov	 DWORD PTR tv363[ebp], ecx
  000e1	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv363[ebp]
  000e7	c1 ea 03	 shr	 edx, 3
  000ea	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f0	88 85 35 ff ff
	ff		 mov	 BYTE PTR tv366[ebp], al
  000f6	80 bd 35 ff ff
	ff 00		 cmp	 BYTE PTR tv366[ebp], 0
  000fd	74 23		 je	 SHORT $LN27@Univers
  000ff	8a 8d 48 ff ff
	ff		 mov	 cl, BYTE PTR tv363[ebp]
  00105	80 e1 07	 and	 cl, 7
  00108	80 c1 03	 add	 cl, 3
  0010b	3a 8d 35 ff ff
	ff		 cmp	 cl, BYTE PTR tv366[ebp]
  00111	7c 0f		 jl	 SHORT $LN27@Univers
  00113	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv363[ebp]
  00119	52		 push	 edx
  0011a	e8 00 00 00 00	 call	 ___asan_report_store4
  0011f	83 c4 04	 add	 esp, 4
$LN27@Univers:
  00122	c7 85 d0 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T3[ebp], 4
  0012c	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00132	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv353[ebp], eax
  00138	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv353[ebp]
  0013e	c1 e9 03	 shr	 ecx, 3
  00141	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00147	88 95 36 ff ff
	ff		 mov	 BYTE PTR tv356[ebp], dl
  0014d	80 bd 36 ff ff
	ff 00		 cmp	 BYTE PTR tv356[ebp], 0
  00154	74 21		 je	 SHORT $LN26@Univers
  00156	8a 85 4c ff ff
	ff		 mov	 al, BYTE PTR tv353[ebp]
  0015c	24 07		 and	 al, 7
  0015e	04 03		 add	 al, 3
  00160	3a 85 36 ff ff
	ff		 cmp	 al, BYTE PTR tv356[ebp]
  00166	7c 0f		 jl	 SHORT $LN26@Univers
  00168	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv353[ebp]
  0016e	51		 push	 ecx
  0016f	e8 00 00 00 00	 call	 ___asan_report_store4
  00174	83 c4 04	 add	 esp, 4
$LN26@Univers:
  00177	c7 85 e0 fe ff
	ff 04 00 00 00	 mov	 DWORD PTR $T4[ebp], 4
  00181	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00187	52		 push	 edx
  00188	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0018e	50		 push	 eax
  0018f	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00195	51		 push	 ecx
  00196	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP>
  0019b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0019e	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001a4	c1 ea 03	 shr	 edx, 3
  001a7	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  001ae	8d 85 e0 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001b4	c1 e8 03	 shr	 eax, 3
  001b7	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 8    : 	Terrain* ter;
; 9    : 	RessourcePack* RP;
; 10   : 	sf::RenderWindow* RW;
; 11   : 	
; 12   : 	Player* p;
; 13   : 	int lvl = 1 ;

  001be	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	83 c1 18	 add	 ecx, 24			; 00000018H
  001c7	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv64[ebp], ecx
  001cd	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv64[ebp]
  001d3	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv343[ebp], edx
  001d9	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv343[ebp]
  001df	c1 e8 03	 shr	 eax, 3
  001e2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e8	88 8d 37 ff ff
	ff		 mov	 BYTE PTR tv346[ebp], cl
  001ee	80 bd 37 ff ff
	ff 00		 cmp	 BYTE PTR tv346[ebp], 0
  001f5	74 23		 je	 SHORT $LN25@Univers
  001f7	8a 95 50 ff ff
	ff		 mov	 dl, BYTE PTR tv343[ebp]
  001fd	80 e2 07	 and	 dl, 7
  00200	80 c2 03	 add	 dl, 3
  00203	3a 95 37 ff ff
	ff		 cmp	 dl, BYTE PTR tv346[ebp]
  00209	7c 0f		 jl	 SHORT $LN25@Univers
  0020b	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv343[ebp]
  00211	50		 push	 eax
  00212	e8 00 00 00 00	 call	 ___asan_report_store4
  00217	83 c4 04	 add	 esp, 4
$LN25@Univers:
  0021a	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv64[ebp]
  00220	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
  00226	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0022c	c1 ea 03	 shr	 edx, 3
  0022f	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 14   : 	std::vector<bool>* res = new std::vector<bool>(4);

  00236	6a 18		 push	 24			; 00000018H
  00238	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0023d	83 c4 04	 add	 esp, 4
  00240	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00246	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0024d	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  00254	74 34		 je	 SHORT $LN4@Univers
  00256	6a 18		 push	 24			; 00000018H
  00258	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  0025e	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
  00263	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00269	e8 00 00 00 00	 call	 ??0?$allocator@_N@std@@QAE@XZ ; std::allocator<bool>::allocator<bool>
  0026e	89 45 a8	 mov	 DWORD PTR tv88[ebp], eax
  00271	8b 45 a8	 mov	 eax, DWORD PTR tv88[ebp]
  00274	50		 push	 eax
  00275	6a 04		 push	 4
  00277	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  0027d	e8 00 00 00 00	 call	 ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
  00282	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv89[ebp], eax
  00288	eb 0a		 jmp	 SHORT $LN5@Univers
$LN4@Univers:
  0028a	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv89[ebp], 0
$LN5@Univers:
  00294	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp]
  0029a	89 4d ac	 mov	 DWORD PTR $T8[ebp], ecx
  0029d	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  002a4	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002aa	83 c2 1c	 add	 edx, 28			; 0000001cH
  002ad	89 55 80	 mov	 DWORD PTR tv69[ebp], edx
  002b0	8b 45 80	 mov	 eax, DWORD PTR tv69[ebp]
  002b3	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv333[ebp], eax
  002b9	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv333[ebp]
  002bf	c1 e9 03	 shr	 ecx, 3
  002c2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  002c8	88 95 38 ff ff
	ff		 mov	 BYTE PTR tv336[ebp], dl
  002ce	80 bd 38 ff ff
	ff 00		 cmp	 BYTE PTR tv336[ebp], 0
  002d5	74 21		 je	 SHORT $LN24@Univers
  002d7	8a 85 58 ff ff
	ff		 mov	 al, BYTE PTR tv333[ebp]
  002dd	24 07		 and	 al, 7
  002df	04 03		 add	 al, 3
  002e1	3a 85 38 ff ff
	ff		 cmp	 al, BYTE PTR tv336[ebp]
  002e7	7c 0f		 jl	 SHORT $LN24@Univers
  002e9	8b 8d 58 ff ff
	ff		 mov	 ecx, DWORD PTR tv333[ebp]
  002ef	51		 push	 ecx
  002f0	e8 00 00 00 00	 call	 ___asan_report_store4
  002f5	83 c4 04	 add	 esp, 4
$LN24@Univers:
  002f8	8b 55 80	 mov	 edx, DWORD PTR tv69[ebp]
  002fb	8b 45 ac	 mov	 eax, DWORD PTR $T8[ebp]
  002fe	89 02		 mov	 DWORD PTR [edx], eax
  00300	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00306	c1 e9 03	 shr	 ecx, 3
  00309	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 15   : 	sf::Sprite* background = nullptr;

  00310	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00316	83 c2 20	 add	 edx, 32			; 00000020H
  00319	89 55 84	 mov	 DWORD PTR tv77[ebp], edx
  0031c	8b 45 84	 mov	 eax, DWORD PTR tv77[ebp]
  0031f	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv323[ebp], eax
  00325	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv323[ebp]
  0032b	c1 e9 03	 shr	 ecx, 3
  0032e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00334	88 95 39 ff ff
	ff		 mov	 BYTE PTR tv326[ebp], dl
  0033a	80 bd 39 ff ff
	ff 00		 cmp	 BYTE PTR tv326[ebp], 0
  00341	74 21		 je	 SHORT $LN23@Univers
  00343	8a 85 5c ff ff
	ff		 mov	 al, BYTE PTR tv323[ebp]
  00349	24 07		 and	 al, 7
  0034b	04 03		 add	 al, 3
  0034d	3a 85 39 ff ff
	ff		 cmp	 al, BYTE PTR tv326[ebp]
  00353	7c 0f		 jl	 SHORT $LN23@Univers
  00355	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv323[ebp]
  0035b	51		 push	 ecx
  0035c	e8 00 00 00 00	 call	 ___asan_report_store4
  00361	83 c4 04	 add	 esp, 4
$LN23@Univers:
  00364	8b 55 84	 mov	 edx, DWORD PTR tv77[ebp]
  00367	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 16   : 	sf::Texture* backgroundTex = nullptr;

  0036d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00373	83 c0 24	 add	 eax, 36			; 00000024H
  00376	89 45 88	 mov	 DWORD PTR tv90[ebp], eax
  00379	8b 4d 88	 mov	 ecx, DWORD PTR tv90[ebp]
  0037c	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv313[ebp], ecx
  00382	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv313[ebp]
  00388	c1 ea 03	 shr	 edx, 3
  0038b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00391	88 85 3a ff ff
	ff		 mov	 BYTE PTR tv316[ebp], al
  00397	80 bd 3a ff ff
	ff 00		 cmp	 BYTE PTR tv316[ebp], 0
  0039e	74 23		 je	 SHORT $LN22@Univers
  003a0	8a 8d 60 ff ff
	ff		 mov	 cl, BYTE PTR tv313[ebp]
  003a6	80 e1 07	 and	 cl, 7
  003a9	80 c1 03	 add	 cl, 3
  003ac	3a 8d 3a ff ff
	ff		 cmp	 cl, BYTE PTR tv316[ebp]
  003b2	7c 0f		 jl	 SHORT $LN22@Univers
  003b4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv313[ebp]
  003ba	52		 push	 edx
  003bb	e8 00 00 00 00	 call	 ___asan_report_store4
  003c0	83 c4 04	 add	 esp, 4
$LN22@Univers:
  003c3	8b 45 88	 mov	 eax, DWORD PTR tv90[ebp]
  003c6	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp

; 159  :     RW = rw;

  003cc	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003d2	83 c1 10	 add	 ecx, 16			; 00000010H
  003d5	89 4d 8c	 mov	 DWORD PTR tv91[ebp], ecx
  003d8	8b 55 8c	 mov	 edx, DWORD PTR tv91[ebp]
  003db	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv303[ebp], edx
  003e1	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv303[ebp]
  003e7	c1 e8 03	 shr	 eax, 3
  003ea	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003f0	88 8d 3b ff ff
	ff		 mov	 BYTE PTR tv306[ebp], cl
  003f6	80 bd 3b ff ff
	ff 00		 cmp	 BYTE PTR tv306[ebp], 0
  003fd	74 23		 je	 SHORT $LN21@Univers
  003ff	8a 95 64 ff ff
	ff		 mov	 dl, BYTE PTR tv303[ebp]
  00405	80 e2 07	 and	 dl, 7
  00408	80 c2 03	 add	 dl, 3
  0040b	3a 95 3b ff ff
	ff		 cmp	 dl, BYTE PTR tv306[ebp]
  00411	7c 0f		 jl	 SHORT $LN21@Univers
  00413	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv303[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 ___asan_report_store4
  0041f	83 c4 04	 add	 esp, 4
$LN21@Univers:
  00422	8b 4d 8c	 mov	 ecx, DWORD PTR tv91[ebp]
  00425	8b 53 0c	 mov	 edx, DWORD PTR _rw$[ebx]
  00428	89 11		 mov	 DWORD PTR [ecx], edx

; 160  :     RP = rp;

  0042a	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00430	83 c0 0c	 add	 eax, 12			; 0000000cH
  00433	89 45 90	 mov	 DWORD PTR tv92[ebp], eax
  00436	8b 4d 90	 mov	 ecx, DWORD PTR tv92[ebp]
  00439	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv293[ebp], ecx
  0043f	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv293[ebp]
  00445	c1 ea 03	 shr	 edx, 3
  00448	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0044e	88 85 3c ff ff
	ff		 mov	 BYTE PTR tv296[ebp], al
  00454	80 bd 3c ff ff
	ff 00		 cmp	 BYTE PTR tv296[ebp], 0
  0045b	74 23		 je	 SHORT $LN20@Univers
  0045d	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv293[ebp]
  00463	80 e1 07	 and	 cl, 7
  00466	80 c1 03	 add	 cl, 3
  00469	3a 8d 3c ff ff
	ff		 cmp	 cl, BYTE PTR tv296[ebp]
  0046f	7c 0f		 jl	 SHORT $LN20@Univers
  00471	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv293[ebp]
  00477	52		 push	 edx
  00478	e8 00 00 00 00	 call	 ___asan_report_store4
  0047d	83 c4 04	 add	 esp, 4
$LN20@Univers:
  00480	8b 45 90	 mov	 eax, DWORD PTR tv92[ebp]
  00483	8b 4b 08	 mov	 ecx, DWORD PTR _rp$[ebx]
  00486	89 08		 mov	 DWORD PTR [eax], ecx

; 161  : 
; 162  :     try {

  00488	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 163  :         RP->generateImg("\\Ressources\\img");

  0048f	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00495	83 c2 0c	 add	 edx, 12			; 0000000cH
  00498	89 55 94	 mov	 DWORD PTR tv93[ebp], edx
  0049b	8b 45 94	 mov	 eax, DWORD PTR tv93[ebp]
  0049e	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv283[ebp], eax
  004a4	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv283[ebp]
  004aa	c1 e9 03	 shr	 ecx, 3
  004ad	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  004b3	88 95 3d ff ff
	ff		 mov	 BYTE PTR tv286[ebp], dl
  004b9	80 bd 3d ff ff
	ff 00		 cmp	 BYTE PTR tv286[ebp], 0
  004c0	74 21		 je	 SHORT $LN19@Univers
  004c2	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv283[ebp]
  004c8	24 07		 and	 al, 7
  004ca	04 03		 add	 al, 3
  004cc	3a 85 3d ff ff
	ff		 cmp	 al, BYTE PTR tv286[ebp]
  004d2	7c 0f		 jl	 SHORT $LN19@Univers
  004d4	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv283[ebp]
  004da	51		 push	 ecx
  004db	e8 00 00 00 00	 call	 ___asan_report_load4
  004e0	83 c4 04	 add	 esp, 4
$LN19@Univers:
  004e3	8b 55 94	 mov	 edx, DWORD PTR tv93[ebp]
  004e6	8b 02		 mov	 eax, DWORD PTR [edx]
  004e8	89 45 b0	 mov	 DWORD PTR tv141[ebp], eax
  004eb	83 ec 1c	 sub	 esp, 28			; 0000001cH
  004ee	8b cc		 mov	 ecx, esp
  004f0	89 65 d0	 mov	 DWORD PTR $T9[ebp], esp
  004f3	68 00 00 00 00	 push	 OFFSET $SG231380
  004f8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  004fd	8b 4d b0	 mov	 ecx, DWORD PTR tv141[ebp]
  00500	e8 00 00 00 00	 call	 ?generateImg@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::generateImg

; 164  :         RP->generateAudioData("\\Ressources\\audio");

  00505	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0050b	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0050e	89 4d 98	 mov	 DWORD PTR tv143[ebp], ecx
  00511	8b 55 98	 mov	 edx, DWORD PTR tv143[ebp]
  00514	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv273[ebp], edx
  0051a	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv273[ebp]
  00520	c1 e8 03	 shr	 eax, 3
  00523	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00529	88 8d 3e ff ff
	ff		 mov	 BYTE PTR tv276[ebp], cl
  0052f	80 bd 3e ff ff
	ff 00		 cmp	 BYTE PTR tv276[ebp], 0
  00536	74 23		 je	 SHORT $LN18@Univers
  00538	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv273[ebp]
  0053e	80 e2 07	 and	 dl, 7
  00541	80 c2 03	 add	 dl, 3
  00544	3a 95 3e ff ff
	ff		 cmp	 dl, BYTE PTR tv276[ebp]
  0054a	7c 0f		 jl	 SHORT $LN18@Univers
  0054c	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv273[ebp]
  00552	50		 push	 eax
  00553	e8 00 00 00 00	 call	 ___asan_report_load4
  00558	83 c4 04	 add	 esp, 4
$LN18@Univers:
  0055b	8b 4d 98	 mov	 ecx, DWORD PTR tv143[ebp]
  0055e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00560	89 55 b4	 mov	 DWORD PTR tv159[ebp], edx
  00563	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00566	8b cc		 mov	 ecx, esp
  00568	89 65 d4	 mov	 DWORD PTR $T10[ebp], esp
  0056b	68 00 00 00 00	 push	 OFFSET $SG231381
  00570	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00575	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00578	e8 00 00 00 00	 call	 ?generateAudioData@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::generateAudioData

; 165  :         RP->generateBackgrounds("\\Ressources\\img\\backgrounds");

  0057d	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00583	83 c0 0c	 add	 eax, 12			; 0000000cH
  00586	89 45 9c	 mov	 DWORD PTR tv161[ebp], eax
  00589	8b 4d 9c	 mov	 ecx, DWORD PTR tv161[ebp]
  0058c	89 8d 74 ff ff
	ff		 mov	 DWORD PTR tv263[ebp], ecx
  00592	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv263[ebp]
  00598	c1 ea 03	 shr	 edx, 3
  0059b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  005a1	88 85 3f ff ff
	ff		 mov	 BYTE PTR tv266[ebp], al
  005a7	80 bd 3f ff ff
	ff 00		 cmp	 BYTE PTR tv266[ebp], 0
  005ae	74 23		 je	 SHORT $LN17@Univers
  005b0	8a 8d 74 ff ff
	ff		 mov	 cl, BYTE PTR tv263[ebp]
  005b6	80 e1 07	 and	 cl, 7
  005b9	80 c1 03	 add	 cl, 3
  005bc	3a 8d 3f ff ff
	ff		 cmp	 cl, BYTE PTR tv266[ebp]
  005c2	7c 0f		 jl	 SHORT $LN17@Univers
  005c4	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv263[ebp]
  005ca	52		 push	 edx
  005cb	e8 00 00 00 00	 call	 ___asan_report_load4
  005d0	83 c4 04	 add	 esp, 4
$LN17@Univers:
  005d3	8b 45 9c	 mov	 eax, DWORD PTR tv161[ebp]
  005d6	8b 08		 mov	 ecx, DWORD PTR [eax]
  005d8	89 4d b8	 mov	 DWORD PTR tv177[ebp], ecx
  005db	83 ec 1c	 sub	 esp, 28			; 0000001cH
  005de	8b cc		 mov	 ecx, esp
  005e0	89 65 d8	 mov	 DWORD PTR $T11[ebp], esp
  005e3	68 00 00 00 00	 push	 OFFSET $SG231382
  005e8	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  005ed	8b 4d b8	 mov	 ecx, DWORD PTR tv177[ebp]
  005f0	e8 00 00 00 00	 call	 ?generateBackgrounds@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::generateBackgrounds

; 166  :     }

  005f5	e9 90 00 00 00	 jmp	 $LN6@Univers
__catch$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$0:
  005fa	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]

; 167  :     catch (std::invalid_argument e) {

  005fd	8d 95 00 ff ff
	ff		 lea	 edx, DWORD PTR _e$6[ebp]
  00603	c1 ea 03	 shr	 edx, 3
  00606	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0060c	89 55 a0	 mov	 DWORD PTR tv252[ebp], edx
  0060f	6a 01		 push	 1
  00611	8b 45 a0	 mov	 eax, DWORD PTR tv252[ebp]
  00614	50		 push	 eax
  00615	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0061a	83 c4 08	 add	 esp, 8
  0061d	8b 4d a0	 mov	 ecx, DWORD PTR tv252[ebp]
  00620	c6 41 01 04	 mov	 BYTE PTR [ecx+1], 4
  00624	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 168  :         std::cerr << e.what() << std::endl;

  00628	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0062e	89 55 c0	 mov	 DWORD PTR tv190[ebp], edx
  00631	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _e$6[ebp]
  00637	e8 00 00 00 00	 call	 ?what@exception@std@@UBEPBDXZ ; std::exception::what
  0063c	89 45 bc	 mov	 DWORD PTR tv192[ebp], eax
  0063f	8b 45 bc	 mov	 eax, DWORD PTR tv192[ebp]
  00642	50		 push	 eax
  00643	8b 4d c0	 mov	 ecx, DWORD PTR tv190[ebp]
  00646	51		 push	 ecx
  00647	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0064c	83 c4 08	 add	 esp, 8
  0064f	89 45 c4	 mov	 DWORD PTR tv197[ebp], eax
  00652	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00657	8b 4d c4	 mov	 ecx, DWORD PTR tv197[ebp]
  0065a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z

; 169  :         return;

  00660	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00664	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _e$6[ebp]
  0066a	e8 00 00 00 00	 call	 ??1invalid_argument@std@@UAE@XZ
  0066f	b8 00 00 00 00	 mov	 eax, $LN29@Univers
  00674	c3		 ret	 0

; 170  :     }

  00675	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  00679	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _e$6[ebp]
  0067f	e8 00 00 00 00	 call	 ??1invalid_argument@std@@UAE@XZ
  00684	b8 00 00 00 00	 mov	 eax, $LN30@Univers
  00689	c3		 ret	 0
$LN6@Univers:
  0068a	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  00691	eb 0a		 jmp	 SHORT __tryend$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$1
$LN30@Univers:
  00693	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]
  00696	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$1:
  0069d	eb 0c		 jmp	 SHORT $LN13@Univers
$LN29@Univers:
  0069f	8b 5d ec	 mov	 ebx, DWORD PTR [ebp-20]
  006a2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 169  :         return;

  006a9	eb 0d		 jmp	 SHORT $LN1@Univers
$LN13@Univers:

; 171  :     loadTerrain(1);

  006ab	6a 01		 push	 1
  006ad	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  006b3	e8 00 00 00 00	 call	 ?loadTerrain@Univers@@QAEXH@Z ; Univers::loadTerrain
$LN1@Univers:

; 172  : 
; 173  : 
; 174  : }

  006b8	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  006be	89 55 cc	 mov	 DWORD PTR tv212[ebp], edx
  006c1	c7 85 c0 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  006cb	8d 85 c0 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  006d1	c1 e8 03	 shr	 eax, 3
  006d4	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  006d9	89 45 c8	 mov	 DWORD PTR tv259[ebp], eax
  006dc	6a 0e		 push	 14			; 0000000eH
  006de	8b 4d c8	 mov	 ecx, DWORD PTR tv259[ebp]
  006e1	51		 push	 ecx
  006e2	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  006e7	83 c4 08	 add	 esp, 8
  006ea	8b 45 cc	 mov	 eax, DWORD PTR tv212[ebp]
  006ed	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  006f0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  006f7	59		 pop	 ecx
  006f8	5f		 pop	 edi
  006f9	5e		 pop	 esi
  006fa	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  006fd	33 cd		 xor	 ecx, ebp
  006ff	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00704	8b e5		 mov	 esp, ebp
  00706	5d		 pop	 ebp
  00707	8b e3		 mov	 esp, ebx
  00709	5b		 pop	 ebx
  0070a	c2 08 00	 ret	 8
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$2:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$6:
  00012	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR _e$6[ebp]
  00018	e9 00 00 00 00	 jmp	 ??1invalid_argument@std@@UAE@XZ
  0001d	cc		 int	 3
  0001e	cc		 int	 3
  0001f	cc		 int	 3
  00020	cc		 int	 3
  00021	cc		 int	 3
__ehhandler$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z:
  00022	90		 npad	 1
  00023	90		 npad	 1
  00024	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00028	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0002b	8b 8a ac fe ff
	ff		 mov	 ecx, DWORD PTR [edx-340]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0003b	33 c8		 xor	 ecx, eax
  0003d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00042	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
  00047	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z ENDP ; Univers::Univers
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest, COMDAT
; _this$ = ecx

; 672  :     constexpr _Mybase& _Get_rest() noexcept { // get reference to rest of elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 673  :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 674  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv76 = -28						; size = 4
tv69 = -24						; size = 4
tv75 = -20						; size = 4
_this$ = -16						; size = 4
tv82 = -12						; size = 4
tv92 = -8						; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
___that$ = 8						; size = 4
??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z PROC	; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>, COMDAT
; _this$ = ecx

; 359  :     tuple(const tuple&) = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00016	50		 push	 eax
  00017	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00022	83 c1 04	 add	 ecx, 4
  00025	89 4d ec	 mov	 DWORD PTR tv75[ebp], ecx
  00028	8b 55 ec	 mov	 edx, DWORD PTR tv75[ebp]
  0002b	89 55 f8	 mov	 DWORD PTR tv92[ebp], edx
  0002e	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  00031	c1 e8 03	 shr	 eax, 3
  00034	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003a	88 4d ff	 mov	 BYTE PTR tv95[ebp], cl
  0003d	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  00041	74 1a		 je	 SHORT $LN4@tuple
  00043	8a 55 f8	 mov	 dl, BYTE PTR tv92[ebp]
  00046	80 e2 07	 and	 dl, 7
  00049	80 c2 03	 add	 dl, 3
  0004c	3a 55 ff	 cmp	 dl, BYTE PTR tv95[ebp]
  0004f	7c 0c		 jl	 SHORT $LN4@tuple
  00051	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  00054	50		 push	 eax
  00055	e8 00 00 00 00	 call	 ___asan_report_load4
  0005a	83 c4 04	 add	 esp, 4
$LN4@tuple:
  0005d	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00060	8b 11		 mov	 edx, DWORD PTR [ecx]
  00062	89 55 e4	 mov	 DWORD PTR tv76[ebp], edx
  00065	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00068	83 c0 04	 add	 eax, 4
  0006b	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  0006e	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00071	89 4d f4	 mov	 DWORD PTR tv82[ebp], ecx
  00074	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00077	c1 ea 03	 shr	 edx, 3
  0007a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00080	88 45 fe	 mov	 BYTE PTR tv85[ebp], al
  00083	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  00087	74 1a		 je	 SHORT $LN3@tuple
  00089	8a 4d f4	 mov	 cl, BYTE PTR tv82[ebp]
  0008c	80 e1 07	 and	 cl, 7
  0008f	80 c1 03	 add	 cl, 3
  00092	3a 4d fe	 cmp	 cl, BYTE PTR tv85[ebp]
  00095	7c 0c		 jl	 SHORT $LN3@tuple
  00097	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  0009a	52		 push	 edx
  0009b	e8 00 00 00 00	 call	 ___asan_report_store4
  000a0	83 c4 04	 add	 esp, 4
$LN3@tuple:
  000a3	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  000a6	8b 4d e4	 mov	 ecx, DWORD PTR tv76[ebp]
  000a9	89 08		 mov	 DWORD PTR [eax], ecx
  000ab	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c2 04 00	 ret	 4
??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z ENDP	; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ PROC ; std::tuple<enum DIRDEP>::_Get_rest, COMDAT
; _this$ = ecx

; 672  :     constexpr _Mybase& _Get_rest() noexcept { // get reference to rest of elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 673  :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 674  :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ENDP ; std::tuple<enum DIRDEP>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv76 = -28						; size = 4
tv69 = -24						; size = 4
tv75 = -20						; size = 4
_this$ = -16						; size = 4
tv82 = -12						; size = 4
tv92 = -8						; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
___that$ = 8						; size = 4
??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z PROC		; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>, COMDAT
; _this$ = ecx

; 359  :     tuple(const tuple&) = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00016	50		 push	 eax
  00017	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001a	e8 00 00 00 00	 call	 ??0?$tuple@$$V@std@@QAE@ABV01@@Z ; std::tuple<>::tuple<>
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00022	89 4d ec	 mov	 DWORD PTR tv75[ebp], ecx
  00025	8b 55 ec	 mov	 edx, DWORD PTR tv75[ebp]
  00028	89 55 f8	 mov	 DWORD PTR tv92[ebp], edx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  0002e	c1 e8 03	 shr	 eax, 3
  00031	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00037	88 4d ff	 mov	 BYTE PTR tv95[ebp], cl
  0003a	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  0003e	74 1a		 je	 SHORT $LN4@tuple
  00040	8a 55 f8	 mov	 dl, BYTE PTR tv92[ebp]
  00043	80 e2 07	 and	 dl, 7
  00046	80 c2 03	 add	 dl, 3
  00049	3a 55 ff	 cmp	 dl, BYTE PTR tv95[ebp]
  0004c	7c 0c		 jl	 SHORT $LN4@tuple
  0004e	8b 45 f8	 mov	 eax, DWORD PTR tv92[ebp]
  00051	50		 push	 eax
  00052	e8 00 00 00 00	 call	 ___asan_report_load4
  00057	83 c4 04	 add	 esp, 4
$LN4@tuple:
  0005a	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	89 55 e4	 mov	 DWORD PTR tv76[ebp], edx
  00062	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00065	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00068	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  0006b	89 4d f4	 mov	 DWORD PTR tv82[ebp], ecx
  0006e	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00071	c1 ea 03	 shr	 edx, 3
  00074	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0007a	88 45 fe	 mov	 BYTE PTR tv85[ebp], al
  0007d	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  00081	74 1a		 je	 SHORT $LN3@tuple
  00083	8a 4d f4	 mov	 cl, BYTE PTR tv82[ebp]
  00086	80 e1 07	 and	 cl, 7
  00089	80 c1 03	 add	 cl, 3
  0008c	3a 4d fe	 cmp	 cl, BYTE PTR tv85[ebp]
  0008f	7c 0c		 jl	 SHORT $LN3@tuple
  00091	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00094	52		 push	 edx
  00095	e8 00 00 00 00	 call	 ___asan_report_store4
  0009a	83 c4 04	 add	 esp, 4
$LN3@tuple:
  0009d	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv76[ebp]
  000a3	89 08		 mov	 DWORD PTR [eax], ecx
  000a5	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a8	8b e5		 mov	 esp, ebp
  000aa	5d		 pop	 ebp
  000ab	c2 04 00	 ret	 4
??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z ENDP		; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVBlock@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVBlock@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVBlock@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVBlock@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<Block *>,std::_Vector_val<std::_Simple_types<Block *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVBlock@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVBlock@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<Block *>,std::_Vector_val<std::_Simple_types<Block *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@AAEAAV?$allocator@PAVBlock@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@AAEAAV?$allocator@PAVBlock@@@2@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PAVBlock@@@std@@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVBlock@@@2@XZ ; std::_Compressed_pair<std::allocator<Block *>,std::_Vector_val<std::_Simple_types<Block *> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@AAEAAV?$allocator@PAVBlock@@@2@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z PROC ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1802 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1803 :         // orphan iterators within specified (inclusive) range
; 1804 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1805 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 12		 je	 SHORT $LN2@Orphan_ran

; 1806 :             _Orphan_range_unlocked(_First, _Last);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00024	52		 push	 edx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_unlocked

; 1807 :         } else

  0002d	eb 10		 jmp	 SHORT $LN1@Orphan_ran
$LN2@Orphan_ran:

; 1808 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1809 :         {
; 1810 :             _Orphan_range_locked(_First, _Last);

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_locked
$LN1@Orphan_ran:

; 1811 :         }
; 1812 :     }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ENDP ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
_TEXT	SEGMENT
__asan_gen_0$ = -112					; size = 4
__asan_gen_1$ = -108					; size = 4
__asan_gen_2$ = -104					; size = 4
__Lock$ = -96						; size = 4
tv74 = -52						; size = 4
tv65 = -48						; size = 4
_this$ = -44						; size = 4
tv77 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z PROC ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 1797 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 45 90 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00046	c7 45 94 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
  0004d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_locked
  00054	8d 45 90	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00057	89 45 d0	 mov	 DWORD PTR tv65[ebp], eax
  0005a	8b 4d d0	 mov	 ecx, DWORD PTR tv65[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00066	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  00069	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  0006c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00072	83 45 cc 04	 add	 DWORD PTR tv74[ebp], 4
  00076	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0007b	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  0007e	66 89 01	 mov	 WORD PTR [ecx], ax
  00081	83 45 cc 02	 add	 DWORD PTR tv74[ebp], 2
  00085	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  00088	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1798 :         _Lockit _Lock(_LOCK_DEBUG);

  00095	6a 03		 push	 3
  00097	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  000a0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1799 :         _Orphan_range_unlocked(_First, _Last);

  000a7	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000aa	50		 push	 eax
  000ab	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ae	51		 push	 ecx
  000af	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_unlocked

; 1800 :     }

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c7	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000ce	8d 55 90	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000d1	c1 ea 03	 shr	 edx, 3
  000d4	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000da	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
  000dd	6a 07		 push	 7
  000df	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e8	83 c4 08	 add	 esp, 8
  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	8b e3		 mov	 esp, ebx
  00105	5b		 pop	 ebx
  00106	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z$0:
  00000	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ENDP ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z
_TEXT	SEGMENT
tv136 = -104						; size = 4
tv129 = -100						; size = 4
__Temp$1 = -96						; size = 4
tv94 = -92						; size = 4
tv89 = -88						; size = 4
tv86 = -84						; size = 4
_this$ = -80						; size = 4
tv82 = -76						; size = 4
__Temp$2 = -72						; size = 4
tv81 = -68						; size = 4
__Pnextptr$3 = -64					; size = 4
tv77 = -60						; size = 4
tv69 = -56						; size = 4
tv139 = -52						; size = 4
tv149 = -48						; size = 4
tv159 = -44						; size = 4
tv169 = -40						; size = 4
tv179 = -36						; size = 4
tv189 = -32						; size = 4
tv199 = -28						; size = 4
tv209 = -24						; size = 4
tv219 = -20						; size = 4
__Pnext$ = -16						; size = 4
tv142 = -9						; size = 1
tv152 = -8						; size = 1
tv162 = -7						; size = 1
tv172 = -6						; size = 1
tv182 = -5						; size = 1
tv192 = -4						; size = 1
tv202 = -3						; size = 1
tv212 = -2						; size = 1
tv222 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z PROC ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 1782 :     _CONSTEXPR20_CONTAINER void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1783 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  00013	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c8	 mov	 DWORD PTR tv69[ebp], eax
  00019	8b 4d c8	 mov	 ecx, DWORD PTR tv69[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv219[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv219[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv222[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv222[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_ran
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv219[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv222[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_ran
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv219[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_ran:
  0004e	8b 45 c8	 mov	 eax, DWORD PTR tv69[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	83 c1 04	 add	 ecx, 4
  00056	89 4d f0	 mov	 DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 1784 :         while (*_Pnext) {

  00059	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0005c	89 55 ac	 mov	 DWORD PTR tv86[ebp], edx
  0005f	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  00062	89 45 e8	 mov	 DWORD PTR tv209[ebp], eax
  00065	8b 4d e8	 mov	 ecx, DWORD PTR tv209[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv212[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv212[ebp], 0
  00078	74 18		 je	 SHORT $LN15@Orphan_ran
  0007a	8a 45 e8	 mov	 al, BYTE PTR tv209[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv212[ebp]
  00084	7c 0c		 jl	 SHORT $LN15@Orphan_ran
  00086	8b 4d e8	 mov	 ecx, DWORD PTR tv209[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_load4
  0008f	83 c4 04	 add	 esp, 4
$LN15@Orphan_ran:
  00092	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00095	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00098	0f 84 eb 01 00
	00		 je	 $LN1@Orphan_ran

; 1785 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

  0009e	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a1	89 45 a8	 mov	 DWORD PTR tv89[ebp], eax
  000a4	8b 4d a8	 mov	 ecx, DWORD PTR tv89[ebp]
  000a7	89 4d e4	 mov	 DWORD PTR tv199[ebp], ecx
  000aa	8b 55 e4	 mov	 edx, DWORD PTR tv199[ebp]
  000ad	c1 ea 03	 shr	 edx, 3
  000b0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b6	88 45 fd	 mov	 BYTE PTR tv202[ebp], al
  000b9	80 7d fd 00	 cmp	 BYTE PTR tv202[ebp], 0
  000bd	74 1a		 je	 SHORT $LN14@Orphan_ran
  000bf	8a 4d e4	 mov	 cl, BYTE PTR tv199[ebp]
  000c2	80 e1 07	 and	 cl, 7
  000c5	80 c1 03	 add	 cl, 3
  000c8	3a 4d fd	 cmp	 cl, BYTE PTR tv202[ebp]
  000cb	7c 0c		 jl	 SHORT $LN14@Orphan_ran
  000cd	8b 55 e4	 mov	 edx, DWORD PTR tv199[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ___asan_report_load4
  000d6	83 c4 04	 add	 esp, 4
$LN14@Orphan_ran:
  000d9	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	83 c1 08	 add	 ecx, 8
  000e1	89 4d c4	 mov	 DWORD PTR tv77[ebp], ecx
  000e4	8b 55 c4	 mov	 edx, DWORD PTR tv77[ebp]
  000e7	89 55 e0	 mov	 DWORD PTR tv189[ebp], edx
  000ea	8b 45 e0	 mov	 eax, DWORD PTR tv189[ebp]
  000ed	c1 e8 03	 shr	 eax, 3
  000f0	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000f6	88 4d fc	 mov	 BYTE PTR tv192[ebp], cl
  000f9	80 7d fc 00	 cmp	 BYTE PTR tv192[ebp], 0
  000fd	74 1a		 je	 SHORT $LN13@Orphan_ran
  000ff	8a 55 e0	 mov	 dl, BYTE PTR tv189[ebp]
  00102	80 e2 07	 and	 dl, 7
  00105	80 c2 03	 add	 dl, 3
  00108	3a 55 fc	 cmp	 dl, BYTE PTR tv192[ebp]
  0010b	7c 0c		 jl	 SHORT $LN13@Orphan_ran
  0010d	8b 45 e0	 mov	 eax, DWORD PTR tv189[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ___asan_report_load4
  00116	83 c4 04	 add	 esp, 4
$LN13@Orphan_ran:
  00119	8b 4d c4	 mov	 ecx, DWORD PTR tv77[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	89 55 c0	 mov	 DWORD PTR __Pnextptr$3[ebp], edx

; 1786 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

  00121	8b 45 c0	 mov	 eax, DWORD PTR __Pnextptr$3[ebp]
  00124	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  00127	72 08		 jb	 SHORT $LN6@Orphan_ran
  00129	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0012c	3b 4d c0	 cmp	 ecx, DWORD PTR __Pnextptr$3[ebp]
  0012f	73 4f		 jae	 SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 1787 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00131	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00134	89 55 a4	 mov	 DWORD PTR tv94[ebp], edx
  00137	8b 45 a4	 mov	 eax, DWORD PTR tv94[ebp]
  0013a	89 45 dc	 mov	 DWORD PTR tv179[ebp], eax
  0013d	8b 4d dc	 mov	 ecx, DWORD PTR tv179[ebp]
  00140	c1 e9 03	 shr	 ecx, 3
  00143	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00149	88 55 fb	 mov	 BYTE PTR tv182[ebp], dl
  0014c	80 7d fb 00	 cmp	 BYTE PTR tv182[ebp], 0
  00150	74 18		 je	 SHORT $LN12@Orphan_ran
  00152	8a 45 dc	 mov	 al, BYTE PTR tv179[ebp]
  00155	24 07		 and	 al, 7
  00157	04 03		 add	 al, 3
  00159	3a 45 fb	 cmp	 al, BYTE PTR tv182[ebp]
  0015c	7c 0c		 jl	 SHORT $LN12@Orphan_ran
  0015e	8b 4d dc	 mov	 ecx, DWORD PTR tv179[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN12@Orphan_ran:
  0016a	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	89 45 a0	 mov	 DWORD PTR __Temp$1[ebp], eax

; 1788 :                 _Pnext           = &_Temp->_Mynextiter;

  00172	8b 4d a0	 mov	 ecx, DWORD PTR __Temp$1[ebp]
  00175	83 c1 04	 add	 ecx, 4
  00178	89 4d f0	 mov	 DWORD PTR __Pnext$[ebp], ecx

; 1789 :             } else { // orphan the iterator

  0017b	e9 04 01 00 00	 jmp	 $LN5@Orphan_ran
$LN4@Orphan_ran:

; 1790 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00180	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00183	89 55 9c	 mov	 DWORD PTR tv129[ebp], edx
  00186	8b 45 9c	 mov	 eax, DWORD PTR tv129[ebp]
  00189	89 45 d8	 mov	 DWORD PTR tv169[ebp], eax
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR tv169[ebp]
  0018f	c1 e9 03	 shr	 ecx, 3
  00192	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00198	88 55 fa	 mov	 BYTE PTR tv172[ebp], dl
  0019b	80 7d fa 00	 cmp	 BYTE PTR tv172[ebp], 0
  0019f	74 18		 je	 SHORT $LN11@Orphan_ran
  001a1	8a 45 d8	 mov	 al, BYTE PTR tv169[ebp]
  001a4	24 07		 and	 al, 7
  001a6	04 03		 add	 al, 3
  001a8	3a 45 fa	 cmp	 al, BYTE PTR tv172[ebp]
  001ab	7c 0c		 jl	 SHORT $LN11@Orphan_ran
  001ad	8b 4d d8	 mov	 ecx, DWORD PTR tv169[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 ___asan_report_load4
  001b6	83 c4 04	 add	 esp, 4
$LN11@Orphan_ran:
  001b9	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  001bc	8b 02		 mov	 eax, DWORD PTR [edx]
  001be	89 45 b8	 mov	 DWORD PTR __Temp$2[ebp], eax

; 1791 :                 _Temp->_Myproxy  = nullptr;

  001c1	8b 4d b8	 mov	 ecx, DWORD PTR __Temp$2[ebp]
  001c4	89 4d bc	 mov	 DWORD PTR tv81[ebp], ecx
  001c7	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  001ca	89 55 d4	 mov	 DWORD PTR tv159[ebp], edx
  001cd	8b 45 d4	 mov	 eax, DWORD PTR tv159[ebp]
  001d0	c1 e8 03	 shr	 eax, 3
  001d3	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001d9	88 4d f9	 mov	 BYTE PTR tv162[ebp], cl
  001dc	80 7d f9 00	 cmp	 BYTE PTR tv162[ebp], 0
  001e0	74 1a		 je	 SHORT $LN10@Orphan_ran
  001e2	8a 55 d4	 mov	 dl, BYTE PTR tv159[ebp]
  001e5	80 e2 07	 and	 dl, 7
  001e8	80 c2 03	 add	 dl, 3
  001eb	3a 55 f9	 cmp	 dl, BYTE PTR tv162[ebp]
  001ee	7c 0c		 jl	 SHORT $LN10@Orphan_ran
  001f0	8b 45 d4	 mov	 eax, DWORD PTR tv159[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ___asan_report_store4
  001f9	83 c4 04	 add	 esp, 4
$LN10@Orphan_ran:
  001fc	8b 4d bc	 mov	 ecx, DWORD PTR tv81[ebp]
  001ff	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1792 :                 *_Pnext          = _Temp->_Mynextiter;

  00205	8b 55 b8	 mov	 edx, DWORD PTR __Temp$2[ebp]
  00208	83 c2 04	 add	 edx, 4
  0020b	89 55 b4	 mov	 DWORD PTR tv82[ebp], edx
  0020e	8b 45 b4	 mov	 eax, DWORD PTR tv82[ebp]
  00211	89 45 d0	 mov	 DWORD PTR tv149[ebp], eax
  00214	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  00217	c1 e9 03	 shr	 ecx, 3
  0021a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00220	88 55 f8	 mov	 BYTE PTR tv152[ebp], dl
  00223	80 7d f8 00	 cmp	 BYTE PTR tv152[ebp], 0
  00227	74 18		 je	 SHORT $LN9@Orphan_ran
  00229	8a 45 d0	 mov	 al, BYTE PTR tv149[ebp]
  0022c	24 07		 and	 al, 7
  0022e	04 03		 add	 al, 3
  00230	3a 45 f8	 cmp	 al, BYTE PTR tv152[ebp]
  00233	7c 0c		 jl	 SHORT $LN9@Orphan_ran
  00235	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 ___asan_report_load4
  0023e	83 c4 04	 add	 esp, 4
$LN9@Orphan_ran:
  00241	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00244	89 55 98	 mov	 DWORD PTR tv136[ebp], edx
  00247	8b 45 98	 mov	 eax, DWORD PTR tv136[ebp]
  0024a	89 45 cc	 mov	 DWORD PTR tv139[ebp], eax
  0024d	8b 4d cc	 mov	 ecx, DWORD PTR tv139[ebp]
  00250	c1 e9 03	 shr	 ecx, 3
  00253	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00259	88 55 f7	 mov	 BYTE PTR tv142[ebp], dl
  0025c	80 7d f7 00	 cmp	 BYTE PTR tv142[ebp], 0
  00260	74 18		 je	 SHORT $LN8@Orphan_ran
  00262	8a 45 cc	 mov	 al, BYTE PTR tv139[ebp]
  00265	24 07		 and	 al, 7
  00267	04 03		 add	 al, 3
  00269	3a 45 f7	 cmp	 al, BYTE PTR tv142[ebp]
  0026c	7c 0c		 jl	 SHORT $LN8@Orphan_ran
  0026e	8b 4d cc	 mov	 ecx, DWORD PTR tv139[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ___asan_report_store4
  00277	83 c4 04	 add	 esp, 4
$LN8@Orphan_ran:
  0027a	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0027d	8b 45 b4	 mov	 eax, DWORD PTR tv82[ebp]
  00280	8b 08		 mov	 ecx, DWORD PTR [eax]
  00282	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@Orphan_ran:

; 1793 :             }
; 1794 :         }

  00284	e9 d0 fd ff ff	 jmp	 $LN2@Orphan_ran
$LN1@Orphan_ran:

; 1795 :     }

  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c2 08 00	 ret	 8
?_Orphan_range_unlocked@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ENDP ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@CAXXZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@CAXXZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEAAPAVBlock@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEAAPAVBlock@@I@Z PROC ; std::vector<Block *,std::allocator<Block *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@CAXXZ ; std::vector<Block *,std::allocator<Block *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEAAPAVBlock@@I@Z ENDP ; std::vector<Block *,std::allocator<Block *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
__My_data$ = -16					; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?size@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QBEIXZ PROC ; std::vector<Block *,std::allocator<Block *> >::size, COMDAT
; _this$ = ecx

; 1547 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1548 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d ec	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00044	74 18		 je	 SHORT $LN4@size
  00046	8a 45 f8	 mov	 al, BYTE PTR tv85[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00050	7c 0c		 jl	 SHORT $LN4@size
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN4@size:
  0005e	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00077	74 1a		 je	 SHORT $LN3@size
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00085	7c 0c		 jl	 SHORT $LN3@size
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN3@size:
  00093	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2

; 1550 :     }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?size@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QBEIXZ ENDP ; std::vector<Block *,std::allocator<Block *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv66 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1534 :     _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1535 :         return _Mypair._Myval2._Mylast;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Unchecked_
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Unchecked_
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Unchecked_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1536 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv66 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1526 :     _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1527 :         return _Mypair._Myval2._Myfirst;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Unchecked_
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Unchecked_
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Unchecked_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1528 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv75 = -16						; size = 4
__My_data$ = -12					; size = 4
tv84 = -8						; size = 4
tv87 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::begin, COMDAT
; _this$ = ecx

; 1474 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1475 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1476 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00019	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Block *> > >
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  00028	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002b	83 c2 04	 add	 edx, 4
  0002e	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  00031	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00034	89 45 f8	 mov	 DWORD PTR tv84[ebp], eax
  00037	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00043	88 55 ff	 mov	 BYTE PTR tv87[ebp], dl
  00046	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0004a	74 18		 je	 SHORT $LN3@begin
  0004c	8a 45 f8	 mov	 al, BYTE PTR tv84[ebp]
  0004f	24 07		 and	 al, 7
  00051	04 03		 add	 al, 3
  00053	3a 45 ff	 cmp	 al, BYTE PTR tv87[ebp]
  00056	7c 0c		 jl	 SHORT $LN3@begin
  00058	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ___asan_report_load4
  00061	83 c4 04	 add	 esp, 4
$LN3@begin:
  00064	8b 55 f0	 mov	 edx, DWORD PTR tv75[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	89 45 e4	 mov	 DWORD PTR tv78[ebp], eax
  0006c	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0006f	51		 push	 ecx
  00070	8b 55 e4	 mov	 edx, DWORD PTR tv78[ebp]
  00073	52		 push	 edx
  00074	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00077	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z
  0007c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1477 :     }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
?begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv150 = -88						; size = 4
tv174 = -84						; size = 4
tv171 = -80						; size = 4
tv147 = -76						; size = 4
tv149 = -72						; size = 4
tv168 = -68						; size = 4
tv165 = -64						; size = 4
tv81 = -60						; size = 4
tv177 = -56						; size = 4
tv187 = -52						; size = 4
_this$ = -48						; size = 4
tv197 = -44						; size = 4
tv207 = -40						; size = 4
tv217 = -36						; size = 4
__My_data$ = -32					; size = 4
__Whereptr$ = -28					; size = 4
__Mylast$ = -24						; size = 4
tv180 = -17						; size = 1
tv190 = -16						; size = 1
tv200 = -15						; size = 1
tv210 = -14						; size = 1
tv220 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z PROC ; std::vector<Block *,std::allocator<Block *> >::erase, COMDAT
; _this$ = ecx

; 1407 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1408 :         const pointer _Whereptr = _Where._Ptr;

  00033	8b 45 14	 mov	 eax, DWORD PTR __Where$[ebp+8]
  00036	89 45 e4	 mov	 DWORD PTR __Whereptr$[ebp], eax

; 1409 :         auto& _My_data          = _Mypair._Myval2;

  00039	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	89 4d e0	 mov	 DWORD PTR __My_data$[ebp], ecx

; 1410 :         pointer& _Mylast        = _My_data._Mylast;

  0003f	8b 55 e0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00042	83 c2 08	 add	 edx, 8
  00045	89 55 e8	 mov	 DWORD PTR __Mylast$[ebp], edx
$LN4@erase:

; 1411 : 
; 1412 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1413 :         _STL_VERIFY(

  00048	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00050	8b f0		 mov	 esi, eax
  00052	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Block *> > >
  0005b	83 c4 04	 add	 esp, 4
  0005e	3b f0		 cmp	 esi, eax
  00060	0f 85 8f 00 00
	00		 jne	 $LN7@erase
  00066	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00069	83 c1 04	 add	 ecx, 4
  0006c	89 4d c4	 mov	 DWORD PTR tv81[ebp], ecx
  0006f	8b 55 c4	 mov	 edx, DWORD PTR tv81[ebp]
  00072	89 55 dc	 mov	 DWORD PTR tv217[ebp], edx
  00075	8b 45 dc	 mov	 eax, DWORD PTR tv217[ebp]
  00078	c1 e8 03	 shr	 eax, 3
  0007b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00081	88 4d f3	 mov	 BYTE PTR tv220[ebp], cl
  00084	80 7d f3 00	 cmp	 BYTE PTR tv220[ebp], 0
  00088	74 1a		 je	 SHORT $LN16@erase
  0008a	8a 55 dc	 mov	 dl, BYTE PTR tv217[ebp]
  0008d	80 e2 07	 and	 dl, 7
  00090	80 c2 03	 add	 dl, 3
  00093	3a 55 f3	 cmp	 dl, BYTE PTR tv220[ebp]
  00096	7c 0c		 jl	 SHORT $LN16@erase
  00098	8b 45 dc	 mov	 eax, DWORD PTR tv217[ebp]
  0009b	50		 push	 eax
  0009c	e8 00 00 00 00	 call	 ___asan_report_load4
  000a1	83 c4 04	 add	 esp, 4
$LN16@erase:
  000a4	8b 4d c4	 mov	 ecx, DWORD PTR tv81[ebp]
  000a7	8b 55 e4	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  000aa	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000ac	72 47		 jb	 SHORT $LN7@erase
  000ae	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000b1	89 45 c0	 mov	 DWORD PTR tv165[ebp], eax
  000b4	8b 4d c0	 mov	 ecx, DWORD PTR tv165[ebp]
  000b7	89 4d d8	 mov	 DWORD PTR tv207[ebp], ecx
  000ba	8b 55 d8	 mov	 edx, DWORD PTR tv207[ebp]
  000bd	c1 ea 03	 shr	 edx, 3
  000c0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c6	88 45 f2	 mov	 BYTE PTR tv210[ebp], al
  000c9	80 7d f2 00	 cmp	 BYTE PTR tv210[ebp], 0
  000cd	74 1a		 je	 SHORT $LN15@erase
  000cf	8a 4d d8	 mov	 cl, BYTE PTR tv207[ebp]
  000d2	80 e1 07	 and	 cl, 7
  000d5	80 c1 03	 add	 cl, 3
  000d8	3a 4d f2	 cmp	 cl, BYTE PTR tv210[ebp]
  000db	7c 0c		 jl	 SHORT $LN15@erase
  000dd	8b 55 d8	 mov	 edx, DWORD PTR tv207[ebp]
  000e0	52		 push	 edx
  000e1	e8 00 00 00 00	 call	 ___asan_report_load4
  000e6	83 c4 04	 add	 esp, 4
$LN15@erase:
  000e9	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000ec	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ee	3b 4d e4	 cmp	 ecx, DWORD PTR __Whereptr$[ebp]
  000f1	76 02		 jbe	 SHORT $LN7@erase
  000f3	eb 4a		 jmp	 SHORT $LN2@erase
$LN7@erase:
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
  000fa	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000ff	6a 00		 push	 0
  00101	68 87 05 00 00	 push	 1415			; 00000587H
  00106	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0010b	6a 02		 push	 2
  0010d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00113	83 c4 18	 add	 esp, 24			; 00000018H
  00116	83 f8 01	 cmp	 eax, 1
  00119	75 01		 jne	 SHORT $LN11@erase
  0011b	cc		 int	 3
$LN11@erase:
  0011c	6a 00		 push	 0
  0011e	68 87 05 00 00	 push	 1415			; 00000587H
  00123	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00128	68 00 00 00 00	 push	 OFFSET ??_C@_1IO@JBEJNAIO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa@
  0012d	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
  00132	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00138	83 c4 14	 add	 esp, 20			; 00000014H
  0013b	33 c0		 xor	 eax, eax
  0013d	75 b6		 jne	 SHORT $LN7@erase
$LN2@erase:
  0013f	33 c9		 xor	 ecx, ecx
  00141	0f 85 01 ff ff
	ff		 jne	 $LN4@erase

; 1414 :             _Where._Getcont() == _STD addressof(_My_data) && _Whereptr >= _My_data._Myfirst && _Mylast > _Whereptr,
; 1415 :             "vector erase iterator outside range");
; 1416 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1417 : 
; 1418 :         _Orphan_range(_Whereptr, _Mylast);

  00147	8b 55 e8	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0014a	8b 02		 mov	 eax, DWORD PTR [edx]
  0014c	50		 push	 eax
  0014d	8b 4d e4	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  00150	51		 push	 ecx
  00151	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00154	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@ABEXPAPAVBlock@@0@Z ; std::vector<Block *,std::allocator<Block *> >::_Orphan_range

; 1419 :         _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);

  00159	8b 55 e4	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  0015c	52		 push	 edx
  0015d	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00160	8b 08		 mov	 ecx, DWORD PTR [eax]
  00162	51		 push	 ecx
  00163	8b 55 e4	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  00166	83 c2 04	 add	 edx, 4
  00169	52		 push	 edx
  0016a	e8 00 00 00 00	 call	 ??$_Move_unchecked@PAPAVBlock@@PAPAV1@@std@@YAPAPAVBlock@@PAPAV1@00@Z ; std::_Move_unchecked<Block * *,Block * *>
  0016f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1420 :         _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));

  00172	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00175	89 45 bc	 mov	 DWORD PTR tv168[ebp], eax
  00178	8b 4d bc	 mov	 ecx, DWORD PTR tv168[ebp]
  0017b	89 4d d4	 mov	 DWORD PTR tv197[ebp], ecx
  0017e	8b 55 d4	 mov	 edx, DWORD PTR tv197[ebp]
  00181	c1 ea 03	 shr	 edx, 3
  00184	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0018a	88 45 f1	 mov	 BYTE PTR tv200[ebp], al
  0018d	80 7d f1 00	 cmp	 BYTE PTR tv200[ebp], 0
  00191	74 1a		 je	 SHORT $LN14@erase
  00193	8a 4d d4	 mov	 cl, BYTE PTR tv197[ebp]
  00196	80 e1 07	 and	 cl, 7
  00199	80 c1 03	 add	 cl, 3
  0019c	3a 4d f1	 cmp	 cl, BYTE PTR tv200[ebp]
  0019f	7c 0c		 jl	 SHORT $LN14@erase
  001a1	8b 55 d4	 mov	 edx, DWORD PTR tv197[ebp]
  001a4	52		 push	 edx
  001a5	e8 00 00 00 00	 call	 ___asan_report_load4
  001aa	83 c4 04	 add	 esp, 4
$LN14@erase:
  001ad	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  001b0	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b2	83 e9 04	 sub	 ecx, 4
  001b5	51		 push	 ecx
  001b6	e8 00 00 00 00	 call	 ??$_Unfancy@PAVBlock@@@std@@YAPAPAVBlock@@PAPAV1@@Z ; std::_Unfancy<Block *>
  001bb	83 c4 04	 add	 esp, 4
  001be	89 45 b8	 mov	 DWORD PTR tv149[ebp], eax
  001c1	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c4	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@AAEAAV?$allocator@PAVBlock@@@2@XZ ; std::vector<Block *,std::allocator<Block *> >::_Getal
  001c9	89 45 b4	 mov	 DWORD PTR tv147[ebp], eax
  001cc	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001cf	52		 push	 edx
  001d0	8b 45 b4	 mov	 eax, DWORD PTR tv147[ebp]
  001d3	50		 push	 eax
  001d4	e8 00 00 00 00	 call	 ??$destroy@PAVBlock@@@?$_Default_allocator_traits@V?$allocator@PAVBlock@@@std@@@std@@SAXAAV?$allocator@PAVBlock@@@1@QAPAVBlock@@@Z ; std::_Default_allocator_traits<std::allocator<Block *> >::destroy<Block *>
  001d9	83 c4 08	 add	 esp, 8

; 1421 :         --_Mylast;

  001dc	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  001df	89 4d b0	 mov	 DWORD PTR tv171[ebp], ecx
  001e2	8b 55 b0	 mov	 edx, DWORD PTR tv171[ebp]
  001e5	89 55 cc	 mov	 DWORD PTR tv187[ebp], edx
  001e8	8b 45 cc	 mov	 eax, DWORD PTR tv187[ebp]
  001eb	c1 e8 03	 shr	 eax, 3
  001ee	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001f4	88 4d f0	 mov	 BYTE PTR tv190[ebp], cl
  001f7	80 7d f0 00	 cmp	 BYTE PTR tv190[ebp], 0
  001fb	74 1a		 je	 SHORT $LN13@erase
  001fd	8a 55 cc	 mov	 dl, BYTE PTR tv187[ebp]
  00200	80 e2 07	 and	 dl, 7
  00203	80 c2 03	 add	 dl, 3
  00206	3a 55 f0	 cmp	 dl, BYTE PTR tv190[ebp]
  00209	7c 0c		 jl	 SHORT $LN13@erase
  0020b	8b 45 cc	 mov	 eax, DWORD PTR tv187[ebp]
  0020e	50		 push	 eax
  0020f	e8 00 00 00 00	 call	 ___asan_report_load4
  00214	83 c4 04	 add	 esp, 4
$LN13@erase:
  00217	8b 4d e8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0021a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0021c	83 ea 04	 sub	 edx, 4
  0021f	89 55 a8	 mov	 DWORD PTR tv150[ebp], edx
  00222	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00225	89 45 ac	 mov	 DWORD PTR tv174[ebp], eax
  00228	8b 4d ac	 mov	 ecx, DWORD PTR tv174[ebp]
  0022b	89 4d c8	 mov	 DWORD PTR tv177[ebp], ecx
  0022e	8b 55 c8	 mov	 edx, DWORD PTR tv177[ebp]
  00231	c1 ea 03	 shr	 edx, 3
  00234	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0023a	88 45 ef	 mov	 BYTE PTR tv180[ebp], al
  0023d	80 7d ef 00	 cmp	 BYTE PTR tv180[ebp], 0
  00241	74 1a		 je	 SHORT $LN12@erase
  00243	8a 4d c8	 mov	 cl, BYTE PTR tv177[ebp]
  00246	80 e1 07	 and	 cl, 7
  00249	80 c1 03	 add	 cl, 3
  0024c	3a 4d ef	 cmp	 cl, BYTE PTR tv180[ebp]
  0024f	7c 0c		 jl	 SHORT $LN12@erase
  00251	8b 55 c8	 mov	 edx, DWORD PTR tv177[ebp]
  00254	52		 push	 edx
  00255	e8 00 00 00 00	 call	 ___asan_report_store4
  0025a	83 c4 04	 add	 esp, 4
$LN12@erase:
  0025d	8b 45 e8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00260	8b 4d a8	 mov	 ecx, DWORD PTR tv150[ebp]
  00263	89 08		 mov	 DWORD PTR [eax], ecx

; 1422 :         return iterator(_Whereptr, _STD addressof(_My_data));

  00265	8b 55 e0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00268	52		 push	 edx
  00269	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<Block *> > >
  0026e	83 c4 04	 add	 esp, 4
  00271	50		 push	 eax
  00272	8b 45 e4	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00275	50		 push	 eax
  00276	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00279	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@PAPAVBlock@@PBU_Container_base12@1@@Z
  0027e	8d 4d 0c	 lea	 ecx, DWORD PTR __Where$[ebp]
  00281	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@std@@QAE@XZ
  00286	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1423 :     }

  00289	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0028c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00293	59		 pop	 ecx
  00294	5e		 pop	 esi
  00295	8b e5		 mov	 esp, ebp
  00297	5d		 pop	 ebp
  00298	c2 10 00	 ret	 16			; 00000010H
  0029b	cc		 int	 3
  0029c	cc		 int	 3
  0029d	cc		 int	 3
  0029e	cc		 int	 3
  0029f	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ac	 mov	 ecx, DWORD PTR [edx-84]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@PAVBlock@@@std@@@std@@@2@@Z ENDP ; std::vector<Block *,std::allocator<Block *> >::erase
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_GTerrain@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTerrain@@QAEPAXI@Z PROC				; Terrain::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Terrain@@QAE@XZ	; Terrain::~Terrain
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GTerrain@@QAEPAXI@Z ENDP				; Terrain::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@Terrain@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@Terrain@@QAEXI@Z PROC			; Terrain::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@Terrain@@QAEXI@Z ENDP			; Terrain::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getSizeY@Terrain@@QAEIXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv65 = -20						; size = 4
tv64 = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
?getSizeY@Terrain@@QAEIXZ PROC				; Terrain::getSizeY, COMDAT
; _this$ = ecx

; 25   : 	inline unsigned int getSizeY() { return TC->sizeY; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00035	74 1a		 je	 SHORT $LN4@getSizeY
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00043	7c 0c		 jl	 SHORT $LN4@getSizeY
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN4@getSizeY:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	83 c1 0c	 add	 ecx, 12			; 0000000cH
  00059	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  0005c	8b 55 ec	 mov	 edx, DWORD PTR tv65[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv74[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00075	74 1a		 je	 SHORT $LN3@getSizeY
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv71[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv74[ebp]
  00083	7c 0c		 jl	 SHORT $LN3@getSizeY
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN3@getSizeY:
  00091	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00094	8b 01		 mov	 eax, DWORD PTR [ecx]
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?getSizeY@Terrain@@QAEIXZ ENDP				; Terrain::getSizeY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getSizeX@Terrain@@QAEIXZ
_TEXT	SEGMENT
_this$ = -24						; size = 4
tv65 = -20						; size = 4
tv64 = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
?getSizeX@Terrain@@QAEIXZ PROC				; Terrain::getSizeX, COMDAT
; _this$ = ecx

; 24   : 	inline unsigned int getSizeX() { return TC->sizeX; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00035	74 1a		 je	 SHORT $LN4@getSizeX
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00043	7c 0c		 jl	 SHORT $LN4@getSizeX
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN4@getSizeX:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	83 c1 08	 add	 ecx, 8
  00059	89 4d ec	 mov	 DWORD PTR tv65[ebp], ecx
  0005c	8b 55 ec	 mov	 edx, DWORD PTR tv65[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv74[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00075	74 1a		 je	 SHORT $LN3@getSizeX
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv71[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv74[ebp]
  00083	7c 0c		 jl	 SHORT $LN3@getSizeX
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN3@getSizeX:
  00091	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00094	8b 01		 mov	 eax, DWORD PTR [ecx]
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
?getSizeX@Terrain@@QAEIXZ ENDP				; Terrain::getSizeX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getElementAtPos@Terrain@@QAEPAVBlock@@H@Z
_TEXT	SEGMENT
tv69 = -28						; size = 4
_this$ = -24						; size = 4
tv66 = -20						; size = 4
tv64 = -16						; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
_x$ = 8							; size = 4
?getElementAtPos@Terrain@@QAEPAVBlock@@H@Z PROC		; Terrain::getElementAtPos, COMDAT
; _this$ = ecx

; 22   : 	inline Block* getElementAtPos(int x) { return terrain->at(x); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv85[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv88[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@getElement
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv85[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv88[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@getElement
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN4@getElement:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	89 4d e4	 mov	 DWORD PTR tv69[ebp], ecx
  00056	8b 55 08	 mov	 edx, DWORD PTR _x$[ebp]
  00059	52		 push	 edx
  0005a	8b 4d e4	 mov	 ecx, DWORD PTR tv69[ebp]
  0005d	e8 00 00 00 00	 call	 ?at@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEAAPAVBlock@@I@Z ; std::vector<Block *,std::allocator<Block *> >::at
  00062	89 45 ec	 mov	 DWORD PTR tv66[ebp], eax
  00065	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  00068	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0006e	c1 e9 03	 shr	 ecx, 3
  00071	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00077	88 55 fe	 mov	 BYTE PTR tv78[ebp], dl
  0007a	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  0007e	74 18		 je	 SHORT $LN3@getElement
  00080	8a 45 f4	 mov	 al, BYTE PTR tv75[ebp]
  00083	24 07		 and	 al, 7
  00085	04 03		 add	 al, 3
  00087	3a 45 fe	 cmp	 al, BYTE PTR tv78[ebp]
  0008a	7c 0c		 jl	 SHORT $LN3@getElement
  0008c	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN3@getElement:
  00098	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  0009b	8b 02		 mov	 eax, DWORD PTR [edx]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 04 00	 ret	 4
?getElementAtPos@Terrain@@QAEPAVBlock@@H@Z ENDP		; Terrain::getElementAtPos
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getPlayer@Terrain@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
?getPlayer@Terrain@@QAEPAVPlayer@@XZ PROC		; Terrain::getPlayer, COMDAT
; _this$ = ecx

; 21   : 	inline Player* getPlayer() { return TC->getPlayer(); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@getPlayer
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@getPlayer
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@getPlayer:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	e8 00 00 00 00	 call	 ?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ ; TerrainConstructor::getPlayer
  0005b	8b e5		 mov	 esp, ebp
  0005d	5d		 pop	 ebp
  0005e	c3		 ret	 0
?getPlayer@Terrain@@QAEPAVPlayer@@XZ ENDP		; Terrain::getPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ PROC ; Terrain::getTerrain, COMDAT
; _this$ = ecx

; 20   : 	inline std::vector<Block*>* getTerrain() { return terrain; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@getTerrain
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@getTerrain
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@getTerrain:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ENDP ; Terrain::getTerrain
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\TerrainConstructor.h
;	COMDAT ?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ PROC	; TerrainConstructor::getPlayer, COMDAT
; _this$ = ecx

; 22   : 	inline Player* getPlayer() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __78BC29F0_TerrainConstructor@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 23   : 		return p;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@getPlayer
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@getPlayer
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@getPlayer:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 24   : 	}

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ ENDP	; TerrainConstructor::getPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Block.h
;	COMDAT ?getY@Block@@QAEMXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?getY@Block@@QAEMXZ PROC				; Block::getY, COMDAT
; _this$ = ecx

; 23   : 	inline float getY() { return _y; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9344C8DF_Block@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@getY
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@getY
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@getY:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	d9 00		 fld	 DWORD PTR [eax]
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?getY@Block@@QAEMXZ ENDP				; Block::getY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Block.h
;	COMDAT ?getX@Block@@QAEMXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?getX@Block@@QAEMXZ PROC				; Block::getX, COMDAT
; _this$ = ecx

; 22   : 	inline float getX() { return _x; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __9344C8DF_Block@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@getX
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@getX
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@getX:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	d9 00		 fld	 DWORD PTR [eax]
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?getX@Block@@QAEMXZ ENDP				; Block::getX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??__Flevel1@@YAXXZ
text$yd	SEGMENT
??__Flevel1@@YAXXZ PROC					; `dynamic atexit destructor for 'level1'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  00008	e8 00 00 00 00	 call	 ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Flevel1@@YAXXZ ENDP					; `dynamic atexit destructor for 'level1''
text$yd	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Levels.h
;	COMDAT ??__Elevel1@@YAXXZ
text$di	SEGMENT
__asan_gen_0$ = -2248					; size = 4
__asan_gen_1$ = -2244					; size = 4
__asan_gen_2$ = -2240					; size = 4
$T3 = -2232						; size = 224
$T4 = -1976						; size = 36
$T5 = -1904						; size = 36
$T6 = -1832						; size = 36
$T7 = -1760						; size = 36
$T8 = -1688						; size = 36
$T9 = -1616						; size = 36
$T10 = -1544						; size = 36
$T11 = -1472						; size = 36
$T12 = -1400						; size = 36
$T13 = -1328						; size = 36
$T14 = -1256						; size = 36
$T15 = -1184						; size = 36
$T16 = -1112						; size = 36
$T17 = -1040						; size = 36
$T18 = -968						; size = 1
$T19 = -952						; size = 1
$T20 = -936						; size = 8
$T21 = -920						; size = 1
$T22 = -904						; size = 8
$T23 = -888						; size = 1
$T24 = -872						; size = 8
$T25 = -856						; size = 1
$T26 = -840						; size = 8
$T27 = -824						; size = 1
$T28 = -808						; size = 8
$T29 = -792						; size = 1
$T30 = -776						; size = 8
$T31 = -760						; size = 1
$T32 = -744						; size = 8
$T33 = -728						; size = 1
$T34 = -712						; size = 8
$T35 = -696						; size = 1
$T36 = -680						; size = 8
$T37 = -664						; size = 1
$T38 = -648						; size = 8
$T39 = -632						; size = 1
$T40 = -616						; size = 8
$T41 = -600						; size = 1
$T42 = -584						; size = 8
$T43 = -568						; size = 1
$T44 = -552						; size = 8
$T45 = -536						; size = 1
$T46 = -520						; size = 8
$T47 = -504						; size = 8
tv1007 = -460						; size = 4
tv918 = -456						; size = 4
tv924 = -452						; size = 4
tv930 = -448						; size = 4
tv936 = -444						; size = 4
tv942 = -440						; size = 4
tv948 = -436						; size = 4
tv954 = -432						; size = 4
tv960 = -428						; size = 4
tv966 = -424						; size = 4
tv972 = -420						; size = 4
tv978 = -416						; size = 4
tv984 = -412						; size = 4
tv990 = -408						; size = 4
tv996 = -404						; size = 4
tv1002 = -400						; size = 4
tv919 = -396						; size = 4
tv1185 = -392						; size = 4
tv1172 = -388						; size = 4
tv1159 = -384						; size = 4
tv1146 = -380						; size = 4
tv1133 = -376						; size = 4
tv1120 = -372						; size = 4
tv1107 = -368						; size = 4
tv1094 = -364						; size = 4
tv1081 = -360						; size = 4
tv1068 = -356						; size = 4
tv1055 = -352						; size = 4
tv1042 = -348						; size = 4
tv1029 = -344						; size = 4
tv1016 = -340						; size = 4
tv916 = -336						; size = 4
tv923 = -332						; size = 4
tv928 = -328						; size = 4
tv929 = -324						; size = 4
tv934 = -320						; size = 4
tv935 = -316						; size = 4
tv940 = -312						; size = 4
tv941 = -308						; size = 4
tv946 = -304						; size = 4
tv947 = -300						; size = 4
tv952 = -296						; size = 4
tv953 = -292						; size = 4
tv958 = -288						; size = 4
tv959 = -284						; size = 4
tv964 = -280						; size = 4
tv965 = -276						; size = 4
tv970 = -272						; size = 4
tv971 = -268						; size = 4
tv976 = -264						; size = 4
tv977 = -260						; size = 4
tv982 = -256						; size = 4
tv983 = -252						; size = 4
tv988 = -248						; size = 4
tv989 = -244						; size = 4
tv994 = -240						; size = 4
tv995 = -236						; size = 4
tv1000 = -232						; size = 4
tv1001 = -228						; size = 4
tv1006 = -224						; size = 4
tv84 = -220						; size = 4
tv164 = -216						; size = 4
tv179 = -212						; size = 4
tv226 = -208						; size = 4
tv241 = -204						; size = 4
tv320 = -200						; size = 4
tv335 = -196						; size = 4
tv350 = -192						; size = 4
tv397 = -188						; size = 4
tv412 = -184						; size = 4
tv459 = -180						; size = 4
tv474 = -176						; size = 4
tv553 = -172						; size = 4
tv568 = -168						; size = 4
tv612 = -164						; size = 4
tv1195 = -160						; size = 4
tv1204 = -156						; size = 4
$T48 = -152						; size = 8
$T49 = -144						; size = 8
$T50 = -136						; size = 8
$T51 = -128						; size = 8
$T52 = -120						; size = 8
$T53 = -112						; size = 8
$T54 = -104						; size = 8
$T55 = -96						; size = 8
$T56 = -88						; size = 8
$T57 = -80						; size = 8
$T58 = -72						; size = 8
$T59 = -64						; size = 8
$T60 = -56						; size = 8
$T61 = -48						; size = 8
$T62 = -40						; size = 8
__$EHRec$ = -12						; size = 12
??__Elevel1@@YAXXZ PROC					; `dynamic initializer for 'level1'', COMDAT

; 19   : };

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??__Elevel1@@YAXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 30 f7 ff
	ff		 add	 esp, -2256		; fffff730H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 85 38 f7 ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00046	c7 85 3c f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??__Elevel1@@YAXXZ
  00050	c7 85 40 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??__Elevel1@@YAXXZ ; `dynamic initializer for 'level1''
  0005a	8d 85 38 f7 ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv916[ebp], eax
  00066	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv916[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv918[ebp], ecx
  0007b	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  00080	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR tv918[ebp]
  00086	66 89 10	 mov	 WORD PTR [eax], dx
  00089	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR tv918[ebp]
  0008f	83 c1 02	 add	 ecx, 2
  00092	89 8d 74 fe ff
	ff		 mov	 DWORD PTR tv919[ebp], ecx
  00098	6a 1c		 push	 28			; 0000001cH
  0009a	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR tv919[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000a6	83 c4 08	 add	 esp, 8
  000a9	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv919[ebp]
  000af	83 c0 1c	 add	 eax, 28			; 0000001cH
  000b2	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv923[ebp], eax
  000b8	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv923[ebp]
  000be	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  000c4	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  000ca	83 c2 22	 add	 edx, 34			; 00000022H
  000cd	89 95 3c fe ff
	ff		 mov	 DWORD PTR tv924[ebp], edx
  000d3	6a 04		 push	 4
  000d5	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR tv924[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e1	83 c4 08	 add	 esp, 8
  000e4	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR tv924[ebp]
  000ea	83 c1 04	 add	 ecx, 4
  000ed	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv928[ebp], ecx
  000f3	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv928[ebp]
  000f9	c6 02 04	 mov	 BYTE PTR [edx], 4
  000fc	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR tv924[ebp]
  00102	83 c0 05	 add	 eax, 5
  00105	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv929[ebp], eax
  0010b	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv929[ebp]
  00111	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00117	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0011d	83 c2 2b	 add	 edx, 43			; 0000002bH
  00120	89 95 40 fe ff
	ff		 mov	 DWORD PTR tv930[ebp], edx
  00126	6a 04		 push	 4
  00128	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00134	83 c4 08	 add	 esp, 8
  00137	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv930[ebp]
  0013d	83 c1 04	 add	 ecx, 4
  00140	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv934[ebp], ecx
  00146	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR tv934[ebp]
  0014c	c6 02 04	 mov	 BYTE PTR [edx], 4
  0014f	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  00155	83 c0 05	 add	 eax, 5
  00158	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv935[ebp], eax
  0015e	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv935[ebp]
  00164	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  0016a	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00170	83 c2 34	 add	 edx, 52			; 00000034H
  00173	89 95 44 fe ff
	ff		 mov	 DWORD PTR tv936[ebp], edx
  00179	6a 04		 push	 4
  0017b	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv936[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00187	83 c4 08	 add	 esp, 8
  0018a	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR tv936[ebp]
  00190	83 c1 04	 add	 ecx, 4
  00193	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv940[ebp], ecx
  00199	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv940[ebp]
  0019f	c6 02 04	 mov	 BYTE PTR [edx], 4
  001a2	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv936[ebp]
  001a8	83 c0 05	 add	 eax, 5
  001ab	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv941[ebp], eax
  001b1	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv941[ebp]
  001b7	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  001bd	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  001c3	83 c2 3d	 add	 edx, 61			; 0000003dH
  001c6	89 95 48 fe ff
	ff		 mov	 DWORD PTR tv942[ebp], edx
  001cc	6a 04		 push	 4
  001ce	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001da	83 c4 08	 add	 esp, 8
  001dd	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR tv942[ebp]
  001e3	83 c1 04	 add	 ecx, 4
  001e6	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv946[ebp], ecx
  001ec	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv946[ebp]
  001f2	c6 02 04	 mov	 BYTE PTR [edx], 4
  001f5	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  001fb	83 c0 05	 add	 eax, 5
  001fe	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv947[ebp], eax
  00204	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv947[ebp]
  0020a	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00210	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00216	83 c2 46	 add	 edx, 70			; 00000046H
  00219	89 95 4c fe ff
	ff		 mov	 DWORD PTR tv948[ebp], edx
  0021f	6a 04		 push	 4
  00221	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv948[ebp]
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022d	83 c4 08	 add	 esp, 8
  00230	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR tv948[ebp]
  00236	83 c1 04	 add	 ecx, 4
  00239	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv952[ebp], ecx
  0023f	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv952[ebp]
  00245	c6 02 04	 mov	 BYTE PTR [edx], 4
  00248	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv948[ebp]
  0024e	83 c0 05	 add	 eax, 5
  00251	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv953[ebp], eax
  00257	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv953[ebp]
  0025d	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00263	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00269	83 c2 4f	 add	 edx, 79			; 0000004fH
  0026c	89 95 50 fe ff
	ff		 mov	 DWORD PTR tv954[ebp], edx
  00272	6a 04		 push	 4
  00274	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv954[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00280	83 c4 08	 add	 esp, 8
  00283	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR tv954[ebp]
  00289	83 c1 04	 add	 ecx, 4
  0028c	89 8d e0 fe ff
	ff		 mov	 DWORD PTR tv958[ebp], ecx
  00292	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv958[ebp]
  00298	c6 02 04	 mov	 BYTE PTR [edx], 4
  0029b	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv954[ebp]
  002a1	83 c0 05	 add	 eax, 5
  002a4	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv959[ebp], eax
  002aa	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv959[ebp]
  002b0	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  002b6	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  002bc	83 c2 58	 add	 edx, 88			; 00000058H
  002bf	89 95 54 fe ff
	ff		 mov	 DWORD PTR tv960[ebp], edx
  002c5	6a 04		 push	 4
  002c7	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv960[ebp]
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002d3	83 c4 08	 add	 esp, 8
  002d6	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv960[ebp]
  002dc	83 c1 04	 add	 ecx, 4
  002df	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv964[ebp], ecx
  002e5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv964[ebp]
  002eb	c6 02 04	 mov	 BYTE PTR [edx], 4
  002ee	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv960[ebp]
  002f4	83 c0 05	 add	 eax, 5
  002f7	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv965[ebp], eax
  002fd	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv965[ebp]
  00303	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00309	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0030f	83 c2 61	 add	 edx, 97			; 00000061H
  00312	89 95 58 fe ff
	ff		 mov	 DWORD PTR tv966[ebp], edx
  00318	6a 04		 push	 4
  0031a	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv966[ebp]
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00326	83 c4 08	 add	 esp, 8
  00329	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv966[ebp]
  0032f	83 c1 04	 add	 ecx, 4
  00332	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv970[ebp], ecx
  00338	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv970[ebp]
  0033e	c6 02 04	 mov	 BYTE PTR [edx], 4
  00341	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv966[ebp]
  00347	83 c0 05	 add	 eax, 5
  0034a	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv971[ebp], eax
  00350	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv971[ebp]
  00356	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  0035c	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00362	83 c2 6a	 add	 edx, 106		; 0000006aH
  00365	89 95 5c fe ff
	ff		 mov	 DWORD PTR tv972[ebp], edx
  0036b	6a 04		 push	 4
  0036d	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv972[ebp]
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00379	83 c4 08	 add	 esp, 8
  0037c	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR tv972[ebp]
  00382	83 c1 04	 add	 ecx, 4
  00385	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv976[ebp], ecx
  0038b	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv976[ebp]
  00391	c6 02 04	 mov	 BYTE PTR [edx], 4
  00394	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv972[ebp]
  0039a	83 c0 05	 add	 eax, 5
  0039d	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv977[ebp], eax
  003a3	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR tv977[ebp]
  003a9	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  003af	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  003b5	83 c2 73	 add	 edx, 115		; 00000073H
  003b8	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv978[ebp], edx
  003be	6a 04		 push	 4
  003c0	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003cc	83 c4 08	 add	 esp, 8
  003cf	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR tv978[ebp]
  003d5	83 c1 04	 add	 ecx, 4
  003d8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv982[ebp], ecx
  003de	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv982[ebp]
  003e4	c6 02 04	 mov	 BYTE PTR [edx], 4
  003e7	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  003ed	83 c0 05	 add	 eax, 5
  003f0	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv983[ebp], eax
  003f6	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv983[ebp]
  003fc	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00402	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00408	83 c2 7c	 add	 edx, 124		; 0000007cH
  0040b	89 95 64 fe ff
	ff		 mov	 DWORD PTR tv984[ebp], edx
  00411	6a 04		 push	 4
  00413	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv984[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0041f	83 c4 08	 add	 esp, 8
  00422	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR tv984[ebp]
  00428	83 c1 04	 add	 ecx, 4
  0042b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv988[ebp], ecx
  00431	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR tv988[ebp]
  00437	c6 02 04	 mov	 BYTE PTR [edx], 4
  0043a	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv984[ebp]
  00440	83 c0 05	 add	 eax, 5
  00443	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv989[ebp], eax
  00449	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv989[ebp]
  0044f	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00455	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0045b	81 c2 85 00 00
	00		 add	 edx, 133		; 00000085H
  00461	89 95 68 fe ff
	ff		 mov	 DWORD PTR tv990[ebp], edx
  00467	6a 04		 push	 4
  00469	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  0046f	50		 push	 eax
  00470	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00475	83 c4 08	 add	 esp, 8
  00478	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv990[ebp]
  0047e	83 c1 04	 add	 ecx, 4
  00481	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv994[ebp], ecx
  00487	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv994[ebp]
  0048d	c6 02 04	 mov	 BYTE PTR [edx], 4
  00490	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  00496	83 c0 05	 add	 eax, 5
  00499	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv995[ebp], eax
  0049f	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv995[ebp]
  004a5	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  004ab	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  004b1	81 c2 8e 00 00
	00		 add	 edx, 142		; 0000008eH
  004b7	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv996[ebp], edx
  004bd	6a 04		 push	 4
  004bf	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv996[ebp]
  004c5	50		 push	 eax
  004c6	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  004cb	83 c4 08	 add	 esp, 8
  004ce	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv996[ebp]
  004d4	83 c1 04	 add	 ecx, 4
  004d7	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv1000[ebp], ecx
  004dd	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv1000[ebp]
  004e3	c6 02 04	 mov	 BYTE PTR [edx], 4
  004e6	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv996[ebp]
  004ec	83 c0 05	 add	 eax, 5
  004ef	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv1001[ebp], eax
  004f5	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv1001[ebp]
  004fb	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00501	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00507	81 c2 97 00 00
	00		 add	 edx, 151		; 00000097H
  0050d	89 95 70 fe ff
	ff		 mov	 DWORD PTR tv1002[ebp], edx
  00513	6a 04		 push	 4
  00515	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv1002[ebp]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00521	83 c4 08	 add	 esp, 8
  00524	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv1002[ebp]
  0052a	83 c1 04	 add	 ecx, 4
  0052d	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv1006[ebp], ecx
  00533	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv1006[ebp]
  00539	c6 02 04	 mov	 BYTE PTR [edx], 4
  0053c	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv1002[ebp]
  00542	83 c0 05	 add	 eax, 5
  00545	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv1007[ebp], eax
  0054b	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00551	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00557	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0055e	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  00564	c7 02 01 f2 01
	f2		 mov	 DWORD PTR [edx], -234753535 ; f201f201H
  0056a	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00571	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00577	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  0057d	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00584	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  0058a	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  00590	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00597	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  0059d	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  005a3	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005aa	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  005b0	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  005b6	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005bd	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  005c3	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  005c9	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005d0	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  005d6	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  005dc	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005e3	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  005e9	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  005ef	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005f6	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  005fc	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  00602	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00609	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  0060f	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  00615	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0061c	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00622	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  00628	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0062f	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00635	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  0063b	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00642	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  00648	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  0064e	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00655	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  0065b	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  00661	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00668	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  0066e	c7 01 00 f2 00
	f3		 mov	 DWORD PTR [ecx], -218041856 ; f300f200H
  00674	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0067b	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  00680	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00686	66 89 10	 mov	 WORD PTR [eax], dx
  00689	83 85 34 fe ff
	ff 02		 add	 DWORD PTR tv1007[ebp], 2
  00690	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00696	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00699	b9 00 00 00 00	 mov	 ecx, OFFSET __218DFE2C_Levels@h
  0069e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4    : inline std::vector<std::vector<int>> level1 = {

  006a3	6a 10		 push	 16			; 00000010H
  006a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  006aa	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
  006af	8d 8d 38 fc ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  006b5	e8 00 00 00 00	 call	 ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
  006ba	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv612[ebp], eax
  006c0	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  006c6	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  006cb	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  006d1	c7 85 48 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  006db	c7 85 4c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], 0
  006e5	c7 85 50 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+8], 0
  006ef	c7 85 54 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+12], 0
  006f9	c7 85 58 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0
  00703	c7 85 5c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 0
  0070d	c7 85 60 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+24], 0
  00717	c7 85 64 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+28], 0
  00721	c7 85 68 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+32], 0
  0072b	8d 95 48 f8 ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00731	83 c2 24	 add	 edx, 36			; 00000024H
  00734	52		 push	 edx
  00735	8d 85 48 f8 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0073b	50		 push	 eax
  0073c	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00742	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00747	6a 08		 push	 8
  00749	50		 push	 eax
  0074a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T48[ebp]
  00750	51		 push	 ecx
  00751	e8 00 00 00 00	 call	 ___asan_memcpy
  00756	83 c4 0c	 add	 esp, 12			; 0000000cH
  00759	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  0075f	52		 push	 edx
  00760	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T48[ebp+4]
  00766	50		 push	 eax
  00767	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T48[ebp]
  0076d	51		 push	 ecx
  0076e	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00774	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00779	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00780	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00786	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0078b	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv164[ebp], eax
  00791	c7 85 90 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  0079b	c7 85 94 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], 0
  007a5	c7 85 98 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+8], 0
  007af	c7 85 9c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+12], 0
  007b9	c7 85 a0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  007c3	c7 85 a4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 0
  007cd	c7 85 a8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+24], 0
  007d7	c7 85 ac f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+28], 0
  007e1	c7 85 b0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+32], 0
  007eb	8d 95 90 f8 ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  007f1	83 c2 24	 add	 edx, 36			; 00000024H
  007f4	52		 push	 edx
  007f5	8d 85 90 f8 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  007fb	50		 push	 eax
  007fc	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00802	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00807	6a 08		 push	 8
  00809	50		 push	 eax
  0080a	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp]
  00810	51		 push	 ecx
  00811	e8 00 00 00 00	 call	 ___asan_memcpy
  00816	83 c4 0c	 add	 esp, 12			; 0000000cH
  00819	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv164[ebp]
  0081f	52		 push	 edx
  00820	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T49[ebp+4]
  00826	50		 push	 eax
  00827	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T49[ebp]
  0082d	51		 push	 ecx
  0082e	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+16]
  00834	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00839	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0083d	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00843	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00848	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  0084e	c7 85 d8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  00858	c7 85 dc f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], 0
  00862	c7 85 e0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+8], 0
  0086c	c7 85 e4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+12], 0
  00876	c7 85 e8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  00880	c7 85 ec f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 0
  0088a	c7 85 f0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+24], 0
  00894	c7 85 f4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+28], 0
  0089e	c7 85 f8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+32], 0
  008a8	8d 95 d8 f8 ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  008ae	83 c2 24	 add	 edx, 36			; 00000024H
  008b1	52		 push	 edx
  008b2	8d 85 d8 f8 ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  008b8	50		 push	 eax
  008b9	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  008bf	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  008c4	6a 08		 push	 8
  008c6	50		 push	 eax
  008c7	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  008cd	51		 push	 ecx
  008ce	e8 00 00 00 00	 call	 ___asan_memcpy
  008d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  008d6	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv179[ebp]
  008dc	52		 push	 edx
  008dd	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T50[ebp+4]
  008e3	50		 push	 eax
  008e4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T50[ebp]
  008ea	51		 push	 ecx
  008eb	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+32]
  008f1	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  008f6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  008fa	8d 8d a8 fc ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00900	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00905	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  0090b	c7 85 20 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], 0
  00915	c7 85 24 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], 0
  0091f	c7 85 28 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+8], 0
  00929	c7 85 2c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+12], 0
  00933	c7 85 30 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  0093d	c7 85 34 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 0
  00947	c7 85 38 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+24], 0
  00951	c7 85 3c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+28], 0
  0095b	c7 85 40 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+32], 0
  00965	8d 95 20 f9 ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0096b	83 c2 24	 add	 edx, 36			; 00000024H
  0096e	52		 push	 edx
  0096f	8d 85 20 f9 ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00975	50		 push	 eax
  00976	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0097c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00981	6a 08		 push	 8
  00983	50		 push	 eax
  00984	8d 4d 80	 lea	 ecx, DWORD PTR $T51[ebp]
  00987	51		 push	 ecx
  00988	e8 00 00 00 00	 call	 ___asan_memcpy
  0098d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00990	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  00996	52		 push	 edx
  00997	8b 45 84	 mov	 eax, DWORD PTR $T51[ebp+4]
  0099a	50		 push	 eax
  0099b	8b 4d 80	 mov	 ecx, DWORD PTR $T51[ebp]
  0099e	51		 push	 ecx
  0099f	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+48]
  009a5	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  009aa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  009ae	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  009b4	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  009b9	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  009bf	c7 85 68 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], 0
  009c9	c7 85 6c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], 0
  009d3	c7 85 70 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+8], 0
  009dd	c7 85 74 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+12], 0
  009e7	c7 85 78 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  009f1	c7 85 7c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 0
  009fb	c7 85 80 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+24], 0
  00a05	c7 85 84 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+28], 0
  00a0f	c7 85 88 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+32], 0
  00a19	8d 95 68 f9 ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00a1f	83 c2 24	 add	 edx, 36			; 00000024H
  00a22	52		 push	 edx
  00a23	8d 85 68 f9 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00a29	50		 push	 eax
  00a2a	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00a30	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00a35	6a 08		 push	 8
  00a37	50		 push	 eax
  00a38	8d 4d 88	 lea	 ecx, DWORD PTR $T52[ebp]
  00a3b	51		 push	 ecx
  00a3c	e8 00 00 00 00	 call	 ___asan_memcpy
  00a41	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a44	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  00a4a	52		 push	 edx
  00a4b	8b 45 8c	 mov	 eax, DWORD PTR $T52[ebp+4]
  00a4e	50		 push	 eax
  00a4f	8b 4d 88	 mov	 ecx, DWORD PTR $T52[ebp]
  00a52	51		 push	 ecx
  00a53	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+64]
  00a59	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00a5e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00a62	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00a68	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00a6d	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv320[ebp], eax
  00a73	c7 85 b0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], 0
  00a7d	c7 85 b4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+4], 0
  00a87	c7 85 b8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+8], 0
  00a91	c7 85 bc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+12], 0
  00a9b	c7 85 c0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  00aa5	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 0
  00aaf	c7 85 c8 f9 ff
	ff 03 00 00 00	 mov	 DWORD PTR $T9[ebp+24], 3
  00ab9	c7 85 cc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+28], 0
  00ac3	c7 85 d0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+32], 0
  00acd	8d 95 b0 f9 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  00ad3	83 c2 24	 add	 edx, 36			; 00000024H
  00ad6	52		 push	 edx
  00ad7	8d 85 b0 f9 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00add	50		 push	 eax
  00ade	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  00ae4	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00ae9	6a 08		 push	 8
  00aeb	50		 push	 eax
  00aec	8d 4d 90	 lea	 ecx, DWORD PTR $T53[ebp]
  00aef	51		 push	 ecx
  00af0	e8 00 00 00 00	 call	 ___asan_memcpy
  00af5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00af8	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv320[ebp]
  00afe	52		 push	 edx
  00aff	8b 45 94	 mov	 eax, DWORD PTR $T53[ebp+4]
  00b02	50		 push	 eax
  00b03	8b 4d 90	 mov	 ecx, DWORD PTR $T53[ebp]
  00b06	51		 push	 ecx
  00b07	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+80]
  00b0d	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00b12	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00b16	8d 8d 08 fd ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  00b1c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00b21	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv335[ebp], eax
  00b27	c7 85 f8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp], 0
  00b31	c7 85 fc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+4], 0
  00b3b	c7 85 00 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+8], 0
  00b45	c7 85 04 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+12], 0
  00b4f	c7 85 08 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+16], 0
  00b59	c7 85 0c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+20], 0
  00b63	c7 85 10 fa ff
	ff 05 00 00 00	 mov	 DWORD PTR $T10[ebp+24], 5
  00b6d	c7 85 14 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+28], 0
  00b77	c7 85 18 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+32], 0
  00b81	8d 95 f8 f9 ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  00b87	83 c2 24	 add	 edx, 36			; 00000024H
  00b8a	52		 push	 edx
  00b8b	8d 85 f8 f9 ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00b91	50		 push	 eax
  00b92	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  00b98	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00b9d	6a 08		 push	 8
  00b9f	50		 push	 eax
  00ba0	8d 4d 98	 lea	 ecx, DWORD PTR $T54[ebp]
  00ba3	51		 push	 ecx
  00ba4	e8 00 00 00 00	 call	 ___asan_memcpy
  00ba9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bac	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv335[ebp]
  00bb2	52		 push	 edx
  00bb3	8b 45 9c	 mov	 eax, DWORD PTR $T54[ebp+4]
  00bb6	50		 push	 eax
  00bb7	8b 4d 98	 mov	 ecx, DWORD PTR $T54[ebp]
  00bba	51		 push	 ecx
  00bbb	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+96]
  00bc1	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00bc6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00bca	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00bd0	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00bd5	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv350[ebp], eax
  00bdb	c7 85 40 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp], 0
  00be5	c7 85 44 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+4], 0
  00bef	c7 85 48 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+8], 0
  00bf9	c7 85 4c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+12], 0
  00c03	c7 85 50 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  00c0d	c7 85 54 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 0
  00c17	c7 85 58 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T11[ebp+24], 3
  00c21	c7 85 5c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+28], 0
  00c2b	c7 85 60 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+32], 0
  00c35	8d 95 40 fa ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  00c3b	83 c2 24	 add	 edx, 36			; 00000024H
  00c3e	52		 push	 edx
  00c3f	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00c45	50		 push	 eax
  00c46	8d 8d 38 fd ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  00c4c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00c51	6a 08		 push	 8
  00c53	50		 push	 eax
  00c54	8d 4d a0	 lea	 ecx, DWORD PTR $T55[ebp]
  00c57	51		 push	 ecx
  00c58	e8 00 00 00 00	 call	 ___asan_memcpy
  00c5d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c60	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv350[ebp]
  00c66	52		 push	 edx
  00c67	8b 45 a4	 mov	 eax, DWORD PTR $T55[ebp+4]
  00c6a	50		 push	 eax
  00c6b	8b 4d a0	 mov	 ecx, DWORD PTR $T55[ebp]
  00c6e	51		 push	 ecx
  00c6f	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+112]
  00c75	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00c7a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00c7e	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  00c84	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00c89	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
  00c8f	c7 85 88 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp], 2
  00c99	c7 85 8c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+4], 0
  00ca3	c7 85 90 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+8], 0
  00cad	c7 85 94 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+12], 2
  00cb7	c7 85 98 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+16], 0
  00cc1	c7 85 9c fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+20], 2
  00ccb	c7 85 a0 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+24], 2
  00cd5	c7 85 a4 fa ff
	ff 06 00 00 00	 mov	 DWORD PTR $T12[ebp+28], 6
  00cdf	c7 85 a8 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+32], 2
  00ce9	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00cef	83 c2 24	 add	 edx, 36			; 00000024H
  00cf2	52		 push	 edx
  00cf3	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  00cf9	50		 push	 eax
  00cfa	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  00d00	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00d05	6a 08		 push	 8
  00d07	50		 push	 eax
  00d08	8d 4d a8	 lea	 ecx, DWORD PTR $T56[ebp]
  00d0b	51		 push	 ecx
  00d0c	e8 00 00 00 00	 call	 ___asan_memcpy
  00d11	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d14	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv397[ebp]
  00d1a	52		 push	 edx
  00d1b	8b 45 ac	 mov	 eax, DWORD PTR $T56[ebp+4]
  00d1e	50		 push	 eax
  00d1f	8b 4d a8	 mov	 ecx, DWORD PTR $T56[ebp]
  00d22	51		 push	 ecx
  00d23	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+128]
  00d29	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00d2e	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00d32	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR $T37[ebp]
  00d38	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00d3d	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv412[ebp], eax
  00d43	c7 85 d0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp], 0
  00d4d	c7 85 d4 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+4], 2
  00d57	c7 85 d8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+8], 0
  00d61	c7 85 dc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+12], 0
  00d6b	c7 85 e0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+16], 0
  00d75	c7 85 e4 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp+20], 3
  00d7f	c7 85 e8 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp+24], 3
  00d89	c7 85 ec fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+28], 2
  00d93	c7 85 f0 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+32], 2
  00d9d	8d 95 d0 fa ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  00da3	83 c2 24	 add	 edx, 36			; 00000024H
  00da6	52		 push	 edx
  00da7	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00dad	50		 push	 eax
  00dae	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  00db4	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00db9	6a 08		 push	 8
  00dbb	50		 push	 eax
  00dbc	8d 4d b0	 lea	 ecx, DWORD PTR $T57[ebp]
  00dbf	51		 push	 ecx
  00dc0	e8 00 00 00 00	 call	 ___asan_memcpy
  00dc5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dc8	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv412[ebp]
  00dce	52		 push	 edx
  00dcf	8b 45 b4	 mov	 eax, DWORD PTR $T57[ebp+4]
  00dd2	50		 push	 eax
  00dd3	8b 4d b0	 mov	 ecx, DWORD PTR $T57[ebp]
  00dd6	51		 push	 ecx
  00dd7	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+144]
  00ddd	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00de2	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00de6	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  00dec	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00df1	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  00df7	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp], 0
  00e01	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+4], 0
  00e0b	c7 85 20 fb ff
	ff 05 00 00 00	 mov	 DWORD PTR $T14[ebp+8], 5
  00e15	c7 85 24 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+12], 0
  00e1f	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0
  00e29	c7 85 2c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 0
  00e33	c7 85 30 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T14[ebp+24], 4
  00e3d	c7 85 34 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T14[ebp+28], 3
  00e47	c7 85 38 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+32], 0
  00e51	8d 95 18 fb ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  00e57	83 c2 24	 add	 edx, 36			; 00000024H
  00e5a	52		 push	 edx
  00e5b	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00e61	50		 push	 eax
  00e62	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR $T40[ebp]
  00e68	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00e6d	6a 08		 push	 8
  00e6f	50		 push	 eax
  00e70	8d 4d b8	 lea	 ecx, DWORD PTR $T58[ebp]
  00e73	51		 push	 ecx
  00e74	e8 00 00 00 00	 call	 ___asan_memcpy
  00e79	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e7c	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv459[ebp]
  00e82	52		 push	 edx
  00e83	8b 45 bc	 mov	 eax, DWORD PTR $T58[ebp+4]
  00e86	50		 push	 eax
  00e87	8b 4d b8	 mov	 ecx, DWORD PTR $T58[ebp]
  00e8a	51		 push	 ecx
  00e8b	8d 8d e8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+160]
  00e91	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00e96	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00e9a	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00ea0	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00ea5	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv474[ebp], eax
  00eab	c7 85 60 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp], 0
  00eb5	c7 85 64 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+4], 0
  00ebf	c7 85 68 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T15[ebp+8], 3
  00ec9	c7 85 6c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp+12], 2
  00ed3	c7 85 70 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR $T15[ebp+16], -1
  00edd	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 0
  00ee7	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+24], 0
  00ef1	c7 85 7c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp+28], 2
  00efb	c7 85 80 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+32], 0
  00f05	8d 95 60 fb ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00f0b	83 c2 24	 add	 edx, 36			; 00000024H
  00f0e	52		 push	 edx
  00f0f	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00f15	50		 push	 eax
  00f16	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00f1c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00f21	6a 08		 push	 8
  00f23	50		 push	 eax
  00f24	8d 4d c0	 lea	 ecx, DWORD PTR $T59[ebp]
  00f27	51		 push	 ecx
  00f28	e8 00 00 00 00	 call	 ___asan_memcpy
  00f2d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f30	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv474[ebp]
  00f36	52		 push	 edx
  00f37	8b 45 c4	 mov	 eax, DWORD PTR $T59[ebp+4]
  00f3a	50		 push	 eax
  00f3b	8b 4d c0	 mov	 ecx, DWORD PTR $T59[ebp]
  00f3e	51		 push	 ecx
  00f3f	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+176]
  00f45	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00f4a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00f4e	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00f54	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00f59	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv553[ebp], eax
  00f5f	c7 85 a8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp], 0
  00f69	c7 85 ac fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+4], 0
  00f73	c7 85 b0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T16[ebp+8], 2
  00f7d	c7 85 b4 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp+12], 4
  00f87	c7 85 b8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 3
  00f91	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 0
  00f9b	c7 85 c0 fb ff
	ff 64 00 00 00	 mov	 DWORD PTR $T16[ebp+24], 100 ; 00000064H
  00fa5	c7 85 c4 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp+28], 4
  00faf	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+32], 0
  00fb9	8d 95 a8 fb ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  00fbf	83 c2 24	 add	 edx, 36			; 00000024H
  00fc2	52		 push	 edx
  00fc3	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00fc9	50		 push	 eax
  00fca	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00fd0	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00fd5	6a 08		 push	 8
  00fd7	50		 push	 eax
  00fd8	8d 4d c8	 lea	 ecx, DWORD PTR $T60[ebp]
  00fdb	51		 push	 ecx
  00fdc	e8 00 00 00 00	 call	 ___asan_memcpy
  00fe1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe4	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv553[ebp]
  00fea	52		 push	 edx
  00feb	8b 45 cc	 mov	 eax, DWORD PTR $T60[ebp+4]
  00fee	50		 push	 eax
  00fef	8b 4d c8	 mov	 ecx, DWORD PTR $T60[ebp]
  00ff2	51		 push	 ecx
  00ff3	8d 8d 08 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+192]
  00ff9	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00ffe	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  01002	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  01008	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0100d	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv568[ebp], eax
  01013	c7 85 f0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp], 2
  0101d	c7 85 f4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+4], 2
  01027	c7 85 f8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+8], 3
  01031	c7 85 fc fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+12], 3
  0103b	c7 85 00 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 2
  01045	c7 85 04 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 3
  0104f	c7 85 08 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+24], 3
  01059	c7 85 0c fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+28], 2
  01063	c7 85 10 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR $T17[ebp+32], 4
  0106d	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T17[ebp]
  01073	83 c2 24	 add	 edx, 36			; 00000024H
  01076	52		 push	 edx
  01077	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0107d	50		 push	 eax
  0107e	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  01084	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  01089	6a 08		 push	 8
  0108b	50		 push	 eax
  0108c	8d 4d d0	 lea	 ecx, DWORD PTR $T61[ebp]
  0108f	51		 push	 ecx
  01090	e8 00 00 00 00	 call	 ___asan_memcpy
  01095	83 c4 0c	 add	 esp, 12			; 0000000cH
  01098	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv568[ebp]
  0109e	52		 push	 edx
  0109f	8b 45 d4	 mov	 eax, DWORD PTR $T61[ebp+4]
  010a2	50		 push	 eax
  010a3	8b 4d d0	 mov	 ecx, DWORD PTR $T61[ebp]
  010a6	51		 push	 ecx
  010a7	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+208]
  010ad	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  010b2	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  010b9	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  010bf	81 c2 e0 00 00
	00		 add	 edx, 224		; 000000e0H
  010c5	52		 push	 edx
  010c6	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  010cc	50		 push	 eax
  010cd	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  010d3	e8 00 00 00 00	 call	 ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
  010d8	6a 08		 push	 8
  010da	50		 push	 eax
  010db	8d 4d d8	 lea	 ecx, DWORD PTR $T62[ebp]
  010de	51		 push	 ecx
  010df	e8 00 00 00 00	 call	 ___asan_memcpy
  010e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  010e7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv612[ebp]
  010ed	52		 push	 edx
  010ee	8b 45 dc	 mov	 eax, DWORD PTR $T62[ebp+4]
  010f1	50		 push	 eax
  010f2	8b 4d d8	 mov	 ecx, DWORD PTR $T62[ebp]
  010f5	51		 push	 ecx
  010f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  010fb	e8 00 00 00 00	 call	 ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  01100	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01107	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0110c	6a 0e		 push	 14			; 0000000eH
  0110e	6a 10		 push	 16			; 00000010H
  01110	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  01116	52		 push	 edx
  01117	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0111c	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  01122	c1 e8 03	 shr	 eax, 3
  01125	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0112c	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  01132	c1 e9 03	 shr	 ecx, 3
  01135	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0113b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1195[ebp], ecx
  01141	6a 1c		 push	 28			; 0000001cH
  01143	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv1195[ebp]
  01149	52		 push	 edx
  0114a	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0114f	83 c4 08	 add	 esp, 8
  01152	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  01158	c1 e8 03	 shr	 eax, 3
  0115b	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01162	8d 8d 48 f8 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  01168	c1 e9 03	 shr	 ecx, 3
  0116b	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  01171	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv1185[ebp], ecx
  01177	6a 04		 push	 4
  01179	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR tv1185[ebp]
  0117f	52		 push	 edx
  01180	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01185	83 c4 08	 add	 esp, 8
  01188	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR tv1185[ebp]
  0118e	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01192	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  01198	c1 e9 03	 shr	 ecx, 3
  0119b	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  011a2	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR $T21[ebp]
  011a8	c1 ea 03	 shr	 edx, 3
  011ab	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  011b2	8d 85 90 f8 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  011b8	c1 e8 03	 shr	 eax, 3
  011bb	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  011c0	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv1172[ebp], eax
  011c6	6a 04		 push	 4
  011c8	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR tv1172[ebp]
  011ce	51		 push	 ecx
  011cf	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  011d4	83 c4 08	 add	 esp, 8
  011d7	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR tv1172[ebp]
  011dd	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  011e1	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  011e7	c1 e8 03	 shr	 eax, 3
  011ea	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  011f1	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  011f7	c1 e9 03	 shr	 ecx, 3
  011fa	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01201	8d 95 d8 f8 ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  01207	c1 ea 03	 shr	 edx, 3
  0120a	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  01210	89 95 80 fe ff
	ff		 mov	 DWORD PTR tv1159[ebp], edx
  01216	6a 04		 push	 4
  01218	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR tv1159[ebp]
  0121e	50		 push	 eax
  0121f	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01224	83 c4 08	 add	 esp, 8
  01227	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR tv1159[ebp]
  0122d	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  01231	8d 95 98 fc ff
	ff		 lea	 edx, DWORD PTR $T24[ebp]
  01237	c1 ea 03	 shr	 edx, 3
  0123a	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01241	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  01247	c1 e8 03	 shr	 eax, 3
  0124a	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01251	8d 8d 20 f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  01257	c1 e9 03	 shr	 ecx, 3
  0125a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  01260	89 8d 84 fe ff
	ff		 mov	 DWORD PTR tv1146[ebp], ecx
  01266	6a 04		 push	 4
  01268	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv1146[ebp]
  0126e	52		 push	 edx
  0126f	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01274	83 c4 08	 add	 esp, 8
  01277	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv1146[ebp]
  0127d	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01281	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  01287	c1 e9 03	 shr	 ecx, 3
  0128a	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01291	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR $T27[ebp]
  01297	c1 ea 03	 shr	 edx, 3
  0129a	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  012a1	8d 85 68 f9 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  012a7	c1 e8 03	 shr	 eax, 3
  012aa	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  012af	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv1133[ebp], eax
  012b5	6a 04		 push	 4
  012b7	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv1133[ebp]
  012bd	51		 push	 ecx
  012be	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  012c3	83 c4 08	 add	 esp, 8
  012c6	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv1133[ebp]
  012cc	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  012d0	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  012d6	c1 e8 03	 shr	 eax, 3
  012d9	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  012e0	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  012e6	c1 e9 03	 shr	 ecx, 3
  012e9	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  012f0	8d 95 b0 f9 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  012f6	c1 ea 03	 shr	 edx, 3
  012f9	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  012ff	89 95 8c fe ff
	ff		 mov	 DWORD PTR tv1120[ebp], edx
  01305	6a 04		 push	 4
  01307	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv1120[ebp]
  0130d	50		 push	 eax
  0130e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01313	83 c4 08	 add	 esp, 8
  01316	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR tv1120[ebp]
  0131c	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  01320	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR $T30[ebp]
  01326	c1 ea 03	 shr	 edx, 3
  01329	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01330	8d 85 08 fd ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  01336	c1 e8 03	 shr	 eax, 3
  01339	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01340	8d 8d f8 f9 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  01346	c1 e9 03	 shr	 ecx, 3
  01349	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0134f	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv1107[ebp], ecx
  01355	6a 04		 push	 4
  01357	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR tv1107[ebp]
  0135d	52		 push	 edx
  0135e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01363	83 c4 08	 add	 esp, 8
  01366	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv1107[ebp]
  0136c	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01370	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  01376	c1 e9 03	 shr	 ecx, 3
  01379	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01380	8d 95 28 fd ff
	ff		 lea	 edx, DWORD PTR $T33[ebp]
  01386	c1 ea 03	 shr	 edx, 3
  01389	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01390	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  01396	c1 e8 03	 shr	 eax, 3
  01399	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0139e	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv1094[ebp], eax
  013a4	6a 04		 push	 4
  013a6	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv1094[ebp]
  013ac	51		 push	 ecx
  013ad	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  013b2	83 c4 08	 add	 esp, 8
  013b5	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv1094[ebp]
  013bb	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  013bf	8d 85 38 fd ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  013c5	c1 e8 03	 shr	 eax, 3
  013c8	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  013cf	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  013d5	c1 e9 03	 shr	 ecx, 3
  013d8	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  013df	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  013e5	c1 ea 03	 shr	 edx, 3
  013e8	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  013ee	89 95 98 fe ff
	ff		 mov	 DWORD PTR tv1081[ebp], edx
  013f4	6a 04		 push	 4
  013f6	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv1081[ebp]
  013fc	50		 push	 eax
  013fd	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01402	83 c4 08	 add	 esp, 8
  01405	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv1081[ebp]
  0140b	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  0140f	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR $T36[ebp]
  01415	c1 ea 03	 shr	 edx, 3
  01418	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0141f	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR $T37[ebp]
  01425	c1 e8 03	 shr	 eax, 3
  01428	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0142f	8d 8d d0 fa ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  01435	c1 e9 03	 shr	 ecx, 3
  01438	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0143e	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv1068[ebp], ecx
  01444	6a 04		 push	 4
  01446	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv1068[ebp]
  0144c	52		 push	 edx
  0144d	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01452	83 c4 08	 add	 esp, 8
  01455	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv1068[ebp]
  0145b	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  0145f	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  01465	c1 e9 03	 shr	 ecx, 3
  01468	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  0146f	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR $T39[ebp]
  01475	c1 ea 03	 shr	 edx, 3
  01478	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0147f	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  01485	c1 e8 03	 shr	 eax, 3
  01488	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0148d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv1055[ebp], eax
  01493	6a 04		 push	 4
  01495	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1055[ebp]
  0149b	51		 push	 ecx
  0149c	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  014a1	83 c4 08	 add	 esp, 8
  014a4	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR tv1055[ebp]
  014aa	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  014ae	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR $T40[ebp]
  014b4	c1 e8 03	 shr	 eax, 3
  014b7	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  014be	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  014c4	c1 e9 03	 shr	 ecx, 3
  014c7	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  014ce	8d 95 60 fb ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  014d4	c1 ea 03	 shr	 edx, 3
  014d7	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  014dd	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv1042[ebp], edx
  014e3	6a 04		 push	 4
  014e5	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv1042[ebp]
  014eb	50		 push	 eax
  014ec	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  014f1	83 c4 08	 add	 esp, 8
  014f4	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv1042[ebp]
  014fa	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  014fe	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR $T42[ebp]
  01504	c1 ea 03	 shr	 edx, 3
  01507	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0150e	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  01514	c1 e8 03	 shr	 eax, 3
  01517	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0151e	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  01524	c1 e9 03	 shr	 ecx, 3
  01527	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0152d	89 8d a8 fe ff
	ff		 mov	 DWORD PTR tv1029[ebp], ecx
  01533	6a 04		 push	 4
  01535	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR tv1029[ebp]
  0153b	52		 push	 edx
  0153c	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01541	83 c4 08	 add	 esp, 8
  01544	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv1029[ebp]
  0154a	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  0154e	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  01554	c1 e9 03	 shr	 ecx, 3
  01557	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  0155e	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR $T45[ebp]
  01564	c1 ea 03	 shr	 edx, 3
  01567	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0156e	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01574	c1 e8 03	 shr	 eax, 3
  01577	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0157c	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv1016[ebp], eax
  01582	6a 04		 push	 4
  01584	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv1016[ebp]
  0158a	51		 push	 ecx
  0158b	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01590	83 c4 08	 add	 esp, 8
  01593	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv1016[ebp]
  01599	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  0159d	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR $T46[ebp]
  015a3	c1 e8 03	 shr	 eax, 3
  015a6	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  015ad	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  015b3	c1 e9 03	 shr	 ecx, 3
  015b6	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  015bd	68 00 00 00 00	 push	 OFFSET ??__Flevel1@@YAXXZ ; `dynamic atexit destructor for 'level1''
  015c2	e8 00 00 00 00	 call	 _atexit
  015c7	83 c4 04	 add	 esp, 4
  015ca	c7 85 38 f7 ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  015d4	8d 95 38 f7 ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  015da	c1 ea 03	 shr	 edx, 3
  015dd	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  015e3	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1204[ebp], edx
  015e9	68 df 00 00 00	 push	 223			; 000000dfH
  015ee	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv1204[ebp]
  015f4	50		 push	 eax
  015f5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  015fa	83 c4 08	 add	 esp, 8
  015fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01600	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01607	59		 pop	 ecx
  01608	8b e5		 mov	 esp, ebp
  0160a	5d		 pop	 ebp
  0160b	8b e3		 mov	 esp, ebx
  0160d	5b		 pop	 ebx
  0160e	c3		 ret	 0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Elevel1@@YAXXZ$0:
  00000	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$1:
  0000b	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+16]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$2:
  00016	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+32]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$3:
  00021	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+48]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$4:
  0002c	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+64]
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$5:
  00037	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+80]
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$6:
  00042	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+96]
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$7:
  0004d	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+112]
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$8:
  00058	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+128]
  0005e	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$9:
  00063	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+144]
  00069	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$10:
  0006e	8d 8d e8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+160]
  00074	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$11:
  00079	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+176]
  0007f	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$12:
  00084	8d 8d 08 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+192]
  0008a	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$14:
  0008f	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00094	6a 0e		 push	 14			; 0000000eH
  00096	6a 10		 push	 16			; 00000010H
  00098	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000a4	c3		 ret	 0
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
__ehhandler$??__Elevel1@@YAXXZ:
  000aa	90		 npad	 1
  000ab	90		 npad	 1
  000ac	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000b0	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000b3	8b 8a 28 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2264]
  000b9	33 c8		 xor	 ecx, eax
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Elevel1@@YAXXZ
  000c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Elevel1@@YAXXZ ENDP					; `dynamic initializer for 'level1''
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >, COMDAT

; 719  :     static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 720  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 721  :         _STD destroy_at(_Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
  00016	83 c4 04	 add	 esp, 4

; 722  : #else // __cpp_lib_constexpr_dynamic_alloc
; 723  :         _Ptr->~_Uty();
; 724  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 725  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {

  0002c	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	83 c0 10	 add	 eax, 16			; 00000010H
  00034	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003a	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0003d	74 1b		 je	 SHORT $LN5@Destroy_ra

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
  00055	83 c4 08	 add	 esp, 8

; 951  :         }

  00058	eb d4		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 952  :     }
; 953  : }

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z PROC		; std::construct_at<int,int &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ENDP		; std::construct_at<int,int &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ; std::construct_at<int,int &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z PROC		; std::_Get_unwrapped<int * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ENDP		; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z PROC ; std::forward<std::allocator<int> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ENDP ; std::forward<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv78 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z PROC ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 10		 push	 16			; 00000010H
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR tv78[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00040	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 145  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ENDP ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv85 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	eb 35		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00040	83 c4 04	 add	 esp, 4
  00043	50		 push	 eax
  00044	6a 10		 push	 16			; 00000010H
  00046	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 fc	 mov	 DWORD PTR tv85[ebp], eax
  00060	8b 55 fc	 mov	 edx, DWORD PTR tv85[ebp]
  00063	52		 push	 edx
  00064	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00067	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z PROC ; std::_Unfancy<std::vector<int,std::allocator<int> > >, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 10	 add	 eax, 16			; 00000010H
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
__Backout$ = -112					; size = 12
tv86 = -64						; size = 4
__UFirst$ = -60						; size = 4
tv84 = -56						; size = 4
__ULast$ = -52						; size = 4
$T3 = -48						; size = 4
tv89 = -44						; size = 4
tv71 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00043	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0004a	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  00051	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00054	89 45 c8	 mov	 DWORD PTR tv84[ebp], eax
  00057	8b 4d c8	 mov	 ecx, DWORD PTR tv84[ebp]
  0005a	c1 e9 03	 shr	 ecx, 3
  0005d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00063	89 4d c0	 mov	 DWORD PTR tv86[ebp], ecx
  00066	8b 55 c0	 mov	 edx, DWORD PTR tv86[ebp]
  00069	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0006f	83 45 c0 04	 add	 DWORD PTR tv86[ebp], 4
  00073	8b 45 c0	 mov	 eax, DWORD PTR tv86[ebp]
  00076	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00081	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00086	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 c4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00095	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0009e	83 c4 04	 add	 esp, 4
  000a1	89 45 cc	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())
; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1664 :             _Dest += _ULast - _UFirst;
; 1665 :             return _Dest;
; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000a4	6a 0c		 push	 12			; 0000000cH
  000a6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000a9	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
  000ae	8b 43 14	 mov	 eax, DWORD PTR __Al$[ebx]
  000b1	50		 push	 eax
  000b2	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000b5	51		 push	 ecx
  000b6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b9	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  000c5	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000c7	8b 55 c4	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000ca	83 c2 10	 add	 edx, 16			; 00000010H
  000cd	89 55 c4	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  000d0	8b 45 c4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d3	3b 45 cc	 cmp	 eax, DWORD PTR __ULast$[ebp]
  000d6	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000d8	8b 4d c4	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000db	51		 push	 ecx
  000dc	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000df	e8 00 00 00 00	 call	 ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>

; 1672 :     }

  000e4	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000e6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000e9	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
  000ee	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  000f1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f8	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000fb	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00100	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp]
  00103	89 55 d8	 mov	 DWORD PTR tv71[ebp], edx
  00106	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0010d	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00110	c1 e8 03	 shr	 eax, 3
  00113	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00118	89 45 d4	 mov	 DWORD PTR tv89[ebp], eax
  0011b	6a 08		 push	 8
  0011d	8b 4d d4	 mov	 ecx, DWORD PTR tv89[ebp]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00126	83 c4 08	 add	 esp, 8
  00129	8b 45 d8	 mov	 eax, DWORD PTR tv71[ebp]

; 1675 : }

  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	8b e3		 mov	 esp, ebx
  00146	5b		 pop	 ebx
  00147	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0:
  00000	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z PROC ; std::distance<std::vector<int,std::allocator<int> > const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 04	 sar	 eax, 4

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ENDP ; std::distance<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Guard$3 = -136					; size = 4
tv172 = -92						; size = 1
tv162 = -91						; size = 1
tv152 = -90						; size = 1
tv142 = -89						; size = 1
tv94 = -88						; size = 4
_this$ = -84						; size = 4
tv169 = -80						; size = 4
tv159 = -76						; size = 4
tv149 = -72						; size = 4
tv139 = -68						; size = 4
__Count$ = -64						; size = 4
tv78 = -60						; size = 4
__My_data$4 = -56					; size = 4
tv75 = -52						; size = 4
tv92 = -48						; size = 4
tv77 = -44						; size = 4
tv135 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  00056	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
  00060	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  00069	8b 4d d0	 mov	 ecx, DWORD PTR tv92[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d a8	 mov	 DWORD PTR tv94[ebp], ecx
  00078	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  0007b	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00081	83 45 a8 04	 add	 DWORD PTR tv94[ebp], 4
  00085	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0008a	8b 4d a8	 mov	 ecx, DWORD PTR tv94[ebp]
  0008d	66 89 01	 mov	 WORD PTR [ecx], ax
  00090	83 45 a8 02	 add	 DWORD PTR tv94[ebp], 2
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  00097	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0009f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  000a4	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000a7	50		 push	 eax
  000a8	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 c0	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  000c0	83 7d c0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000c4	0f 84 69 01 00
	00		 je	 $LN1@Range_cons
  000ca	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 527  :             _Buy_nonzero(_Count);

  000da	8b 45 c0	 mov	 eax, DWORD PTR __Count$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  000e6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ec	89 4d b0	 mov	 DWORD PTR tv169[ebp], ecx
  000ef	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 a4	 mov	 BYTE PTR tv172[ebp], al
  000fe	80 7d a4 00	 cmp	 BYTE PTR tv172[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@Range_cons
  00104	8a 4d b0	 mov	 cl, BYTE PTR tv169[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d a4	 cmp	 cl, BYTE PTR tv172[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@Range_cons
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN8@Range_cons:
  0011e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Guard$3[ebp], eax
  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0012e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	89 4d c8	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00134	8b 55 c8	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00137	83 c2 04	 add	 edx, 4
  0013a	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00140	89 45 b4	 mov	 DWORD PTR tv159[ebp], eax
  00143	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	c1 e9 03	 shr	 ecx, 3
  00149	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0014f	88 55 a5	 mov	 BYTE PTR tv162[ebp], dl
  00152	80 7d a5 00	 cmp	 BYTE PTR tv162[ebp], 0
  00156	74 18		 je	 SHORT $LN7@Range_cons
  00158	8a 45 b4	 mov	 al, BYTE PTR tv159[ebp]
  0015b	24 07		 and	 al, 7
  0015d	04 03		 add	 al, 3
  0015f	3a 45 a5	 cmp	 al, BYTE PTR tv162[ebp]
  00162	7c 0c		 jl	 SHORT $LN7@Range_cons
  00164	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ___asan_report_load4
  0016d	83 c4 04	 add	 esp, 4
$LN7@Range_cons:
  00170	8b 55 c4	 mov	 edx, DWORD PTR tv78[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	50		 push	 eax
  00176	8b 4b 0c	 mov	 ecx, DWORD PTR __Last$[ebx]
  00179	51		 push	 ecx
  0017a	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  0017d	52		 push	 edx
  0017e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
  00186	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00189	8b 45 c8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	89 45 cc	 mov	 DWORD PTR tv75[ebp], eax
  00192	8b 4d cc	 mov	 ecx, DWORD PTR tv75[ebp]
  00195	89 4d b8	 mov	 DWORD PTR tv149[ebp], ecx
  00198	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  0019b	c1 ea 03	 shr	 edx, 3
  0019e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001a4	88 45 a6	 mov	 BYTE PTR tv152[ebp], al
  001a7	80 7d a6 00	 cmp	 BYTE PTR tv152[ebp], 0
  001ab	74 1a		 je	 SHORT $LN6@Range_cons
  001ad	8a 4d b8	 mov	 cl, BYTE PTR tv149[ebp]
  001b0	80 e1 07	 and	 cl, 7
  001b3	80 c1 03	 add	 cl, 3
  001b6	3a 4d a6	 cmp	 cl, BYTE PTR tv152[ebp]
  001b9	7c 0c		 jl	 SHORT $LN6@Range_cons
  001bb	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 ___asan_report_store4
  001c4	83 c4 04	 add	 esp, 4
$LN6@Range_cons:
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv75[ebp]
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  001cd	89 08		 mov	 DWORD PTR [eax], ecx

; 531  :             _Guard._Target   = nullptr;

  001cf	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  001d5	89 55 bc	 mov	 DWORD PTR tv139[ebp], edx
  001d8	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d a7	 mov	 BYTE PTR tv142[ebp], cl
  001e7	80 7d a7 00	 cmp	 BYTE PTR tv142[ebp], 0
  001eb	74 1a		 je	 SHORT $LN5@Range_cons
  001ed	8a 55 bc	 mov	 dl, BYTE PTR tv139[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 a7	 cmp	 dl, BYTE PTR tv142[ebp]
  001f9	7c 0c		 jl	 SHORT $LN5@Range_cons
  001fb	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN5@Range_cons:
  00207	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  00211	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00218	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0021e	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN1@Range_cons:

; 533  :     }

  00233	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0023d	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00243	c1 ea 03	 shr	 edx, 3
  00246	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0024c	89 55 d8	 mov	 DWORD PTR tv135[ebp], edx
  0024f	6a 07		 push	 7
  00251	8b 45 d8	 mov	 eax, DWORD PTR tv135[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025a	83 c4 08	 add	 esp, 8
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	59		 pop	 ecx
  00268	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	8b e3		 mov	 esp, ebx
  00277	5b		 pop	 ebx
  00278	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : _CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 999  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1000 :     using _Ty = typename _Alloc::value_type;
; 1001 :     _Ptr->~_Ty();
; 1002 :     _Deallocate_plain(_Al, _Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0001a	83 c4 08	 add	 esp, 8

; 1003 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z PROC		; std::_Voidify_iter<int *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ENDP		; std::_Voidify_iter<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HABHX@std@@YAPAHQAHABH@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HABHX@std@@YAPAHQAHABH@Z PROC		; std::construct_at<int,int const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@HABHX@std@@YAPAHQAHABH@Z ENDP		; std::construct_at<int,int const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@HABHX@std@@YAPAHQAHABH@Z ; std::construct_at<int,int const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z PROC	; std::_Copy_memmove<int const *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ENDP	; std::_Copy_memmove<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@H@std@@YAPAHQAH@Z PROC			; std::to_address<int>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@H@std@@YAPAHQAH@Z ENDP			; std::to_address<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@$$CBH@std@@YAPBHQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@$$CBH@std@@YAPBHQBH@Z PROC		; std::to_address<int const >, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@$$CBH@std@@YAPBHQBH@Z ENDP		; std::to_address<int const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z PROC		; std::_Get_unwrapped<int const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ENDP		; std::_Get_unwrapped<int const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int const *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ; std::_Copy_memmove<int const *,int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int const *,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
tv67 = -20						; size = 4
tv65 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 66   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 67   :     // return smaller of _Left and _Right
; 68   :     return _Right < _Left ? _Right : _Left;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@min
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@min
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@min:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv70[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv76[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@min
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv73[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv76[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@min
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@min:
  00086	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	73 08		 jae	 SHORT $LN3@min
  00092	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00098	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009d	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  000a3	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000a6	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 69   : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBH@std@@YAHPBH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBH@std@@YAHPBH0@Z PROC			; std::distance<int const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 02	 sar	 eax, 2

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$distance@PBH@std@@YAHPBH0@Z ENDP			; std::distance<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z PROC ; std::_Voidify_iter<std::_Container_proxy *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ENDP ; std::_Voidify_iter<std::_Container_proxy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv78 = -16						; size = 4
tv74 = -12						; size = 4
tv82 = -8						; size = 4
tv85 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 08		 push	 8
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv85[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00052	74 1a		 je	 SHORT $LN3@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv82[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv85[ebp]
  00060	7c 0c		 jl	 SHORT $LN3@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN3@construct_:
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
  00076	8b 45 f0	 mov	 eax, DWORD PTR tv78[ebp]
  00079	50		 push	 eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0007d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 145  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Guard$3 = -136					; size = 4
tv172 = -92						; size = 1
tv162 = -91						; size = 1
tv152 = -90						; size = 1
tv142 = -89						; size = 1
tv94 = -88						; size = 4
_this$ = -84						; size = 4
tv169 = -80						; size = 4
tv159 = -76						; size = 4
tv149 = -72						; size = 4
tv139 = -68						; size = 4
__Count$ = -64						; size = 4
tv78 = -60						; size = 4
__My_data$4 = -56					; size = 4
tv75 = -52						; size = 4
tv92 = -48						; size = 4
tv77 = -44						; size = 4
tv135 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  00056	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
  00060	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  00069	8b 4d d0	 mov	 ecx, DWORD PTR tv92[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d a8	 mov	 DWORD PTR tv94[ebp], ecx
  00078	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  0007b	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00081	83 45 a8 04	 add	 DWORD PTR tv94[ebp], 4
  00085	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0008a	8b 4d a8	 mov	 ecx, DWORD PTR tv94[ebp]
  0008d	66 89 01	 mov	 WORD PTR [ecx], ax
  00090	83 45 a8 02	 add	 DWORD PTR tv94[ebp], 2
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  00097	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0009f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  000a4	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000a7	50		 push	 eax
  000a8	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$distance@PBH@std@@YAHPBH0@Z ; std::distance<int const *>
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 c0	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  000c0	83 7d c0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000c4	0f 84 69 01 00
	00		 je	 $LN1@Range_cons
  000ca	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 527  :             _Buy_nonzero(_Count);

  000da	8b 45 c0	 mov	 eax, DWORD PTR __Count$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  000e6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ec	89 4d b0	 mov	 DWORD PTR tv169[ebp], ecx
  000ef	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 a4	 mov	 BYTE PTR tv172[ebp], al
  000fe	80 7d a4 00	 cmp	 BYTE PTR tv172[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@Range_cons
  00104	8a 4d b0	 mov	 cl, BYTE PTR tv169[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d a4	 cmp	 cl, BYTE PTR tv172[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@Range_cons
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN8@Range_cons:
  0011e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Guard$3[ebp], eax
  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0012e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	89 4d c8	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00134	8b 55 c8	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00137	83 c2 04	 add	 edx, 4
  0013a	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00140	89 45 b4	 mov	 DWORD PTR tv159[ebp], eax
  00143	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	c1 e9 03	 shr	 ecx, 3
  00149	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0014f	88 55 a5	 mov	 BYTE PTR tv162[ebp], dl
  00152	80 7d a5 00	 cmp	 BYTE PTR tv162[ebp], 0
  00156	74 18		 je	 SHORT $LN7@Range_cons
  00158	8a 45 b4	 mov	 al, BYTE PTR tv159[ebp]
  0015b	24 07		 and	 al, 7
  0015d	04 03		 add	 al, 3
  0015f	3a 45 a5	 cmp	 al, BYTE PTR tv162[ebp]
  00162	7c 0c		 jl	 SHORT $LN7@Range_cons
  00164	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ___asan_report_load4
  0016d	83 c4 04	 add	 esp, 4
$LN7@Range_cons:
  00170	8b 55 c4	 mov	 edx, DWORD PTR tv78[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	50		 push	 eax
  00176	8b 4b 0c	 mov	 ecx, DWORD PTR __Last$[ebx]
  00179	51		 push	 ecx
  0017a	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  0017d	52		 push	 edx
  0017e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
  00186	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00189	8b 45 c8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	89 45 cc	 mov	 DWORD PTR tv75[ebp], eax
  00192	8b 4d cc	 mov	 ecx, DWORD PTR tv75[ebp]
  00195	89 4d b8	 mov	 DWORD PTR tv149[ebp], ecx
  00198	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  0019b	c1 ea 03	 shr	 edx, 3
  0019e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001a4	88 45 a6	 mov	 BYTE PTR tv152[ebp], al
  001a7	80 7d a6 00	 cmp	 BYTE PTR tv152[ebp], 0
  001ab	74 1a		 je	 SHORT $LN6@Range_cons
  001ad	8a 4d b8	 mov	 cl, BYTE PTR tv149[ebp]
  001b0	80 e1 07	 and	 cl, 7
  001b3	80 c1 03	 add	 cl, 3
  001b6	3a 4d a6	 cmp	 cl, BYTE PTR tv152[ebp]
  001b9	7c 0c		 jl	 SHORT $LN6@Range_cons
  001bb	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 ___asan_report_store4
  001c4	83 c4 04	 add	 esp, 4
$LN6@Range_cons:
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv75[ebp]
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  001cd	89 08		 mov	 DWORD PTR [eax], ecx

; 531  :             _Guard._Target   = nullptr;

  001cf	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  001d5	89 55 bc	 mov	 DWORD PTR tv139[ebp], edx
  001d8	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d a7	 mov	 BYTE PTR tv142[ebp], cl
  001e7	80 7d a7 00	 cmp	 BYTE PTR tv142[ebp], 0
  001eb	74 1a		 je	 SHORT $LN5@Range_cons
  001ed	8a 55 bc	 mov	 dl, BYTE PTR tv139[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 a7	 cmp	 dl, BYTE PTR tv142[ebp]
  001f9	7c 0c		 jl	 SHORT $LN5@Range_cons
  001fb	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN5@Range_cons:
  00207	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  00211	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00218	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0021e	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN1@Range_cons:

; 533  :     }

  00233	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0023d	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00243	c1 ea 03	 shr	 edx, 3
  00246	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0024c	89 55 d8	 mov	 DWORD PTR tv135[ebp], edx
  0024f	6a 07		 push	 7
  00251	8b 45 d8	 mov	 eax, DWORD PTR tv135[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025a	83 c4 08	 add	 esp, 8
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	59		 pop	 ecx
  00268	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	8b e3		 mov	 esp, ebx
  00277	5b		 pop	 ebx
  00278	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv79 = -16						; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
tv85 = -1						; size = 1
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1353 :     _CONSTEXPR20_CONTAINER ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1354 :         if (_Ptr) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv79[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv82[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv85[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv82[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv85[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 15		 je	 SHORT $LN3@Container_

; 1355 :             _Delete_plain_internal(_Al, _Ptr);

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	52		 push	 edx
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00068	83 c4 08	 add	 esp, 8
$LN3@Container_:

; 1356 :         }
; 1357 :     }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
$T2 = -112						; size = 4
tv199 = -69						; size = 1
tv189 = -68						; size = 1
tv179 = -67						; size = 1
tv169 = -66						; size = 1
tv159 = -65						; size = 1
_this$ = -64						; size = 4
tv146 = -60						; size = 4
tv196 = -56						; size = 4
tv186 = -52						; size = 4
tv176 = -48						; size = 4
tv166 = -44						; size = 4
tv156 = -40						; size = 4
tv69 = -36						; size = 4
tv92 = -32						; size = 4
tv144 = -28						; size = 4
tv134 = -24						; size = 4
tv75 = -20						; size = 4
tv83 = -16						; size = 4
tv139 = -12						; size = 4
tv152 = -8						; size = 4
tv131 = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1339 :     _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
  0002d	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00034	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e4	 mov	 DWORD PTR tv144[ebp], eax
  0003a	8b 4d e4	 mov	 ecx, DWORD PTR tv144[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d c4	 mov	 DWORD PTR tv146[ebp], ecx
  00049	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  0004c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00052	83 45 c4 04	 add	 DWORD PTR tv146[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d c4	 mov	 ecx, DWORD PTR tv146[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 c4 02	 add	 DWORD PTR tv146[ebp], 2
  00065	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00070	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00075	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0007d	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 c0 04	 add	 eax, 4
  00083	89 45 dc	 mov	 DWORD PTR tv69[ebp], eax
  00086	8b 4d dc	 mov	 ecx, DWORD PTR tv69[ebp]
  00089	89 4d c8	 mov	 DWORD PTR tv196[ebp], ecx
  0008c	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  0008f	c1 ea 03	 shr	 edx, 3
  00092	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00098	88 45 bb	 mov	 BYTE PTR tv199[ebp], al
  0009b	80 7d bb 00	 cmp	 BYTE PTR tv199[ebp], 0
  0009f	74 1a		 je	 SHORT $LN7@Container_
  000a1	8a 4d c8	 mov	 cl, BYTE PTR tv196[ebp]
  000a4	80 e1 07	 and	 cl, 7
  000a7	80 c1 03	 add	 cl, 3
  000aa	3a 4d bb	 cmp	 cl, BYTE PTR tv199[ebp]
  000ad	7c 0c		 jl	 SHORT $LN7@Container_
  000af	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ___asan_report_store4
  000b8	83 c4 04	 add	 esp, 4
$LN7@Container_:
  000bb	8b 45 dc	 mov	 eax, DWORD PTR tv69[ebp]
  000be	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c1	89 08		 mov	 DWORD PTR [eax], ecx

; 1340 :         // create a new _Container_proxy pointing at _Mycont
; 1341 :         _Ptr = _Unfancy(_Al_.allocate(1));

  000c3	6a 01		 push	 1
  000c5	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  000d3	83 c4 04	 add	 esp, 4
  000d6	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  000d9	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000dc	89 55 e8	 mov	 DWORD PTR tv134[ebp], edx
  000df	8b 45 e8	 mov	 eax, DWORD PTR tv134[ebp]
  000e2	89 45 cc	 mov	 DWORD PTR tv186[ebp], eax
  000e5	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  000e8	c1 e9 03	 shr	 ecx, 3
  000eb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f1	88 55 bc	 mov	 BYTE PTR tv189[ebp], dl
  000f4	80 7d bc 00	 cmp	 BYTE PTR tv189[ebp], 0
  000f8	74 18		 je	 SHORT $LN6@Container_
  000fa	8a 45 cc	 mov	 al, BYTE PTR tv186[ebp]
  000fd	24 07		 and	 al, 7
  000ff	04 03		 add	 al, 3
  00101	3a 45 bc	 cmp	 al, BYTE PTR tv189[ebp]
  00104	7c 0c		 jl	 SHORT $LN6@Container_
  00106	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 ___asan_report_store4
  0010f	83 c4 04	 add	 esp, 4
$LN6@Container_:
  00112	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00115	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00118	89 02		 mov	 DWORD PTR [edx], eax

; 1342 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  0011a	8b 4b 0c	 mov	 ecx, DWORD PTR __Mycont$[ebx]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00123	83 c4 04	 add	 esp, 4
  00126	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  00129	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  0012c	89 55 d0	 mov	 DWORD PTR tv176[ebp], edx
  0012f	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00132	c1 e8 03	 shr	 eax, 3
  00135	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0013b	88 4d bd	 mov	 BYTE PTR tv179[ebp], cl
  0013e	80 7d bd 00	 cmp	 BYTE PTR tv179[ebp], 0
  00142	74 1a		 je	 SHORT $LN5@Container_
  00144	8a 55 d0	 mov	 dl, BYTE PTR tv176[ebp]
  00147	80 e2 07	 and	 dl, 7
  0014a	80 c2 03	 add	 dl, 3
  0014d	3a 55 bd	 cmp	 dl, BYTE PTR tv179[ebp]
  00150	7c 0c		 jl	 SHORT $LN5@Container_
  00152	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ___asan_report_store4
  0015b	83 c4 04	 add	 esp, 4
$LN5@Container_:
  0015e	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00161	89 4d 90	 mov	 DWORD PTR $T2[ebp], ecx
  00164	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00167	52		 push	 edx
  00168	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00173	83 c4 08	 add	 esp, 8
  00176	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00179	c1 ea 03	 shr	 edx, 3
  0017c	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 1343 :         _Mycont._Myproxy = _Ptr;

  00183	8b 43 0c	 mov	 eax, DWORD PTR __Mycont$[ebx]
  00186	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  00189	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0018f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00192	89 55 d4	 mov	 DWORD PTR tv166[ebp], edx
  00195	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  00198	c1 e8 03	 shr	 eax, 3
  0019b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001a1	88 4d be	 mov	 BYTE PTR tv169[ebp], cl
  001a4	80 7d be 00	 cmp	 BYTE PTR tv169[ebp], 0
  001a8	74 1a		 je	 SHORT $LN4@Container_
  001aa	8a 55 d4	 mov	 dl, BYTE PTR tv166[ebp]
  001ad	80 e2 07	 and	 dl, 7
  001b0	80 c2 03	 add	 dl, 3
  001b3	3a 55 be	 cmp	 dl, BYTE PTR tv169[ebp]
  001b6	7c 0c		 jl	 SHORT $LN4@Container_
  001b8	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ___asan_report_load4
  001c1	83 c4 04	 add	 esp, 4
$LN4@Container_:
  001c4	8b 4d e0	 mov	 ecx, DWORD PTR tv92[ebp]
  001c7	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
  001ca	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001cd	c1 ea 03	 shr	 edx, 3
  001d0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001d6	88 45 bf	 mov	 BYTE PTR tv159[ebp], al
  001d9	80 7d bf 00	 cmp	 BYTE PTR tv159[ebp], 0
  001dd	74 1a		 je	 SHORT $LN3@Container_
  001df	8a 4d d8	 mov	 cl, BYTE PTR tv156[ebp]
  001e2	80 e1 07	 and	 cl, 7
  001e5	80 c1 03	 add	 cl, 3
  001e8	3a 4d bf	 cmp	 cl, BYTE PTR tv159[ebp]
  001eb	7c 0c		 jl	 SHORT $LN3@Container_
  001ed	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001f0	52		 push	 edx
  001f1	e8 00 00 00 00	 call	 ___asan_report_store4
  001f6	83 c4 04	 add	 esp, 4
$LN3@Container_:
  001f9	8b 45 e0	 mov	 eax, DWORD PTR tv92[ebp]
  001fc	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00201	89 10		 mov	 DWORD PTR [eax], edx

; 1344 :     }

  00203	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00206	89 45 fc	 mov	 DWORD PTR tv131[ebp], eax
  00209	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00210	8d 4d 80	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00213	c1 e9 03	 shr	 ecx, 3
  00216	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0021c	89 4d f8	 mov	 DWORD PTR tv152[ebp], ecx
  0021f	6a 07		 push	 7
  00221	8b 55 f8	 mov	 edx, DWORD PTR tv152[ebp]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022a	83 c4 08	 add	 esp, 8
  0022d	8b 45 fc	 mov	 eax, DWORD PTR tv131[ebp]
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	8b e3		 mov	 esp, ebx
  00235	5b		 pop	 ebx
  00236	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 03	 shl	 eax, 3
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@end
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@end
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@end:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 44   :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@begin
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@begin
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@begin:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@initialize
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@initialize
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@initialize:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@initialize
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@initialize
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@initialize:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 04	 sar	 edx, 4
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 04	 shl	 eax, 4
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S10$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S10$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S10$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
_$S8$ = -152						; size = 1
__Proxy$ = -136						; size = 8
$T3 = -120						; size = 1
$T4 = -76						; size = 1
$T5 = -75						; size = 1
$T6 = -74						; size = 1
$T7 = -73						; size = 1
tv153 = -72						; size = 4
_this$ = -68						; size = 4
tv151 = -64						; size = 4
tv70 = -60						; size = 4
__Alproxy$ = -56					; size = 4
tv135 = -52						; size = 4
tv133 = -48						; size = 4
tv162 = -44						; size = 4
tv150 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  00056	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  00060	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv151[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv151[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b8	 mov	 DWORD PTR tv153[ebp], ecx
  00078	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00085	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b8 02	 add	 DWORD PTR tv153[ebp], 2
  000a1	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	c1 e9 03	 shr	 ecx, 3
  000ad	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	89 55 c4	 mov	 DWORD PTR tv70[ebp], edx
  000c4	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  000c7	50		 push	 eax
  000c8	0f b6 4d b6	 movzx	 ecx, BYTE PTR $T6[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  000d0	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  000dd	50		 push	 eax
  000de	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$[ebp]
  000e4	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  000e9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _$S8$[ebp]
  000ef	89 55 c8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000f9	51		 push	 ecx
  000fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0010c	6a 01		 push	 1
  0010e	6a 00		 push	 0
  00110	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_memset
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	6a 01		 push	 1
  0011e	8d 45 b7	 lea	 eax, DWORD PTR $T7[ebp]
  00121	50		 push	 eax
  00122	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ___asan_memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	6a 01		 push	 1
  00130	8d 55 b4	 lea	 edx, DWORD PTR $T4[ebp]
  00133	52		 push	 edx
  00134	8d 45 b5	 lea	 eax, DWORD PTR $T5[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ___asan_memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  00143	e8 00 00 00 00	 call	 ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
  00148	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  0014b	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  0014e	e8 00 00 00 00	 call	 ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
  00153	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  00156	0f b6 4d b5	 movzx	 ecx, BYTE PTR $T5[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00162	50		 push	 eax
  00163	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
  0016b	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	c1 e9 03	 shr	 ecx, 3
  00171	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 551  :         _Proxy._Release();

  00178	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00190	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00195	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	89 55 d8	 mov	 DWORD PTR tv150[ebp], edx
  0019b	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  001ab	c1 e8 03	 shr	 eax, 3
  001ae	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001b3	89 45 d4	 mov	 DWORD PTR tv162[ebp], eax
  001b6	6a 0b		 push	 11			; 0000000bH
  001b8	8b 4d d4	 mov	 ecx, DWORD PTR tv162[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 45 d8	 mov	 eax, DWORD PTR tv150[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	8b e3		 mov	 esp, ebx
  001e1	5b		 pop	 ebx
  001e2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YAII@Z ; std::_Get_size_of_n<16>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 04	 shl	 eax, 4
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.h
;	COMDAT ?getSize@Character@@QAE?AV?$Vector2@I@sf@@XZ
_TEXT	SEGMENT
tv65 = -32						; size = 8
tv69 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv72 = -12						; size = 4
tv82 = -8						; size = 4
tv75 = -2						; size = 1
tv85 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?getSize@Character@@QAE?AV?$Vector2@I@sf@@XZ PROC	; Character::getSize, COMDAT
; _this$ = ecx

; 29   : 	inline sf::Vector2u getSize() { return _size; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D6BD463_Character@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 20	 add	 eax, 32			; 00000020H
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv82[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv82[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv85[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00035	74 1a		 je	 SHORT $LN4@getSize
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv82[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 07	 add	 cl, 7
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv85[ebp]
  00043	7c 0c		 jl	 SHORT $LN4@getSize
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv82[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load8
  0004e	83 c4 04	 add	 esp, 4
$LN4@getSize:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00059	89 4d e0	 mov	 DWORD PTR tv65[ebp], ecx
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp+4], edx
  0005f	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00062	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00065	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00068	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
  0006b	8b 55 f4	 mov	 edx, DWORD PTR tv72[ebp]
  0006e	c1 ea 03	 shr	 edx, 3
  00071	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00077	88 45 fe	 mov	 BYTE PTR tv75[ebp], al
  0007a	80 7d fe 00	 cmp	 BYTE PTR tv75[ebp], 0
  0007e	74 1a		 je	 SHORT $LN3@getSize
  00080	8a 4d f4	 mov	 cl, BYTE PTR tv72[ebp]
  00083	80 e1 07	 and	 cl, 7
  00086	80 c1 07	 add	 cl, 7
  00089	3a 4d fe	 cmp	 cl, BYTE PTR tv75[ebp]
  0008c	7c 0c		 jl	 SHORT $LN3@getSize
  0008e	8b 55 f4	 mov	 edx, DWORD PTR tv72[ebp]
  00091	52		 push	 edx
  00092	e8 00 00 00 00	 call	 ___asan_report_store8
  00097	83 c4 04	 add	 esp, 4
$LN3@getSize:
  0009a	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0009d	8b 4d e0	 mov	 ecx, DWORD PTR tv65[ebp]
  000a0	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp+4]
  000a3	89 08		 mov	 DWORD PTR [eax], ecx
  000a5	89 50 04	 mov	 DWORD PTR [eax+4], edx
  000a8	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c2 04 00	 ret	 4
?getSize@Character@@QAE?AV?$Vector2@I@sf@@XZ ENDP	; Character::getSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.h
;	COMDAT ?setMaxX@Character@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
_x$ = 8							; size = 4
?setMaxX@Character@@QAEXH@Z PROC			; Character::setMaxX, COMDAT
; _this$ = ecx

; 28   : 	inline void setMaxX(int x) { _maxX = x; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D6BD463_Character@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 18	 add	 eax, 24			; 00000018H
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@setMaxX
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@setMaxX
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_store4
  0004e	83 c4 04	 add	 esp, 4
$LN3@setMaxX:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00057	89 08		 mov	 DWORD PTR [eax], ecx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c2 04 00	 ret	 4
?setMaxX@Character@@QAEXH@Z ENDP			; Character::setMaxX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.h
;	COMDAT ?getY@Character@@QAEMXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?getY@Character@@QAEMXZ PROC				; Character::getY, COMDAT
; _this$ = ecx

; 27   : 	inline float getY() { return _y; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D6BD463_Character@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@getY
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@getY
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@getY:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	d9 00		 fld	 DWORD PTR [eax]
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?getY@Character@@QAEMXZ ENDP				; Character::getY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.h
;	COMDAT ?getX@Character@@QAEMXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?getX@Character@@QAEMXZ PROC				; Character::getX, COMDAT
; _this$ = ecx

; 26   : 	inline float getX() { return _x; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D6BD463_Character@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@getX
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@getX
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@getX:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	d9 00		 fld	 DWORD PTR [eax]
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?getX@Character@@QAEMXZ ENDP				; Character::getX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.h
;	COMDAT ?getRect@Character@@QAE?AV?$Rect@H@sf@@XZ
_TEXT	SEGMENT
$T1 = -48						; size = 16
tv72 = -32						; size = 4
_this$ = -28						; size = 4
tv65 = -24						; size = 4
tv64 = -20						; size = 4
tv75 = -16						; size = 4
tv86 = -12						; size = 4
tv129 = -8						; size = 4
tv78 = -3						; size = 1
tv89 = -2						; size = 1
tv132 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?getRect@Character@@QAE?AV?$Rect@H@sf@@XZ PROC		; Character::getRect, COMDAT
; _this$ = ecx

; 25   : 	inline sf::IntRect getRect() { return *_rect; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D6BD463_Character@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv129[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv129[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv132[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  00035	74 1a		 je	 SHORT $LN5@getRect
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv129[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv132[ebp]
  00043	7c 0c		 jl	 SHORT $LN5@getRect
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv129[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN5@getRect:
  00051	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00059	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  0005c	89 55 f4	 mov	 DWORD PTR tv86[ebp], edx
  0005f	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  00062	c1 e8 03	 shr	 eax, 3
  00065	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006b	88 4d fe	 mov	 BYTE PTR tv89[ebp], cl
  0006e	80 7d fe 00	 cmp	 BYTE PTR tv89[ebp], 0
  00072	74 1c		 je	 SHORT $LN4@getRect
  00074	8a 55 f4	 mov	 dl, BYTE PTR tv86[ebp]
  00077	80 e2 07	 and	 dl, 7
  0007a	80 c2 07	 add	 dl, 7
  0007d	3a 55 fe	 cmp	 dl, BYTE PTR tv89[ebp]
  00080	7c 0e		 jl	 SHORT $LN4@getRect
  00082	6a 10		 push	 16			; 00000010H
  00084	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ___asan_report_load16
  0008d	83 c4 08	 add	 esp, 8
$LN4@getRect:
  00090	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  00093	8b 11		 mov	 edx, DWORD PTR [ecx]
  00095	89 55 d0	 mov	 DWORD PTR $T1[ebp], edx
  00098	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  0009b	89 45 d4	 mov	 DWORD PTR $T1[ebp+4], eax
  0009e	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000a1	89 55 d8	 mov	 DWORD PTR $T1[ebp+8], edx
  000a4	8b 41 0c	 mov	 eax, DWORD PTR [ecx+12]
  000a7	89 45 dc	 mov	 DWORD PTR $T1[ebp+12], eax
  000aa	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ad	89 4d e0	 mov	 DWORD PTR tv72[ebp], ecx
  000b0	8b 55 e0	 mov	 edx, DWORD PTR tv72[ebp]
  000b3	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  000b6	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  000b9	c1 e8 03	 shr	 eax, 3
  000bc	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000c2	88 4d fd	 mov	 BYTE PTR tv78[ebp], cl
  000c5	80 7d fd 00	 cmp	 BYTE PTR tv78[ebp], 0
  000c9	74 1c		 je	 SHORT $LN3@getRect
  000cb	8a 55 f0	 mov	 dl, BYTE PTR tv75[ebp]
  000ce	80 e2 07	 and	 dl, 7
  000d1	80 c2 07	 add	 dl, 7
  000d4	3a 55 fd	 cmp	 dl, BYTE PTR tv78[ebp]
  000d7	7c 0e		 jl	 SHORT $LN3@getRect
  000d9	6a 10		 push	 16			; 00000010H
  000db	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  000de	50		 push	 eax
  000df	e8 00 00 00 00	 call	 ___asan_report_store16
  000e4	83 c4 08	 add	 esp, 8
$LN3@getRect:
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000ea	8b 55 d0	 mov	 edx, DWORD PTR $T1[ebp]
  000ed	89 11		 mov	 DWORD PTR [ecx], edx
  000ef	8b 45 d4	 mov	 eax, DWORD PTR $T1[ebp+4]
  000f2	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  000f5	8b 55 d8	 mov	 edx, DWORD PTR $T1[ebp+8]
  000f8	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000fb	8b 45 dc	 mov	 eax, DWORD PTR $T1[ebp+12]
  000fe	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00101	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 04 00	 ret	 4
?getRect@Character@@QAE?AV?$Rect@H@sf@@XZ ENDP		; Character::getRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.h
;	COMDAT ?show@Character@@QAEXPAVRenderWindow@sf@@@Z
_TEXT	SEGMENT
tv87 = -48						; size = 4
tv83 = -44						; size = 4
tv85 = -40						; size = 4
tv79 = -36						; size = 4
tv75 = -32						; size = 4
tv76 = -28						; size = 4
_this$ = -24						; size = 4
tv73 = -20						; size = 4
tv95 = -16						; size = 4
tv137 = -12						; size = 4
tv147 = -8						; size = 4
tv130 = -3						; size = 1
tv140 = -2						; size = 1
tv150 = -1						; size = 1
_rw$ = 8						; size = 4
?show@Character@@QAEXPAVRenderWindow@sf@@@Z PROC	; Character::show, COMDAT
; _this$ = ecx

; 24   : 	inline void show(sf::RenderWindow* rw) { rw->draw(*_sprite->at(_place)); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D6BD463_Character@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 08	 mov	 eax, DWORD PTR _rw$[ebp]
  00016	83 c0 30	 add	 eax, 48			; 00000030H
  00019	89 45 d0	 mov	 DWORD PTR tv87[ebp], eax
  0001c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?Default@RenderStates@sf@@2V12@B
  00022	89 4d d8	 mov	 DWORD PTR tv85[ebp], ecx
  00025	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00028	83 c2 0c	 add	 edx, 12			; 0000000cH
  0002b	89 55 ec	 mov	 DWORD PTR tv73[ebp], edx
  0002e	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]
  00031	89 45 f8	 mov	 DWORD PTR tv147[ebp], eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR tv147[ebp]
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00040	88 55 ff	 mov	 BYTE PTR tv150[ebp], dl
  00043	80 7d ff 00	 cmp	 BYTE PTR tv150[ebp], 0
  00047	74 18		 je	 SHORT $LN5@show
  00049	8a 45 f8	 mov	 al, BYTE PTR tv147[ebp]
  0004c	24 07		 and	 al, 7
  0004e	04 03		 add	 al, 3
  00050	3a 45 ff	 cmp	 al, BYTE PTR tv150[ebp]
  00053	7c 0c		 jl	 SHORT $LN5@show
  00055	8b 4d f8	 mov	 ecx, DWORD PTR tv147[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ___asan_report_load4
  0005e	83 c4 04	 add	 esp, 4
$LN5@show:
  00061	8b 55 ec	 mov	 edx, DWORD PTR tv73[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	89 45 dc	 mov	 DWORD PTR tv79[ebp], eax
  00069	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006c	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0006f	89 4d e4	 mov	 DWORD PTR tv76[ebp], ecx
  00072	8b 55 e4	 mov	 edx, DWORD PTR tv76[ebp]
  00075	89 55 f4	 mov	 DWORD PTR tv137[ebp], edx
  00078	8b 45 f4	 mov	 eax, DWORD PTR tv137[ebp]
  0007b	c1 e8 03	 shr	 eax, 3
  0007e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00084	88 4d fe	 mov	 BYTE PTR tv140[ebp], cl
  00087	80 7d fe 00	 cmp	 BYTE PTR tv140[ebp], 0
  0008b	74 1a		 je	 SHORT $LN4@show
  0008d	8a 55 f4	 mov	 dl, BYTE PTR tv137[ebp]
  00090	80 e2 07	 and	 dl, 7
  00093	80 c2 03	 add	 dl, 3
  00096	3a 55 fe	 cmp	 dl, BYTE PTR tv140[ebp]
  00099	7c 0c		 jl	 SHORT $LN4@show
  0009b	8b 45 f4	 mov	 eax, DWORD PTR tv137[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ___asan_report_load4
  000a4	83 c4 04	 add	 esp, 4
$LN4@show:
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR tv76[ebp]
  000aa	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ac	52		 push	 edx
  000ad	8b 4d dc	 mov	 ecx, DWORD PTR tv79[ebp]
  000b0	e8 00 00 00 00	 call	 ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
  000b5	89 45 e0	 mov	 DWORD PTR tv75[ebp], eax
  000b8	8b 45 e0	 mov	 eax, DWORD PTR tv75[ebp]
  000bb	89 45 f0	 mov	 DWORD PTR tv95[ebp], eax
  000be	8b 4d f0	 mov	 ecx, DWORD PTR tv95[ebp]
  000c1	c1 e9 03	 shr	 ecx, 3
  000c4	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ca	88 55 fd	 mov	 BYTE PTR tv130[ebp], dl
  000cd	80 7d fd 00	 cmp	 BYTE PTR tv130[ebp], 0
  000d1	74 18		 je	 SHORT $LN3@show
  000d3	8a 45 f0	 mov	 al, BYTE PTR tv95[ebp]
  000d6	24 07		 and	 al, 7
  000d8	04 03		 add	 al, 3
  000da	3a 45 fd	 cmp	 al, BYTE PTR tv130[ebp]
  000dd	7c 0c		 jl	 SHORT $LN3@show
  000df	8b 4d f0	 mov	 ecx, DWORD PTR tv95[ebp]
  000e2	51		 push	 ecx
  000e3	e8 00 00 00 00	 call	 ___asan_report_load4
  000e8	83 c4 04	 add	 esp, 4
$LN3@show:
  000eb	8b 55 e0	 mov	 edx, DWORD PTR tv75[ebp]
  000ee	8b 02		 mov	 eax, DWORD PTR [edx]
  000f0	89 45 d4	 mov	 DWORD PTR tv83[ebp], eax
  000f3	8b 4d d8	 mov	 ecx, DWORD PTR tv85[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 d4	 mov	 edx, DWORD PTR tv83[ebp]
  000fa	52		 push	 edx
  000fb	8b 4d d0	 mov	 ecx, DWORD PTR tv87[ebp]
  000fe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?draw@RenderTarget@sf@@QAEXABVDrawable@2@ABVRenderStates@2@@Z
  00104	8b e5		 mov	 esp, ebp
  00106	5d		 pop	 ebp
  00107	c2 04 00	 ret	 4
?show@Character@@QAEXPAVRenderWindow@sf@@@Z ENDP	; Character::show
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_GSprite@sf@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSprite@sf@@UAEPAXI@Z PROC				; sf::Sprite::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1Sprite@sf@@UAE@XZ
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 11		 je	 SHORT $LN2@scalar
  00018	68 10 01 00 00	 push	 272			; 00000110H
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??_GSprite@sf@@UAEPAXI@Z ENDP				; sf::Sprite::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Graphics\Rect.inl
;	COMDAT ??0?$Rect@M@sf@@QAE@MMMM@Z
_TEXT	SEGMENT
tv67 = -40						; size = 4
tv66 = -36						; size = 4
tv65 = -32						; size = 4
tv64 = -28						; size = 4
tv77 = -24						; size = 4
tv87 = -20						; size = 4
tv129 = -16						; size = 4
tv139 = -12						; size = 4
_this$ = -8						; size = 4
tv80 = -4						; size = 1
tv90 = -3						; size = 1
tv132 = -2						; size = 1
tv142 = -1						; size = 1
_rectLeft$ = 8						; size = 4
_rectTop$ = 12						; size = 4
_rectWidth$ = 16					; size = 4
_rectHeight$ = 20					; size = 4
??0?$Rect@M@sf@@QAE@MMMM@Z PROC				; sf::Rect<float>::Rect<float>, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C23CD225_Rect@inl
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 41   : left  (rectLeft),

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv142[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv142[ebp], 0
  00032	74 1a		 je	 SHORT $LN6@Rect
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv139[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv142[ebp]
  00040	7c 0c		 jl	 SHORT $LN6@Rect
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN6@Rect:
  0004e	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _rectLeft$[ebp]
  00056	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 42   : top   (rectTop),

  0005a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	83 c1 04	 add	 ecx, 4
  00060	89 4d e0	 mov	 DWORD PTR tv65[ebp], ecx
  00063	8b 55 e0	 mov	 edx, DWORD PTR tv65[ebp]
  00066	89 55 f0	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f0	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d fe	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d fe 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN5@Rect
  0007e	8a 55 f0	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 fe	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN5@Rect
  0008c	8b 45 f0	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_store4
  00095	83 c4 04	 add	 esp, 4
$LN5@Rect:
  00098	8b 4d e0	 mov	 ecx, DWORD PTR tv65[ebp]
  0009b	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rectTop$[ebp]
  000a0	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 43   : width (rectWidth),

  000a4	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a7	83 c2 08	 add	 edx, 8
  000aa	89 55 dc	 mov	 DWORD PTR tv66[ebp], edx
  000ad	8b 45 dc	 mov	 eax, DWORD PTR tv66[ebp]
  000b0	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
  000b3	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000b6	c1 e9 03	 shr	 ecx, 3
  000b9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000bf	88 55 fd	 mov	 BYTE PTR tv90[ebp], dl
  000c2	80 7d fd 00	 cmp	 BYTE PTR tv90[ebp], 0
  000c6	74 18		 je	 SHORT $LN4@Rect
  000c8	8a 45 ec	 mov	 al, BYTE PTR tv87[ebp]
  000cb	24 07		 and	 al, 7
  000cd	04 03		 add	 al, 3
  000cf	3a 45 fd	 cmp	 al, BYTE PTR tv90[ebp]
  000d2	7c 0c		 jl	 SHORT $LN4@Rect
  000d4	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000d7	51		 push	 ecx
  000d8	e8 00 00 00 00	 call	 ___asan_report_store4
  000dd	83 c4 04	 add	 esp, 4
$LN4@Rect:
  000e0	8b 55 dc	 mov	 edx, DWORD PTR tv66[ebp]
  000e3	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rectWidth$[ebp]
  000e8	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 44   : height(rectHeight)

  000ec	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 c0 0c	 add	 eax, 12			; 0000000cH
  000f2	89 45 d8	 mov	 DWORD PTR tv67[ebp], eax
  000f5	8b 4d d8	 mov	 ecx, DWORD PTR tv67[ebp]
  000f8	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  000fb	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  000fe	c1 ea 03	 shr	 edx, 3
  00101	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00107	88 45 fc	 mov	 BYTE PTR tv80[ebp], al
  0010a	80 7d fc 00	 cmp	 BYTE PTR tv80[ebp], 0
  0010e	74 1a		 je	 SHORT $LN3@Rect
  00110	8a 4d e8	 mov	 cl, BYTE PTR tv77[ebp]
  00113	80 e1 07	 and	 cl, 7
  00116	80 c1 03	 add	 cl, 3
  00119	3a 4d fc	 cmp	 cl, BYTE PTR tv80[ebp]
  0011c	7c 0c		 jl	 SHORT $LN3@Rect
  0011e	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 ___asan_report_store4
  00127	83 c4 04	 add	 esp, 4
$LN3@Rect:
  0012a	8b 45 d8	 mov	 eax, DWORD PTR tv67[ebp]
  0012d	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _rectHeight$[ebp]
  00132	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 46   : 
; 47   : }

  00136	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b e5		 mov	 esp, ebp
  0013b	5d		 pop	 ebp
  0013c	c2 10 00	 ret	 16			; 00000010H
??0?$Rect@M@sf@@QAE@MMMM@Z ENDP				; sf::Rect<float>::Rect<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z PROC ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ENDP ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
__My_data$ = -16					; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ PROC ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size, COMDAT
; _this$ = ecx

; 1547 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1548 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d ec	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00044	74 18		 je	 SHORT $LN4@size
  00046	8a 45 f8	 mov	 al, BYTE PTR tv85[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00050	7c 0c		 jl	 SHORT $LN4@size
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN4@size:
  0005e	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00077	74 1a		 je	 SHORT $LN3@size
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00085	7c 0c		 jl	 SHORT $LN3@size
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN3@size:
  00093	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2

; 1550 :     }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ENDP ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\RessourcePack.h
;	COMDAT ?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z
_TEXT	SEGMENT
tv85 = -76						; size = 4
tv79 = -72						; size = 4
tv77 = -68						; size = 4
tv86 = -64						; size = 4
tv82 = -60						; size = 4
tv80 = -56						; size = 4
tv70 = -52						; size = 4
tv71 = -48						; size = 4
tv68 = -44						; size = 4
tv64 = -40						; size = 4
tv132 = -36						; size = 4
tv142 = -32						; size = 4
tv152 = -28						; size = 4
tv162 = -24						; size = 4
tv172 = -20						; size = 4
tv182 = -16						; size = 4
_this$ = -12						; size = 4
tv135 = -6						; size = 1
tv145 = -5						; size = 1
tv155 = -4						; size = 1
tv165 = -3						; size = 1
tv175 = -2						; size = 1
tv185 = -1						; size = 1
_lvl$ = 8						; size = 4
?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z PROC	; RessourcePack::getLevelMusic, COMDAT
; _this$ = ecx

; 48   : 	{ return ((unsigned int)lvl >= musicList->size()) ? musicList->at(musicList->size() - 1) : musicList->at(lvl); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __28BBFA9C_RessourcePack@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 d8	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d d8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f0	 mov	 DWORD PTR tv182[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR tv182[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv185[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv185[ebp], 0
  00035	74 1a		 je	 SHORT $LN10@getLevelMu
  00037	8a 4d f0	 mov	 cl, BYTE PTR tv182[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv185[ebp]
  00043	7c 0c		 jl	 SHORT $LN10@getLevelMu
  00045	8b 55 f0	 mov	 edx, DWORD PTR tv182[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN10@getLevelMu:
  00051	8b 45 d8	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	e8 00 00 00 00	 call	 ?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
  0005b	39 45 08	 cmp	 DWORD PTR _lvl$[ebp], eax
  0005e	0f 82 e5 00 00
	00		 jb	 $LN3@getLevelMu
  00064	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0006a	89 4d d4	 mov	 DWORD PTR tv68[ebp], ecx
  0006d	8b 55 d4	 mov	 edx, DWORD PTR tv68[ebp]
  00070	89 55 ec	 mov	 DWORD PTR tv172[ebp], edx
  00073	8b 45 ec	 mov	 eax, DWORD PTR tv172[ebp]
  00076	c1 e8 03	 shr	 eax, 3
  00079	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007f	88 4d fe	 mov	 BYTE PTR tv175[ebp], cl
  00082	80 7d fe 00	 cmp	 BYTE PTR tv175[ebp], 0
  00086	74 1a		 je	 SHORT $LN9@getLevelMu
  00088	8a 55 ec	 mov	 dl, BYTE PTR tv172[ebp]
  0008b	80 e2 07	 and	 dl, 7
  0008e	80 c2 03	 add	 dl, 3
  00091	3a 55 fe	 cmp	 dl, BYTE PTR tv175[ebp]
  00094	7c 0c		 jl	 SHORT $LN9@getLevelMu
  00096	8b 45 ec	 mov	 eax, DWORD PTR tv172[ebp]
  00099	50		 push	 eax
  0009a	e8 00 00 00 00	 call	 ___asan_report_load4
  0009f	83 c4 04	 add	 esp, 4
$LN9@getLevelMu:
  000a2	8b 4d d4	 mov	 ecx, DWORD PTR tv68[ebp]
  000a5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a7	89 55 b8	 mov	 DWORD PTR tv79[ebp], edx
  000aa	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	83 c0 0c	 add	 eax, 12			; 0000000cH
  000b0	89 45 d0	 mov	 DWORD PTR tv71[ebp], eax
  000b3	8b 4d d0	 mov	 ecx, DWORD PTR tv71[ebp]
  000b6	89 4d e8	 mov	 DWORD PTR tv162[ebp], ecx
  000b9	8b 55 e8	 mov	 edx, DWORD PTR tv162[ebp]
  000bc	c1 ea 03	 shr	 edx, 3
  000bf	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c5	88 45 fd	 mov	 BYTE PTR tv165[ebp], al
  000c8	80 7d fd 00	 cmp	 BYTE PTR tv165[ebp], 0
  000cc	74 1a		 je	 SHORT $LN8@getLevelMu
  000ce	8a 4d e8	 mov	 cl, BYTE PTR tv162[ebp]
  000d1	80 e1 07	 and	 cl, 7
  000d4	80 c1 03	 add	 cl, 3
  000d7	3a 4d fd	 cmp	 cl, BYTE PTR tv165[ebp]
  000da	7c 0c		 jl	 SHORT $LN8@getLevelMu
  000dc	8b 55 e8	 mov	 edx, DWORD PTR tv162[ebp]
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ___asan_report_load4
  000e5	83 c4 04	 add	 esp, 4
$LN8@getLevelMu:
  000e8	8b 45 d0	 mov	 eax, DWORD PTR tv71[ebp]
  000eb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ed	e8 00 00 00 00	 call	 ?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
  000f2	83 e8 01	 sub	 eax, 1
  000f5	89 45 bc	 mov	 DWORD PTR tv77[ebp], eax
  000f8	8b 4d bc	 mov	 ecx, DWORD PTR tv77[ebp]
  000fb	51		 push	 ecx
  000fc	8b 4d b8	 mov	 ecx, DWORD PTR tv79[ebp]
  000ff	e8 00 00 00 00	 call	 ?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
  00104	89 45 cc	 mov	 DWORD PTR tv70[ebp], eax
  00107	8b 55 cc	 mov	 edx, DWORD PTR tv70[ebp]
  0010a	89 55 e4	 mov	 DWORD PTR tv152[ebp], edx
  0010d	8b 45 e4	 mov	 eax, DWORD PTR tv152[ebp]
  00110	c1 e8 03	 shr	 eax, 3
  00113	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00119	88 4d fc	 mov	 BYTE PTR tv155[ebp], cl
  0011c	80 7d fc 00	 cmp	 BYTE PTR tv155[ebp], 0
  00120	74 1a		 je	 SHORT $LN7@getLevelMu
  00122	8a 55 e4	 mov	 dl, BYTE PTR tv152[ebp]
  00125	80 e2 07	 and	 dl, 7
  00128	80 c2 03	 add	 dl, 3
  0012b	3a 55 fc	 cmp	 dl, BYTE PTR tv155[ebp]
  0012e	7c 0c		 jl	 SHORT $LN7@getLevelMu
  00130	8b 45 e4	 mov	 eax, DWORD PTR tv152[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 ___asan_report_load4
  00139	83 c4 04	 add	 esp, 4
$LN7@getLevelMu:
  0013c	8b 4d cc	 mov	 ecx, DWORD PTR tv70[ebp]
  0013f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00141	89 55 c0	 mov	 DWORD PTR tv86[ebp], edx
  00144	e9 90 00 00 00	 jmp	 $LN4@getLevelMu
$LN3@getLevelMu:
  00149	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0014c	83 c0 0c	 add	 eax, 12			; 0000000cH
  0014f	89 45 c8	 mov	 DWORD PTR tv80[ebp], eax
  00152	8b 4d c8	 mov	 ecx, DWORD PTR tv80[ebp]
  00155	89 4d e0	 mov	 DWORD PTR tv142[ebp], ecx
  00158	8b 55 e0	 mov	 edx, DWORD PTR tv142[ebp]
  0015b	c1 ea 03	 shr	 edx, 3
  0015e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00164	88 45 fb	 mov	 BYTE PTR tv145[ebp], al
  00167	80 7d fb 00	 cmp	 BYTE PTR tv145[ebp], 0
  0016b	74 1a		 je	 SHORT $LN6@getLevelMu
  0016d	8a 4d e0	 mov	 cl, BYTE PTR tv142[ebp]
  00170	80 e1 07	 and	 cl, 7
  00173	80 c1 03	 add	 cl, 3
  00176	3a 4d fb	 cmp	 cl, BYTE PTR tv145[ebp]
  00179	7c 0c		 jl	 SHORT $LN6@getLevelMu
  0017b	8b 55 e0	 mov	 edx, DWORD PTR tv142[ebp]
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 ___asan_report_load4
  00184	83 c4 04	 add	 esp, 4
$LN6@getLevelMu:
  00187	8b 45 c8	 mov	 eax, DWORD PTR tv80[ebp]
  0018a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0018c	89 4d b4	 mov	 DWORD PTR tv85[ebp], ecx
  0018f	8b 55 08	 mov	 edx, DWORD PTR _lvl$[ebp]
  00192	52		 push	 edx
  00193	8b 4d b4	 mov	 ecx, DWORD PTR tv85[ebp]
  00196	e8 00 00 00 00	 call	 ?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
  0019b	89 45 c4	 mov	 DWORD PTR tv82[ebp], eax
  0019e	8b 45 c4	 mov	 eax, DWORD PTR tv82[ebp]
  001a1	89 45 dc	 mov	 DWORD PTR tv132[ebp], eax
  001a4	8b 4d dc	 mov	 ecx, DWORD PTR tv132[ebp]
  001a7	c1 e9 03	 shr	 ecx, 3
  001aa	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001b0	88 55 fa	 mov	 BYTE PTR tv135[ebp], dl
  001b3	80 7d fa 00	 cmp	 BYTE PTR tv135[ebp], 0
  001b7	74 18		 je	 SHORT $LN5@getLevelMu
  001b9	8a 45 dc	 mov	 al, BYTE PTR tv132[ebp]
  001bc	24 07		 and	 al, 7
  001be	04 03		 add	 al, 3
  001c0	3a 45 fa	 cmp	 al, BYTE PTR tv135[ebp]
  001c3	7c 0c		 jl	 SHORT $LN5@getLevelMu
  001c5	8b 4d dc	 mov	 ecx, DWORD PTR tv132[ebp]
  001c8	51		 push	 ecx
  001c9	e8 00 00 00 00	 call	 ___asan_report_load4
  001ce	83 c4 04	 add	 esp, 4
$LN5@getLevelMu:
  001d1	8b 55 c4	 mov	 edx, DWORD PTR tv82[ebp]
  001d4	8b 02		 mov	 eax, DWORD PTR [edx]
  001d6	89 45 c0	 mov	 DWORD PTR tv86[ebp], eax
$LN4@getLevelMu:
  001d9	8b 45 c0	 mov	 eax, DWORD PTR tv86[ebp]
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	c2 04 00	 ret	 4
?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z ENDP	; RessourcePack::getLevelMusic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\RessourcePack.h
;	COMDAT ?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z
_TEXT	SEGMENT
tv70 = -28						; size = 4
_this$ = -24						; size = 4
tv66 = -20						; size = 4
tv64 = -16						; size = 4
tv76 = -12						; size = 4
tv86 = -8						; size = 4
tv79 = -2						; size = 1
tv89 = -1						; size = 1
_n$ = 8							; size = 4
?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z PROC ; RessourcePack::getImgBackground, COMDAT
; _this$ = ecx

; 45   : 	inline sf::Image* getImgBackground(int n) { return backgroundImages->at(n - 1); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __28BBFA9C_RessourcePack@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 10	 add	 eax, 16			; 00000010H
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv86[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv86[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00035	74 1a		 je	 SHORT $LN4@getImgBack
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv86[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv89[ebp]
  00043	7c 0c		 jl	 SHORT $LN4@getImgBack
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv86[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN4@getImgBack:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  00059	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  0005c	83 ea 01	 sub	 edx, 1
  0005f	52		 push	 edx
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  00063	e8 00 00 00 00	 call	 ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
  00068	89 45 ec	 mov	 DWORD PTR tv66[ebp], eax
  0006b	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  0006e	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  00074	c1 e9 03	 shr	 ecx, 3
  00077	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0007d	88 55 fe	 mov	 BYTE PTR tv79[ebp], dl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv79[ebp], 0
  00084	74 18		 je	 SHORT $LN3@getImgBack
  00086	8a 45 f4	 mov	 al, BYTE PTR tv76[ebp]
  00089	24 07		 and	 al, 7
  0008b	04 03		 add	 al, 3
  0008d	3a 45 fe	 cmp	 al, BYTE PTR tv79[ebp]
  00090	7c 0c		 jl	 SHORT $LN3@getImgBack
  00092	8b 4d f4	 mov	 ecx, DWORD PTR tv76[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ___asan_report_load4
  0009b	83 c4 04	 add	 esp, 4
$LN3@getImgBack:
  0009e	8b 55 ec	 mov	 edx, DWORD PTR tv66[ebp]
  000a1	8b 02		 mov	 eax, DWORD PTR [edx]
  000a3	8b e5		 mov	 esp, ebp
  000a5	5d		 pop	 ebp
  000a6	c2 04 00	 ret	 4
?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z ENDP ; RessourcePack::getImgBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20_CONTAINER _Vbase _Mask() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2099 :         return static_cast<_Vbase>(1) << this->_Myoff;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Mask
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Mask
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Mask:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	ba 01 00 00 00	 mov	 edx, 1
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	d3 e2		 shl	 edx, cl
  0005d	8b c2		 mov	 eax, edx

; 2100 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
tv128 = -32						; size = 4
tv152 = -28						; size = 4
tv130 = -24						; size = 4
tv162 = -20						; size = 4
_this$ = -16						; size = 4
tv172 = -12						; size = 4
__Cont$ = -8						; size = 4
tv165 = -2						; size = 1
tv175 = -1						; size = 1
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr, COMDAT
; _this$ = ecx

; 2080 :     _CONSTEXPR20_CONTAINER const _Vbase* _Getptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2081 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2082 :         const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());

  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 f8	 mov	 DWORD PTR __Cont$[ebp], eax
$LN4@Getptr:

; 2083 :         _STL_VERIFY(_Cont, "cannot dereference value-initialized vector<bool> iterator");

  0001e	83 7d f8 00	 cmp	 DWORD PTR __Cont$[ebp], 0
  00022	74 02		 je	 SHORT $LN7@Getptr
  00024	eb 4a		 jmp	 SHORT $LN2@Getptr
$LN7@Getptr:
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00030	6a 00		 push	 0
  00032	68 23 08 00 00	 push	 2083			; 00000823H
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0003c	6a 02		 push	 2
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	83 f8 01	 cmp	 eax, 1
  0004a	75 01		 jne	 SHORT $LN19@Getptr
  0004c	cc		 int	 3
$LN19@Getptr:
  0004d	6a 00		 push	 0
  0004f	68 23 08 00 00	 push	 2083			; 00000823H
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	33 c9		 xor	 ecx, ecx
  0006e	75 b6		 jne	 SHORT $LN7@Getptr
$LN2@Getptr:
  00070	33 d2		 xor	 edx, edx
  00072	75 aa		 jne	 SHORT $LN4@Getptr
$LN10@Getptr:

; 2084 :         _STL_VERIFY(this->_Total_off(_Cont) <= static_cast<_Difference_type>(_Cont->_Mysize),

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Cont$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
  00080	89 45 e0	 mov	 DWORD PTR tv128[ebp], eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Cont$[ebp]
  00086	83 c1 14	 add	 ecx, 20			; 00000014H
  00089	89 4d e8	 mov	 DWORD PTR tv130[ebp], ecx
  0008c	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  0008f	89 55 f4	 mov	 DWORD PTR tv172[ebp], edx
  00092	8b 45 f4	 mov	 eax, DWORD PTR tv172[ebp]
  00095	c1 e8 03	 shr	 eax, 3
  00098	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0009e	88 4d ff	 mov	 BYTE PTR tv175[ebp], cl
  000a1	80 7d ff 00	 cmp	 BYTE PTR tv175[ebp], 0
  000a5	74 1a		 je	 SHORT $LN22@Getptr
  000a7	8a 55 f4	 mov	 dl, BYTE PTR tv172[ebp]
  000aa	80 e2 07	 and	 dl, 7
  000ad	80 c2 03	 add	 dl, 3
  000b0	3a 55 ff	 cmp	 dl, BYTE PTR tv175[ebp]
  000b3	7c 0c		 jl	 SHORT $LN22@Getptr
  000b5	8b 45 f4	 mov	 eax, DWORD PTR tv172[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ___asan_report_load4
  000be	83 c4 04	 add	 esp, 4
$LN22@Getptr:
  000c1	8b 4d e8	 mov	 ecx, DWORD PTR tv130[ebp]
  000c4	8b 55 e0	 mov	 edx, DWORD PTR tv128[ebp]
  000c7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000c9	7f 02		 jg	 SHORT $LN13@Getptr
  000cb	eb 4a		 jmp	 SHORT $LN8@Getptr
$LN13@Getptr:
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000d7	6a 00		 push	 0
  000d9	68 25 08 00 00	 push	 2085			; 00000825H
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000e3	6a 02		 push	 2
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	75 01		 jne	 SHORT $LN20@Getptr
  000f3	cc		 int	 3
$LN20@Getptr:
  000f4	6a 00		 push	 0
  000f6	68 25 08 00 00	 push	 2085			; 00000825H
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	33 c9		 xor	 ecx, ecx
  00115	75 b6		 jne	 SHORT $LN13@Getptr
$LN8@Getptr:
  00117	33 d2		 xor	 edx, edx
  00119	0f 85 55 ff ff
	ff		 jne	 $LN10@Getptr

; 2085 :             "vector<bool> iterator not dereferenceable");
; 2086 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2087 : 
; 2088 :         return this->_Myptr;

  0011f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00122	83 c0 08	 add	 eax, 8
  00125	89 45 e4	 mov	 DWORD PTR tv152[ebp], eax
  00128	8b 4d e4	 mov	 ecx, DWORD PTR tv152[ebp]
  0012b	89 4d ec	 mov	 DWORD PTR tv162[ebp], ecx
  0012e	8b 55 ec	 mov	 edx, DWORD PTR tv162[ebp]
  00131	c1 ea 03	 shr	 edx, 3
  00134	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0013a	88 45 fe	 mov	 BYTE PTR tv165[ebp], al
  0013d	80 7d fe 00	 cmp	 BYTE PTR tv165[ebp], 0
  00141	74 1a		 je	 SHORT $LN21@Getptr
  00143	8a 4d ec	 mov	 cl, BYTE PTR tv162[ebp]
  00146	80 e1 07	 and	 cl, 7
  00149	80 c1 03	 add	 cl, 3
  0014c	3a 4d fe	 cmp	 cl, BYTE PTR tv165[ebp]
  0014f	7c 0c		 jl	 SHORT $LN21@Getptr
  00151	8b 55 ec	 mov	 edx, DWORD PTR tv162[ebp]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 ___asan_report_load4
  0015a	83 c4 04	 add	 esp, 4
$LN21@Getptr:
  0015d	8b 45 e4	 mov	 eax, DWORD PTR tv152[ebp]
  00160	8b 00		 mov	 eax, DWORD PTR [eax]

; 2089 :     }

  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
tv86 = -56						; size = 4
tv85 = -52						; size = 4
tv83 = -48						; size = 4
tv75 = -44						; size = 4
tv74 = -40						; size = 4
tv72 = -36						; size = 4
tv128 = -32						; size = 4
tv138 = -28						; size = 4
tv148 = -24						; size = 4
tv158 = -20						; size = 4
tv81 = -16						; size = 4
tv70 = -12						; size = 4
_this$ = -8						; size = 4
tv131 = -4						; size = 1
tv141 = -3						; size = 1
tv151 = -2						; size = 1
tv161 = -1						; size = 1
__Val$ = 8						; size = 1
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=, COMDAT
; _this$ = ecx

; 2062 :     _CONSTEXPR20_CONTAINER _Vb_reference& operator=(bool _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2063 :         if (_Val) {

  00013	0f b6 45 08	 movzx	 eax, BYTE PTR __Val$[ebp]
  00017	85 c0		 test	 eax, eax
  00019	0f 84 9c 00 00
	00		 je	 $LN2@operator

; 2064 :             *const_cast<_Vbase*>(_Getptr()) |= _Mask();

  0001f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00022	e8 00 00 00 00	 call	 ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  00027	89 45 d8	 mov	 DWORD PTR tv74[ebp], eax
  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  00032	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00035	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00038	89 4d ec	 mov	 DWORD PTR tv158[ebp], ecx
  0003b	8b 55 ec	 mov	 edx, DWORD PTR tv158[ebp]
  0003e	c1 ea 03	 shr	 edx, 3
  00041	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00047	88 45 ff	 mov	 BYTE PTR tv161[ebp], al
  0004a	80 7d ff 00	 cmp	 BYTE PTR tv161[ebp], 0
  0004e	74 1a		 je	 SHORT $LN8@operator
  00050	8a 4d ec	 mov	 cl, BYTE PTR tv158[ebp]
  00053	80 e1 07	 and	 cl, 7
  00056	80 c1 03	 add	 cl, 3
  00059	3a 4d ff	 cmp	 cl, BYTE PTR tv161[ebp]
  0005c	7c 0c		 jl	 SHORT $LN8@operator
  0005e	8b 55 ec	 mov	 edx, DWORD PTR tv158[ebp]
  00061	52		 push	 edx
  00062	e8 00 00 00 00	 call	 ___asan_report_load4
  00067	83 c4 04	 add	 esp, 4
$LN8@operator:
  0006a	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0006d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006f	89 4d dc	 mov	 DWORD PTR tv72[ebp], ecx
  00072	8b 55 dc	 mov	 edx, DWORD PTR tv72[ebp]
  00075	0b 55 d8	 or	 edx, DWORD PTR tv74[ebp]
  00078	89 55 d4	 mov	 DWORD PTR tv75[ebp], edx
  0007b	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  0007e	89 45 e8	 mov	 DWORD PTR tv148[ebp], eax
  00081	8b 4d e8	 mov	 ecx, DWORD PTR tv148[ebp]
  00084	c1 e9 03	 shr	 ecx, 3
  00087	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0008d	88 55 fe	 mov	 BYTE PTR tv151[ebp], dl
  00090	80 7d fe 00	 cmp	 BYTE PTR tv151[ebp], 0
  00094	74 18		 je	 SHORT $LN7@operator
  00096	8a 45 e8	 mov	 al, BYTE PTR tv148[ebp]
  00099	24 07		 and	 al, 7
  0009b	04 03		 add	 al, 3
  0009d	3a 45 fe	 cmp	 al, BYTE PTR tv151[ebp]
  000a0	7c 0c		 jl	 SHORT $LN7@operator
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR tv148[ebp]
  000a5	51		 push	 ecx
  000a6	e8 00 00 00 00	 call	 ___asan_report_store4
  000ab	83 c4 04	 add	 esp, 4
$LN7@operator:
  000ae	8b 55 f4	 mov	 edx, DWORD PTR tv70[ebp]
  000b1	8b 45 d4	 mov	 eax, DWORD PTR tv75[ebp]
  000b4	89 02		 mov	 DWORD PTR [edx], eax

; 2065 :         } else {

  000b6	e9 99 00 00 00	 jmp	 $LN3@operator
$LN2@operator:

; 2066 :             *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();

  000bb	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000be	e8 00 00 00 00	 call	 ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  000c3	f7 d0		 not	 eax
  000c5	89 45 cc	 mov	 DWORD PTR tv85[ebp], eax
  000c8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000cb	e8 00 00 00 00	 call	 ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  000d0	89 45 f0	 mov	 DWORD PTR tv81[ebp], eax
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR tv81[ebp]
  000d6	89 4d e4	 mov	 DWORD PTR tv138[ebp], ecx
  000d9	8b 55 e4	 mov	 edx, DWORD PTR tv138[ebp]
  000dc	c1 ea 03	 shr	 edx, 3
  000df	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000e5	88 45 fd	 mov	 BYTE PTR tv141[ebp], al
  000e8	80 7d fd 00	 cmp	 BYTE PTR tv141[ebp], 0
  000ec	74 1a		 je	 SHORT $LN6@operator
  000ee	8a 4d e4	 mov	 cl, BYTE PTR tv138[ebp]
  000f1	80 e1 07	 and	 cl, 7
  000f4	80 c1 03	 add	 cl, 3
  000f7	3a 4d fd	 cmp	 cl, BYTE PTR tv141[ebp]
  000fa	7c 0c		 jl	 SHORT $LN6@operator
  000fc	8b 55 e4	 mov	 edx, DWORD PTR tv138[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ___asan_report_load4
  00105	83 c4 04	 add	 esp, 4
$LN6@operator:
  00108	8b 45 f0	 mov	 eax, DWORD PTR tv81[ebp]
  0010b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0010d	89 4d d0	 mov	 DWORD PTR tv83[ebp], ecx
  00110	8b 55 d0	 mov	 edx, DWORD PTR tv83[ebp]
  00113	23 55 cc	 and	 edx, DWORD PTR tv85[ebp]
  00116	89 55 c8	 mov	 DWORD PTR tv86[ebp], edx
  00119	8b 45 f0	 mov	 eax, DWORD PTR tv81[ebp]
  0011c	89 45 e0	 mov	 DWORD PTR tv128[ebp], eax
  0011f	8b 4d e0	 mov	 ecx, DWORD PTR tv128[ebp]
  00122	c1 e9 03	 shr	 ecx, 3
  00125	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0012b	88 55 fc	 mov	 BYTE PTR tv131[ebp], dl
  0012e	80 7d fc 00	 cmp	 BYTE PTR tv131[ebp], 0
  00132	74 18		 je	 SHORT $LN5@operator
  00134	8a 45 e0	 mov	 al, BYTE PTR tv128[ebp]
  00137	24 07		 and	 al, 7
  00139	04 03		 add	 al, 3
  0013b	3a 45 fc	 cmp	 al, BYTE PTR tv131[ebp]
  0013e	7c 0c		 jl	 SHORT $LN5@operator
  00140	8b 4d e0	 mov	 ecx, DWORD PTR tv128[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ___asan_report_store4
  00149	83 c4 04	 add	 esp, 4
$LN5@operator:
  0014c	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  0014f	8b 45 c8	 mov	 eax, DWORD PTR tv86[ebp]
  00152	89 02		 mov	 DWORD PTR [edx], eax
$LN3@operator:

; 2067 :         }
; 2068 : 
; 2069 :         return *this;

  00154	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 2070 :     }

  00157	8b e5		 mov	 esp, ebp
  00159	5d		 pop	 ebp
  0015a	c2 04 00	 ret	 4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv82 = -36						; size = 4
tv86 = -32						; size = 4
tv84 = -28						; size = 4
_this$ = -24						; size = 4
tv79 = -20						; size = 4
tv77 = -16						; size = 4
tv128 = -12						; size = 4
tv138 = -8						; size = 4
tv131 = -2						; size = 1
tv141 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2055 :     _CONSTEXPR20_CONTAINER _Vb_reference(const _Mybase& _Right) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2056 :         : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 e4	 mov	 DWORD PTR tv84[ebp], eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	83 c0 0c	 add	 eax, 12			; 0000000cH
  00024	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  00027	8b 4d f0	 mov	 ecx, DWORD PTR tv77[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv138[ebp], ecx
  0002d	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  00030	c1 ea 03	 shr	 edx, 3
  00033	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00039	88 45 ff	 mov	 BYTE PTR tv141[ebp], al
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv141[ebp], 0
  00040	74 1a		 je	 SHORT $LN4@Vb_referen
  00042	8a 4d f8	 mov	 cl, BYTE PTR tv138[ebp]
  00045	80 e1 07	 and	 cl, 7
  00048	80 c1 03	 add	 cl, 3
  0004b	3a 4d ff	 cmp	 cl, BYTE PTR tv141[ebp]
  0004e	7c 0c		 jl	 SHORT $LN4@Vb_referen
  00050	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ___asan_report_load4
  00059	83 c4 04	 add	 esp, 4
$LN4@Vb_referen:
  0005c	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d e0	 mov	 DWORD PTR tv86[ebp], ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00067	83 c2 08	 add	 edx, 8
  0006a	89 55 ec	 mov	 DWORD PTR tv79[ebp], edx
  0006d	8b 45 ec	 mov	 eax, DWORD PTR tv79[ebp]
  00070	89 45 f4	 mov	 DWORD PTR tv128[ebp], eax
  00073	8b 4d f4	 mov	 ecx, DWORD PTR tv128[ebp]
  00076	c1 e9 03	 shr	 ecx, 3
  00079	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0007f	88 55 fe	 mov	 BYTE PTR tv131[ebp], dl
  00082	80 7d fe 00	 cmp	 BYTE PTR tv131[ebp], 0
  00086	74 18		 je	 SHORT $LN3@Vb_referen
  00088	8a 45 f4	 mov	 al, BYTE PTR tv128[ebp]
  0008b	24 07		 and	 al, 7
  0008d	04 03		 add	 al, 3
  0008f	3a 45 fe	 cmp	 al, BYTE PTR tv131[ebp]
  00092	7c 0c		 jl	 SHORT $LN3@Vb_referen
  00094	8b 4d f4	 mov	 ecx, DWORD PTR tv128[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ___asan_report_load4
  0009d	83 c4 04	 add	 esp, 4
$LN3@Vb_referen:
  000a0	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	89 45 dc	 mov	 DWORD PTR tv82[ebp], eax
  000a8	8b 4d e4	 mov	 ecx, DWORD PTR tv84[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 e0	 mov	 edx, DWORD PTR tv86[ebp]
  000af	52		 push	 edx
  000b0	8b 45 dc	 mov	 eax, DWORD PTR tv82[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
  000bc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z
_TEXT	SEGMENT
tv74 = -32						; size = 4
tv71 = -28						; size = 4
tv75 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv82 = -12						; size = 4
tv92 = -8						; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
__Cont$ = 8						; size = 4
?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off, COMDAT
; _this$ = ecx

; 2032 :     _CONSTEXPR20_CONTAINER _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2033 :         return static_cast<_Difference_type>(_VBITS * (_Myptr - _Cont->_Myvec.data()) + _Myoff);

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  0001f	83 c1 04	 add	 ecx, 4
  00022	e8 00 00 00 00	 call	 ?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
  00027	89 45 e4	 mov	 DWORD PTR tv71[ebp], eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0002d	89 4d f8	 mov	 DWORD PTR tv92[ebp], ecx
  00030	8b 55 f8	 mov	 edx, DWORD PTR tv92[ebp]
  00033	c1 ea 03	 shr	 edx, 3
  00036	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0003c	88 45 ff	 mov	 BYTE PTR tv95[ebp], al
  0003f	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  00043	74 1a		 je	 SHORT $LN4@Total_off
  00045	8a 4d f8	 mov	 cl, BYTE PTR tv92[ebp]
  00048	80 e1 07	 and	 cl, 7
  0004b	80 c1 03	 add	 cl, 3
  0004e	3a 4d ff	 cmp	 cl, BYTE PTR tv95[ebp]
  00051	7c 0c		 jl	 SHORT $LN4@Total_off
  00053	8b 55 f8	 mov	 edx, DWORD PTR tv92[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ___asan_report_load4
  0005c	83 c4 04	 add	 esp, 4
$LN4@Total_off:
  0005f	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	2b 4d e4	 sub	 ecx, DWORD PTR tv71[ebp]
  00067	c1 f9 02	 sar	 ecx, 2
  0006a	c1 e1 05	 shl	 ecx, 5
  0006d	89 4d e0	 mov	 DWORD PTR tv74[ebp], ecx
  00070	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00073	83 c2 0c	 add	 edx, 12			; 0000000cH
  00076	89 55 e8	 mov	 DWORD PTR tv75[ebp], edx
  00079	8b 45 e8	 mov	 eax, DWORD PTR tv75[ebp]
  0007c	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR tv82[ebp]
  00082	c1 e9 03	 shr	 ecx, 3
  00085	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0008b	88 55 fe	 mov	 BYTE PTR tv85[ebp], dl
  0008e	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  00092	74 18		 je	 SHORT $LN3@Total_off
  00094	8a 45 f4	 mov	 al, BYTE PTR tv82[ebp]
  00097	24 07		 and	 al, 7
  00099	04 03		 add	 al, 3
  0009b	3a 45 fe	 cmp	 al, BYTE PTR tv85[ebp]
  0009e	7c 0c		 jl	 SHORT $LN3@Total_off
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR tv82[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load4
  000a9	83 c4 04	 add	 esp, 4
$LN3@Total_off:
  000ac	8b 55 e8	 mov	 edx, DWORD PTR tv75[ebp]
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv74[ebp]
  000b2	03 02		 add	 eax, DWORD PTR [edx]

; 2034 :     }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv75 = -84						; size = 4
tv72 = -80						; size = 4
tv70 = -76						; size = 4
tv66 = -72						; size = 4
tv74 = -68						; size = 4
tv73 = -64						; size = 4
tv71 = -60						; size = 4
tv67 = -56						; size = 4
tv68 = -52						; size = 4
tv65 = -48						; size = 4
tv64 = -44						; size = 4
tv91 = -40						; size = 4
tv133 = -36						; size = 4
tv143 = -32						; size = 4
tv153 = -28						; size = 4
tv163 = -24						; size = 4
tv173 = -20						; size = 4
tv183 = -16						; size = 4
_this$ = -12						; size = 4
tv94 = -7						; size = 1
tv136 = -6						; size = 1
tv146 = -5						; size = 1
tv156 = -4						; size = 1
tv166 = -3						; size = 1
tv176 = -2						; size = 1
tv186 = -1						; size = 1
__Off$ = 8						; size = 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance, COMDAT
; _this$ = ecx

; 2025 :     _CONSTEXPR20_CONTAINER void _Advance(_Size_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2026 :         _Myoff += _Off;

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f0	 mov	 DWORD PTR tv183[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR tv183[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv186[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv186[ebp], 0
  00035	74 1a		 je	 SHORT $LN9@Advance
  00037	8a 4d f0	 mov	 cl, BYTE PTR tv183[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv186[ebp]
  00043	7c 0c		 jl	 SHORT $LN9@Advance
  00045	8b 55 f0	 mov	 edx, DWORD PTR tv183[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN9@Advance:
  00051	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  00059	89 4d b8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00062	89 55 d0	 mov	 DWORD PTR tv65[ebp], edx
  00065	8b 45 d0	 mov	 eax, DWORD PTR tv65[ebp]
  00068	89 45 ec	 mov	 DWORD PTR tv173[ebp], eax
  0006b	8b 4d ec	 mov	 ecx, DWORD PTR tv173[ebp]
  0006e	c1 e9 03	 shr	 ecx, 3
  00071	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00077	88 55 fe	 mov	 BYTE PTR tv176[ebp], dl
  0007a	80 7d fe 00	 cmp	 BYTE PTR tv176[ebp], 0
  0007e	74 18		 je	 SHORT $LN8@Advance
  00080	8a 45 ec	 mov	 al, BYTE PTR tv173[ebp]
  00083	24 07		 and	 al, 7
  00085	04 03		 add	 al, 3
  00087	3a 45 fe	 cmp	 al, BYTE PTR tv176[ebp]
  0008a	7c 0c		 jl	 SHORT $LN8@Advance
  0008c	8b 4d ec	 mov	 ecx, DWORD PTR tv173[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ___asan_report_store4
  00095	83 c4 04	 add	 esp, 4
$LN8@Advance:
  00098	8b 55 d0	 mov	 edx, DWORD PTR tv65[ebp]
  0009b	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  0009e	89 02		 mov	 DWORD PTR [edx], eax

; 2027 :         _Myptr += _Myoff / _VBITS;

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a6	89 4d cc	 mov	 DWORD PTR tv68[ebp], ecx
  000a9	8b 55 cc	 mov	 edx, DWORD PTR tv68[ebp]
  000ac	89 55 e8	 mov	 DWORD PTR tv163[ebp], edx
  000af	8b 45 e8	 mov	 eax, DWORD PTR tv163[ebp]
  000b2	c1 e8 03	 shr	 eax, 3
  000b5	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000bb	88 4d fd	 mov	 BYTE PTR tv166[ebp], cl
  000be	80 7d fd 00	 cmp	 BYTE PTR tv166[ebp], 0
  000c2	74 1a		 je	 SHORT $LN7@Advance
  000c4	8a 55 e8	 mov	 dl, BYTE PTR tv163[ebp]
  000c7	80 e2 07	 and	 dl, 7
  000ca	80 c2 03	 add	 dl, 3
  000cd	3a 55 fd	 cmp	 dl, BYTE PTR tv166[ebp]
  000d0	7c 0c		 jl	 SHORT $LN7@Advance
  000d2	8b 45 e8	 mov	 eax, DWORD PTR tv163[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ___asan_report_load4
  000db	83 c4 04	 add	 esp, 4
$LN7@Advance:
  000de	8b 4d cc	 mov	 ecx, DWORD PTR tv68[ebp]
  000e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e3	c1 ea 05	 shr	 edx, 5
  000e6	c1 e2 02	 shl	 edx, 2
  000e9	89 55 b4	 mov	 DWORD PTR tv70[ebp], edx
  000ec	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 c0 08	 add	 eax, 8
  000f2	89 45 c8	 mov	 DWORD PTR tv67[ebp], eax
  000f5	8b 4d c8	 mov	 ecx, DWORD PTR tv67[ebp]
  000f8	89 4d e4	 mov	 DWORD PTR tv153[ebp], ecx
  000fb	8b 55 e4	 mov	 edx, DWORD PTR tv153[ebp]
  000fe	c1 ea 03	 shr	 edx, 3
  00101	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00107	88 45 fc	 mov	 BYTE PTR tv156[ebp], al
  0010a	80 7d fc 00	 cmp	 BYTE PTR tv156[ebp], 0
  0010e	74 1a		 je	 SHORT $LN6@Advance
  00110	8a 4d e4	 mov	 cl, BYTE PTR tv153[ebp]
  00113	80 e1 07	 and	 cl, 7
  00116	80 c1 03	 add	 cl, 3
  00119	3a 4d fc	 cmp	 cl, BYTE PTR tv156[ebp]
  0011c	7c 0c		 jl	 SHORT $LN6@Advance
  0011e	8b 55 e4	 mov	 edx, DWORD PTR tv153[ebp]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 ___asan_report_load4
  00127	83 c4 04	 add	 esp, 4
$LN6@Advance:
  0012a	8b 45 c8	 mov	 eax, DWORD PTR tv67[ebp]
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	03 4d b4	 add	 ecx, DWORD PTR tv70[ebp]
  00132	89 4d b0	 mov	 DWORD PTR tv72[ebp], ecx
  00135	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00138	83 c2 08	 add	 edx, 8
  0013b	89 55 c4	 mov	 DWORD PTR tv71[ebp], edx
  0013e	8b 45 c4	 mov	 eax, DWORD PTR tv71[ebp]
  00141	89 45 e0	 mov	 DWORD PTR tv143[ebp], eax
  00144	8b 4d e0	 mov	 ecx, DWORD PTR tv143[ebp]
  00147	c1 e9 03	 shr	 ecx, 3
  0014a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00150	88 55 fb	 mov	 BYTE PTR tv146[ebp], dl
  00153	80 7d fb 00	 cmp	 BYTE PTR tv146[ebp], 0
  00157	74 18		 je	 SHORT $LN5@Advance
  00159	8a 45 e0	 mov	 al, BYTE PTR tv143[ebp]
  0015c	24 07		 and	 al, 7
  0015e	04 03		 add	 al, 3
  00160	3a 45 fb	 cmp	 al, BYTE PTR tv146[ebp]
  00163	7c 0c		 jl	 SHORT $LN5@Advance
  00165	8b 4d e0	 mov	 ecx, DWORD PTR tv143[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 ___asan_report_store4
  0016e	83 c4 04	 add	 esp, 4
$LN5@Advance:
  00171	8b 55 c4	 mov	 edx, DWORD PTR tv71[ebp]
  00174	8b 45 b0	 mov	 eax, DWORD PTR tv72[ebp]
  00177	89 02		 mov	 DWORD PTR [edx], eax

; 2028 :         _Myoff %= _VBITS;

  00179	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0017f	89 4d c0	 mov	 DWORD PTR tv73[ebp], ecx
  00182	8b 55 c0	 mov	 edx, DWORD PTR tv73[ebp]
  00185	89 55 dc	 mov	 DWORD PTR tv133[ebp], edx
  00188	8b 45 dc	 mov	 eax, DWORD PTR tv133[ebp]
  0018b	c1 e8 03	 shr	 eax, 3
  0018e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00194	88 4d fa	 mov	 BYTE PTR tv136[ebp], cl
  00197	80 7d fa 00	 cmp	 BYTE PTR tv136[ebp], 0
  0019b	74 1a		 je	 SHORT $LN4@Advance
  0019d	8a 55 dc	 mov	 dl, BYTE PTR tv133[ebp]
  001a0	80 e2 07	 and	 dl, 7
  001a3	80 c2 03	 add	 dl, 3
  001a6	3a 55 fa	 cmp	 dl, BYTE PTR tv136[ebp]
  001a9	7c 0c		 jl	 SHORT $LN4@Advance
  001ab	8b 45 dc	 mov	 eax, DWORD PTR tv133[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ___asan_report_load4
  001b4	83 c4 04	 add	 esp, 4
$LN4@Advance:
  001b7	8b 4d c0	 mov	 ecx, DWORD PTR tv73[ebp]
  001ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bc	33 d2		 xor	 edx, edx
  001be	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001c3	f7 f1		 div	 ecx
  001c5	89 55 ac	 mov	 DWORD PTR tv75[ebp], edx
  001c8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001cb	83 c2 0c	 add	 edx, 12			; 0000000cH
  001ce	89 55 bc	 mov	 DWORD PTR tv74[ebp], edx
  001d1	8b 45 bc	 mov	 eax, DWORD PTR tv74[ebp]
  001d4	89 45 d8	 mov	 DWORD PTR tv91[ebp], eax
  001d7	8b 4d d8	 mov	 ecx, DWORD PTR tv91[ebp]
  001da	c1 e9 03	 shr	 ecx, 3
  001dd	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e3	88 55 f9	 mov	 BYTE PTR tv94[ebp], dl
  001e6	80 7d f9 00	 cmp	 BYTE PTR tv94[ebp], 0
  001ea	74 18		 je	 SHORT $LN3@Advance
  001ec	8a 45 d8	 mov	 al, BYTE PTR tv91[ebp]
  001ef	24 07		 and	 al, 7
  001f1	04 03		 add	 al, 3
  001f3	3a 45 f9	 cmp	 al, BYTE PTR tv94[ebp]
  001f6	7c 0c		 jl	 SHORT $LN3@Advance
  001f8	8b 4d d8	 mov	 ecx, DWORD PTR tv91[ebp]
  001fb	51		 push	 ecx
  001fc	e8 00 00 00 00	 call	 ___asan_report_store4
  00201	83 c4 04	 add	 esp, 4
$LN3@Advance:
  00204	8b 55 bc	 mov	 edx, DWORD PTR tv74[ebp]
  00207	8b 45 ac	 mov	 eax, DWORD PTR tv75[ebp]
  0020a	89 02		 mov	 DWORD PTR [edx], eax

; 2029 :     }

  0020c	8b e5		 mov	 esp, ebp
  0020e	5d		 pop	 ebp
  0020f	c2 04 00	 ret	 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
tv76 = -24						; size = 4
tv75 = -20						; size = 4
tv87 = -16						; size = 4
tv129 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Mypvbool$ = 16					; size = 4
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2018 :         : _Myptr(_Ptr), _Myoff(_Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 08	 add	 eax, 8
  00021	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  00024	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv129[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv129[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv132[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0003d	74 1a		 je	 SHORT $LN4@Vb_iter_ba
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv129[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv132[ebp]
  0004b	7c 0c		 jl	 SHORT $LN4@Vb_iter_ba
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv129[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN4@Vb_iter_ba:
  00059	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	83 c2 0c	 add	 edx, 12			; 0000000cH
  00067	89 55 e8	 mov	 DWORD PTR tv76[ebp], edx
  0006a	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  0006d	89 45 f0	 mov	 DWORD PTR tv87[ebp], eax
  00070	8b 4d f0	 mov	 ecx, DWORD PTR tv87[ebp]
  00073	c1 e9 03	 shr	 ecx, 3
  00076	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0007c	88 55 fe	 mov	 BYTE PTR tv90[ebp], dl
  0007f	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  00083	74 18		 je	 SHORT $LN3@Vb_iter_ba
  00085	8a 45 f0	 mov	 al, BYTE PTR tv87[ebp]
  00088	24 07		 and	 al, 7
  0008a	04 03		 add	 al, 3
  0008c	3a 45 fe	 cmp	 al, BYTE PTR tv90[ebp]
  0008f	7c 0c		 jl	 SHORT $LN3@Vb_iter_ba
  00091	8b 4d f0	 mov	 ecx, DWORD PTR tv87[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ___asan_report_store4
  0009a	83 c4 04	 add	 esp, 4
$LN3@Vb_iter_ba:
  0009d	8b 55 e8	 mov	 edx, DWORD PTR tv76[ebp]
  000a0	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  000a3	89 02		 mov	 DWORD PTR [edx], eax

; 2019 :         this->_Adopt(_Mypvbool);

  000a5	8b 4d 10	 mov	 ecx, DWORD PTR __Mypvbool$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 2020 :     }

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?end@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@end
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@end
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@end:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 44   :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?end@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?begin@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@begin
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@begin
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@begin:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?begin@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@H@std@@QAE@PBH0@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@H@std@@QAE@PBH0@Z PROC		; std::initializer_list<int>::initializer_list<int>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@initialize
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@initialize
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@initialize:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@initialize
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@initialize
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@initialize:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$initializer_list@H@std@@QAE@PBH0@Z ENDP		; std::initializer_list<int>::initializer_list<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 02	 shl	 eax, 2
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S13$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S13$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S13$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -240					; size = 4
__asan_gen_1$ = -236					; size = 4
__asan_gen_2$ = -232					; size = 4
$T3 = -224						; size = 1
_$S9$ = -208						; size = 1
__Proxy$ = -192						; size = 8
__Guard$4 = -176					; size = 4
tv242 = -136						; size = 1
tv232 = -135						; size = 1
tv222 = -134						; size = 1
tv212 = -133						; size = 1
tv202 = -132						; size = 1
tv192 = -131						; size = 1
$T5 = -130						; size = 1
$T6 = -129						; size = 1
tv167 = -128						; size = 4
_this$ = -124						; size = 4
tv239 = -120						; size = 4
tv229 = -116						; size = 4
tv219 = -112						; size = 4
tv209 = -108						; size = 4
__Rightlast$ = -104					; size = 4
__Rightfirst$ = -100					; size = 4
__My_data$ = -96					; size = 4
tv199 = -92						; size = 4
tv189 = -88						; size = 4
tv86 = -84						; size = 4
__Right_data$ = -80					; size = 4
tv87 = -76						; size = 4
tv138 = -72						; size = 4
tv135 = -68						; size = 4
tv165 = -64						; size = 4
tv76 = -60						; size = 4
tv78 = -56						; size = 4
__Alproxy$ = -52					; size = 4
tv137 = -48						; size = 4
tv185 = -44						; size = 4
tv152 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 555  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 10 ff ff
	ff		 add	 esp, -240		; ffffff10H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 10 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00056	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00060	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv165[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv165[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d 80	 mov	 DWORD PTR tv167[ebp], ecx
  00078	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00085	8b 45 80	 mov	 eax, DWORD PTR tv167[ebp]
  00088	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  0008e	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00092	8b 4d 80	 mov	 ecx, DWORD PTR tv167[ebp]
  00095	c7 01 f8 f3 f3
	f3		 mov	 DWORD PTR [ecx], -202116104 ; f3f3f3f8H
  0009b	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  0009f	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  000a2	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  000a5	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S9$[ebp]
  000ab	c1 e8 03	 shr	 eax, 3
  000ae	c6 80 00 00 00
	30 01		 mov	 BYTE PTR [eax+805306368], 1
  000b5	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000ca	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000cf	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	89 55 c8	 mov	 DWORD PTR tv78[ebp], edx
  000d5	8b 4b 08	 mov	 ecx, DWORD PTR __Right$[ebx]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
  000ea	83 c4 08	 add	 esp, 8
  000ed	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000f0	6a 01		 push	 1
  000f2	8d 8d 7f ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000f8	51		 push	 ecx
  000f9	8d 95 7e ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ___asan_memcpy
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  0010b	50		 push	 eax
  0010c	0f b6 8d 7e ff
	ff ff		 movzx	 ecx, BYTE PTR $T5[ebp]
  00113	51		 push	 ecx
  00114	8b 4d c8	 mov	 ecx, DWORD PTR tv78[ebp]
  00117	e8 00 00 00 00	 call	 ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
  0011c	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00122	c1 ea 03	 shr	 edx, 3
  00125	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 556  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0012c	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00134	50		 push	 eax
  00135	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _$S9$[ebp]
  0013b	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  00140	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S9$[ebp]
  00146	89 45 cc	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 557  :         auto& _My_data            = _Mypair._Myval2;

  00149	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	89 4d a0	 mov	 DWORD PTR __My_data$[ebp], ecx

; 558  :         const auto& _Right_data   = _Right._Mypair._Myval2;

  0014f	8b 53 08	 mov	 edx, DWORD PTR __Right$[ebx]
  00152	89 55 b0	 mov	 DWORD PTR __Right_data$[ebp], edx

; 559  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00155	8b 45 b0	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00158	83 c0 04	 add	 eax, 4
  0015b	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
  0015e	8b 4d ac	 mov	 ecx, DWORD PTR tv86[ebp]
  00161	89 4d 88	 mov	 DWORD PTR tv239[ebp], ecx
  00164	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00167	c1 ea 03	 shr	 edx, 3
  0016a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00170	88 85 78 ff ff
	ff		 mov	 BYTE PTR tv242[ebp], al
  00176	80 bd 78 ff ff
	ff 00		 cmp	 BYTE PTR tv242[ebp], 0
  0017d	74 1d		 je	 SHORT $LN11@vector
  0017f	8a 4d 88	 mov	 cl, BYTE PTR tv239[ebp]
  00182	80 e1 07	 and	 cl, 7
  00185	80 c1 03	 add	 cl, 3
  00188	3a 8d 78 ff ff
	ff		 cmp	 cl, BYTE PTR tv242[ebp]
  0018e	7c 0c		 jl	 SHORT $LN11@vector
  00190	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ___asan_report_load4
  00199	83 c4 04	 add	 esp, 4
$LN11@vector:
  0019c	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	89 4d 9c	 mov	 DWORD PTR __Rightfirst$[ebp], ecx

; 560  :         const pointer _Rightlast  = _Right_data._Mylast;

  001a4	8b 55 b0	 mov	 edx, DWORD PTR __Right_data$[ebp]
  001a7	83 c2 08	 add	 edx, 8
  001aa	89 55 b4	 mov	 DWORD PTR tv87[ebp], edx
  001ad	8b 45 b4	 mov	 eax, DWORD PTR tv87[ebp]
  001b0	89 45 8c	 mov	 DWORD PTR tv229[ebp], eax
  001b3	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001b6	c1 e9 03	 shr	 ecx, 3
  001b9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001bf	88 95 79 ff ff
	ff		 mov	 BYTE PTR tv232[ebp], dl
  001c5	80 bd 79 ff ff
	ff 00		 cmp	 BYTE PTR tv232[ebp], 0
  001cc	74 1b		 je	 SHORT $LN10@vector
  001ce	8a 45 8c	 mov	 al, BYTE PTR tv229[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 85 79 ff ff
	ff		 cmp	 al, BYTE PTR tv232[ebp]
  001db	7c 0c		 jl	 SHORT $LN10@vector
  001dd	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ___asan_report_load4
  001e6	83 c4 04	 add	 esp, 4
$LN10@vector:
  001e9	8b 55 b4	 mov	 edx, DWORD PTR tv87[ebp]
  001ec	8b 02		 mov	 eax, DWORD PTR [edx]
  001ee	89 45 98	 mov	 DWORD PTR __Rightlast$[ebp], eax

; 561  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  001f1	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  001f4	51		 push	 ecx
  001f5	8b 55 cc	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  001f8	52		 push	 edx
  001f9	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  001ff	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00204	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 562  :         if (_Rightfirst != _Rightlast) {

  0020b	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  0020e	3b 45 98	 cmp	 eax, DWORD PTR __Rightlast$[ebp]
  00211	0f 84 85 01 00
	00		 je	 $LN2@vector
  00217	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  0021d	c1 e9 03	 shr	 ecx, 3
  00220	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4

; 563  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00227	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  0022a	2b 55 9c	 sub	 edx, DWORD PTR __Rightfirst$[ebp]
  0022d	c1 fa 02	 sar	 edx, 2
  00230	52		 push	 edx
  00231	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 564  :             _Tidy_guard<vector> _Guard{this};

  00239	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0023f	89 45 90	 mov	 DWORD PTR tv219[ebp], eax
  00242	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  00245	c1 e9 03	 shr	 ecx, 3
  00248	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0024e	88 95 7a ff ff
	ff		 mov	 BYTE PTR tv222[ebp], dl
  00254	80 bd 7a ff ff
	ff 00		 cmp	 BYTE PTR tv222[ebp], 0
  0025b	74 1b		 je	 SHORT $LN9@vector
  0025d	8a 45 90	 mov	 al, BYTE PTR tv219[ebp]
  00260	24 07		 and	 al, 7
  00262	04 03		 add	 al, 3
  00264	3a 85 7a ff ff
	ff		 cmp	 al, BYTE PTR tv222[ebp]
  0026a	7c 0c		 jl	 SHORT $LN9@vector
  0026c	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ___asan_report_store4
  00275	83 c4 04	 add	 esp, 4
$LN9@vector:
  00278	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  0027b	89 95 50 ff ff
	ff		 mov	 DWORD PTR __Guard$4[ebp], edx
  00281	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 565  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00285	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00288	83 c0 04	 add	 eax, 4
  0028b	89 45 b8	 mov	 DWORD PTR tv138[ebp], eax
  0028e	8b 4d b8	 mov	 ecx, DWORD PTR tv138[ebp]
  00291	89 4d 94	 mov	 DWORD PTR tv209[ebp], ecx
  00294	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  00297	c1 ea 03	 shr	 edx, 3
  0029a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  002a0	88 85 7b ff ff
	ff		 mov	 BYTE PTR tv212[ebp], al
  002a6	80 bd 7b ff ff
	ff 00		 cmp	 BYTE PTR tv212[ebp], 0
  002ad	74 1d		 je	 SHORT $LN8@vector
  002af	8a 4d 94	 mov	 cl, BYTE PTR tv209[ebp]
  002b2	80 e1 07	 and	 cl, 7
  002b5	80 c1 03	 add	 cl, 3
  002b8	3a 8d 7b ff ff
	ff		 cmp	 cl, BYTE PTR tv212[ebp]
  002be	7c 0c		 jl	 SHORT $LN8@vector
  002c0	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 ___asan_report_load4
  002c9	83 c4 04	 add	 esp, 4
$LN8@vector:
  002cc	8b 45 b8	 mov	 eax, DWORD PTR tv138[ebp]
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	51		 push	 ecx
  002d2	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  002d5	52		 push	 edx
  002d6	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  002d9	50		 push	 eax
  002da	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  002dd	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  002e2	89 45 d0	 mov	 DWORD PTR tv137[ebp], eax
  002e5	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  002e8	83 c1 08	 add	 ecx, 8
  002eb	89 4d bc	 mov	 DWORD PTR tv135[ebp], ecx
  002ee	8b 55 bc	 mov	 edx, DWORD PTR tv135[ebp]
  002f1	89 55 a4	 mov	 DWORD PTR tv199[ebp], edx
  002f4	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  002f7	c1 e8 03	 shr	 eax, 3
  002fa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00300	88 8d 7c ff ff
	ff		 mov	 BYTE PTR tv202[ebp], cl
  00306	80 bd 7c ff ff
	ff 00		 cmp	 BYTE PTR tv202[ebp], 0
  0030d	74 1d		 je	 SHORT $LN7@vector
  0030f	8a 55 a4	 mov	 dl, BYTE PTR tv199[ebp]
  00312	80 e2 07	 and	 dl, 7
  00315	80 c2 03	 add	 dl, 3
  00318	3a 95 7c ff ff
	ff		 cmp	 dl, BYTE PTR tv202[ebp]
  0031e	7c 0c		 jl	 SHORT $LN7@vector
  00320	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 ___asan_report_store4
  00329	83 c4 04	 add	 esp, 4
$LN7@vector:
  0032c	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp]
  0032f	8b 55 d0	 mov	 edx, DWORD PTR tv137[ebp]
  00332	89 11		 mov	 DWORD PTR [ecx], edx

; 566  :             _Guard._Target   = nullptr;

  00334	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0033a	89 45 a8	 mov	 DWORD PTR tv189[ebp], eax
  0033d	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  00340	c1 e9 03	 shr	 ecx, 3
  00343	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00349	88 95 7d ff ff
	ff		 mov	 BYTE PTR tv192[ebp], dl
  0034f	80 bd 7d ff ff
	ff 00		 cmp	 BYTE PTR tv192[ebp], 0
  00356	74 1b		 je	 SHORT $LN6@vector
  00358	8a 45 a8	 mov	 al, BYTE PTR tv189[ebp]
  0035b	24 07		 and	 al, 7
  0035d	04 03		 add	 al, 3
  0035f	3a 85 7d ff ff
	ff		 cmp	 al, BYTE PTR tv192[ebp]
  00365	7c 0c		 jl	 SHORT $LN6@vector
  00367	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  0036a	51		 push	 ecx
  0036b	e8 00 00 00 00	 call	 ___asan_report_store4
  00370	83 c4 04	 add	 esp, 4
$LN6@vector:
  00373	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$4[ebp], 0

; 567  :         }

  0037d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00381	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00387	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  0038c	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$4[ebp]
  00392	c1 ea 03	 shr	 edx, 3
  00395	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN2@vector:

; 568  : 
; 569  :         _Proxy._Release();

  0039c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003a2	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 570  :     }

  003a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ae	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003b4	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  003b9	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  003bc	89 45 d8	 mov	 DWORD PTR tv152[ebp], eax
  003bf	c7 85 10 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  003c9	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  003cf	c1 e9 03	 shr	 ecx, 3
  003d2	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  003d8	89 4d d4	 mov	 DWORD PTR tv185[ebp], ecx
  003db	6a 0d		 push	 13			; 0000000dH
  003dd	8b 55 d4	 mov	 edx, DWORD PTR tv185[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003e6	83 c4 08	 add	 esp, 8
  003e9	8b 45 d8	 mov	 eax, DWORD PTR tv152[ebp]
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f6	59		 pop	 ecx
  003f7	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fa	33 cd		 xor	 ecx, ebp
  003fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00401	8b e5		 mov	 esp, ebp
  00403	5d		 pop	 ebp
  00404	8b e3		 mov	 esp, ebx
  00406	5b		 pop	 ebx
  00407	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1:
  0000b	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
_$S7$ = -152						; size = 1
__Proxy$ = -136						; size = 8
$T3 = -120						; size = 1
$T4 = -76						; size = 1
$T5 = -75						; size = 1
$T6 = -74						; size = 1
$T7 = -73						; size = 1
tv153 = -72						; size = 4
_this$ = -68						; size = 4
tv151 = -64						; size = 4
tv70 = -60						; size = 4
__Alproxy$ = -56					; size = 4
tv135 = -52						; size = 4
tv133 = -48						; size = 4
tv162 = -44						; size = 4
tv150 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  00056	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00060	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv151[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv151[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b8	 mov	 DWORD PTR tv153[ebp], ecx
  00078	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00085	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b8 02	 add	 DWORD PTR tv153[ebp], 2
  000a1	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	c1 e9 03	 shr	 ecx, 3
  000ad	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	89 55 c4	 mov	 DWORD PTR tv70[ebp], edx
  000c4	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  000c7	50		 push	 eax
  000c8	0f b6 4d b6	 movzx	 ecx, BYTE PTR $T6[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  000d0	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _$S7$[ebp]
  000e4	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  000e9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _$S7$[ebp]
  000ef	89 55 c8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000f9	51		 push	 ecx
  000fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0010c	6a 01		 push	 1
  0010e	6a 00		 push	 0
  00110	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_memset
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	6a 01		 push	 1
  0011e	8d 45 b7	 lea	 eax, DWORD PTR $T7[ebp]
  00121	50		 push	 eax
  00122	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ___asan_memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	6a 01		 push	 1
  00130	8d 55 b4	 lea	 edx, DWORD PTR $T4[ebp]
  00133	52		 push	 edx
  00134	8d 45 b5	 lea	 eax, DWORD PTR $T5[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ___asan_memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  00143	e8 00 00 00 00	 call	 ?end@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::end
  00148	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  0014b	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  0014e	e8 00 00 00 00	 call	 ?begin@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::begin
  00153	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  00156	0f b6 4d b5	 movzx	 ecx, BYTE PTR $T5[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00162	50		 push	 eax
  00163	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
  0016b	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	c1 e9 03	 shr	 ecx, 3
  00171	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 551  :         _Proxy._Release();

  00178	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00190	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00195	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	89 55 d8	 mov	 DWORD PTR tv150[ebp], edx
  0019b	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  001ab	c1 e8 03	 shr	 eax, 3
  001ae	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001b3	89 45 d4	 mov	 DWORD PTR tv162[ebp], eax
  001b6	6a 0b		 push	 11			; 0000000bH
  001b8	8b 4d d4	 mov	 ecx, DWORD PTR tv162[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 45 d8	 mov	 eax, DWORD PTR tv150[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	8b e3		 mov	 esp, ebx
  001e1	5b		 pop	 ebx
  001e2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction, COMDAT

; 731  :     _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :         return _Al;

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 733  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xran, COMDAT
; _this$ = ecx

; 3096 :     [[noreturn]] void _Xran() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3097 :         _Xout_of_range("invalid vector<bool> subscript");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 3098 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 3092 :     [[noreturn]] void _Xlen() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3093 :         _Xlength_error("vector<bool> too long");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@
  00016	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 3094 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__asan_gen_0$ = -336					; size = 4
__asan_gen_1$ = -332					; size = 4
__asan_gen_2$ = -328					; size = 4
$T2 = -320						; size = 12
$T3 = -272						; size = 12
$T4 = -224						; size = 12
$T5 = -176						; size = 12
tv318 = -127						; size = 1
tv308 = -126						; size = 1
tv298 = -125						; size = 1
tv232 = -124						; size = 4
_this$ = -120						; size = 4
tv208 = -116						; size = 4
tv315 = -112						; size = 4
__Words$ = -108						; size = 4
tv305 = -104						; size = 4
tv295 = -100						; size = 4
tv256 = -96						; size = 4
tv249 = -92						; size = 4
tv242 = -88						; size = 4
tv235 = -84						; size = 4
tv284 = -80						; size = 4
tv277 = -76						; size = 4
tv270 = -72						; size = 4
tv263 = -68						; size = 4
tv188 = -64						; size = 4
tv230 = -60						; size = 4
tv166 = -56						; size = 4
tv212 = -52						; size = 4
tv137 = -48						; size = 4
tv214 = -44						; size = 4
tv174 = -40						; size = 4
tv219 = -36						; size = 4
tv185 = -32						; size = 4
tv205 = -28						; size = 4
tv207 = -24						; size = 4
tv209 = -20						; size = 4
tv291 = -16						; size = 4
$T6 = -12						; size = 4
$T7 = -8						; size = 4
tv217 = -4						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 3075 :     _CONSTEXPR20_CONTAINER void _Trim(size_type _Size) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 5c 01 00
	00		 sub	 esp, 348		; 0000015cH
  0001c	56		 push	 esi
  0001d	89 4d 88	 mov	 DWORD PTR _this$[ebp], ecx
  00020	c7 85 b0 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002a	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
  00034	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
  0003e	8d 85 b0 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00044	89 45 c4	 mov	 DWORD PTR tv230[ebp], eax
  00047	8b 4d c4	 mov	 ecx, DWORD PTR tv230[ebp]
  0004a	c1 e9 03	 shr	 ecx, 3
  0004d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00053	89 4d 84	 mov	 DWORD PTR tv232[ebp], ecx
  00056	8b 55 84	 mov	 edx, DWORD PTR tv232[ebp]
  00059	c7 02 f1 f1 f8
	04		 mov	 DWORD PTR [edx], 83423729 ; 04f8f1f1H
  0005f	83 45 84 04	 add	 DWORD PTR tv232[ebp], 4
  00063	8b 45 84	 mov	 eax, DWORD PTR tv232[ebp]
  00066	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  0006c	83 45 84 04	 add	 DWORD PTR tv232[ebp], 4
  00070	8b 4d 84	 mov	 ecx, DWORD PTR tv232[ebp]
  00073	c7 01 f8 04 f2
	f2		 mov	 DWORD PTR [ecx], -219020040 ; f2f204f8H
  00079	83 45 84 04	 add	 DWORD PTR tv232[ebp], 4
  0007d	8b 55 84	 mov	 edx, DWORD PTR tv232[ebp]
  00080	c7 02 f2 f2 f8
	04		 mov	 DWORD PTR [edx], 83423986 ; 04f8f2f2H
  00086	83 45 84 04	 add	 DWORD PTR tv232[ebp], 4
  0008a	8b 45 84	 mov	 eax, DWORD PTR tv232[ebp]
  0008d	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  00093	83 45 84 04	 add	 DWORD PTR tv232[ebp], 4
  00097	8b 4d 84	 mov	 ecx, DWORD PTR tv232[ebp]
  0009a	c7 01 f8 04 f3
	f3		 mov	 DWORD PTR [ecx], -202177288 ; f3f304f8H
  000a0	83 45 84 04	 add	 DWORD PTR tv232[ebp], 4
  000a4	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  000a9	8b 45 84	 mov	 eax, DWORD PTR tv232[ebp]
  000ac	66 89 10	 mov	 WORD PTR [eax], dx
  000af	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b4	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3076 :         if (max_size() < _Size) {

  000b9	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000bc	e8 00 00 00 00	 call	 ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
  000c1	3b 43 08	 cmp	 eax, DWORD PTR __Size$[ebx]
  000c4	73 08		 jae	 SHORT $LN2@Trim

; 3077 :             _Xlen(); // result too long

  000c6	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000c9	e8 00 00 00 00	 call	 ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN2@Trim:

; 3078 :         }
; 3079 : 
; 3080 :         const size_type _Words = this->_Nw(_Size);

  000ce	8b 4b 08	 mov	 ecx, DWORD PTR __Size$[ebx]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  000d7	83 c4 04	 add	 esp, 4
  000da	89 45 94	 mov	 DWORD PTR __Words$[ebp], eax

; 3081 :         if (_Words < this->_Myvec.size()) {

  000dd	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  000e0	83 c1 04	 add	 ecx, 4
  000e3	e8 00 00 00 00	 call	 ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
  000e8	39 45 94	 cmp	 DWORD PTR __Words$[ebp], eax
  000eb	0f 83 f7 01 00
	00		 jae	 $LN3@Trim
  000f1	8d 95 c0 fe ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  000f7	c1 ea 03	 shr	 edx, 3
  000fa	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00100	89 55 a0	 mov	 DWORD PTR tv256[ebp], edx
  00103	6a 01		 push	 1
  00105	8b 45 a0	 mov	 eax, DWORD PTR tv256[ebp]
  00108	50		 push	 eax
  00109	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0010e	83 c4 08	 add	 esp, 8
  00111	8b 4d a0	 mov	 ecx, DWORD PTR tv256[ebp]
  00114	c6 41 01 04	 mov	 BYTE PTR [ecx+1], 4
  00118	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0011e	c1 ea 03	 shr	 edx, 3
  00121	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00127	89 55 a4	 mov	 DWORD PTR tv249[ebp], edx
  0012a	6a 01		 push	 1
  0012c	8b 45 a4	 mov	 eax, DWORD PTR tv249[ebp]
  0012f	50		 push	 eax
  00130	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00135	83 c4 08	 add	 esp, 8
  00138	8b 4d a4	 mov	 ecx, DWORD PTR tv249[ebp]
  0013b	c6 41 01 04	 mov	 BYTE PTR [ecx+1], 4
  0013f	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00145	c1 ea 03	 shr	 edx, 3
  00148	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0014e	89 55 a8	 mov	 DWORD PTR tv242[ebp], edx
  00151	6a 01		 push	 1
  00153	8b 45 a8	 mov	 eax, DWORD PTR tv242[ebp]
  00156	50		 push	 eax
  00157	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0015c	83 c4 08	 add	 esp, 8
  0015f	8b 4d a8	 mov	 ecx, DWORD PTR tv242[ebp]
  00162	c6 41 01 04	 mov	 BYTE PTR [ecx+1], 4
  00166	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00175	89 55 ac	 mov	 DWORD PTR tv235[ebp], edx
  00178	6a 01		 push	 1
  0017a	8b 45 ac	 mov	 eax, DWORD PTR tv235[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00183	83 c4 08	 add	 esp, 8
  00186	8b 4d ac	 mov	 ecx, DWORD PTR tv235[ebp]
  00189	c6 41 01 04	 mov	 BYTE PTR [ecx+1], 4

; 3082 :             this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());

  0018d	8b 55 88	 mov	 edx, DWORD PTR _this$[ebp]
  00190	83 c2 04	 add	 edx, 4
  00193	89 55 e0	 mov	 DWORD PTR tv185[ebp], edx
  00196	8b 45 88	 mov	 eax, DWORD PTR _this$[ebp]
  00199	83 c0 04	 add	 eax, 4
  0019c	89 45 d0	 mov	 DWORD PTR tv137[ebp], eax
  0019f	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  001a2	83 c1 04	 add	 ecx, 4
  001a5	89 4d c8	 mov	 DWORD PTR tv166[ebp], ecx
  001a8	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001ae	52		 push	 edx
  001af	8b 4d c8	 mov	 ecx, DWORD PTR tv166[ebp]
  001b2	e8 00 00 00 00	 call	 ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
  001b7	89 45 cc	 mov	 DWORD PTR tv212[ebp], eax
  001ba	8b 45 cc	 mov	 eax, DWORD PTR tv212[ebp]
  001bd	89 45 d8	 mov	 DWORD PTR tv174[ebp], eax
  001c0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001c3	8b f4		 mov	 esi, esp
  001c5	89 65 f4	 mov	 DWORD PTR $T6[ebp], esp
  001c8	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  001ce	51		 push	 ecx
  001cf	8b 4d d0	 mov	 ecx, DWORD PTR tv137[ebp]
  001d2	e8 00 00 00 00	 call	 ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
  001d7	89 45 d4	 mov	 DWORD PTR tv214[ebp], eax
  001da	8b 55 d4	 mov	 edx, DWORD PTR tv214[ebp]
  001dd	52		 push	 edx
  001de	8b ce		 mov	 ecx, esi
  001e0	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  001e5	83 ec 0c	 sub	 esp, 12			; 0000000cH
  001e8	8b f4		 mov	 esi, esp
  001ea	89 65 f8	 mov	 DWORD PTR $T7[ebp], esp
  001ed	8b 45 94	 mov	 eax, DWORD PTR __Words$[ebp]
  001f0	50		 push	 eax
  001f1	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  001f7	51		 push	 ecx
  001f8	8b 4d d8	 mov	 ecx, DWORD PTR tv174[ebp]
  001fb	e8 00 00 00 00	 call	 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
  00200	89 45 dc	 mov	 DWORD PTR tv219[ebp], eax
  00203	8b 55 dc	 mov	 edx, DWORD PTR tv219[ebp]
  00206	52		 push	 edx
  00207	8b ce		 mov	 ecx, esi
  00209	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  0020e	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  00214	50		 push	 eax
  00215	8b 4d e0	 mov	 ecx, DWORD PTR tv185[ebp]
  00218	e8 00 00 00 00	 call	 ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
  0021d	89 45 fc	 mov	 DWORD PTR tv217[ebp], eax
  00220	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00226	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  0022b	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00231	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  00236	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0023c	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  00241	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00247	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  0024c	8d 8d c0 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00252	c1 e9 03	 shr	 ecx, 3
  00255	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0025b	89 4d b0	 mov	 DWORD PTR tv284[ebp], ecx
  0025e	6a 01		 push	 1
  00260	8b 55 b0	 mov	 edx, DWORD PTR tv284[ebp]
  00263	52		 push	 edx
  00264	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00269	83 c4 08	 add	 esp, 8
  0026c	8b 45 b0	 mov	 eax, DWORD PTR tv284[ebp]
  0026f	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
  00273	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00279	c1 e9 03	 shr	 ecx, 3
  0027c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00282	89 4d b4	 mov	 DWORD PTR tv277[ebp], ecx
  00285	6a 01		 push	 1
  00287	8b 55 b4	 mov	 edx, DWORD PTR tv277[ebp]
  0028a	52		 push	 edx
  0028b	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00290	83 c4 08	 add	 esp, 8
  00293	8b 45 b4	 mov	 eax, DWORD PTR tv277[ebp]
  00296	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
  0029a	8d 8d 20 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  002a0	c1 e9 03	 shr	 ecx, 3
  002a3	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  002a9	89 4d b8	 mov	 DWORD PTR tv270[ebp], ecx
  002ac	6a 01		 push	 1
  002ae	8b 55 b8	 mov	 edx, DWORD PTR tv270[ebp]
  002b1	52		 push	 edx
  002b2	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  002b7	83 c4 08	 add	 esp, 8
  002ba	8b 45 b8	 mov	 eax, DWORD PTR tv270[ebp]
  002bd	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
  002c1	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002c7	c1 e9 03	 shr	 ecx, 3
  002ca	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  002d0	89 4d bc	 mov	 DWORD PTR tv263[ebp], ecx
  002d3	6a 01		 push	 1
  002d5	8b 55 bc	 mov	 edx, DWORD PTR tv263[ebp]
  002d8	52		 push	 edx
  002d9	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  002de	83 c4 08	 add	 esp, 8
  002e1	8b 45 bc	 mov	 eax, DWORD PTR tv263[ebp]
  002e4	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H
$LN3@Trim:

; 3083 :         }
; 3084 : 
; 3085 :         this->_Mysize = _Size;

  002e8	8b 4d 88	 mov	 ecx, DWORD PTR _this$[ebp]
  002eb	83 c1 14	 add	 ecx, 20			; 00000014H
  002ee	89 4d c0	 mov	 DWORD PTR tv188[ebp], ecx
  002f1	8b 55 c0	 mov	 edx, DWORD PTR tv188[ebp]
  002f4	89 55 90	 mov	 DWORD PTR tv315[ebp], edx
  002f7	8b 45 90	 mov	 eax, DWORD PTR tv315[ebp]
  002fa	c1 e8 03	 shr	 eax, 3
  002fd	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00303	88 4d 81	 mov	 BYTE PTR tv318[ebp], cl
  00306	80 7d 81 00	 cmp	 BYTE PTR tv318[ebp], 0
  0030a	74 1a		 je	 SHORT $LN14@Trim
  0030c	8a 55 90	 mov	 dl, BYTE PTR tv315[ebp]
  0030f	80 e2 07	 and	 dl, 7
  00312	80 c2 03	 add	 dl, 3
  00315	3a 55 81	 cmp	 dl, BYTE PTR tv318[ebp]
  00318	7c 0c		 jl	 SHORT $LN14@Trim
  0031a	8b 45 90	 mov	 eax, DWORD PTR tv315[ebp]
  0031d	50		 push	 eax
  0031e	e8 00 00 00 00	 call	 ___asan_report_store4
  00323	83 c4 04	 add	 esp, 4
$LN14@Trim:
  00326	8b 4d c0	 mov	 ecx, DWORD PTR tv188[ebp]
  00329	8b 53 08	 mov	 edx, DWORD PTR __Size$[ebx]
  0032c	89 11		 mov	 DWORD PTR [ecx], edx

; 3086 :         _Size %= _VBITS;

  0032e	8b 43 08	 mov	 eax, DWORD PTR __Size$[ebx]
  00331	33 d2		 xor	 edx, edx
  00333	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00338	f7 f1		 div	 ecx
  0033a	89 53 08	 mov	 DWORD PTR __Size$[ebx], edx

; 3087 :         if (0 < _Size) {

  0033d	83 7b 08 00	 cmp	 DWORD PTR __Size$[ebx], 0
  00341	0f 86 a6 00 00
	00		 jbe	 $LN5@Trim

; 3088 :             this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;

  00347	8b 55 88	 mov	 edx, DWORD PTR _this$[ebp]
  0034a	83 c2 04	 add	 edx, 4
  0034d	89 55 e4	 mov	 DWORD PTR tv205[ebp], edx
  00350	8b 45 94	 mov	 eax, DWORD PTR __Words$[ebp]
  00353	83 e8 01	 sub	 eax, 1
  00356	50		 push	 eax
  00357	8b 4d e4	 mov	 ecx, DWORD PTR tv205[ebp]
  0035a	e8 00 00 00 00	 call	 ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
  0035f	89 45 8c	 mov	 DWORD PTR tv208[ebp], eax
  00362	ba 01 00 00 00	 mov	 edx, 1
  00367	8b 4b 08	 mov	 ecx, DWORD PTR __Size$[ebx]
  0036a	d3 e2		 shl	 edx, cl
  0036c	83 ea 01	 sub	 edx, 1
  0036f	89 55 e8	 mov	 DWORD PTR tv207[ebp], edx
  00372	8b 45 8c	 mov	 eax, DWORD PTR tv208[ebp]
  00375	89 45 98	 mov	 DWORD PTR tv305[ebp], eax
  00378	8b 4d 98	 mov	 ecx, DWORD PTR tv305[ebp]
  0037b	c1 e9 03	 shr	 ecx, 3
  0037e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00384	88 55 82	 mov	 BYTE PTR tv308[ebp], dl
  00387	80 7d 82 00	 cmp	 BYTE PTR tv308[ebp], 0
  0038b	74 18		 je	 SHORT $LN13@Trim
  0038d	8a 45 98	 mov	 al, BYTE PTR tv305[ebp]
  00390	24 07		 and	 al, 7
  00392	04 03		 add	 al, 3
  00394	3a 45 82	 cmp	 al, BYTE PTR tv308[ebp]
  00397	7c 0c		 jl	 SHORT $LN13@Trim
  00399	8b 4d 98	 mov	 ecx, DWORD PTR tv305[ebp]
  0039c	51		 push	 ecx
  0039d	e8 00 00 00 00	 call	 ___asan_report_load4
  003a2	83 c4 04	 add	 esp, 4
$LN13@Trim:
  003a5	8b 55 8c	 mov	 edx, DWORD PTR tv208[ebp]
  003a8	8b 02		 mov	 eax, DWORD PTR [edx]
  003aa	23 45 e8	 and	 eax, DWORD PTR tv207[ebp]
  003ad	89 45 ec	 mov	 DWORD PTR tv209[ebp], eax
  003b0	8b 4d 8c	 mov	 ecx, DWORD PTR tv208[ebp]
  003b3	89 4d 9c	 mov	 DWORD PTR tv295[ebp], ecx
  003b6	8b 55 9c	 mov	 edx, DWORD PTR tv295[ebp]
  003b9	c1 ea 03	 shr	 edx, 3
  003bc	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  003c2	88 45 83	 mov	 BYTE PTR tv298[ebp], al
  003c5	80 7d 83 00	 cmp	 BYTE PTR tv298[ebp], 0
  003c9	74 1a		 je	 SHORT $LN12@Trim
  003cb	8a 4d 9c	 mov	 cl, BYTE PTR tv295[ebp]
  003ce	80 e1 07	 and	 cl, 7
  003d1	80 c1 03	 add	 cl, 3
  003d4	3a 4d 83	 cmp	 cl, BYTE PTR tv298[ebp]
  003d7	7c 0c		 jl	 SHORT $LN12@Trim
  003d9	8b 55 9c	 mov	 edx, DWORD PTR tv295[ebp]
  003dc	52		 push	 edx
  003dd	e8 00 00 00 00	 call	 ___asan_report_store4
  003e2	83 c4 04	 add	 esp, 4
$LN12@Trim:
  003e5	8b 45 8c	 mov	 eax, DWORD PTR tv208[ebp]
  003e8	8b 4d ec	 mov	 ecx, DWORD PTR tv209[ebp]
  003eb	89 08		 mov	 DWORD PTR [eax], ecx
$LN5@Trim:

; 3089 :         }
; 3090 :     }

  003ed	c7 85 b0 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  003f7	8d 95 b0 fe ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  003fd	c1 ea 03	 shr	 edx, 3
  00400	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00406	89 55 f0	 mov	 DWORD PTR tv291[ebp], edx
  00409	6a 1a		 push	 26			; 0000001aH
  0040b	8b 45 f0	 mov	 eax, DWORD PTR tv291[ebp]
  0040e	50		 push	 eax
  0040f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00414	83 c4 08	 add	 esp, 8
  00417	5e		 pop	 esi
  00418	8b e5		 mov	 esp, ebp
  0041a	5d		 pop	 ebp
  0041b	8b e3		 mov	 esp, ebx
  0041d	5b		 pop	 ebx
  0041e	c2 04 00	 ret	 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
__It$ = -88						; size = 16
tv149 = -33						; size = 1
tv139 = -32						; size = 4
tv146 = -28						; size = 4
tv64 = -24						; size = 4
_this$ = -20						; size = 4
tv137 = -16						; size = 4
tv142 = -12						; size = 4
tv89 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2834 :     _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](size_type _Off) noexcept /* strengthened */ {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv137[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e0	 mov	 DWORD PTR tv139[ebp], ecx
  00053	8b 55 e0	 mov	 edx, DWORD PTR tv139[ebp]
  00056	c7 02 f1 f1 00
	00		 mov	 DWORD PTR [edx], 61937	; 0000f1f1H
  0005c	83 45 e0 04	 add	 DWORD PTR tv139[ebp], 4
  00060	8b 45 e0	 mov	 eax, DWORD PTR tv139[ebp]
  00063	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@operator:

; 2835 : #if _CONTAINER_DEBUG_LEVEL > 0
; 2836 :         _STL_VERIFY(_Off < this->_Mysize, "vector<bool> subscript out of range");

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 14	 add	 ecx, 20			; 00000014H
  00079	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  0007c	8b 55 e8	 mov	 edx, DWORD PTR tv64[ebp]
  0007f	89 55 e4	 mov	 DWORD PTR tv146[ebp], edx
  00082	8b 45 e4	 mov	 eax, DWORD PTR tv146[ebp]
  00085	c1 e8 03	 shr	 eax, 3
  00088	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0008e	88 4d df	 mov	 BYTE PTR tv149[ebp], cl
  00091	80 7d df 00	 cmp	 BYTE PTR tv149[ebp], 0
  00095	74 1a		 je	 SHORT $LN12@operator
  00097	8a 55 e4	 mov	 dl, BYTE PTR tv146[ebp]
  0009a	80 e2 07	 and	 dl, 7
  0009d	80 c2 03	 add	 dl, 3
  000a0	3a 55 df	 cmp	 dl, BYTE PTR tv149[ebp]
  000a3	7c 0c		 jl	 SHORT $LN12@operator
  000a5	8b 45 e4	 mov	 eax, DWORD PTR tv146[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ___asan_report_load4
  000ae	83 c4 04	 add	 esp, 4
$LN12@operator:
  000b1	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  000b4	8b 53 0c	 mov	 edx, DWORD PTR __Off$[ebx]
  000b7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000b9	73 02		 jae	 SHORT $LN7@operator
  000bb	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000c7	6a 00		 push	 0
  000c9	68 14 0b 00 00	 push	 2836			; 00000b14H
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000d3	6a 02		 push	 2
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000db	83 c4 18	 add	 esp, 24			; 00000018H
  000de	83 f8 01	 cmp	 eax, 1
  000e1	75 01		 jne	 SHORT $LN11@operator
  000e3	cc		 int	 3
$LN11@operator:
  000e4	6a 00		 push	 0
  000e6	68 14 0b 00 00	 push	 2836			; 00000b14H
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00100	83 c4 14	 add	 esp, 20			; 00000014H
  00103	33 c9		 xor	 ecx, ecx
  00105	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  00107	33 d2		 xor	 edx, edx
  00109	0f 85 64 ff ff
	ff		 jne	 $LN4@operator

; 2837 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 2838 : 
; 2839 :         iterator _It = begin();

  0010f	6a 10		 push	 16			; 00000010H
  00111	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  00114	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
  00119	8d 45 a8	 lea	 eax, DWORD PTR __It$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	e8 00 00 00 00	 call	 ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin

; 2840 :         _It._Advance(_Off);

  00125	8b 4b 0c	 mov	 ecx, DWORD PTR __Off$[ebx]
  00128	51		 push	 ecx
  00129	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  0012c	e8 00 00 00 00	 call	 ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance

; 2841 :         return *_It;

  00131	8b 53 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebx]
  00134	52		 push	 edx
  00135	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  00138	e8 00 00 00 00	 call	 ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  0013d	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  00140	e8 00 00 00 00	 call	 ??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00145	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]
  00148	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax
  0014b	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00152	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00155	c1 e9 03	 shr	 ecx, 3
  00158	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0015e	89 4d f4	 mov	 DWORD PTR tv142[ebp], ecx
  00161	6a 08		 push	 8
  00163	8b 55 f4	 mov	 edx, DWORD PTR tv142[ebp]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0016c	83 c4 08	 add	 esp, 8
  0016f	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]

; 2842 :     }

  00172	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00175	33 cd		 xor	 ecx, ebp
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c2 08 00	 ret	 8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::at, COMDAT
; _this$ = ecx

; 2816 :     _NODISCARD _CONSTEXPR20_CONTAINER reference at(size_type _Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00015	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2817 :         if (size() <= _Off) {

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00022	3b 45 0c	 cmp	 eax, DWORD PTR __Off$[ebp]
  00025	77 08		 ja	 SHORT $LN2@at

; 2818 :             _Xran();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xran
$LN2@at:

; 2819 :         }
; 2820 : 
; 2821 :         return (*this)[_Off];

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  0003f	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00042	83 ca 01	 or	 edx, 1
  00045	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00048	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@at:

; 2822 :     }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__Diff_max$ = -12					; size = 4
_this$ = -8						; size = 4
__Ints_max$ = -4					; size = 4
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2789 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2790 :         constexpr auto _Diff_max  = static_cast<size_type>((numeric_limits<difference_type>::max)());

  00013	c7 45 f4 ff ff
	ff 7f		 mov	 DWORD PTR __Diff_max$[ebp], 2147483647 ; 7fffffffH

; 2791 :         const size_type _Ints_max = this->_Myvec.max_size();

  0001a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	83 c1 04	 add	 ecx, 4
  00020	e8 00 00 00 00	 call	 ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
  00025	89 45 fc	 mov	 DWORD PTR __Ints_max$[ebp], eax

; 2792 :         if (_Ints_max > _Diff_max / _VBITS) { // max_size bound by difference_type limits

  00028	81 7d fc ff ff
	ff 03		 cmp	 DWORD PTR __Ints_max$[ebp], 67108863 ; 03ffffffH
  0002f	76 07		 jbe	 SHORT $LN2@max_size

; 2793 :             return _Diff_max;

  00031	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  00036	eb 06		 jmp	 SHORT $LN3@max_size
$LN2@max_size:

; 2794 :         }
; 2795 : 
; 2796 :         // max_size bound by underlying storage limits
; 2797 :         return _Ints_max * _VBITS;

  00038	8b 45 fc	 mov	 eax, DWORD PTR __Ints_max$[ebp]
  0003b	c1 e0 05	 shl	 eax, 5
$LN3@max_size:

; 2798 :     }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv72 = -8						; size = 4
tv75 = -1						; size = 1
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2785 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2786 :         return this->_Mysize;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 14	 add	 eax, 20			; 00000014H
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@size
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv72[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv75[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@size
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@size:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 2787 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 2697 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2698 :         return iterator(this->_Myvec.data(), this);

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 04	 add	 ecx, 4
  0001b	e8 00 00 00 00	 call	 ?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2699 :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2529 :     _CONSTEXPR20_CONTAINER vector(const vector& _Right) : _Mybase(_Right) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
  0001d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c2 04 00	 ret	 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T3 = -104						; size = 1
tv131 = -57						; size = 1
tv86 = -56						; size = 4
tv128 = -52						; size = 4
_this$ = -48						; size = 4
tv84 = -44						; size = 4
tv92 = -40						; size = 4
tv69 = -36						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2519 :     _CONSTEXPR20_CONTAINER explicit vector(_CRT_GUARDOVERFLOW size_type _Count, const _Alloc& _Al = _Alloc())

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00043	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
  0004a	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
  00051	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00054	89 45 d4	 mov	 DWORD PTR tv84[ebp], eax
  00057	8b 4d d4	 mov	 ecx, DWORD PTR tv84[ebp]
  0005a	c1 e9 03	 shr	 ecx, 3
  0005d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00063	89 4d c8	 mov	 DWORD PTR tv86[ebp], ecx
  00066	8b 55 c8	 mov	 edx, DWORD PTR tv86[ebp]
  00069	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0006f	83 45 c8 04	 add	 DWORD PTR tv86[ebp], 4
  00073	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00078	8b 4d c8	 mov	 ecx, DWORD PTR tv86[ebp]
  0007b	66 89 01	 mov	 WORD PTR [ecx], ax
  0007e	83 45 c8 02	 add	 DWORD PTR tv86[ebp], 2
  00082	8b 55 c8	 mov	 edx, DWORD PTR tv86[ebp]
  00085	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2520 :         : _Mybase(_Count, false, _Al) {

  00092	8d 45 98	 lea	 eax, DWORD PTR $T3[ebp]
  00095	89 45 cc	 mov	 DWORD PTR tv128[ebp], eax
  00098	8b 4d cc	 mov	 ecx, DWORD PTR tv128[ebp]
  0009b	c1 e9 03	 shr	 ecx, 3
  0009e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a4	88 55 c7	 mov	 BYTE PTR tv131[ebp], dl
  000a7	80 7d c7 00	 cmp	 BYTE PTR tv131[ebp], 0
  000ab	74 16		 je	 SHORT $LN4@vector
  000ad	8a 45 cc	 mov	 al, BYTE PTR tv128[ebp]
  000b0	24 07		 and	 al, 7
  000b2	3a 45 c7	 cmp	 al, BYTE PTR tv131[ebp]
  000b5	7c 0c		 jl	 SHORT $LN4@vector
  000b7	8b 4d cc	 mov	 ecx, DWORD PTR tv128[ebp]
  000ba	51		 push	 ecx
  000bb	e8 00 00 00 00	 call	 ___asan_report_store1
  000c0	83 c4 04	 add	 esp, 4
$LN4@vector:
  000c3	c6 45 98 00	 mov	 BYTE PTR $T3[ebp], 0
  000c7	8b 53 0c	 mov	 edx, DWORD PTR __Al$[ebx]
  000ca	52		 push	 edx
  000cb	8d 45 98	 lea	 eax, DWORD PTR $T3[ebp]
  000ce	50		 push	 eax
  000cf	8b 4b 08	 mov	 ecx, DWORD PTR __Count$[ebx]
  000d2	51		 push	 ecx
  000d3	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d6	e8 00 00 00 00	 call	 ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
  000db	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000e2	8d 55 98	 lea	 edx, DWORD PTR $T3[ebp]
  000e5	c1 ea 03	 shr	 edx, 3
  000e8	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 2521 :         _Trim(_Count);

  000ef	8b 43 08	 mov	 eax, DWORD PTR __Count$[ebx]
  000f2	50		 push	 eax
  000f3	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2522 :     }

  000fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	89 4d dc	 mov	 DWORD PTR tv69[ebp], ecx
  00108	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0010f	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00112	c1 ea 03	 shr	 edx, 3
  00115	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0011b	89 55 d8	 mov	 DWORD PTR tv92[ebp], edx
  0011e	6a 07		 push	 7
  00120	8b 45 d8	 mov	 eax, DWORD PTR tv92[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00129	83 c4 08	 add	 esp, 8
  0012c	8b 45 dc	 mov	 eax, DWORD PTR tv69[ebp]
  0012f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00132	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00139	59		 pop	 ecx
  0013a	8b e5		 mov	 esp, ebp
  0013c	5d		 pop	 ebp
  0013d	8b e3		 mov	 esp, ebx
  0013f	5b		 pop	 ebx
  00140	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z$0:
  00000	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1802 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1803 :         // orphan iterators within specified (inclusive) range
; 1804 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1805 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 12		 je	 SHORT $LN2@Orphan_ran

; 1806 :             _Orphan_range_unlocked(_First, _Last);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00024	52		 push	 edx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked

; 1807 :         } else

  0002d	eb 10		 jmp	 SHORT $LN1@Orphan_ran
$LN2@Orphan_ran:

; 1808 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1809 :         {
; 1810 :             _Orphan_range_locked(_First, _Last);

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
$LN1@Orphan_ran:

; 1811 :         }
; 1812 :     }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
__asan_gen_0$ = -112					; size = 4
__asan_gen_1$ = -108					; size = 4
__asan_gen_2$ = -104					; size = 4
__Lock$ = -96						; size = 4
tv74 = -52						; size = 4
tv65 = -48						; size = 4
_this$ = -44						; size = 4
tv77 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 1797 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 45 90 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00046	c7 45 94 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
  0004d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
  00054	8d 45 90	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00057	89 45 d0	 mov	 DWORD PTR tv65[ebp], eax
  0005a	8b 4d d0	 mov	 ecx, DWORD PTR tv65[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00066	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  00069	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  0006c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00072	83 45 cc 04	 add	 DWORD PTR tv74[ebp], 4
  00076	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0007b	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  0007e	66 89 01	 mov	 WORD PTR [ecx], ax
  00081	83 45 cc 02	 add	 DWORD PTR tv74[ebp], 2
  00085	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  00088	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1798 :         _Lockit _Lock(_LOCK_DEBUG);

  00095	6a 03		 push	 3
  00097	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  000a0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1799 :         _Orphan_range_unlocked(_First, _Last);

  000a7	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000aa	50		 push	 eax
  000ab	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ae	51		 push	 ecx
  000af	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked

; 1800 :     }

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c7	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000ce	8d 55 90	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000d1	c1 ea 03	 shr	 edx, 3
  000d4	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000da	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
  000dd	6a 07		 push	 7
  000df	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e8	83 c4 08	 add	 esp, 8
  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	8b e3		 mov	 esp, ebx
  00105	5b		 pop	 ebx
  00106	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z$0:
  00000	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
tv136 = -104						; size = 4
tv129 = -100						; size = 4
__Temp$1 = -96						; size = 4
tv94 = -92						; size = 4
tv89 = -88						; size = 4
tv86 = -84						; size = 4
_this$ = -80						; size = 4
tv82 = -76						; size = 4
__Temp$2 = -72						; size = 4
tv81 = -68						; size = 4
__Pnextptr$3 = -64					; size = 4
tv77 = -60						; size = 4
tv69 = -56						; size = 4
tv139 = -52						; size = 4
tv149 = -48						; size = 4
tv159 = -44						; size = 4
tv169 = -40						; size = 4
tv179 = -36						; size = 4
tv189 = -32						; size = 4
tv199 = -28						; size = 4
tv209 = -24						; size = 4
tv219 = -20						; size = 4
__Pnext$ = -16						; size = 4
tv142 = -9						; size = 1
tv152 = -8						; size = 1
tv162 = -7						; size = 1
tv172 = -6						; size = 1
tv182 = -5						; size = 1
tv192 = -4						; size = 1
tv202 = -3						; size = 1
tv212 = -2						; size = 1
tv222 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 1782 :     _CONSTEXPR20_CONTAINER void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1783 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  00013	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c8	 mov	 DWORD PTR tv69[ebp], eax
  00019	8b 4d c8	 mov	 ecx, DWORD PTR tv69[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv219[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv219[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv222[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv222[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_ran
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv219[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv222[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_ran
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv219[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_ran:
  0004e	8b 45 c8	 mov	 eax, DWORD PTR tv69[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	83 c1 04	 add	 ecx, 4
  00056	89 4d f0	 mov	 DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 1784 :         while (*_Pnext) {

  00059	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0005c	89 55 ac	 mov	 DWORD PTR tv86[ebp], edx
  0005f	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  00062	89 45 e8	 mov	 DWORD PTR tv209[ebp], eax
  00065	8b 4d e8	 mov	 ecx, DWORD PTR tv209[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv212[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv212[ebp], 0
  00078	74 18		 je	 SHORT $LN15@Orphan_ran
  0007a	8a 45 e8	 mov	 al, BYTE PTR tv209[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv212[ebp]
  00084	7c 0c		 jl	 SHORT $LN15@Orphan_ran
  00086	8b 4d e8	 mov	 ecx, DWORD PTR tv209[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_load4
  0008f	83 c4 04	 add	 esp, 4
$LN15@Orphan_ran:
  00092	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00095	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00098	0f 84 eb 01 00
	00		 je	 $LN1@Orphan_ran

; 1785 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

  0009e	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a1	89 45 a8	 mov	 DWORD PTR tv89[ebp], eax
  000a4	8b 4d a8	 mov	 ecx, DWORD PTR tv89[ebp]
  000a7	89 4d e4	 mov	 DWORD PTR tv199[ebp], ecx
  000aa	8b 55 e4	 mov	 edx, DWORD PTR tv199[ebp]
  000ad	c1 ea 03	 shr	 edx, 3
  000b0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b6	88 45 fd	 mov	 BYTE PTR tv202[ebp], al
  000b9	80 7d fd 00	 cmp	 BYTE PTR tv202[ebp], 0
  000bd	74 1a		 je	 SHORT $LN14@Orphan_ran
  000bf	8a 4d e4	 mov	 cl, BYTE PTR tv199[ebp]
  000c2	80 e1 07	 and	 cl, 7
  000c5	80 c1 03	 add	 cl, 3
  000c8	3a 4d fd	 cmp	 cl, BYTE PTR tv202[ebp]
  000cb	7c 0c		 jl	 SHORT $LN14@Orphan_ran
  000cd	8b 55 e4	 mov	 edx, DWORD PTR tv199[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ___asan_report_load4
  000d6	83 c4 04	 add	 esp, 4
$LN14@Orphan_ran:
  000d9	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	83 c1 08	 add	 ecx, 8
  000e1	89 4d c4	 mov	 DWORD PTR tv77[ebp], ecx
  000e4	8b 55 c4	 mov	 edx, DWORD PTR tv77[ebp]
  000e7	89 55 e0	 mov	 DWORD PTR tv189[ebp], edx
  000ea	8b 45 e0	 mov	 eax, DWORD PTR tv189[ebp]
  000ed	c1 e8 03	 shr	 eax, 3
  000f0	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000f6	88 4d fc	 mov	 BYTE PTR tv192[ebp], cl
  000f9	80 7d fc 00	 cmp	 BYTE PTR tv192[ebp], 0
  000fd	74 1a		 je	 SHORT $LN13@Orphan_ran
  000ff	8a 55 e0	 mov	 dl, BYTE PTR tv189[ebp]
  00102	80 e2 07	 and	 dl, 7
  00105	80 c2 03	 add	 dl, 3
  00108	3a 55 fc	 cmp	 dl, BYTE PTR tv192[ebp]
  0010b	7c 0c		 jl	 SHORT $LN13@Orphan_ran
  0010d	8b 45 e0	 mov	 eax, DWORD PTR tv189[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ___asan_report_load4
  00116	83 c4 04	 add	 esp, 4
$LN13@Orphan_ran:
  00119	8b 4d c4	 mov	 ecx, DWORD PTR tv77[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	89 55 c0	 mov	 DWORD PTR __Pnextptr$3[ebp], edx

; 1786 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

  00121	8b 45 c0	 mov	 eax, DWORD PTR __Pnextptr$3[ebp]
  00124	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  00127	72 08		 jb	 SHORT $LN6@Orphan_ran
  00129	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0012c	3b 4d c0	 cmp	 ecx, DWORD PTR __Pnextptr$3[ebp]
  0012f	73 4f		 jae	 SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 1787 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00131	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00134	89 55 a4	 mov	 DWORD PTR tv94[ebp], edx
  00137	8b 45 a4	 mov	 eax, DWORD PTR tv94[ebp]
  0013a	89 45 dc	 mov	 DWORD PTR tv179[ebp], eax
  0013d	8b 4d dc	 mov	 ecx, DWORD PTR tv179[ebp]
  00140	c1 e9 03	 shr	 ecx, 3
  00143	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00149	88 55 fb	 mov	 BYTE PTR tv182[ebp], dl
  0014c	80 7d fb 00	 cmp	 BYTE PTR tv182[ebp], 0
  00150	74 18		 je	 SHORT $LN12@Orphan_ran
  00152	8a 45 dc	 mov	 al, BYTE PTR tv179[ebp]
  00155	24 07		 and	 al, 7
  00157	04 03		 add	 al, 3
  00159	3a 45 fb	 cmp	 al, BYTE PTR tv182[ebp]
  0015c	7c 0c		 jl	 SHORT $LN12@Orphan_ran
  0015e	8b 4d dc	 mov	 ecx, DWORD PTR tv179[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN12@Orphan_ran:
  0016a	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	89 45 a0	 mov	 DWORD PTR __Temp$1[ebp], eax

; 1788 :                 _Pnext           = &_Temp->_Mynextiter;

  00172	8b 4d a0	 mov	 ecx, DWORD PTR __Temp$1[ebp]
  00175	83 c1 04	 add	 ecx, 4
  00178	89 4d f0	 mov	 DWORD PTR __Pnext$[ebp], ecx

; 1789 :             } else { // orphan the iterator

  0017b	e9 04 01 00 00	 jmp	 $LN5@Orphan_ran
$LN4@Orphan_ran:

; 1790 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00180	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00183	89 55 9c	 mov	 DWORD PTR tv129[ebp], edx
  00186	8b 45 9c	 mov	 eax, DWORD PTR tv129[ebp]
  00189	89 45 d8	 mov	 DWORD PTR tv169[ebp], eax
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR tv169[ebp]
  0018f	c1 e9 03	 shr	 ecx, 3
  00192	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00198	88 55 fa	 mov	 BYTE PTR tv172[ebp], dl
  0019b	80 7d fa 00	 cmp	 BYTE PTR tv172[ebp], 0
  0019f	74 18		 je	 SHORT $LN11@Orphan_ran
  001a1	8a 45 d8	 mov	 al, BYTE PTR tv169[ebp]
  001a4	24 07		 and	 al, 7
  001a6	04 03		 add	 al, 3
  001a8	3a 45 fa	 cmp	 al, BYTE PTR tv172[ebp]
  001ab	7c 0c		 jl	 SHORT $LN11@Orphan_ran
  001ad	8b 4d d8	 mov	 ecx, DWORD PTR tv169[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 ___asan_report_load4
  001b6	83 c4 04	 add	 esp, 4
$LN11@Orphan_ran:
  001b9	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  001bc	8b 02		 mov	 eax, DWORD PTR [edx]
  001be	89 45 b8	 mov	 DWORD PTR __Temp$2[ebp], eax

; 1791 :                 _Temp->_Myproxy  = nullptr;

  001c1	8b 4d b8	 mov	 ecx, DWORD PTR __Temp$2[ebp]
  001c4	89 4d bc	 mov	 DWORD PTR tv81[ebp], ecx
  001c7	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  001ca	89 55 d4	 mov	 DWORD PTR tv159[ebp], edx
  001cd	8b 45 d4	 mov	 eax, DWORD PTR tv159[ebp]
  001d0	c1 e8 03	 shr	 eax, 3
  001d3	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001d9	88 4d f9	 mov	 BYTE PTR tv162[ebp], cl
  001dc	80 7d f9 00	 cmp	 BYTE PTR tv162[ebp], 0
  001e0	74 1a		 je	 SHORT $LN10@Orphan_ran
  001e2	8a 55 d4	 mov	 dl, BYTE PTR tv159[ebp]
  001e5	80 e2 07	 and	 dl, 7
  001e8	80 c2 03	 add	 dl, 3
  001eb	3a 55 f9	 cmp	 dl, BYTE PTR tv162[ebp]
  001ee	7c 0c		 jl	 SHORT $LN10@Orphan_ran
  001f0	8b 45 d4	 mov	 eax, DWORD PTR tv159[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ___asan_report_store4
  001f9	83 c4 04	 add	 esp, 4
$LN10@Orphan_ran:
  001fc	8b 4d bc	 mov	 ecx, DWORD PTR tv81[ebp]
  001ff	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1792 :                 *_Pnext          = _Temp->_Mynextiter;

  00205	8b 55 b8	 mov	 edx, DWORD PTR __Temp$2[ebp]
  00208	83 c2 04	 add	 edx, 4
  0020b	89 55 b4	 mov	 DWORD PTR tv82[ebp], edx
  0020e	8b 45 b4	 mov	 eax, DWORD PTR tv82[ebp]
  00211	89 45 d0	 mov	 DWORD PTR tv149[ebp], eax
  00214	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  00217	c1 e9 03	 shr	 ecx, 3
  0021a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00220	88 55 f8	 mov	 BYTE PTR tv152[ebp], dl
  00223	80 7d f8 00	 cmp	 BYTE PTR tv152[ebp], 0
  00227	74 18		 je	 SHORT $LN9@Orphan_ran
  00229	8a 45 d0	 mov	 al, BYTE PTR tv149[ebp]
  0022c	24 07		 and	 al, 7
  0022e	04 03		 add	 al, 3
  00230	3a 45 f8	 cmp	 al, BYTE PTR tv152[ebp]
  00233	7c 0c		 jl	 SHORT $LN9@Orphan_ran
  00235	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 ___asan_report_load4
  0023e	83 c4 04	 add	 esp, 4
$LN9@Orphan_ran:
  00241	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00244	89 55 98	 mov	 DWORD PTR tv136[ebp], edx
  00247	8b 45 98	 mov	 eax, DWORD PTR tv136[ebp]
  0024a	89 45 cc	 mov	 DWORD PTR tv139[ebp], eax
  0024d	8b 4d cc	 mov	 ecx, DWORD PTR tv139[ebp]
  00250	c1 e9 03	 shr	 ecx, 3
  00253	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00259	88 55 f7	 mov	 BYTE PTR tv142[ebp], dl
  0025c	80 7d f7 00	 cmp	 BYTE PTR tv142[ebp], 0
  00260	74 18		 je	 SHORT $LN8@Orphan_ran
  00262	8a 45 cc	 mov	 al, BYTE PTR tv139[ebp]
  00265	24 07		 and	 al, 7
  00267	04 03		 add	 al, 3
  00269	3a 45 f7	 cmp	 al, BYTE PTR tv142[ebp]
  0026c	7c 0c		 jl	 SHORT $LN8@Orphan_ran
  0026e	8b 4d cc	 mov	 ecx, DWORD PTR tv139[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ___asan_report_store4
  00277	83 c4 04	 add	 esp, 4
$LN8@Orphan_ran:
  0027a	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0027d	8b 45 b4	 mov	 eax, DWORD PTR tv82[ebp]
  00280	8b 08		 mov	 ecx, DWORD PTR [eax]
  00282	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@Orphan_ran:

; 1793 :             }
; 1794 :         }

  00284	e9 d0 fd ff ff	 jmp	 $LN2@Orphan_ran
$LN1@Orphan_ran:

; 1795 :     }

  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c2 08 00	 ret	 8
?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@I@std@@QAEXQAII@Z ; std::allocator<unsigned int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@I@std@@QAEPAII@Z ; std::allocator<unsigned int>::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 02	 shl	 eax, 2
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1641 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1642 :         // fill raw _Dest with _Count copies of _Val, using allocator
; 1643 :         return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1644 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
tv88 = -40						; size = 4
_this$ = -36						; size = 4
tv87 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv129 = -20						; size = 4
__My_data$ = -16					; size = 4
tv139 = -12						; size = 4
tv149 = -8						; size = 4
tv132 = -3						; size = 1
tv142 = -2						; size = 1
tv152 = -1						; size = 1
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = ecx

; 1562 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1563 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv149[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv149[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv152[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv152[ebp], 0
  00044	74 18		 je	 SHORT $LN14@operator
  00046	8a 45 f8	 mov	 al, BYTE PTR tv149[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv152[ebp]
  00050	7c 0c		 jl	 SHORT $LN14@operator
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv149[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN14@operator:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv139[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv139[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv142[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv142[ebp], 0
  00077	74 1a		 je	 SHORT $LN13@operator
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv139[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv142[ebp]
  00085	7c 0c		 jl	 SHORT $LN13@operator
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv139[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN13@operator:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	39 45 08	 cmp	 DWORD PTR __Pos$[ebp], eax
  000a3	73 02		 jae	 SHORT $LN7@operator
  000a5	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000b1	6a 00		 push	 0
  000b3	68 1e 06 00 00	 push	 1566			; 0000061eH
  000b8	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000bd	6a 02		 push	 2
  000bf	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000c5	83 c4 18	 add	 esp, 24			; 00000018H
  000c8	83 f8 01	 cmp	 eax, 1
  000cb	75 01		 jne	 SHORT $LN11@operator
  000cd	cc		 int	 3
$LN11@operator:
  000ce	6a 00		 push	 0
  000d0	68 1e 06 00 00	 push	 1566			; 0000061eH
  000d5	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000da	68 00 00 00 00	 push	 OFFSET ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
  000df	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
  000e4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ea	83 c4 14	 add	 esp, 20			; 00000014H
  000ed	33 d2		 xor	 edx, edx
  000ef	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  000f1	33 c0		 xor	 eax, eax
  000f3	0f 85 20 ff ff
	ff		 jne	 $LN4@operator

; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

  000f9	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000fc	83 c1 04	 add	 ecx, 4
  000ff	89 4d e0	 mov	 DWORD PTR tv87[ebp], ecx
  00102	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  00105	c1 e2 02	 shl	 edx, 2
  00108	89 55 d8	 mov	 DWORD PTR tv88[ebp], edx
  0010b	8b 45 e0	 mov	 eax, DWORD PTR tv87[ebp]
  0010e	89 45 ec	 mov	 DWORD PTR tv129[ebp], eax
  00111	8b 4d ec	 mov	 ecx, DWORD PTR tv129[ebp]
  00114	c1 e9 03	 shr	 ecx, 3
  00117	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0011d	88 55 fd	 mov	 BYTE PTR tv132[ebp], dl
  00120	80 7d fd 00	 cmp	 BYTE PTR tv132[ebp], 0
  00124	74 18		 je	 SHORT $LN12@operator
  00126	8a 45 ec	 mov	 al, BYTE PTR tv129[ebp]
  00129	24 07		 and	 al, 7
  0012b	04 03		 add	 al, 3
  0012d	3a 45 fd	 cmp	 al, BYTE PTR tv132[ebp]
  00130	7c 0c		 jl	 SHORT $LN12@operator
  00132	8b 4d ec	 mov	 ecx, DWORD PTR tv129[ebp]
  00135	51		 push	 ecx
  00136	e8 00 00 00 00	 call	 ___asan_report_load4
  0013b	83 c4 04	 add	 esp, 4
$LN12@operator:
  0013e	8b 55 e0	 mov	 edx, DWORD PTR tv87[ebp]
  00141	8b 02		 mov	 eax, DWORD PTR [edx]
  00143	03 45 d8	 add	 eax, DWORD PTR tv88[ebp]

; 1570 :     }

  00146	8b e5		 mov	 esp, ebp
  00148	5d		 pop	 ebp
  00149	c2 04 00	 ret	 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
__My_data$ = -16					; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 1547 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1548 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d ec	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00044	74 18		 je	 SHORT $LN4@size
  00046	8a 45 f8	 mov	 al, BYTE PTR tv85[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00050	7c 0c		 jl	 SHORT $LN4@size
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN4@size:
  0005e	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00077	74 1a		 je	 SHORT $LN3@size
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00085	7c 0c		 jl	 SHORT $LN3@size
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN3@size:
  00093	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2

; 1550 :     }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv75 = -16						; size = 4
__My_data$ = -12					; size = 4
tv84 = -8						; size = 4
tv87 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 1484 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1485 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1486 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  00019	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  00028	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002b	83 c2 08	 add	 edx, 8
  0002e	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  00031	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00034	89 45 f8	 mov	 DWORD PTR tv84[ebp], eax
  00037	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00043	88 55 ff	 mov	 BYTE PTR tv87[ebp], dl
  00046	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0004a	74 18		 je	 SHORT $LN3@end
  0004c	8a 45 f8	 mov	 al, BYTE PTR tv84[ebp]
  0004f	24 07		 and	 al, 7
  00051	04 03		 add	 al, 3
  00053	3a 45 ff	 cmp	 al, BYTE PTR tv87[ebp]
  00056	7c 0c		 jl	 SHORT $LN3@end
  00058	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ___asan_report_load4
  00061	83 c4 04	 add	 esp, 4
$LN3@end:
  00064	8b 55 f0	 mov	 edx, DWORD PTR tv75[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	89 45 e4	 mov	 DWORD PTR tv78[ebp], eax
  0006c	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0006f	51		 push	 ecx
  00070	8b 55 e4	 mov	 edx, DWORD PTR tv78[ebp]
  00073	52		 push	 edx
  00074	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00077	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
  0007c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1487 :     }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv75 = -16						; size = 4
__My_data$ = -12					; size = 4
tv84 = -8						; size = 4
tv87 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 1474 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1475 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1476 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  00019	8b 4d f4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  00028	8b 55 f4	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002b	83 c2 04	 add	 edx, 4
  0002e	89 55 f0	 mov	 DWORD PTR tv75[ebp], edx
  00031	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00034	89 45 f8	 mov	 DWORD PTR tv84[ebp], eax
  00037	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00043	88 55 ff	 mov	 BYTE PTR tv87[ebp], dl
  00046	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0004a	74 18		 je	 SHORT $LN3@begin
  0004c	8a 45 f8	 mov	 al, BYTE PTR tv84[ebp]
  0004f	24 07		 and	 al, 7
  00051	04 03		 add	 al, 3
  00053	3a 45 ff	 cmp	 al, BYTE PTR tv87[ebp]
  00056	7c 0c		 jl	 SHORT $LN3@begin
  00058	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ___asan_report_load4
  00061	83 c4 04	 add	 esp, 4
$LN3@begin:
  00064	8b 55 f0	 mov	 edx, DWORD PTR tv75[ebp]
  00067	8b 02		 mov	 eax, DWORD PTR [edx]
  00069	89 45 e4	 mov	 DWORD PTR tv78[ebp], eax
  0006c	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0006f	51		 push	 ecx
  00070	8b 55 e4	 mov	 edx, DWORD PTR tv78[ebp]
  00073	52		 push	 edx
  00074	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00077	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
  0007c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1477 :     }

  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c2 04 00	 ret	 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv67 = -12						; size = 4
tv72 = -8						; size = 4
tv75 = -1						; size = 1
?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::data, COMDAT
; _this$ = ecx

; 1470 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Ty* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1471 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@data
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv72[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv75[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@data
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@data:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ; std::_Unfancy_maybe_null<unsigned int>
  0005c	83 c4 04	 add	 esp, 4

; 1472 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv67 = -12						; size = 4
tv72 = -8						; size = 4
tv75 = -1						; size = 1
?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::data, COMDAT
; _this$ = ecx

; 1466 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty* data() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1467 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@data
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv72[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv75[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@data
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@data:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ; std::_Unfancy_maybe_null<unsigned int>
  0005c	83 c4 04	 add	 esp, 4

; 1468 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
_TEXT	SEGMENT
tv176 = -64						; size = 4
tv173 = -60						; size = 4
__Newlast$2 = -56					; size = 4
tv95 = -52						; size = 4
tv179 = -48						; size = 4
_this$ = -44						; size = 4
tv189 = -40						; size = 4
tv199 = -36						; size = 4
__Lastptr$ = -32					; size = 4
__My_data$ = -28					; size = 4
__Firstptr$ = -24					; size = 4
__Mylast$ = -20						; size = 4
tv182 = -15						; size = 1
tv192 = -14						; size = 1
tv202 = -13						; size = 1
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1426 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	56		 push	 esi
  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001a	33 c5		 xor	 eax, ebp
  0001c	50		 push	 eax
  0001d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00020	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00026	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1427 :         const pointer _Firstptr = _First._Ptr;

  00033	8b 45 14	 mov	 eax, DWORD PTR __First$[ebp+8]
  00036	89 45 e8	 mov	 DWORD PTR __Firstptr$[ebp], eax

; 1428 :         const pointer _Lastptr  = _Last._Ptr;

  00039	8b 4d 20	 mov	 ecx, DWORD PTR __Last$[ebp+8]
  0003c	89 4d e0	 mov	 DWORD PTR __Lastptr$[ebp], ecx

; 1429 :         auto& _My_data          = _Mypair._Myval2;

  0003f	8b 55 d4	 mov	 edx, DWORD PTR _this$[ebp]
  00042	89 55 e4	 mov	 DWORD PTR __My_data$[ebp], edx

; 1430 :         pointer& _Mylast        = _My_data._Mylast;

  00045	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	83 c0 08	 add	 eax, 8
  0004b	89 45 ec	 mov	 DWORD PTR __Mylast$[ebp], eax
$LN4@erase:

; 1431 : 
; 1432 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1433 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)

  0004e	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00056	8b f0		 mov	 esi, eax
  00058	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00061	83 c4 04	 add	 esp, 4
  00064	3b f0		 cmp	 esi, eax
  00066	0f 85 b5 00 00
	00		 jne	 $LN7@erase
  0006c	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  0006f	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00074	8b f0		 mov	 esi, eax
  00076	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  0007f	83 c4 04	 add	 esp, 4
  00082	3b f0		 cmp	 esi, eax
  00084	0f 85 97 00 00
	00		 jne	 $LN7@erase
  0008a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0008d	83 c0 04	 add	 eax, 4
  00090	89 45 cc	 mov	 DWORD PTR tv95[ebp], eax
  00093	8b 4d cc	 mov	 ecx, DWORD PTR tv95[ebp]
  00096	89 4d dc	 mov	 DWORD PTR tv199[ebp], ecx
  00099	8b 55 dc	 mov	 edx, DWORD PTR tv199[ebp]
  0009c	c1 ea 03	 shr	 edx, 3
  0009f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000a5	88 45 f3	 mov	 BYTE PTR tv202[ebp], al
  000a8	80 7d f3 00	 cmp	 BYTE PTR tv202[ebp], 0
  000ac	74 1a		 je	 SHORT $LN15@erase
  000ae	8a 4d dc	 mov	 cl, BYTE PTR tv199[ebp]
  000b1	80 e1 07	 and	 cl, 7
  000b4	80 c1 03	 add	 cl, 3
  000b7	3a 4d f3	 cmp	 cl, BYTE PTR tv202[ebp]
  000ba	7c 0c		 jl	 SHORT $LN15@erase
  000bc	8b 55 dc	 mov	 edx, DWORD PTR tv199[ebp]
  000bf	52		 push	 edx
  000c0	e8 00 00 00 00	 call	 ___asan_report_load4
  000c5	83 c4 04	 add	 esp, 4
$LN15@erase:
  000c8	8b 45 cc	 mov	 eax, DWORD PTR tv95[ebp]
  000cb	8b 4d e8	 mov	 ecx, DWORD PTR __Firstptr$[ebp]
  000ce	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000d0	72 4f		 jb	 SHORT $LN7@erase
  000d2	8b 55 e0	 mov	 edx, DWORD PTR __Lastptr$[ebp]
  000d5	3b 55 e8	 cmp	 edx, DWORD PTR __Firstptr$[ebp]
  000d8	72 47		 jb	 SHORT $LN7@erase
  000da	8b 45 ec	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000dd	89 45 c4	 mov	 DWORD PTR tv173[ebp], eax
  000e0	8b 4d c4	 mov	 ecx, DWORD PTR tv173[ebp]
  000e3	89 4d d8	 mov	 DWORD PTR tv189[ebp], ecx
  000e6	8b 55 d8	 mov	 edx, DWORD PTR tv189[ebp]
  000e9	c1 ea 03	 shr	 edx, 3
  000ec	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f2	88 45 f2	 mov	 BYTE PTR tv192[ebp], al
  000f5	80 7d f2 00	 cmp	 BYTE PTR tv192[ebp], 0
  000f9	74 1a		 je	 SHORT $LN14@erase
  000fb	8a 4d d8	 mov	 cl, BYTE PTR tv189[ebp]
  000fe	80 e1 07	 and	 cl, 7
  00101	80 c1 03	 add	 cl, 3
  00104	3a 4d f2	 cmp	 cl, BYTE PTR tv192[ebp]
  00107	7c 0c		 jl	 SHORT $LN14@erase
  00109	8b 55 d8	 mov	 edx, DWORD PTR tv189[ebp]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 ___asan_report_load4
  00112	83 c4 04	 add	 esp, 4
$LN14@erase:
  00115	8b 45 ec	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00118	8b 08		 mov	 ecx, DWORD PTR [eax]
  0011a	3b 4d e0	 cmp	 ecx, DWORD PTR __Lastptr$[ebp]
  0011d	72 02		 jb	 SHORT $LN7@erase
  0011f	eb 4a		 jmp	 SHORT $LN2@erase
$LN7@erase:
  00121	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
  00126	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0012b	6a 00		 push	 0
  0012d	68 9b 05 00 00	 push	 1435			; 0000059bH
  00132	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00137	6a 02		 push	 2
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0013f	83 c4 18	 add	 esp, 24			; 00000018H
  00142	83 f8 01	 cmp	 eax, 1
  00145	75 01		 jne	 SHORT $LN12@erase
  00147	cc		 int	 3
$LN12@erase:
  00148	6a 00		 push	 0
  0014a	68 9b 05 00 00	 push	 1435			; 0000059bH
  0014f	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00154	68 00 00 00 00	 push	 OFFSET ??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
  00159	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
  0015e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00164	83 c4 14	 add	 esp, 20			; 00000014H
  00167	33 c0		 xor	 eax, eax
  00169	75 b6		 jne	 SHORT $LN7@erase
$LN2@erase:
  0016b	33 c9		 xor	 ecx, ecx
  0016d	0f 85 db fe ff
	ff		 jne	 $LN4@erase

; 1434 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1435 :             "vector erase iterator outside range");
; 1436 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 
; 1438 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

  00173	8b 55 e8	 mov	 edx, DWORD PTR __Firstptr$[ebp]
  00176	3b 55 e0	 cmp	 edx, DWORD PTR __Lastptr$[ebp]
  00179	0f 84 80 00 00
	00		 je	 $LN10@erase

; 1439 :             _Orphan_range(_Firstptr, _Mylast);

  0017f	8b 45 ec	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00182	8b 08		 mov	 ecx, DWORD PTR [eax]
  00184	51		 push	 ecx
  00185	8b 55 e8	 mov	 edx, DWORD PTR __Firstptr$[ebp]
  00188	52		 push	 edx
  00189	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range

; 1440 : 
; 1441 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

  00191	8b 45 e8	 mov	 eax, DWORD PTR __Firstptr$[ebp]
  00194	50		 push	 eax
  00195	8b 4d ec	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00198	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019a	52		 push	 edx
  0019b	8b 45 e0	 mov	 eax, DWORD PTR __Lastptr$[ebp]
  0019e	50		 push	 eax
  0019f	e8 00 00 00 00	 call	 ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ; std::_Move_unchecked<unsigned int *,unsigned int *>
  001a4	83 c4 0c	 add	 esp, 12			; 0000000cH
  001a7	89 45 c8	 mov	 DWORD PTR __Newlast$2[ebp], eax

; 1442 :             _Destroy(_Newlast, _Mylast);

  001aa	8b 4d ec	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  001ad	8b 11		 mov	 edx, DWORD PTR [ecx]
  001af	52		 push	 edx
  001b0	8b 45 c8	 mov	 eax, DWORD PTR __Newlast$2[ebp]
  001b3	50		 push	 eax
  001b4	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  001b7	e8 00 00 00 00	 call	 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1443 :             _Mylast = _Newlast;

  001bc	8b 4d ec	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  001bf	89 4d c0	 mov	 DWORD PTR tv176[ebp], ecx
  001c2	8b 55 c0	 mov	 edx, DWORD PTR tv176[ebp]
  001c5	89 55 d0	 mov	 DWORD PTR tv179[ebp], edx
  001c8	8b 45 d0	 mov	 eax, DWORD PTR tv179[ebp]
  001cb	c1 e8 03	 shr	 eax, 3
  001ce	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001d4	88 4d f1	 mov	 BYTE PTR tv182[ebp], cl
  001d7	80 7d f1 00	 cmp	 BYTE PTR tv182[ebp], 0
  001db	74 1a		 je	 SHORT $LN13@erase
  001dd	8a 55 d0	 mov	 dl, BYTE PTR tv179[ebp]
  001e0	80 e2 07	 and	 dl, 7
  001e3	80 c2 03	 add	 dl, 3
  001e6	3a 55 f1	 cmp	 dl, BYTE PTR tv182[ebp]
  001e9	7c 0c		 jl	 SHORT $LN13@erase
  001eb	8b 45 d0	 mov	 eax, DWORD PTR tv179[ebp]
  001ee	50		 push	 eax
  001ef	e8 00 00 00 00	 call	 ___asan_report_store4
  001f4	83 c4 04	 add	 esp, 4
$LN13@erase:
  001f7	8b 4d ec	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  001fa	8b 55 c8	 mov	 edx, DWORD PTR __Newlast$2[ebp]
  001fd	89 11		 mov	 DWORD PTR [ecx], edx
$LN10@erase:

; 1444 :         }
; 1445 : 
; 1446 :         return iterator(_Firstptr, _STD addressof(_My_data));

  001ff	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00208	83 c4 04	 add	 esp, 4
  0020b	50		 push	 eax
  0020c	8b 4d e8	 mov	 ecx, DWORD PTR __Firstptr$[ebp]
  0020f	51		 push	 ecx
  00210	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00213	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
  00218	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  0021b	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  00220	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  00223	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  00228	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1447 :     }

  0022b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0022e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00235	59		 pop	 ecx
  00236	5e		 pop	 esi
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	c2 1c 00	 ret	 28			; 0000001cH
  0023d	cc		 int	 3
  0023e	cc		 int	 3
  0023f	cc		 int	 3
  00240	cc		 int	 3
  00241	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a c4	 mov	 ecx, DWORD PTR [edx-60]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S42$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S42$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S42$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -240					; size = 4
__asan_gen_1$ = -236					; size = 4
__asan_gen_2$ = -232					; size = 4
$T3 = -224						; size = 1
_$S43$ = -208						; size = 1
__Proxy$ = -192						; size = 8
__Guard$4 = -176					; size = 4
tv242 = -136						; size = 1
tv232 = -135						; size = 1
tv222 = -134						; size = 1
tv212 = -133						; size = 1
tv202 = -132						; size = 1
tv192 = -131						; size = 1
$T5 = -130						; size = 1
$T6 = -129						; size = 1
tv167 = -128						; size = 4
_this$ = -124						; size = 4
tv239 = -120						; size = 4
tv229 = -116						; size = 4
tv219 = -112						; size = 4
tv209 = -108						; size = 4
__Rightlast$ = -104					; size = 4
__Rightfirst$ = -100					; size = 4
__My_data$ = -96					; size = 4
tv199 = -92						; size = 4
tv189 = -88						; size = 4
tv86 = -84						; size = 4
__Right_data$ = -80					; size = 4
tv87 = -76						; size = 4
tv138 = -72						; size = 4
tv135 = -68						; size = 4
tv165 = -64						; size = 4
tv76 = -60						; size = 4
tv78 = -56						; size = 4
__Alproxy$ = -52					; size = 4
tv137 = -48						; size = 4
tv185 = -44						; size = 4
tv152 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 555  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 10 ff ff
	ff		 add	 esp, -240		; ffffff10H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 10 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
  00056	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
  00060	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv165[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv165[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d 80	 mov	 DWORD PTR tv167[ebp], ecx
  00078	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00085	8b 45 80	 mov	 eax, DWORD PTR tv167[ebp]
  00088	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  0008e	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00092	8b 4d 80	 mov	 ecx, DWORD PTR tv167[ebp]
  00095	c7 01 f8 f3 f3
	f3		 mov	 DWORD PTR [ecx], -202116104 ; f3f3f3f8H
  0009b	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  0009f	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  000a2	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  000a5	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S43$[ebp]
  000ab	c1 e8 03	 shr	 eax, 3
  000ae	c6 80 00 00 00
	30 01		 mov	 BYTE PTR [eax+805306368], 1
  000b5	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000ca	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000cf	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	89 55 c8	 mov	 DWORD PTR tv78[ebp], edx
  000d5	8b 4b 08	 mov	 ecx, DWORD PTR __Right$[ebx]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
  000ea	83 c4 08	 add	 esp, 8
  000ed	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000f0	6a 01		 push	 1
  000f2	8d 8d 7f ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000f8	51		 push	 ecx
  000f9	8d 95 7e ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ___asan_memcpy
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  0010b	50		 push	 eax
  0010c	0f b6 8d 7e ff
	ff ff		 movzx	 ecx, BYTE PTR $T5[ebp]
  00113	51		 push	 ecx
  00114	8b 4d c8	 mov	 ecx, DWORD PTR tv78[ebp]
  00117	e8 00 00 00 00	 call	 ??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >
  0011c	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00122	c1 ea 03	 shr	 edx, 3
  00125	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 556  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0012c	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00134	50		 push	 eax
  00135	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _$S43$[ebp]
  0013b	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  00140	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S43$[ebp]
  00146	89 45 cc	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 557  :         auto& _My_data            = _Mypair._Myval2;

  00149	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	89 4d a0	 mov	 DWORD PTR __My_data$[ebp], ecx

; 558  :         const auto& _Right_data   = _Right._Mypair._Myval2;

  0014f	8b 53 08	 mov	 edx, DWORD PTR __Right$[ebx]
  00152	89 55 b0	 mov	 DWORD PTR __Right_data$[ebp], edx

; 559  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00155	8b 45 b0	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00158	83 c0 04	 add	 eax, 4
  0015b	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
  0015e	8b 4d ac	 mov	 ecx, DWORD PTR tv86[ebp]
  00161	89 4d 88	 mov	 DWORD PTR tv239[ebp], ecx
  00164	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00167	c1 ea 03	 shr	 edx, 3
  0016a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00170	88 85 78 ff ff
	ff		 mov	 BYTE PTR tv242[ebp], al
  00176	80 bd 78 ff ff
	ff 00		 cmp	 BYTE PTR tv242[ebp], 0
  0017d	74 1d		 je	 SHORT $LN11@vector
  0017f	8a 4d 88	 mov	 cl, BYTE PTR tv239[ebp]
  00182	80 e1 07	 and	 cl, 7
  00185	80 c1 03	 add	 cl, 3
  00188	3a 8d 78 ff ff
	ff		 cmp	 cl, BYTE PTR tv242[ebp]
  0018e	7c 0c		 jl	 SHORT $LN11@vector
  00190	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ___asan_report_load4
  00199	83 c4 04	 add	 esp, 4
$LN11@vector:
  0019c	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	89 4d 9c	 mov	 DWORD PTR __Rightfirst$[ebp], ecx

; 560  :         const pointer _Rightlast  = _Right_data._Mylast;

  001a4	8b 55 b0	 mov	 edx, DWORD PTR __Right_data$[ebp]
  001a7	83 c2 08	 add	 edx, 8
  001aa	89 55 b4	 mov	 DWORD PTR tv87[ebp], edx
  001ad	8b 45 b4	 mov	 eax, DWORD PTR tv87[ebp]
  001b0	89 45 8c	 mov	 DWORD PTR tv229[ebp], eax
  001b3	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001b6	c1 e9 03	 shr	 ecx, 3
  001b9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001bf	88 95 79 ff ff
	ff		 mov	 BYTE PTR tv232[ebp], dl
  001c5	80 bd 79 ff ff
	ff 00		 cmp	 BYTE PTR tv232[ebp], 0
  001cc	74 1b		 je	 SHORT $LN10@vector
  001ce	8a 45 8c	 mov	 al, BYTE PTR tv229[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 85 79 ff ff
	ff		 cmp	 al, BYTE PTR tv232[ebp]
  001db	7c 0c		 jl	 SHORT $LN10@vector
  001dd	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ___asan_report_load4
  001e6	83 c4 04	 add	 esp, 4
$LN10@vector:
  001e9	8b 55 b4	 mov	 edx, DWORD PTR tv87[ebp]
  001ec	8b 02		 mov	 eax, DWORD PTR [edx]
  001ee	89 45 98	 mov	 DWORD PTR __Rightlast$[ebp], eax

; 561  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  001f1	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  001f4	51		 push	 ecx
  001f5	8b 55 cc	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  001f8	52		 push	 edx
  001f9	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  001ff	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00204	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 562  :         if (_Rightfirst != _Rightlast) {

  0020b	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  0020e	3b 45 98	 cmp	 eax, DWORD PTR __Rightlast$[ebp]
  00211	0f 84 85 01 00
	00		 je	 $LN2@vector
  00217	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  0021d	c1 e9 03	 shr	 ecx, 3
  00220	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4

; 563  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00227	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  0022a	2b 55 9c	 sub	 edx, DWORD PTR __Rightfirst$[ebp]
  0022d	c1 fa 02	 sar	 edx, 2
  00230	52		 push	 edx
  00231	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw

; 564  :             _Tidy_guard<vector> _Guard{this};

  00239	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0023f	89 45 90	 mov	 DWORD PTR tv219[ebp], eax
  00242	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  00245	c1 e9 03	 shr	 ecx, 3
  00248	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0024e	88 95 7a ff ff
	ff		 mov	 BYTE PTR tv222[ebp], dl
  00254	80 bd 7a ff ff
	ff 00		 cmp	 BYTE PTR tv222[ebp], 0
  0025b	74 1b		 je	 SHORT $LN9@vector
  0025d	8a 45 90	 mov	 al, BYTE PTR tv219[ebp]
  00260	24 07		 and	 al, 7
  00262	04 03		 add	 al, 3
  00264	3a 85 7a ff ff
	ff		 cmp	 al, BYTE PTR tv222[ebp]
  0026a	7c 0c		 jl	 SHORT $LN9@vector
  0026c	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ___asan_report_store4
  00275	83 c4 04	 add	 esp, 4
$LN9@vector:
  00278	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  0027b	89 95 50 ff ff
	ff		 mov	 DWORD PTR __Guard$4[ebp], edx
  00281	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 565  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00285	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00288	83 c0 04	 add	 eax, 4
  0028b	89 45 b8	 mov	 DWORD PTR tv138[ebp], eax
  0028e	8b 4d b8	 mov	 ecx, DWORD PTR tv138[ebp]
  00291	89 4d 94	 mov	 DWORD PTR tv209[ebp], ecx
  00294	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  00297	c1 ea 03	 shr	 edx, 3
  0029a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  002a0	88 85 7b ff ff
	ff		 mov	 BYTE PTR tv212[ebp], al
  002a6	80 bd 7b ff ff
	ff 00		 cmp	 BYTE PTR tv212[ebp], 0
  002ad	74 1d		 je	 SHORT $LN8@vector
  002af	8a 4d 94	 mov	 cl, BYTE PTR tv209[ebp]
  002b2	80 e1 07	 and	 cl, 7
  002b5	80 c1 03	 add	 cl, 3
  002b8	3a 8d 7b ff ff
	ff		 cmp	 cl, BYTE PTR tv212[ebp]
  002be	7c 0c		 jl	 SHORT $LN8@vector
  002c0	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 ___asan_report_load4
  002c9	83 c4 04	 add	 esp, 4
$LN8@vector:
  002cc	8b 45 b8	 mov	 eax, DWORD PTR tv138[ebp]
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	51		 push	 ecx
  002d2	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  002d5	52		 push	 edx
  002d6	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  002d9	50		 push	 eax
  002da	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  002dd	e8 00 00 00 00	 call	 ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
  002e2	89 45 d0	 mov	 DWORD PTR tv137[ebp], eax
  002e5	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  002e8	83 c1 08	 add	 ecx, 8
  002eb	89 4d bc	 mov	 DWORD PTR tv135[ebp], ecx
  002ee	8b 55 bc	 mov	 edx, DWORD PTR tv135[ebp]
  002f1	89 55 a4	 mov	 DWORD PTR tv199[ebp], edx
  002f4	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  002f7	c1 e8 03	 shr	 eax, 3
  002fa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00300	88 8d 7c ff ff
	ff		 mov	 BYTE PTR tv202[ebp], cl
  00306	80 bd 7c ff ff
	ff 00		 cmp	 BYTE PTR tv202[ebp], 0
  0030d	74 1d		 je	 SHORT $LN7@vector
  0030f	8a 55 a4	 mov	 dl, BYTE PTR tv199[ebp]
  00312	80 e2 07	 and	 dl, 7
  00315	80 c2 03	 add	 dl, 3
  00318	3a 95 7c ff ff
	ff		 cmp	 dl, BYTE PTR tv202[ebp]
  0031e	7c 0c		 jl	 SHORT $LN7@vector
  00320	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 ___asan_report_store4
  00329	83 c4 04	 add	 esp, 4
$LN7@vector:
  0032c	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp]
  0032f	8b 55 d0	 mov	 edx, DWORD PTR tv137[ebp]
  00332	89 11		 mov	 DWORD PTR [ecx], edx

; 566  :             _Guard._Target   = nullptr;

  00334	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0033a	89 45 a8	 mov	 DWORD PTR tv189[ebp], eax
  0033d	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  00340	c1 e9 03	 shr	 ecx, 3
  00343	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00349	88 95 7d ff ff
	ff		 mov	 BYTE PTR tv192[ebp], dl
  0034f	80 bd 7d ff ff
	ff 00		 cmp	 BYTE PTR tv192[ebp], 0
  00356	74 1b		 je	 SHORT $LN6@vector
  00358	8a 45 a8	 mov	 al, BYTE PTR tv189[ebp]
  0035b	24 07		 and	 al, 7
  0035d	04 03		 add	 al, 3
  0035f	3a 85 7d ff ff
	ff		 cmp	 al, BYTE PTR tv192[ebp]
  00365	7c 0c		 jl	 SHORT $LN6@vector
  00367	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  0036a	51		 push	 ecx
  0036b	e8 00 00 00 00	 call	 ___asan_report_store4
  00370	83 c4 04	 add	 esp, 4
$LN6@vector:
  00373	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$4[ebp], 0

; 567  :         }

  0037d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00381	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00387	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
  0038c	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$4[ebp]
  00392	c1 ea 03	 shr	 edx, 3
  00395	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN2@vector:

; 568  : 
; 569  :         _Proxy._Release();

  0039c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003a2	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 570  :     }

  003a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ae	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003b4	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  003b9	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  003bc	89 45 d8	 mov	 DWORD PTR tv152[ebp], eax
  003bf	c7 85 10 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  003c9	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  003cf	c1 e9 03	 shr	 ecx, 3
  003d2	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  003d8	89 4d d4	 mov	 DWORD PTR tv185[ebp], ecx
  003db	6a 0d		 push	 13			; 0000000dH
  003dd	8b 55 d4	 mov	 edx, DWORD PTR tv185[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003e6	83 c4 08	 add	 esp, 8
  003e9	8b 45 d8	 mov	 eax, DWORD PTR tv152[ebp]
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f6	59		 pop	 ecx
  003f7	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fa	33 cd		 xor	 ecx, ebp
  003fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00401	8b e5		 mov	 esp, ebp
  00403	5d		 pop	 ebp
  00404	8b e3		 mov	 esp, ebx
  00406	5b		 pop	 ebx
  00407	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$1:
  0000b	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
_this$ = -8						; size = 4
$T1 = -1						; size = 1
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 508  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  0001c	51		 push	 ecx
  0001d	0f b6 55 ff	 movzx	 edx, BYTE PTR $T1[ebp]
  00021	52		 push	 edx
  00022	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00025	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>

; 509  :         _Construct_n_copies_of_ty(_Count, _Val);

  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>

; 510  :     }

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 0c 00	 ret	 12			; 0000000cH
??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z PROC	; std::_Vb_val<std::allocator<bool> >::_Nw, COMDAT

; 2472 :     static _CONSTEXPR20_CONTAINER size_type _Nw(size_type _Count) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2473 :         return (_Count + _VBITS - 1) / _VBITS;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00010	83 c0 1f	 add	 eax, 31			; 0000001fH
  00013	c1 e8 05	 shr	 eax, 5

; 2474 :     }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ENDP	; std::_Vb_val<std::allocator<bool> >::_Nw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ PROC ; std::_Vb_val<std::allocator<bool> >::_Getal, COMDAT
; _this$ = ecx

; 2464 :     _CONSTEXPR20_CONTAINER _Alvbase& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2465 :         return _Myvec._Getal();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 c1 04	 add	 ecx, 4
  00017	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal

; 2466 :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S39$ = -88						; size = 1
$T2 = -72						; size = 4
tv138 = -29						; size = 1
tv90 = -28						; size = 4
_this$ = -24						; size = 4
tv135 = -20						; size = 4
tv88 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv131 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2456 :     _CONSTEXPR20_CONTAINER ~_Vb_val() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv88[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv88[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv90[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv90[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv90[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv90[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv90[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv90[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2457 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2458 :         this->_Orphan_all();

  0008a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2459 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alvbase, this->_Getal());

  00092	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S39$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S39$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2460 :         _Delete_plain_internal(_Alproxy, _STD exchange(this->_Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d ec	 mov	 DWORD PTR tv135[ebp], ecx
  000af	8b 55 ec	 mov	 edx, DWORD PTR tv135[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv138[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv138[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@Vb_val
  000c4	8a 4d ec	 mov	 cl, BYTE PTR tv135[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv138[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@Vb_val
  000d2	8b 55 ec	 mov	 edx, DWORD PTR tv135[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@Vb_val:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 2461 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2462 :     }

  0010f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	83 c1 04	 add	 ecx, 4
  00115	e8 00 00 00 00	 call	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0011a	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00121	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00124	c1 e9 03	 shr	 ecx, 3
  00127	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0012d	89 4d f8	 mov	 DWORD PTR tv131[ebp], ecx
  00130	6a 09		 push	 9
  00132	8b 55 f8	 mov	 edx, DWORD PTR tv131[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0013b	83 c4 08	 add	 esp, 8
  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	33 cd		 xor	 ecx, ebp
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	8b e3		 mov	 esp, ebx
  0014d	5b		 pop	 ebx
  0014e	c3		 ret	 0
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
$T3 = -120						; size = 1
tv155 = -74						; size = 1
tv145 = -73						; size = 1
tv132 = -72						; size = 4
_this$ = -68						; size = 4
tv152 = -64						; size = 4
tv142 = -60						; size = 4
tv78 = -56						; size = 4
tv79 = -52						; size = 4
tv130 = -48						; size = 4
tv75 = -44						; size = 4
tv138 = -40						; size = 4
tv71 = -36						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2431 :     _CONSTEXPR20_CONTAINER _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 d0	 mov	 DWORD PTR tv130[ebp], eax
  00063	8b 4d d0	 mov	 ecx, DWORD PTR tv130[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d b8	 mov	 DWORD PTR tv132[ebp], ecx
  00072	8b 55 b8	 mov	 edx, DWORD PTR tv132[ebp]
  00075	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0007b	83 45 b8 04	 add	 DWORD PTR tv132[ebp], 4
  0007f	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00084	8b 4d b8	 mov	 ecx, DWORD PTR tv132[ebp]
  00087	66 89 01	 mov	 WORD PTR [ecx], ax
  0008a	83 45 b8 02	 add	 DWORD PTR tv132[ebp], 2
  0008e	8b 55 b8	 mov	 edx, DWORD PTR tv132[ebp]
  00091	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00094	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00099	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0009e	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  000a6	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	83 c0 04	 add	 eax, 4
  000ac	89 45 d4	 mov	 DWORD PTR tv75[ebp], eax
  000af	8b 4b 08	 mov	 ecx, DWORD PTR __Right$[ebx]
  000b2	83 c1 04	 add	 ecx, 4
  000b5	51		 push	 ecx
  000b6	8b 4d d4	 mov	 ecx, DWORD PTR tv75[ebp]
  000b9	e8 00 00 00 00	 call	 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000c5	8b 53 08	 mov	 edx, DWORD PTR __Right$[ebx]
  000c8	83 c2 14	 add	 edx, 20			; 00000014H
  000cb	89 55 cc	 mov	 DWORD PTR tv79[ebp], edx
  000ce	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000d1	83 c0 14	 add	 eax, 20			; 00000014H
  000d4	89 45 c8	 mov	 DWORD PTR tv78[ebp], eax
  000d7	8b 4d cc	 mov	 ecx, DWORD PTR tv79[ebp]
  000da	89 4d c0	 mov	 DWORD PTR tv152[ebp], ecx
  000dd	8b 55 c0	 mov	 edx, DWORD PTR tv152[ebp]
  000e0	c1 ea 03	 shr	 edx, 3
  000e3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000e9	88 45 b6	 mov	 BYTE PTR tv155[ebp], al
  000ec	80 7d b6 00	 cmp	 BYTE PTR tv155[ebp], 0
  000f0	74 1a		 je	 SHORT $LN5@Vb_val
  000f2	8a 4d c0	 mov	 cl, BYTE PTR tv152[ebp]
  000f5	80 e1 07	 and	 cl, 7
  000f8	80 c1 03	 add	 cl, 3
  000fb	3a 4d b6	 cmp	 cl, BYTE PTR tv155[ebp]
  000fe	7c 0c		 jl	 SHORT $LN5@Vb_val
  00100	8b 55 c0	 mov	 edx, DWORD PTR tv152[ebp]
  00103	52		 push	 edx
  00104	e8 00 00 00 00	 call	 ___asan_report_load4
  00109	83 c4 04	 add	 esp, 4
$LN5@Vb_val:
  0010c	8b 45 c8	 mov	 eax, DWORD PTR tv78[ebp]
  0010f	89 45 c4	 mov	 DWORD PTR tv142[ebp], eax
  00112	8b 4d c4	 mov	 ecx, DWORD PTR tv142[ebp]
  00115	c1 e9 03	 shr	 ecx, 3
  00118	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0011e	88 55 b7	 mov	 BYTE PTR tv145[ebp], dl
  00121	80 7d b7 00	 cmp	 BYTE PTR tv145[ebp], 0
  00125	74 18		 je	 SHORT $LN4@Vb_val
  00127	8a 45 c4	 mov	 al, BYTE PTR tv142[ebp]
  0012a	24 07		 and	 al, 7
  0012c	04 03		 add	 al, 3
  0012e	3a 45 b7	 cmp	 al, BYTE PTR tv145[ebp]
  00131	7c 0c		 jl	 SHORT $LN4@Vb_val
  00133	8b 4d c4	 mov	 ecx, DWORD PTR tv142[ebp]
  00136	51		 push	 ecx
  00137	e8 00 00 00 00	 call	 ___asan_report_store4
  0013c	83 c4 04	 add	 esp, 4
$LN4@Vb_val:
  0013f	8b 55 c8	 mov	 edx, DWORD PTR tv78[ebp]
  00142	8b 45 cc	 mov	 eax, DWORD PTR tv79[ebp]
  00145	8b 08		 mov	 ecx, DWORD PTR [eax]
  00147	89 0a		 mov	 DWORD PTR [edx], ecx

; 2432 :         this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));

  00149	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  00151	50		 push	 eax
  00152	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  00155	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  0015a	50		 push	 eax
  0015b	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
  00163	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00166	c1 ea 03	 shr	 edx, 3
  00169	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 2433 :     }

  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  0017a	89 45 dc	 mov	 DWORD PTR tv71[ebp], eax
  0017d	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00187	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  0018d	c1 e9 03	 shr	 ecx, 3
  00190	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00196	89 4d d8	 mov	 DWORD PTR tv138[ebp], ecx
  00199	6a 07		 push	 7
  0019b	8b 55 d8	 mov	 edx, DWORD PTR tv138[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001a4	83 c4 08	 add	 esp, 8
  001a7	8b 45 dc	 mov	 eax, DWORD PTR tv71[ebp]
  001aa	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ad	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001b4	59		 pop	 ecx
  001b5	8b e5		 mov	 esp, ebp
  001b7	5d		 pop	 ebp
  001b8	8b e3		 mov	 esp, ebx
  001ba	5b		 pop	 ebx
  001bb	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -184					; size = 4
__asan_gen_1$ = -180					; size = 4
__asan_gen_2$ = -176					; size = 4
$T3 = -168						; size = 1
$T4 = -152						; size = 4
$T5 = -136						; size = 1
tv189 = -91						; size = 1
tv179 = -90						; size = 1
tv169 = -89						; size = 1
tv147 = -88						; size = 4
_this$ = -84						; size = 4
tv186 = -80						; size = 4
tv176 = -76						; size = 4
tv166 = -72						; size = 4
tv78 = -68						; size = 4
tv91 = -64						; size = 4
tv145 = -60						; size = 4
tv138 = -56						; size = 4
tv86 = -52						; size = 4
tv84 = -48						; size = 4
tv88 = -44						; size = 4
tv162 = -40						; size = 4
tv71 = -36						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2427 :         : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 85 48 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
  00053	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
  0005d	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00063	89 45 c4	 mov	 DWORD PTR tv145[ebp], eax
  00066	8b 4d c4	 mov	 ecx, DWORD PTR tv145[ebp]
  00069	c1 e9 03	 shr	 ecx, 3
  0006c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00072	89 4d a8	 mov	 DWORD PTR tv147[ebp], ecx
  00075	8b 55 a8	 mov	 edx, DWORD PTR tv147[ebp]
  00078	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0007e	83 45 a8 04	 add	 DWORD PTR tv147[ebp], 4
  00082	8b 45 a8	 mov	 eax, DWORD PTR tv147[ebp]
  00085	c7 00 04 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788924 ; f3f8f204H
  0008b	83 45 a8 04	 add	 DWORD PTR tv147[ebp], 4
  0008f	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv147[ebp]
  00097	66 89 0a	 mov	 WORD PTR [edx], cx
  0009a	83 45 a8 02	 add	 DWORD PTR tv147[ebp], 2
  0009e	8b 45 a8	 mov	 eax, DWORD PTR tv147[ebp]
  000a1	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000a9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000ae	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  000b6	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	83 c1 04	 add	 ecx, 4
  000bc	89 4d d4	 mov	 DWORD PTR tv88[ebp], ecx
  000bf	8b 53 10	 mov	 edx, DWORD PTR __Al$[ebx]
  000c2	52		 push	 edx
  000c3	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000c9	e8 00 00 00 00	 call	 ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>
  000ce	89 45 cc	 mov	 DWORD PTR tv86[ebp], eax
  000d1	8b 43 0c	 mov	 eax, DWORD PTR __Val$[ebx]
  000d4	89 45 c8	 mov	 DWORD PTR tv138[ebp], eax
  000d7	8b 4d c8	 mov	 ecx, DWORD PTR tv138[ebp]
  000da	89 4d b0	 mov	 DWORD PTR tv186[ebp], ecx
  000dd	8b 55 b0	 mov	 edx, DWORD PTR tv186[ebp]
  000e0	c1 ea 03	 shr	 edx, 3
  000e3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000e9	88 45 a5	 mov	 BYTE PTR tv189[ebp], al
  000ec	80 7d a5 00	 cmp	 BYTE PTR tv189[ebp], 0
  000f0	74 17		 je	 SHORT $LN8@Vb_val
  000f2	8a 4d b0	 mov	 cl, BYTE PTR tv186[ebp]
  000f5	80 e1 07	 and	 cl, 7
  000f8	3a 4d a5	 cmp	 cl, BYTE PTR tv189[ebp]
  000fb	7c 0c		 jl	 SHORT $LN8@Vb_val
  000fd	8b 55 b0	 mov	 edx, DWORD PTR tv186[ebp]
  00100	52		 push	 edx
  00101	e8 00 00 00 00	 call	 ___asan_report_load1
  00106	83 c4 04	 add	 esp, 4
$LN8@Vb_val:
  00109	8b 43 0c	 mov	 eax, DWORD PTR __Val$[ebx]
  0010c	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0010f	85 c9		 test	 ecx, ecx
  00111	74 09		 je	 SHORT $LN3@Vb_val
  00113	c7 45 bc ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
  0011a	eb 07		 jmp	 SHORT $LN4@Vb_val
$LN3@Vb_val:
  0011c	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Vb_val:
  00123	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  00129	c1 ea 03	 shr	 edx, 3
  0012c	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1
  00133	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00139	89 45 b4	 mov	 DWORD PTR tv176[ebp], eax
  0013c	8b 4d b4	 mov	 ecx, DWORD PTR tv176[ebp]
  0013f	c1 e9 03	 shr	 ecx, 3
  00142	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00148	88 55 a6	 mov	 BYTE PTR tv179[ebp], dl
  0014b	80 7d a6 00	 cmp	 BYTE PTR tv179[ebp], 0
  0014f	74 18		 je	 SHORT $LN7@Vb_val
  00151	8a 45 b4	 mov	 al, BYTE PTR tv176[ebp]
  00154	24 07		 and	 al, 7
  00156	04 03		 add	 al, 3
  00158	3a 45 a6	 cmp	 al, BYTE PTR tv179[ebp]
  0015b	7c 0c		 jl	 SHORT $LN7@Vb_val
  0015d	8b 4d b4	 mov	 ecx, DWORD PTR tv176[ebp]
  00160	51		 push	 ecx
  00161	e8 00 00 00 00	 call	 ___asan_report_store4
  00166	83 c4 04	 add	 esp, 4
$LN7@Vb_val:
  00169	8b 55 bc	 mov	 edx, DWORD PTR tv78[ebp]
  0016c	89 95 68 ff ff
	ff		 mov	 DWORD PTR $T4[ebp], edx
  00172	8b 43 08	 mov	 eax, DWORD PTR __Count$[ebx]
  00175	50		 push	 eax
  00176	e8 00 00 00 00	 call	 ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  0017b	83 c4 04	 add	 esp, 4
  0017e	89 45 d0	 mov	 DWORD PTR tv84[ebp], eax
  00181	8b 4d cc	 mov	 ecx, DWORD PTR tv86[ebp]
  00184	51		 push	 ecx
  00185	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0018b	52		 push	 edx
  0018c	8b 45 d0	 mov	 eax, DWORD PTR tv84[ebp]
  0018f	50		 push	 eax
  00190	8b 4d d4	 mov	 ecx, DWORD PTR tv88[ebp]
  00193	e8 00 00 00 00	 call	 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
  00198	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0019f	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001a5	c1 e9 03	 shr	 ecx, 3
  001a8	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  001af	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  001b5	c1 ea 03	 shr	 edx, 3
  001b8	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  001bf	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  001c2	83 c0 14	 add	 eax, 20			; 00000014H
  001c5	89 45 c0	 mov	 DWORD PTR tv91[ebp], eax
  001c8	8b 4d c0	 mov	 ecx, DWORD PTR tv91[ebp]
  001cb	89 4d b8	 mov	 DWORD PTR tv166[ebp], ecx
  001ce	8b 55 b8	 mov	 edx, DWORD PTR tv166[ebp]
  001d1	c1 ea 03	 shr	 edx, 3
  001d4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001da	88 45 a7	 mov	 BYTE PTR tv169[ebp], al
  001dd	80 7d a7 00	 cmp	 BYTE PTR tv169[ebp], 0
  001e1	74 1a		 je	 SHORT $LN6@Vb_val
  001e3	8a 4d b8	 mov	 cl, BYTE PTR tv166[ebp]
  001e6	80 e1 07	 and	 cl, 7
  001e9	80 c1 03	 add	 cl, 3
  001ec	3a 4d a7	 cmp	 cl, BYTE PTR tv169[ebp]
  001ef	7c 0c		 jl	 SHORT $LN6@Vb_val
  001f1	8b 55 b8	 mov	 edx, DWORD PTR tv166[ebp]
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 ___asan_report_store4
  001fa	83 c4 04	 add	 esp, 4
$LN6@Vb_val:
  001fd	8b 45 c0	 mov	 eax, DWORD PTR tv91[ebp]
  00200	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2428 :         this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));

  00206	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00209	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  0020e	50		 push	 eax
  0020f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00215	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  0021a	50		 push	 eax
  0021b	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  0021e	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 2429 :     }

  00233	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0023a	8b 55 ac	 mov	 edx, DWORD PTR _this$[ebp]
  0023d	89 55 dc	 mov	 DWORD PTR tv71[ebp], edx
  00240	c7 85 48 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0024a	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00250	c1 e8 03	 shr	 eax, 3
  00253	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00258	89 45 d8	 mov	 DWORD PTR tv162[ebp], eax
  0025b	6a 0b		 push	 11			; 0000000bH
  0025d	8b 4d d8	 mov	 ecx, DWORD PTR tv162[ebp]
  00260	51		 push	 ecx
  00261	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00266	83 c4 08	 add	 esp, 8
  00269	8b 45 dc	 mov	 eax, DWORD PTR tv71[ebp]
  0026c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0026f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00276	59		 pop	 ecx
  00277	8b e5		 mov	 esp, ebp
  00279	5d		 pop	 ebp
  0027a	8b e3		 mov	 esp, ebx
  0027c	5b		 pop	 ebx
  0027d	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z$0:
  00000	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction, COMDAT

; 731  :     _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :         return _Al;

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 733  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXQAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXQAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@I@std@@QAEXQAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
tv67 = -20						; size = 4
tv65 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 42   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :     // return larger of _Left and _Right
; 44   :     return _Left < _Right ? _Right : _Left;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@max
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@max
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@max:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv70[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv76[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@max
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv73[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv76[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@max
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@max:
  00086	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	73 08		 jae	 SHORT $LN3@max
  00092	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00098	eb 06		 jmp	 SHORT $LN4@max
$LN3@max:
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009d	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  000a3	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000a6	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 45   : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Graphics\Rect.inl
;	COMDAT ??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z
_TEXT	SEGMENT
tv71 = -76						; size = 4
tv70 = -72						; size = 4
tv69 = -68						; size = 4
tv68 = -64						; size = 4
tv67 = -60						; size = 4
tv66 = -56						; size = 4
tv65 = -52						; size = 4
tv64 = -48						; size = 4
tv89 = -44						; size = 4
tv131 = -40						; size = 4
tv141 = -36						; size = 4
tv151 = -32						; size = 4
tv161 = -28						; size = 4
tv171 = -24						; size = 4
tv181 = -20						; size = 4
tv191 = -16						; size = 4
_this$ = -12						; size = 4
tv92 = -8						; size = 1
tv134 = -7						; size = 1
tv144 = -6						; size = 1
tv154 = -5						; size = 1
tv164 = -4						; size = 1
tv174 = -3						; size = 1
tv184 = -2						; size = 1
tv194 = -1						; size = 1
_position$ = 8						; size = 4
_size$ = 12						; size = 4
??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z PROC		; sf::Rect<int>::Rect<int>, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C23CD225_Rect@inl
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 53   : left  (position.x),

  00013	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00016	89 45 cc	 mov	 DWORD PTR tv65[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	89 4d d0	 mov	 DWORD PTR tv64[ebp], ecx
  0001f	8b 55 cc	 mov	 edx, DWORD PTR tv65[ebp]
  00022	89 55 f0	 mov	 DWORD PTR tv191[ebp], edx
  00025	8b 45 f0	 mov	 eax, DWORD PTR tv191[ebp]
  00028	c1 e8 03	 shr	 eax, 3
  0002b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00031	88 4d ff	 mov	 BYTE PTR tv194[ebp], cl
  00034	80 7d ff 00	 cmp	 BYTE PTR tv194[ebp], 0
  00038	74 1a		 je	 SHORT $LN10@Rect
  0003a	8a 55 f0	 mov	 dl, BYTE PTR tv191[ebp]
  0003d	80 e2 07	 and	 dl, 7
  00040	80 c2 03	 add	 dl, 3
  00043	3a 55 ff	 cmp	 dl, BYTE PTR tv194[ebp]
  00046	7c 0c		 jl	 SHORT $LN10@Rect
  00048	8b 45 f0	 mov	 eax, DWORD PTR tv191[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ___asan_report_load4
  00051	83 c4 04	 add	 esp, 4
$LN10@Rect:
  00054	8b 4d d0	 mov	 ecx, DWORD PTR tv64[ebp]
  00057	89 4d ec	 mov	 DWORD PTR tv181[ebp], ecx
  0005a	8b 55 ec	 mov	 edx, DWORD PTR tv181[ebp]
  0005d	c1 ea 03	 shr	 edx, 3
  00060	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00066	88 45 fe	 mov	 BYTE PTR tv184[ebp], al
  00069	80 7d fe 00	 cmp	 BYTE PTR tv184[ebp], 0
  0006d	74 1a		 je	 SHORT $LN9@Rect
  0006f	8a 4d ec	 mov	 cl, BYTE PTR tv181[ebp]
  00072	80 e1 07	 and	 cl, 7
  00075	80 c1 03	 add	 cl, 3
  00078	3a 4d fe	 cmp	 cl, BYTE PTR tv184[ebp]
  0007b	7c 0c		 jl	 SHORT $LN9@Rect
  0007d	8b 55 ec	 mov	 edx, DWORD PTR tv181[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 ___asan_report_store4
  00086	83 c4 04	 add	 esp, 4
$LN9@Rect:
  00089	8b 45 d0	 mov	 eax, DWORD PTR tv64[ebp]
  0008c	8b 4d cc	 mov	 ecx, DWORD PTR tv65[ebp]
  0008f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00091	89 10		 mov	 DWORD PTR [eax], edx

; 54   : top   (position.y),

  00093	8b 45 08	 mov	 eax, DWORD PTR _position$[ebp]
  00096	83 c0 04	 add	 eax, 4
  00099	89 45 c4	 mov	 DWORD PTR tv67[ebp], eax
  0009c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009f	83 c1 04	 add	 ecx, 4
  000a2	89 4d c8	 mov	 DWORD PTR tv66[ebp], ecx
  000a5	8b 55 c4	 mov	 edx, DWORD PTR tv67[ebp]
  000a8	89 55 e8	 mov	 DWORD PTR tv171[ebp], edx
  000ab	8b 45 e8	 mov	 eax, DWORD PTR tv171[ebp]
  000ae	c1 e8 03	 shr	 eax, 3
  000b1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b7	88 4d fd	 mov	 BYTE PTR tv174[ebp], cl
  000ba	80 7d fd 00	 cmp	 BYTE PTR tv174[ebp], 0
  000be	74 1a		 je	 SHORT $LN8@Rect
  000c0	8a 55 e8	 mov	 dl, BYTE PTR tv171[ebp]
  000c3	80 e2 07	 and	 dl, 7
  000c6	80 c2 03	 add	 dl, 3
  000c9	3a 55 fd	 cmp	 dl, BYTE PTR tv174[ebp]
  000cc	7c 0c		 jl	 SHORT $LN8@Rect
  000ce	8b 45 e8	 mov	 eax, DWORD PTR tv171[ebp]
  000d1	50		 push	 eax
  000d2	e8 00 00 00 00	 call	 ___asan_report_load4
  000d7	83 c4 04	 add	 esp, 4
$LN8@Rect:
  000da	8b 4d c8	 mov	 ecx, DWORD PTR tv66[ebp]
  000dd	89 4d e4	 mov	 DWORD PTR tv161[ebp], ecx
  000e0	8b 55 e4	 mov	 edx, DWORD PTR tv161[ebp]
  000e3	c1 ea 03	 shr	 edx, 3
  000e6	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000ec	88 45 fc	 mov	 BYTE PTR tv164[ebp], al
  000ef	80 7d fc 00	 cmp	 BYTE PTR tv164[ebp], 0
  000f3	74 1a		 je	 SHORT $LN7@Rect
  000f5	8a 4d e4	 mov	 cl, BYTE PTR tv161[ebp]
  000f8	80 e1 07	 and	 cl, 7
  000fb	80 c1 03	 add	 cl, 3
  000fe	3a 4d fc	 cmp	 cl, BYTE PTR tv164[ebp]
  00101	7c 0c		 jl	 SHORT $LN7@Rect
  00103	8b 55 e4	 mov	 edx, DWORD PTR tv161[ebp]
  00106	52		 push	 edx
  00107	e8 00 00 00 00	 call	 ___asan_report_store4
  0010c	83 c4 04	 add	 esp, 4
$LN7@Rect:
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv66[ebp]
  00112	8b 4d c4	 mov	 ecx, DWORD PTR tv67[ebp]
  00115	8b 11		 mov	 edx, DWORD PTR [ecx]
  00117	89 10		 mov	 DWORD PTR [eax], edx

; 55   : width (size.x),

  00119	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0011c	89 45 bc	 mov	 DWORD PTR tv69[ebp], eax
  0011f	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00122	83 c1 08	 add	 ecx, 8
  00125	89 4d c0	 mov	 DWORD PTR tv68[ebp], ecx
  00128	8b 55 bc	 mov	 edx, DWORD PTR tv69[ebp]
  0012b	89 55 e0	 mov	 DWORD PTR tv151[ebp], edx
  0012e	8b 45 e0	 mov	 eax, DWORD PTR tv151[ebp]
  00131	c1 e8 03	 shr	 eax, 3
  00134	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0013a	88 4d fb	 mov	 BYTE PTR tv154[ebp], cl
  0013d	80 7d fb 00	 cmp	 BYTE PTR tv154[ebp], 0
  00141	74 1a		 je	 SHORT $LN6@Rect
  00143	8a 55 e0	 mov	 dl, BYTE PTR tv151[ebp]
  00146	80 e2 07	 and	 dl, 7
  00149	80 c2 03	 add	 dl, 3
  0014c	3a 55 fb	 cmp	 dl, BYTE PTR tv154[ebp]
  0014f	7c 0c		 jl	 SHORT $LN6@Rect
  00151	8b 45 e0	 mov	 eax, DWORD PTR tv151[ebp]
  00154	50		 push	 eax
  00155	e8 00 00 00 00	 call	 ___asan_report_load4
  0015a	83 c4 04	 add	 esp, 4
$LN6@Rect:
  0015d	8b 4d c0	 mov	 ecx, DWORD PTR tv68[ebp]
  00160	89 4d dc	 mov	 DWORD PTR tv141[ebp], ecx
  00163	8b 55 dc	 mov	 edx, DWORD PTR tv141[ebp]
  00166	c1 ea 03	 shr	 edx, 3
  00169	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0016f	88 45 fa	 mov	 BYTE PTR tv144[ebp], al
  00172	80 7d fa 00	 cmp	 BYTE PTR tv144[ebp], 0
  00176	74 1a		 je	 SHORT $LN5@Rect
  00178	8a 4d dc	 mov	 cl, BYTE PTR tv141[ebp]
  0017b	80 e1 07	 and	 cl, 7
  0017e	80 c1 03	 add	 cl, 3
  00181	3a 4d fa	 cmp	 cl, BYTE PTR tv144[ebp]
  00184	7c 0c		 jl	 SHORT $LN5@Rect
  00186	8b 55 dc	 mov	 edx, DWORD PTR tv141[ebp]
  00189	52		 push	 edx
  0018a	e8 00 00 00 00	 call	 ___asan_report_store4
  0018f	83 c4 04	 add	 esp, 4
$LN5@Rect:
  00192	8b 45 c0	 mov	 eax, DWORD PTR tv68[ebp]
  00195	8b 4d bc	 mov	 ecx, DWORD PTR tv69[ebp]
  00198	8b 11		 mov	 edx, DWORD PTR [ecx]
  0019a	89 10		 mov	 DWORD PTR [eax], edx

; 56   : height(size.y)

  0019c	8b 45 0c	 mov	 eax, DWORD PTR _size$[ebp]
  0019f	83 c0 04	 add	 eax, 4
  001a2	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  001a5	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001a8	83 c1 0c	 add	 ecx, 12			; 0000000cH
  001ab	89 4d b8	 mov	 DWORD PTR tv70[ebp], ecx
  001ae	8b 55 b4	 mov	 edx, DWORD PTR tv71[ebp]
  001b1	89 55 d8	 mov	 DWORD PTR tv131[ebp], edx
  001b4	8b 45 d8	 mov	 eax, DWORD PTR tv131[ebp]
  001b7	c1 e8 03	 shr	 eax, 3
  001ba	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001c0	88 4d f9	 mov	 BYTE PTR tv134[ebp], cl
  001c3	80 7d f9 00	 cmp	 BYTE PTR tv134[ebp], 0
  001c7	74 1a		 je	 SHORT $LN4@Rect
  001c9	8a 55 d8	 mov	 dl, BYTE PTR tv131[ebp]
  001cc	80 e2 07	 and	 dl, 7
  001cf	80 c2 03	 add	 dl, 3
  001d2	3a 55 f9	 cmp	 dl, BYTE PTR tv134[ebp]
  001d5	7c 0c		 jl	 SHORT $LN4@Rect
  001d7	8b 45 d8	 mov	 eax, DWORD PTR tv131[ebp]
  001da	50		 push	 eax
  001db	e8 00 00 00 00	 call	 ___asan_report_load4
  001e0	83 c4 04	 add	 esp, 4
$LN4@Rect:
  001e3	8b 4d b8	 mov	 ecx, DWORD PTR tv70[ebp]
  001e6	89 4d d4	 mov	 DWORD PTR tv89[ebp], ecx
  001e9	8b 55 d4	 mov	 edx, DWORD PTR tv89[ebp]
  001ec	c1 ea 03	 shr	 edx, 3
  001ef	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001f5	88 45 f8	 mov	 BYTE PTR tv92[ebp], al
  001f8	80 7d f8 00	 cmp	 BYTE PTR tv92[ebp], 0
  001fc	74 1a		 je	 SHORT $LN3@Rect
  001fe	8a 4d d4	 mov	 cl, BYTE PTR tv89[ebp]
  00201	80 e1 07	 and	 cl, 7
  00204	80 c1 03	 add	 cl, 3
  00207	3a 4d f8	 cmp	 cl, BYTE PTR tv92[ebp]
  0020a	7c 0c		 jl	 SHORT $LN3@Rect
  0020c	8b 55 d4	 mov	 edx, DWORD PTR tv89[ebp]
  0020f	52		 push	 edx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN3@Rect:
  00218	8b 45 b8	 mov	 eax, DWORD PTR tv70[ebp]
  0021b	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  0021e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00220	89 10		 mov	 DWORD PTR [eax], edx

; 58   : 
; 59   : }

  00222	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00225	8b e5		 mov	 esp, ebp
  00227	5d		 pop	 ebp
  00228	c2 08 00	 ret	 8
??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z ENDP		; sf::Rect<int>::Rect<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv85 = -32						; size = 4
tv82 = -28						; size = 4
__Ptrdest$ = -24					; size = 4
tv88 = -20						; size = 4
tv130 = -16						; size = 4
__Ptrnext$1 = -12					; size = 4
__Count$ = -8						; size = 4
tv91 = -2						; size = 1
tv133 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00022	68 0e 02 00 00	 push	 526			; 0000020eH
  00027	68 00 00 00 00	 push	 OFFSET $SG258354
  0002c	6a 02		 push	 2
  0002e	6a 01		 push	 1
  00030	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	89 45 e8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 527  : 
; 528  :     if (!_Ptrdest) {

  00040	83 7d e8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00044	75 05		 jne	 SHORT $LN5@Maklocstr

; 529  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0004b	8b 55 e8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  00051	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00053	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	83 e8 01	 sub	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f4	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00068	83 c2 01	 add	 edx, 1
  0006b	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0006e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00072	76 7f		 jbe	 SHORT $LN3@Maklocstr

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00074	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00077	89 45 e4	 mov	 DWORD PTR tv82[ebp], eax
  0007a	8b 4d e4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv130[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 ff	 mov	 BYTE PTR tv133[ebp], al
  0008f	80 7d ff 00	 cmp	 BYTE PTR tv133[ebp], 0
  00093	74 17		 je	 SHORT $LN8@Maklocstr
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv130[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	3a 4d ff	 cmp	 cl, BYTE PTR tv133[ebp]
  0009e	7c 0c		 jl	 SHORT $LN8@Maklocstr
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load1
  000a9	83 c4 04	 add	 esp, 4
$LN8@Maklocstr:
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000af	89 45 e0	 mov	 DWORD PTR tv85[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR tv85[ebp]
  000b5	89 4d ec	 mov	 DWORD PTR tv88[ebp], ecx
  000b8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000bb	c1 ea 03	 shr	 edx, 3
  000be	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c4	88 45 fe	 mov	 BYTE PTR tv91[ebp], al
  000c7	80 7d fe 00	 cmp	 BYTE PTR tv91[ebp], 0
  000cb	74 17		 je	 SHORT $LN7@Maklocstr
  000cd	8a 4d ec	 mov	 cl, BYTE PTR tv88[ebp]
  000d0	80 e1 07	 and	 cl, 7
  000d3	3a 4d fe	 cmp	 cl, BYTE PTR tv91[ebp]
  000d6	7c 0c		 jl	 SHORT $LN7@Maklocstr
  000d8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ___asan_report_store1
  000e1	83 c4 04	 add	 esp, 4
$LN7@Maklocstr:
  000e4	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ea	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ec	88 10		 mov	 BYTE PTR [eax], dl

; 534  :     }

  000ee	e9 60 ff ff ff	 jmp	 $LN2@Maklocstr
$LN3@Maklocstr:

; 535  : 
; 536  :     return _Ptrdest;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 537  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__Ptrdest$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __4CB88277_xlocnum
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0001a	83 c4 04	 add	 esp, 4
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00023	6a 5d		 push	 93			; 0000005dH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0002a	6a 02		 push	 2
  0002c	6a 02		 push	 2
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 94   : 
; 95   :     if (!_Ptrdest) {

  0003e	83 7d fc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00042	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  00044	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00049	8b 55 f8	 mov	 edx, DWORD PTR __Count$[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _wmemcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :     return _Ptrdest;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 101  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Mbst1$ = -136						; size = 8
__Wc$ = -120						; size = 2
__Mbst2$ = -104						; size = 8
tv156 = -57						; size = 1
tv146 = -56						; size = 4
__Wchars$ = -52						; size = 4
__Bytes$ = -48						; size = 4
__Count$ = -44						; size = 4
__Ptrnext$ = -40					; size = 4
__Ptr1$ = -36						; size = 4
tv153 = -32						; size = 4
__Ptrdest$ = -28					; size = 4
__Count1$ = -24						; size = 4
tv144 = -20						; size = 4
tv141 = -16						; size = 4
tv149 = -12						; size = 4
tv140 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 540  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
  0003a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00044	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR tv144[ebp], eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c8	 mov	 DWORD PTR tv146[ebp], ecx
  0005c	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0005f	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00065	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00069	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  0006c	c7 00 02 f2 00
	f3		 mov	 DWORD PTR [eax], -218041854 ; f300f202H
  00072	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00076	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  0007b	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0007e	66 89 0a	 mov	 WORD PTR [edx], cx
  00081	83 45 c8 02	 add	 DWORD PTR tv146[ebp], 2
  00085	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  00088	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 541  :     // convert C string to wchar_t sequence using _Cvtvec
; 542  :     size_t _Count;
; 543  :     size_t _Count1;
; 544  :     size_t _Wchars;
; 545  :     const char* _Ptr1;
; 546  :     int _Bytes;
; 547  :     wchar_t _Wc;
; 548  :     mbstate_t _Mbst1 = {};

  00095	6a 08		 push	 8
  00097	6a 00		 push	 0
  00099	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ___asan_memset
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 549  : 
; 550  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  000a8	8b 53 08	 mov	 edx, DWORD PTR __Ptr$[ebx]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _strlen
  000b1	83 c4 04	 add	 esp, 4
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 e8	 mov	 DWORD PTR __Count1$[ebp], eax

; 551  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  000ba	8b 45 e8	 mov	 eax, DWORD PTR __Count1$[ebp]
  000bd	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  000c0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  000c7	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000ca	89 4d dc	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  000cd	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  000cf	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  000d2	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  000d5	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  000d8	8b 45 dc	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  000db	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  000de	89 45 dc	 mov	 DWORD PTR __Ptr1$[ebp], eax
  000e1	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
$LN4@Maklocstr:
  000ea	83 7d d4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000ee	76 2c		 jbe	 SHORT $LN3@Maklocstr

; 552  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  000f0	8b 53 10	 mov	 edx, DWORD PTR __Cvt$[ebx]
  000f3	52		 push	 edx
  000f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __Mbst1$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 dc	 mov	 edx, DWORD PTR __Ptr1$[ebp]
  00102	52		 push	 edx
  00103	8d 45 88	 lea	 eax, DWORD PTR __Wc$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __Mbrtowc
  0010c	83 c4 14	 add	 esp, 20			; 00000014H
  0010f	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00112	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00116	7f 02		 jg	 SHORT $LN8@Maklocstr

; 553  :             break;

  00118	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 554  :         }
; 555  :     }

  0011a	eb b3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 556  : 
; 557  :     ++_Wchars; // count terminating nul

  0011c	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx

; 558  : 
; 559  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00125	68 2f 02 00 00	 push	 559			; 0000022fH
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0012f	6a 02		 push	 2
  00131	6a 02		 push	 2
  00133	8b 55 cc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  00136	52		 push	 edx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0013d	83 c4 14	 add	 esp, 20			; 00000014H
  00140	89 45 e4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 560  : 
; 561  :     if (!_Ptrdest) {

  00143	83 7d e4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00147	75 05		 jne	 SHORT $LN9@Maklocstr

; 562  :         _Xbad_alloc();

  00149	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 563  :     }
; 564  : 
; 565  :     wchar_t* _Ptrnext = _Ptrdest;

  0014e	8b 45 e4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00151	89 45 d8	 mov	 DWORD PTR __Ptrnext$[ebp], eax

; 566  :     mbstate_t _Mbst2  = {};

  00154	6a 08		 push	 8
  00156	6a 00		 push	 0
  00158	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ___asan_memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 
; 568  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00164	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  00166	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  00169	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  0016c	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  0016f	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00172	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00175	89 43 08	 mov	 DWORD PTR __Ptr$[ebx], eax
  00178	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0017b	83 e9 01	 sub	 ecx, 1
  0017e	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
  00181	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  00184	83 c2 02	 add	 edx, 2
  00187	89 55 d8	 mov	 DWORD PTR __Ptrnext$[ebp], edx
$LN7@Maklocstr:
  0018a	83 7d cc 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0018e	76 29		 jbe	 SHORT $LN6@Maklocstr

; 569  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00190	8b 43 10	 mov	 eax, DWORD PTR __Cvt$[ebx]
  00193	50		 push	 eax
  00194	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 e8	 mov	 edx, DWORD PTR __Count1$[ebp]
  0019b	52		 push	 edx
  0019c	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  0019f	50		 push	 eax
  001a0	8b 4d d8	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 __Mbrtowc
  001a9	83 c4 14	 add	 esp, 20			; 00000014H
  001ac	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  001af	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  001b3	7f 02		 jg	 SHORT $LN10@Maklocstr

; 570  :             break;

  001b5	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 571  :         }
; 572  :     }

  001b7	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 573  : 
; 574  :     *_Ptrnext = L'\0';

  001b9	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  001bc	89 55 f0	 mov	 DWORD PTR tv141[ebp], edx
  001bf	8b 45 f0	 mov	 eax, DWORD PTR tv141[ebp]
  001c2	89 45 e0	 mov	 DWORD PTR tv153[ebp], eax
  001c5	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001c8	c1 e9 03	 shr	 ecx, 3
  001cb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001d1	88 55 c7	 mov	 BYTE PTR tv156[ebp], dl
  001d4	80 7d c7 00	 cmp	 BYTE PTR tv156[ebp], 0
  001d8	74 18		 je	 SHORT $LN12@Maklocstr
  001da	8a 45 e0	 mov	 al, BYTE PTR tv153[ebp]
  001dd	24 07		 and	 al, 7
  001df	04 01		 add	 al, 1
  001e1	3a 45 c7	 cmp	 al, BYTE PTR tv156[ebp]
  001e4	7c 0c		 jl	 SHORT $LN12@Maklocstr
  001e6	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 ___asan_report_store2
  001ef	83 c4 04	 add	 esp, 4
$LN12@Maklocstr:
  001f2	33 d2		 xor	 edx, edx
  001f4	8b 45 d8	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  001f7	66 89 10	 mov	 WORD PTR [eax], dx

; 575  : 
; 576  :     return _Ptrdest;

  001fa	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  001fd	89 4d f8	 mov	 DWORD PTR tv140[ebp], ecx
  00200	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0020a	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00210	c1 ea 03	 shr	 edx, 3
  00213	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00219	89 55 f4	 mov	 DWORD PTR tv149[ebp], edx
  0021c	6a 0b		 push	 11			; 0000000bH
  0021e	8b 45 f4	 mov	 eax, DWORD PTR tv149[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00227	83 c4 08	 add	 esp, 8
  0022a	8b 45 f8	 mov	 eax, DWORD PTR tv140[ebp]
$LN11@Maklocstr:

; 577  : }

  0022d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00230	33 cd		 xor	 ecx, ebp
  00232	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	8b e3		 mov	 esp, ebx
  0023c	5b		 pop	 ebx
  0023d	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABI@std@@YAABIABI@Z PROC			; std::forward<unsigned int const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABI@std@@YAABIABI@Z ENDP			; std::forward<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1invalid_argument@std@@UAE@XZ PROC			; std::invalid_argument::~invalid_argument, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1invalid_argument@std@@UAE@XZ ENDP			; std::invalid_argument::~invalid_argument
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4654 :     _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4655 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4656 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4650 :     _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4651 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4652 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
$T3 = -152						; size = 1
tv194 = -105						; size = 1
tv184 = -104						; size = 1
tv174 = -103						; size = 1
tv164 = -102						; size = 1
tv154 = -101						; size = 1
tv138 = -100						; size = 4
__My_data$ = -96					; size = 4
tv191 = -92						; size = 4
tv181 = -88						; size = 4
tv171 = -84						; size = 4
tv161 = -80						; size = 4
tv151 = -76						; size = 4
tv66 = -72						; size = 4
tv70 = -68						; size = 4
_this$ = -64						; size = 4
tv80 = -60						; size = 4
__New_ptr$4 = -56					; size = 4
tv83 = -52						; size = 4
tv136 = -48						; size = 4
__Al$5 = -44						; size = 4
__Raw_new$6 = -40					; size = 4
tv147 = -36						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4594 :     _CONSTEXPR20_CONTAINER void _Tidy_init() noexcept { // initialize basic_string data members

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00053	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
  0005d	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00063	89 45 d0	 mov	 DWORD PTR tv136[ebp], eax
  00066	8b 4d d0	 mov	 ecx, DWORD PTR tv136[ebp]
  00069	c1 e9 03	 shr	 ecx, 3
  0006c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00072	89 4d 9c	 mov	 DWORD PTR tv138[ebp], ecx
  00075	8b 55 9c	 mov	 edx, DWORD PTR tv138[ebp]
  00078	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  0007e	83 45 9c 04	 add	 DWORD PTR tv138[ebp], 4
  00082	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00087	8b 4d 9c	 mov	 ecx, DWORD PTR tv138[ebp]
  0008a	66 89 01	 mov	 WORD PTR [ecx], ax
  0008d	83 45 9c 02	 add	 DWORD PTR tv138[ebp], 2
  00091	8b 55 9c	 mov	 edx, DWORD PTR tv138[ebp]
  00094	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0009c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4595 :         auto& _My_data   = _Mypair._Myval2;

  000a1	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	89 45 a0	 mov	 DWORD PTR __My_data$[ebp], eax

; 4596 :         _My_data._Mysize = 0;

  000a7	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000aa	83 c1 14	 add	 ecx, 20			; 00000014H
  000ad	89 4d b8	 mov	 DWORD PTR tv66[ebp], ecx
  000b0	8b 55 b8	 mov	 edx, DWORD PTR tv66[ebp]
  000b3	89 55 a4	 mov	 DWORD PTR tv191[ebp], edx
  000b6	8b 45 a4	 mov	 eax, DWORD PTR tv191[ebp]
  000b9	c1 e8 03	 shr	 eax, 3
  000bc	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000c2	88 4d 97	 mov	 BYTE PTR tv194[ebp], cl
  000c5	80 7d 97 00	 cmp	 BYTE PTR tv194[ebp], 0
  000c9	74 1a		 je	 SHORT $LN9@Tidy_init
  000cb	8a 55 a4	 mov	 dl, BYTE PTR tv191[ebp]
  000ce	80 e2 07	 and	 dl, 7
  000d1	80 c2 03	 add	 dl, 3
  000d4	3a 55 97	 cmp	 dl, BYTE PTR tv194[ebp]
  000d7	7c 0c		 jl	 SHORT $LN9@Tidy_init
  000d9	8b 45 a4	 mov	 eax, DWORD PTR tv191[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN9@Tidy_init:
  000e5	8b 4d b8	 mov	 ecx, DWORD PTR tv66[ebp]
  000e8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {

  000ee	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000f3	0f b6 d0	 movzx	 edx, al
  000f6	85 d2		 test	 edx, edx
  000f8	0f 84 c9 00 00
	00		 je	 $LN2@Tidy_init

; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context

  000fe	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00101	83 c0 18	 add	 eax, 24			; 00000018H
  00104	89 45 bc	 mov	 DWORD PTR tv70[ebp], eax
  00107	8b 4d bc	 mov	 ecx, DWORD PTR tv70[ebp]
  0010a	89 4d a8	 mov	 DWORD PTR tv181[ebp], ecx
  0010d	8b 55 a8	 mov	 edx, DWORD PTR tv181[ebp]
  00110	c1 ea 03	 shr	 edx, 3
  00113	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00119	88 45 98	 mov	 BYTE PTR tv184[ebp], al
  0011c	80 7d 98 00	 cmp	 BYTE PTR tv184[ebp], 0
  00120	74 1a		 je	 SHORT $LN8@Tidy_init
  00122	8a 4d a8	 mov	 cl, BYTE PTR tv181[ebp]
  00125	80 e1 07	 and	 cl, 7
  00128	80 c1 03	 add	 cl, 3
  0012b	3a 4d 98	 cmp	 cl, BYTE PTR tv184[ebp]
  0012e	7c 0c		 jl	 SHORT $LN8@Tidy_init
  00130	8b 55 a8	 mov	 edx, DWORD PTR tv181[ebp]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 ___asan_report_store4
  00139	83 c4 04	 add	 esp, 4
$LN8@Tidy_init:
  0013c	8b 45 bc	 mov	 eax, DWORD PTR tv70[ebp]
  0013f	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 4601 :             auto& _Al              = _Getal();

  00145	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0014d	89 45 d4	 mov	 DWORD PTR __Al$5[ebp], eax

; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws

  00150	6a 11		 push	 17			; 00000011H
  00152	8b 4d d4	 mov	 ecx, DWORD PTR __Al$5[ebp]
  00155	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0015a	89 45 c8	 mov	 DWORD PTR __New_ptr$4[ebp], eax

; 4603 :             _My_data._Bx._Ptr      = _New_ptr;

  0015d	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00160	83 c1 04	 add	 ecx, 4
  00163	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  00166	8b 55 c4	 mov	 edx, DWORD PTR tv80[ebp]
  00169	89 55 ac	 mov	 DWORD PTR tv171[ebp], edx
  0016c	8b 45 ac	 mov	 eax, DWORD PTR tv171[ebp]
  0016f	c1 e8 03	 shr	 eax, 3
  00172	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00178	88 4d 99	 mov	 BYTE PTR tv174[ebp], cl
  0017b	80 7d 99 00	 cmp	 BYTE PTR tv174[ebp], 0
  0017f	74 1a		 je	 SHORT $LN7@Tidy_init
  00181	8a 55 ac	 mov	 dl, BYTE PTR tv171[ebp]
  00184	80 e2 07	 and	 dl, 7
  00187	80 c2 03	 add	 dl, 3
  0018a	3a 55 99	 cmp	 dl, BYTE PTR tv174[ebp]
  0018d	7c 0c		 jl	 SHORT $LN7@Tidy_init
  0018f	8b 45 ac	 mov	 eax, DWORD PTR tv171[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ___asan_report_store4
  00198	83 c4 04	 add	 esp, 4
$LN7@Tidy_init:
  0019b	8b 4d c4	 mov	 ecx, DWORD PTR tv80[ebp]
  0019e	8b 55 c8	 mov	 edx, DWORD PTR __New_ptr$4[ebp]
  001a1	89 11		 mov	 DWORD PTR [ecx], edx

; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);

  001a3	8b 45 c8	 mov	 eax, DWORD PTR __New_ptr$4[ebp]
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  001ac	83 c4 04	 add	 esp, 4
  001af	89 45 d8	 mov	 DWORD PTR __Raw_new$6[ebp], eax

; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());

  001b2	6a 00		 push	 0
  001b4	6a 11		 push	 17			; 00000011H
  001b6	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$6[ebp]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4607 :         } else

  001c2	e9 c2 00 00 00	 jmp	 $LN4@Tidy_init
$LN2@Tidy_init:
  001c7	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001cd	c1 ea 03	 shr	 edx, 3
  001d0	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001d7	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  001da	83 c0 18	 add	 eax, 24			; 00000018H
  001dd	89 45 cc	 mov	 DWORD PTR tv83[ebp], eax
  001e0	8b 4d cc	 mov	 ecx, DWORD PTR tv83[ebp]
  001e3	89 4d b0	 mov	 DWORD PTR tv161[ebp], ecx
  001e6	8b 55 b0	 mov	 edx, DWORD PTR tv161[ebp]
  001e9	c1 ea 03	 shr	 edx, 3
  001ec	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001f2	88 45 9a	 mov	 BYTE PTR tv164[ebp], al
  001f5	80 7d 9a 00	 cmp	 BYTE PTR tv164[ebp], 0
  001f9	74 1a		 je	 SHORT $LN6@Tidy_init
  001fb	8a 4d b0	 mov	 cl, BYTE PTR tv161[ebp]
  001fe	80 e1 07	 and	 cl, 7
  00201	80 c1 03	 add	 cl, 3
  00204	3a 4d 9a	 cmp	 cl, BYTE PTR tv164[ebp]
  00207	7c 0c		 jl	 SHORT $LN6@Tidy_init
  00209	8b 55 b0	 mov	 edx, DWORD PTR tv161[ebp]
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 ___asan_report_store4
  00212	83 c4 04	 add	 esp, 4
$LN6@Tidy_init:
  00215	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  00218	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0021e	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00224	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  00227	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  0022a	c1 ea 03	 shr	 edx, 3
  0022d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00233	88 45 9b	 mov	 BYTE PTR tv154[ebp], al
  00236	80 7d 9b 00	 cmp	 BYTE PTR tv154[ebp], 0
  0023a	74 17		 je	 SHORT $LN5@Tidy_init
  0023c	8a 4d b4	 mov	 cl, BYTE PTR tv151[ebp]
  0023f	80 e1 07	 and	 cl, 7
  00242	3a 4d 9b	 cmp	 cl, BYTE PTR tv154[ebp]
  00245	7c 0c		 jl	 SHORT $LN5@Tidy_init
  00247	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ___asan_report_store1
  00250	83 c4 04	 add	 esp, 4
$LN5@Tidy_init:
  00253	c6 85 68 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  0025a	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00260	50		 push	 eax
  00261	b9 01 00 00 00	 mov	 ecx, 1
  00266	6b d1 00	 imul	 edx, ecx, 0
  00269	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0026c	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00276	83 c4 08	 add	 esp, 8
  00279	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0027f	c1 ea 03	 shr	 edx, 3
  00282	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN4@Tidy_init:

; 4613 :         }
; 4614 :     }

  00289	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00293	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00299	c1 e8 03	 shr	 eax, 3
  0029c	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  002a1	89 45 dc	 mov	 DWORD PTR tv147[ebp], eax
  002a4	6a 07		 push	 7
  002a6	8b 4d dc	 mov	 ecx, DWORD PTR tv147[ebp]
  002a9	51		 push	 ecx
  002aa	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002af	83 c4 08	 add	 esp, 8
  002b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002bc	59		 pop	 ecx
  002bd	8b e5		 mov	 esp, ebp
  002bf	5d		 pop	 ebp
  002c0	8b e3		 mov	 esp, ebx
  002c2	5b		 pop	 ebx
  002c3	c3		 ret	 0
  002c4	cc		 int	 3
  002c5	cc		 int	 3
  002c6	cc		 int	 3
  002c7	cc		 int	 3
  002c8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
tv76 = -20						; size = 4
tv70 = -16						; size = 4
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv83 = -1						; size = 1
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4500 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4501 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0001b	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 18	 add	 eax, 24			; 00000018H
  00024	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  00027	8b 4d f0	 mov	 ecx, DWORD PTR tv70[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv80[ebp], ecx
  0002d	8b 55 f8	 mov	 edx, DWORD PTR tv80[ebp]
  00030	c1 ea 03	 shr	 edx, 3
  00033	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00039	88 45 ff	 mov	 BYTE PTR tv83[ebp], al
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv83[ebp], 0
  00040	74 1a		 je	 SHORT $LN3@Calculate_
  00042	8a 4d f8	 mov	 cl, BYTE PTR tv80[ebp]
  00045	80 e1 07	 and	 cl, 7
  00048	80 c1 03	 add	 cl, 3
  0004b	3a 4d ff	 cmp	 cl, BYTE PTR tv83[ebp]
  0004e	7c 0c		 jl	 SHORT $LN3@Calculate_
  00050	8b 55 f8	 mov	 edx, DWORD PTR tv80[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ___asan_report_load4
  00059	83 c4 04	 add	 esp, 4
$LN3@Calculate_:
  0005c	8b 45 f0	 mov	 eax, DWORD PTR tv70[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d e8	 mov	 DWORD PTR tv74[ebp], ecx
  00064	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00067	52		 push	 edx
  00068	8b 45 e8	 mov	 eax, DWORD PTR tv74[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR __Requested$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4502 :     }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__asan_gen_0$ = -144					; size = 4
__asan_gen_1$ = -140					; size = 4
__asan_gen_2$ = -136					; size = 4
__Masked$ = -128					; size = 4
$T2 = -112						; size = 4
tv175 = -68						; size = 1
tv165 = -67						; size = 1
tv155 = -66						; size = 1
tv145 = -65						; size = 1
tv88 = -64						; size = 4
tv172 = -60						; size = 4
tv162 = -56						; size = 4
tv152 = -52						; size = 4
tv142 = -48						; size = 4
tv69 = -44						; size = 4
tv86 = -40						; size = 4
tv64 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv132 = -24						; size = 4
tv76 = -20						; size = 4
tv71 = -16						; size = 4
tv138 = -12						; size = 4
tv77 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4487 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 70 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
  0003a	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00044	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 d8	 mov	 DWORD PTR tv86[ebp], eax
  0004d	8b 4d d8	 mov	 ecx, DWORD PTR tv86[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c0	 mov	 DWORD PTR tv88[ebp], ecx
  0005c	8b 55 c0	 mov	 edx, DWORD PTR tv88[ebp]
  0005f	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00065	83 45 c0 04	 add	 DWORD PTR tv88[ebp], 4
  00069	8b 45 c0	 mov	 eax, DWORD PTR tv88[ebp]
  0006c	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00072	83 45 c0 04	 add	 DWORD PTR tv88[ebp], 4
  00076	8b 4d c0	 mov	 ecx, DWORD PTR tv88[ebp]
  00079	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00081	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00086	8b 53 08	 mov	 edx, DWORD PTR __Requested$[ebx]
  00089	83 ca 0f	 or	 edx, 15			; 0000000fH
  0008c	89 55 dc	 mov	 DWORD PTR tv64[ebp], edx
  0008f	8d 45 80	 lea	 eax, DWORD PTR __Masked$[ebp]
  00092	89 45 c4	 mov	 DWORD PTR tv172[ebp], eax
  00095	8b 4d c4	 mov	 ecx, DWORD PTR tv172[ebp]
  00098	c1 e9 03	 shr	 ecx, 3
  0009b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a1	88 55 bc	 mov	 BYTE PTR tv175[ebp], dl
  000a4	80 7d bc 00	 cmp	 BYTE PTR tv175[ebp], 0
  000a8	74 18		 je	 SHORT $LN8@Calculate_
  000aa	8a 45 c4	 mov	 al, BYTE PTR tv172[ebp]
  000ad	24 07		 and	 al, 7
  000af	04 03		 add	 al, 3
  000b1	3a 45 bc	 cmp	 al, BYTE PTR tv175[ebp]
  000b4	7c 0c		 jl	 SHORT $LN8@Calculate_
  000b6	8b 4d c4	 mov	 ecx, DWORD PTR tv172[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 ___asan_report_store4
  000bf	83 c4 04	 add	 esp, 4
$LN8@Calculate_:
  000c2	8b 55 dc	 mov	 edx, DWORD PTR tv64[ebp]
  000c5	89 55 80	 mov	 DWORD PTR __Masked$[ebp], edx

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  000c8	8d 45 80	 lea	 eax, DWORD PTR __Masked$[ebp]
  000cb	89 45 c8	 mov	 DWORD PTR tv162[ebp], eax
  000ce	8b 4d c8	 mov	 ecx, DWORD PTR tv162[ebp]
  000d1	c1 e9 03	 shr	 ecx, 3
  000d4	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000da	88 55 bd	 mov	 BYTE PTR tv165[ebp], dl
  000dd	80 7d bd 00	 cmp	 BYTE PTR tv165[ebp], 0
  000e1	74 18		 je	 SHORT $LN7@Calculate_
  000e3	8a 45 c8	 mov	 al, BYTE PTR tv162[ebp]
  000e6	24 07		 and	 al, 7
  000e8	04 03		 add	 al, 3
  000ea	3a 45 bd	 cmp	 al, BYTE PTR tv165[ebp]
  000ed	7c 0c		 jl	 SHORT $LN7@Calculate_
  000ef	8b 4d c8	 mov	 ecx, DWORD PTR tv162[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_report_load4
  000f8	83 c4 04	 add	 esp, 4
$LN7@Calculate_:
  000fb	8b 55 80	 mov	 edx, DWORD PTR __Masked$[ebp]
  000fe	3b 53 10	 cmp	 edx, DWORD PTR __Max$[ebx]
  00101	76 38		 jbe	 SHORT $LN2@Calculate_

; 4490 :             return _Max;

  00103	8b 43 10	 mov	 eax, DWORD PTR __Max$[ebx]
  00106	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00109	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00113	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d e0	 mov	 DWORD PTR tv94[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 e0	 mov	 edx, DWORD PTR tv94[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00136	e9 18 01 00 00	 jmp	 $LN4@Calculate_
$LN2@Calculate_:

; 4491 :         }
; 4492 : 
; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0013b	8b 43 0c	 mov	 eax, DWORD PTR __Old$[ebx]
  0013e	d1 e8		 shr	 eax, 1
  00140	8b 4b 10	 mov	 ecx, DWORD PTR __Max$[ebx]
  00143	2b c8		 sub	 ecx, eax
  00145	39 4b 0c	 cmp	 DWORD PTR __Old$[ebx], ecx
  00148	76 37		 jbe	 SHORT $LN3@Calculate_

; 4494 :             return _Max;

  0014a	8b 53 10	 mov	 edx, DWORD PTR __Max$[ebx]
  0014d	89 55 ec	 mov	 DWORD PTR tv76[ebp], edx
  00150	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015a	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00160	c1 e8 03	 shr	 eax, 3
  00163	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00168	89 45 e8	 mov	 DWORD PTR tv132[ebp], eax
  0016b	6a 09		 push	 9
  0016d	8b 4d e8	 mov	 ecx, DWORD PTR tv132[ebp]
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 ec	 mov	 eax, DWORD PTR tv76[ebp]
  0017c	e9 d2 00 00 00	 jmp	 $LN4@Calculate_
$LN3@Calculate_:
  00181	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00184	c1 ea 03	 shr	 edx, 3
  00187	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 4495 :         }
; 4496 : 
; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0018e	8b 43 0c	 mov	 eax, DWORD PTR __Old$[ebx]
  00191	d1 e8		 shr	 eax, 1
  00193	8b 4b 0c	 mov	 ecx, DWORD PTR __Old$[ebx]
  00196	03 c8		 add	 ecx, eax
  00198	89 4d f0	 mov	 DWORD PTR tv71[ebp], ecx
  0019b	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  0019e	89 55 cc	 mov	 DWORD PTR tv152[ebp], edx
  001a1	8b 45 cc	 mov	 eax, DWORD PTR tv152[ebp]
  001a4	c1 e8 03	 shr	 eax, 3
  001a7	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001ad	88 4d be	 mov	 BYTE PTR tv155[ebp], cl
  001b0	80 7d be 00	 cmp	 BYTE PTR tv155[ebp], 0
  001b4	74 1a		 je	 SHORT $LN6@Calculate_
  001b6	8a 55 cc	 mov	 dl, BYTE PTR tv152[ebp]
  001b9	80 e2 07	 and	 dl, 7
  001bc	80 c2 03	 add	 dl, 3
  001bf	3a 55 be	 cmp	 dl, BYTE PTR tv155[ebp]
  001c2	7c 0c		 jl	 SHORT $LN6@Calculate_
  001c4	8b 45 cc	 mov	 eax, DWORD PTR tv152[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ___asan_report_store4
  001cd	83 c4 04	 add	 esp, 4
$LN6@Calculate_:
  001d0	8b 4d f0	 mov	 ecx, DWORD PTR tv71[ebp]
  001d3	89 4d 90	 mov	 DWORD PTR $T2[ebp], ecx
  001d6	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  001d9	52		 push	 edx
  001da	8d 45 80	 lea	 eax, DWORD PTR __Masked$[ebp]
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  001e3	83 c4 08	 add	 esp, 8
  001e6	89 45 d4	 mov	 DWORD PTR tv69[ebp], eax
  001e9	8b 4d d4	 mov	 ecx, DWORD PTR tv69[ebp]
  001ec	89 4d d0	 mov	 DWORD PTR tv142[ebp], ecx
  001ef	8b 55 d0	 mov	 edx, DWORD PTR tv142[ebp]
  001f2	c1 ea 03	 shr	 edx, 3
  001f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001fb	88 45 bf	 mov	 BYTE PTR tv145[ebp], al
  001fe	80 7d bf 00	 cmp	 BYTE PTR tv145[ebp], 0
  00202	74 1a		 je	 SHORT $LN5@Calculate_
  00204	8a 4d d0	 mov	 cl, BYTE PTR tv142[ebp]
  00207	80 e1 07	 and	 cl, 7
  0020a	80 c1 03	 add	 cl, 3
  0020d	3a 4d bf	 cmp	 cl, BYTE PTR tv145[ebp]
  00210	7c 0c		 jl	 SHORT $LN5@Calculate_
  00212	8b 55 d0	 mov	 edx, DWORD PTR tv142[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ___asan_report_load4
  0021b	83 c4 04	 add	 esp, 4
$LN5@Calculate_:
  0021e	8b 45 d4	 mov	 eax, DWORD PTR tv69[ebp]
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
  00226	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00230	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00236	c1 ea 03	 shr	 edx, 3
  00239	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0023f	89 55 f4	 mov	 DWORD PTR tv138[ebp], edx
  00242	6a 09		 push	 9
  00244	8b 45 f4	 mov	 eax, DWORD PTR tv138[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0024d	83 c4 08	 add	 esp, 8
  00250	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
$LN4@Calculate_:

; 4498 :     }

  00253	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00256	33 cd		 xor	 ecx, ebp
  00258	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	8b e3		 mov	 esp, ebx
  00262	5b		 pop	 ebx
  00263	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -184					; size = 4
__asan_gen_1$ = -180					; size = 4
__asan_gen_2$ = -176					; size = 4
__Alloc_max$ = -168					; size = 4
$T2 = -152						; size = 4
$T3 = -136						; size = 4
$T4 = -120						; size = 4
tv196 = -78						; size = 1
tv186 = -77						; size = 1
tv176 = -76						; size = 1
tv166 = -75						; size = 1
tv156 = -74						; size = 1
tv146 = -73						; size = 1
tv92 = -72						; size = 4
tv193 = -68						; size = 4
tv183 = -64						; size = 4
tv173 = -60						; size = 4
tv163 = -56						; size = 4
tv153 = -52						; size = 4
tv143 = -48						; size = 4
tv68 = -44						; size = 4
tv71 = -40						; size = 4
tv90 = -36						; size = 4
_this$ = -32						; size = 4
tv64 = -28						; size = 4
__Storage_max$ = -24					; size = 4
tv72 = -20						; size = 4
tv74 = -16						; size = 4
tv139 = -12						; size = 4
tv77 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3943 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 85 48 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00033	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0003d	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  00050	8b 4d dc	 mov	 ecx, DWORD PTR tv90[ebp]
  00053	c1 e9 03	 shr	 ecx, 3
  00056	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0005c	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  0005f	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00062	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00068	83 45 b8 04	 add	 DWORD PTR tv92[ebp], 4
  0006c	8b 45 b8	 mov	 eax, DWORD PTR tv92[ebp]
  0006f	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  00075	83 45 b8 04	 add	 DWORD PTR tv92[ebp], 4
  00079	8b 4d b8	 mov	 ecx, DWORD PTR tv92[ebp]
  0007c	c7 01 f8 f3 f3
	f3		 mov	 DWORD PTR [ecx], -202116104 ; f3f3f3f8H
  00082	83 45 b8 04	 add	 DWORD PTR tv92[ebp], 4
  00086	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00089	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0008c	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00092	c1 e8 03	 shr	 eax, 3
  00095	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  0009c	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000a2	c1 e9 03	 shr	 ecx, 3
  000a5	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4
  000ac	8d 55 88	 lea	 edx, DWORD PTR $T4[ebp]
  000af	c1 ea 03	 shr	 edx, 3
  000b2	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  000be	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3944 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  000c3	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  000d1	83 c4 04	 add	 esp, 4
  000d4	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  000d7	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  000dd	89 45 bc	 mov	 DWORD PTR tv193[ebp], eax
  000e0	8b 4d bc	 mov	 ecx, DWORD PTR tv193[ebp]
  000e3	c1 e9 03	 shr	 ecx, 3
  000e6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ec	88 55 b2	 mov	 BYTE PTR tv196[ebp], dl
  000ef	80 7d b2 00	 cmp	 BYTE PTR tv196[ebp], 0
  000f3	74 18		 je	 SHORT $LN8@max_size
  000f5	8a 45 bc	 mov	 al, BYTE PTR tv193[ebp]
  000f8	24 07		 and	 al, 7
  000fa	04 03		 add	 al, 3
  000fc	3a 45 b2	 cmp	 al, BYTE PTR tv196[ebp]
  000ff	7c 0c		 jl	 SHORT $LN8@max_size
  00101	8b 4d bc	 mov	 ecx, DWORD PTR tv193[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 ___asan_report_store4
  0010a	83 c4 04	 add	 esp, 4
$LN8@max_size:
  0010d	8b 55 e4	 mov	 edx, DWORD PTR tv64[ebp]
  00110	89 95 58 ff ff
	ff		 mov	 DWORD PTR __Alloc_max$[ebp], edx

; 3945 :         const size_type _Storage_max = // can always store small string

  00116	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0011c	89 45 c0	 mov	 DWORD PTR tv183[ebp], eax
  0011f	8b 4d c0	 mov	 ecx, DWORD PTR tv183[ebp]
  00122	c1 e9 03	 shr	 ecx, 3
  00125	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0012b	88 55 b3	 mov	 BYTE PTR tv186[ebp], dl
  0012e	80 7d b3 00	 cmp	 BYTE PTR tv186[ebp], 0
  00132	74 18		 je	 SHORT $LN7@max_size
  00134	8a 45 c0	 mov	 al, BYTE PTR tv183[ebp]
  00137	24 07		 and	 al, 7
  00139	04 03		 add	 al, 3
  0013b	3a 45 b3	 cmp	 al, BYTE PTR tv186[ebp]
  0013e	7c 0c		 jl	 SHORT $LN7@max_size
  00140	8b 4d c0	 mov	 ecx, DWORD PTR tv183[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ___asan_report_store4
  00149	83 c4 04	 add	 esp, 4
$LN7@max_size:
  0014c	c7 85 68 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR $T2[ebp], 16	; 00000010H
  00156	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0015c	52		 push	 edx
  0015d	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00169	83 c4 08	 add	 esp, 8
  0016c	89 45 d4	 mov	 DWORD PTR tv68[ebp], eax
  0016f	8b 4d d4	 mov	 ecx, DWORD PTR tv68[ebp]
  00172	89 4d c4	 mov	 DWORD PTR tv173[ebp], ecx
  00175	8b 55 c4	 mov	 edx, DWORD PTR tv173[ebp]
  00178	c1 ea 03	 shr	 edx, 3
  0017b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00181	88 45 b4	 mov	 BYTE PTR tv176[ebp], al
  00184	80 7d b4 00	 cmp	 BYTE PTR tv176[ebp], 0
  00188	74 1a		 je	 SHORT $LN6@max_size
  0018a	8a 4d c4	 mov	 cl, BYTE PTR tv173[ebp]
  0018d	80 e1 07	 and	 cl, 7
  00190	80 c1 03	 add	 cl, 3
  00193	3a 4d b4	 cmp	 cl, BYTE PTR tv176[ebp]
  00196	7c 0c		 jl	 SHORT $LN6@max_size
  00198	8b 55 c4	 mov	 edx, DWORD PTR tv173[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 ___asan_report_load4
  001a1	83 c4 04	 add	 esp, 4
$LN6@max_size:
  001a4	8b 45 d4	 mov	 eax, DWORD PTR tv68[ebp]
  001a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a9	89 4d e8	 mov	 DWORD PTR __Storage_max$[ebp], ecx
  001ac	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001b2	c1 ea 03	 shr	 edx, 3
  001b5	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 3946 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3947 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  001bc	8b 45 e8	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  001bf	83 e8 01	 sub	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  001c5	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001cb	89 4d c8	 mov	 DWORD PTR tv163[ebp], ecx
  001ce	8b 55 c8	 mov	 edx, DWORD PTR tv163[ebp]
  001d1	c1 ea 03	 shr	 edx, 3
  001d4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001da	88 45 b5	 mov	 BYTE PTR tv166[ebp], al
  001dd	80 7d b5 00	 cmp	 BYTE PTR tv166[ebp], 0
  001e1	74 1a		 je	 SHORT $LN5@max_size
  001e3	8a 4d c8	 mov	 cl, BYTE PTR tv163[ebp]
  001e6	80 e1 07	 and	 cl, 7
  001e9	80 c1 03	 add	 cl, 3
  001ec	3a 4d b5	 cmp	 cl, BYTE PTR tv166[ebp]
  001ef	7c 0c		 jl	 SHORT $LN5@max_size
  001f1	8b 55 c8	 mov	 edx, DWORD PTR tv163[ebp]
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 ___asan_report_store4
  001fa	83 c4 04	 add	 esp, 4
$LN5@max_size:
  001fd	8b 45 ec	 mov	 eax, DWORD PTR tv72[ebp]
  00200	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00206	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  0020b	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  0020e	8d 4d 88	 lea	 ecx, DWORD PTR $T4[ebp]
  00211	89 4d cc	 mov	 DWORD PTR tv153[ebp], ecx
  00214	8b 55 cc	 mov	 edx, DWORD PTR tv153[ebp]
  00217	c1 ea 03	 shr	 edx, 3
  0021a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00220	88 45 b6	 mov	 BYTE PTR tv156[ebp], al
  00223	80 7d b6 00	 cmp	 BYTE PTR tv156[ebp], 0
  00227	74 1a		 je	 SHORT $LN4@max_size
  00229	8a 4d cc	 mov	 cl, BYTE PTR tv153[ebp]
  0022c	80 e1 07	 and	 cl, 7
  0022f	80 c1 03	 add	 cl, 3
  00232	3a 4d b6	 cmp	 cl, BYTE PTR tv156[ebp]
  00235	7c 0c		 jl	 SHORT $LN4@max_size
  00237	8b 55 cc	 mov	 edx, DWORD PTR tv153[ebp]
  0023a	52		 push	 edx
  0023b	e8 00 00 00 00	 call	 ___asan_report_store4
  00240	83 c4 04	 add	 esp, 4
$LN4@max_size:
  00243	8b 45 f0	 mov	 eax, DWORD PTR tv74[ebp]
  00246	89 45 88	 mov	 DWORD PTR $T4[ebp], eax
  00249	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0024f	51		 push	 ecx
  00250	8d 55 88	 lea	 edx, DWORD PTR $T4[ebp]
  00253	52		 push	 edx
  00254	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00259	83 c4 08	 add	 esp, 8
  0025c	89 45 d8	 mov	 DWORD PTR tv71[ebp], eax
  0025f	8b 45 d8	 mov	 eax, DWORD PTR tv71[ebp]
  00262	89 45 d0	 mov	 DWORD PTR tv143[ebp], eax
  00265	8b 4d d0	 mov	 ecx, DWORD PTR tv143[ebp]
  00268	c1 e9 03	 shr	 ecx, 3
  0026b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00271	88 55 b7	 mov	 BYTE PTR tv146[ebp], dl
  00274	80 7d b7 00	 cmp	 BYTE PTR tv146[ebp], 0
  00278	74 18		 je	 SHORT $LN3@max_size
  0027a	8a 45 d0	 mov	 al, BYTE PTR tv143[ebp]
  0027d	24 07		 and	 al, 7
  0027f	04 03		 add	 al, 3
  00281	3a 45 b7	 cmp	 al, BYTE PTR tv146[ebp]
  00284	7c 0c		 jl	 SHORT $LN3@max_size
  00286	8b 4d d0	 mov	 ecx, DWORD PTR tv143[ebp]
  00289	51		 push	 ecx
  0028a	e8 00 00 00 00	 call	 ___asan_report_load4
  0028f	83 c4 04	 add	 esp, 4
$LN3@max_size:
  00292	8b 55 d8	 mov	 edx, DWORD PTR tv71[ebp]
  00295	8b 02		 mov	 eax, DWORD PTR [edx]
  00297	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  0029a	c7 85 48 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  002a4	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  002aa	c1 e9 03	 shr	 ecx, 3
  002ad	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  002b3	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  002b6	6a 0d		 push	 13			; 0000000dH
  002b8	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  002bb	52		 push	 edx
  002bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002c1	83 c4 08	 add	 esp, 8
  002c4	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]

; 3948 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3949 :         );
; 3950 :     }

  002c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ca	33 cd		 xor	 ecx, ebp
  002cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	8b e3		 mov	 esp, ebx
  002d6	5b		 pop	 ebx
  002d7	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3263 :     _CONSTEXPR20_CONTAINER basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3265 :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__asan_gen_0$ = -112					; size = 4
__asan_gen_1$ = -108					; size = 4
__asan_gen_2$ = -104					; size = 4
$T2 = -96						; size = 1
tv172 = -56						; size = 1
tv162 = -55						; size = 1
tv152 = -54						; size = 1
$T3 = -53						; size = 1
tv130 = -52						; size = 4
_this$ = -48						; size = 4
tv169 = -44						; size = 4
tv159 = -40						; size = 4
tv149 = -36						; size = 4
tv66 = -32						; size = 4
tv74 = -28						; size = 4
__Old_ptr$4 = -24					; size = 4
tv128 = -20						; size = 4
tv139 = -16						; size = 4
tv88 = -12						; size = 4
tv145 = -8						; size = 4
tv89 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 90 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 94 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
  0002d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00034	8d 45 90	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 ec	 mov	 DWORD PTR tv128[ebp], eax
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR tv128[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d cc	 mov	 DWORD PTR tv130[ebp], ecx
  00049	8b 55 cc	 mov	 edx, DWORD PTR tv130[ebp]
  0004c	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00052	83 45 cc 04	 add	 DWORD PTR tv130[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d cc	 mov	 ecx, DWORD PTR tv130[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 cc 02	 add	 DWORD PTR tv130[ebp], 2
  00065	8b 55 cc	 mov	 edx, DWORD PTR tv130[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00070	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00075	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c0 18	 add	 eax, 24			; 00000018H
  0007b	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0007e	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  00081	89 4d d4	 mov	 DWORD PTR tv169[ebp], ecx
  00084	8b 55 d4	 mov	 edx, DWORD PTR tv169[ebp]
  00087	c1 ea 03	 shr	 edx, 3
  0008a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00090	88 45 c8	 mov	 BYTE PTR tv172[ebp], al
  00093	80 7d c8 00	 cmp	 BYTE PTR tv172[ebp], 0
  00097	74 1a		 je	 SHORT $LN6@assign
  00099	8a 4d d4	 mov	 cl, BYTE PTR tv169[ebp]
  0009c	80 e1 07	 and	 cl, 7
  0009f	80 c1 03	 add	 cl, 3
  000a2	3a 4d c8	 cmp	 cl, BYTE PTR tv172[ebp]
  000a5	7c 0c		 jl	 SHORT $LN6@assign
  000a7	8b 55 d4	 mov	 edx, DWORD PTR tv169[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ___asan_report_load4
  000b0	83 c4 04	 add	 esp, 4
$LN6@assign:
  000b3	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000b6	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  000b9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000bb	0f 87 f7 00 00
	00		 ja	 $LN2@assign
  000c1	8d 55 a0	 lea	 edx, DWORD PTR $T2[ebp]
  000c4	c1 ea 03	 shr	 edx, 3
  000c7	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  000ce	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000d6	89 45 e8	 mov	 DWORD PTR __Old_ptr$4[ebp], eax

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 14	 add	 eax, 20			; 00000014H
  000df	89 45 e4	 mov	 DWORD PTR tv74[ebp], eax
  000e2	8b 4d e4	 mov	 ecx, DWORD PTR tv74[ebp]
  000e5	89 4d d8	 mov	 DWORD PTR tv159[ebp], ecx
  000e8	8b 55 d8	 mov	 edx, DWORD PTR tv159[ebp]
  000eb	c1 ea 03	 shr	 edx, 3
  000ee	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f4	88 45 c9	 mov	 BYTE PTR tv162[ebp], al
  000f7	80 7d c9 00	 cmp	 BYTE PTR tv162[ebp], 0
  000fb	74 1a		 je	 SHORT $LN5@assign
  000fd	8a 4d d8	 mov	 cl, BYTE PTR tv159[ebp]
  00100	80 e1 07	 and	 cl, 7
  00103	80 c1 03	 add	 cl, 3
  00106	3a 4d c9	 cmp	 cl, BYTE PTR tv162[ebp]
  00109	7c 0c		 jl	 SHORT $LN5@assign
  0010b	8b 55 d8	 mov	 edx, DWORD PTR tv159[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 ___asan_report_store4
  00114	83 c4 04	 add	 esp, 4
$LN5@assign:
  00117	8b 45 e4	 mov	 eax, DWORD PTR tv74[ebp]
  0011a	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  0011d	89 08		 mov	 DWORD PTR [eax], ecx

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  0011f	8b 53 0c	 mov	 edx, DWORD PTR __Count$[ebx]
  00122	52		 push	 edx
  00123	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00126	50		 push	 eax
  00127	8b 4d e8	 mov	 ecx, DWORD PTR __Old_ptr$4[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00133	8d 55 a0	 lea	 edx, DWORD PTR $T2[ebp]
  00136	89 55 dc	 mov	 DWORD PTR tv149[ebp], edx
  00139	8b 45 dc	 mov	 eax, DWORD PTR tv149[ebp]
  0013c	c1 e8 03	 shr	 eax, 3
  0013f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00145	88 4d ca	 mov	 BYTE PTR tv152[ebp], cl
  00148	80 7d ca 00	 cmp	 BYTE PTR tv152[ebp], 0
  0014c	74 17		 je	 SHORT $LN4@assign
  0014e	8a 55 dc	 mov	 dl, BYTE PTR tv149[ebp]
  00151	80 e2 07	 and	 dl, 7
  00154	3a 55 ca	 cmp	 dl, BYTE PTR tv152[ebp]
  00157	7c 0c		 jl	 SHORT $LN4@assign
  00159	8b 45 dc	 mov	 eax, DWORD PTR tv149[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ___asan_report_store1
  00162	83 c4 04	 add	 esp, 4
$LN4@assign:
  00165	c6 45 a0 00	 mov	 BYTE PTR $T2[ebp], 0
  00169	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  0016c	51		 push	 ecx
  0016d	8b 55 e8	 mov	 edx, DWORD PTR __Old_ptr$4[ebp]
  00170	03 53 0c	 add	 edx, DWORD PTR __Count$[ebx]
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00179	83 c4 08	 add	 esp, 8
  0017c	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  0017f	c1 e8 03	 shr	 eax, 3
  00182	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 3251 :             return *this;

  00189	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	89 4d f4	 mov	 DWORD PTR tv88[ebp], ecx
  0018f	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00196	8d 55 90	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00199	c1 ea 03	 shr	 edx, 3
  0019c	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  001a2	89 55 f0	 mov	 DWORD PTR tv139[ebp], edx
  001a5	6a 07		 push	 7
  001a7	8b 45 f0	 mov	 eax, DWORD PTR tv139[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001b0	83 c4 08	 add	 esp, 8
  001b3	8b 45 f4	 mov	 eax, DWORD PTR tv88[ebp]
  001b6	eb 3f		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3252 :         }
; 3253 : 
; 3254 :         return _Reallocate_for(

  001b8	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  001bb	51		 push	 ecx
  001bc	0f b6 55 cb	 movzx	 edx, BYTE PTR $T3[ebp]
  001c0	52		 push	 edx
  001c1	8b 43 0c	 mov	 eax, DWORD PTR __Count$[ebx]
  001c4	50		 push	 eax
  001c5	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
  001cd	89 45 fc	 mov	 DWORD PTR tv89[ebp], eax
  001d0	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001d7	8d 4d 90	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  001da	c1 e9 03	 shr	 ecx, 3
  001dd	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  001e3	89 4d f8	 mov	 DWORD PTR tv145[ebp], ecx
  001e6	6a 07		 push	 7
  001e8	8b 55 f8	 mov	 edx, DWORD PTR tv145[ebp]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001f1	83 c4 08	 add	 esp, 8
  001f4	8b 45 fc	 mov	 eax, DWORD PTR tv89[ebp]
$LN1@assign:

; 3255 :             _Count,
; 3256 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3257 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	8b e3		 mov	 esp, ebx
  001fc	5b		 pop	 ebx
  001fd	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__asan_gen_0$ = -144					; size = 4
__asan_gen_1$ = -140					; size = 4
__asan_gen_2$ = -136					; size = 4
_$S36$ = -128						; size = 1
__Proxy$ = -112						; size = 8
$T3 = -65						; size = 1
tv132 = -64						; size = 4
_this$ = -60						; size = 4
tv66 = -56						; size = 4
tv69 = -52						; size = 4
__Alproxy$ = -48					; size = 4
tv135 = -44						; size = 4
tv77 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2517 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 70 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00056	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00060	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c8	 mov	 DWORD PTR tv66[ebp], eax
  00069	8b 4d c8	 mov	 ecx, DWORD PTR tv66[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d c0	 mov	 DWORD PTR tv132[ebp], ecx
  00078	8b 55 c0	 mov	 edx, DWORD PTR tv132[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 c0 04	 add	 DWORD PTR tv132[ebp], 4
  00085	8b 45 c0	 mov	 eax, DWORD PTR tv132[ebp]
  00088	c7 00 00 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116352 ; f3f3f300H
  0008e	83 45 c0 04	 add	 DWORD PTR tv132[ebp], 4
  00092	8b 4d c0	 mov	 ecx, DWORD PTR tv132[ebp]
  00095	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0009d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000a2	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	89 55 cc	 mov	 DWORD PTR tv69[ebp], edx
  000a8	0f b6 45 bf	 movzx	 eax, BYTE PTR $T3[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d cc	 mov	 ecx, DWORD PTR tv69[ebp]
  000b0	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  000b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2518 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000bc	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000c4	50		 push	 eax
  000c5	8d 4d 80	 lea	 ecx, DWORD PTR _$S36$[ebp]
  000c8	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  000cd	8d 4d 80	 lea	 ecx, DWORD PTR _$S36$[ebp]
  000d0	89 4d d0	 mov	 DWORD PTR __Alproxy$[ebp], ecx

; 2519 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000d3	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 d0	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  000da	50		 push	 eax
  000db	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000de	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000e3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 2520 :         _Tidy_init();

  000e7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2521 :         assign(_Ptr);

  000ef	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000f2	51		 push	 ecx
  000f3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2522 :         _Proxy._Release();

  000fb	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2523 :     }

  00103	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00107	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0010a	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0010f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00119	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
  0011c	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00126	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0012c	c1 e8 03	 shr	 eax, 3
  0012f	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00134	89 45 d4	 mov	 DWORD PTR tv135[ebp], eax
  00137	6a 09		 push	 9
  00139	8b 4d d4	 mov	 ecx, DWORD PTR tv135[ebp]
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00142	83 c4 08	 add	 esp, 8
  00145	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  00148	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00152	59		 pop	 ecx
  00153	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	8b e3		 mov	 esp, ebx
  00162	5b		 pop	 ebx
  00163	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1:
  00008	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2348 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Bxty
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Bxty
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Bxty:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv69 = -16						; size = 4
tv67 = -12						; size = 4
tv74 = -8						; size = 4
tv77 = -1						; size = 1
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2313 :     _CONSTEXPR20_CONTAINER bool _Large_string_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2314 : #ifdef __cpp_lib_constexpr_string
; 2315 :         if (_STD is_constant_evaluated()) {

  00013	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	74 04		 je	 SHORT $LN2@Large_stri

; 2316 :             return true;

  0001f	b0 01		 mov	 al, 1
  00021	eb 59		 jmp	 SHORT $LN3@Large_stri
$LN2@Large_stri:

; 2317 :         }
; 2318 : #endif // __cpp_lib_constexpr_string
; 2319 :         return _BUF_SIZE <= _Myres;

  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 18	 add	 ecx, 24			; 00000018H
  00029	89 4d f4	 mov	 DWORD PTR tv67[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv67[ebp]
  0002f	89 55 f8	 mov	 DWORD PTR tv74[ebp], edx
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
  00035	c1 e8 03	 shr	 eax, 3
  00038	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003e	88 4d ff	 mov	 BYTE PTR tv77[ebp], cl
  00041	80 7d ff 00	 cmp	 BYTE PTR tv77[ebp], 0
  00045	74 1a		 je	 SHORT $LN6@Large_stri
  00047	8a 55 f8	 mov	 dl, BYTE PTR tv74[ebp]
  0004a	80 e2 07	 and	 dl, 7
  0004d	80 c2 03	 add	 dl, 3
  00050	3a 55 ff	 cmp	 dl, BYTE PTR tv77[ebp]
  00053	7c 0c		 jl	 SHORT $LN6@Large_stri
  00055	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ___asan_report_load4
  0005e	83 c4 04	 add	 esp, 4
$LN6@Large_stri:
  00061	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  00064	83 39 10	 cmp	 DWORD PTR [ecx], 16	; 00000010H
  00067	72 09		 jb	 SHORT $LN4@Large_stri
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN5@Large_stri
$LN4@Large_stri:
  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN5@Large_stri:
  00079	8a 45 f0	 mov	 al, BYTE PTR tv69[ebp]
$LN3@Large_stri:

; 2320 :     }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
tv72 = -16						; size = 4
tv77 = -12						; size = 4
_this$ = -8						; size = 4
tv80 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2295 :     _CONSTEXPR20_CONTAINER value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2296 :         value_type* _Result = _Bx._Buf;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 2297 :         if (_Large_string_engaged()) {

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00024	0f b6 c8	 movzx	 ecx, al
  00027	85 c9		 test	 ecx, ecx
  00029	74 4d		 je	 SHORT $LN2@Myptr

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	83 c2 04	 add	 edx, 4
  00031	89 55 f0	 mov	 DWORD PTR tv72[ebp], edx
  00034	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  00037	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00046	88 55 ff	 mov	 BYTE PTR tv80[ebp], dl
  00049	80 7d ff 00	 cmp	 BYTE PTR tv80[ebp], 0
  0004d	74 18		 je	 SHORT $LN4@Myptr
  0004f	8a 45 f4	 mov	 al, BYTE PTR tv77[ebp]
  00052	24 07		 and	 al, 7
  00054	04 03		 add	 al, 3
  00056	3a 45 ff	 cmp	 al, BYTE PTR tv80[ebp]
  00059	7c 0c		 jl	 SHORT $LN4@Myptr
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ___asan_report_load4
  00064	83 c4 04	 add	 esp, 4
$LN4@Myptr:
  00067	8b 55 f0	 mov	 edx, DWORD PTR tv72[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2299 :         }
; 2300 : 
; 2301 :         return _Result;

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 2302 :     }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
tv74 = -20						; size = 4
tv80 = -16						; size = 4
tv90 = -12						; size = 4
_this$ = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2284 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2285 : 
; 2286 :     // length of internal buffer, [1, 16]:
; 2287 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2288 :     // roundup mask for allocated buffers, [0, 15]:
; 2289 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2290 :                                            : sizeof(value_type) <= 2 ? 7
; 2291 :                                            : sizeof(value_type) <= 4 ? 3
; 2292 :                                            : sizeof(value_type) <= 8 ? 1
; 2293 :                                                                      : 0;
; 2294 : 
; 2295 :     _CONSTEXPR20_CONTAINER value_type* _Myptr() noexcept {
; 2296 :         value_type* _Result = _Bx._Buf;
; 2297 :         if (_Large_string_engaged()) {
; 2298 :             _Result = _Unfancy(_Bx._Ptr);
; 2299 :         }
; 2300 : 
; 2301 :         return _Result;
; 2302 :     }
; 2303 : 
; 2304 :     _CONSTEXPR20_CONTAINER const value_type* _Myptr() const noexcept {
; 2305 :         const value_type* _Result = _Bx._Buf;
; 2306 :         if (_Large_string_engaged()) {
; 2307 :             _Result = _Unfancy(_Bx._Ptr);
; 2308 :         }
; 2309 : 
; 2310 :         return _Result;
; 2311 :     }
; 2312 : 
; 2313 :     _CONSTEXPR20_CONTAINER bool _Large_string_engaged() const noexcept {
; 2314 : #ifdef __cpp_lib_constexpr_string
; 2315 :         if (_STD is_constant_evaluated()) {
; 2316 :             return true;
; 2317 :         }
; 2318 : #endif // __cpp_lib_constexpr_string
; 2319 :         return _BUF_SIZE <= _Myres;
; 2320 :     }
; 2321 : 
; 2322 :     _CONSTEXPR20_CONTAINER void _Check_offset(const size_type _Off) const {
; 2323 :         // checks whether _Off is in the bounds of [0, size()]
; 2324 :         if (_Mysize < _Off) {
; 2325 :             _Xran();
; 2326 :         }
; 2327 :     }
; 2328 : 
; 2329 :     _CONSTEXPR20_CONTAINER void _Check_offset_exclusive(const size_type _Off) const {
; 2330 :         // checks whether _Off is in the bounds of [0, size())
; 2331 :         if (_Mysize <= _Off) {
; 2332 :             _Xran();
; 2333 :         }
; 2334 :     }
; 2335 : 
; 2336 :     [[noreturn]] static void _Xran() {
; 2337 :         _Xout_of_range("invalid string position");
; 2338 :     }
; 2339 : 
; 2340 :     _CONSTEXPR20_CONTAINER size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2341 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2342 :         return (_STD min)(_Size, _Mysize - _Off);
; 2343 :     }
; 2344 : 
; 2345 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers
; 2347 : 
; 2348 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2349 : 
; 2350 :         value_type _Buf[_BUF_SIZE];
; 2351 :         pointer _Ptr;
; 2352 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2353 :     } _Bx;
; 2354 : 
; 2355 :     size_type _Mysize = 0; // current length of string

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c0 14	 add	 eax, 20			; 00000014H
  0002c	89 45 ec	 mov	 DWORD PTR tv74[ebp], eax
  0002f	8b 4d ec	 mov	 ecx, DWORD PTR tv74[ebp]
  00032	89 4d f4	 mov	 DWORD PTR tv90[ebp], ecx
  00035	8b 55 f4	 mov	 edx, DWORD PTR tv90[ebp]
  00038	c1 ea 03	 shr	 edx, 3
  0003b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00041	88 45 ff	 mov	 BYTE PTR tv93[ebp], al
  00044	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00048	74 1a		 je	 SHORT $LN4@String_val
  0004a	8a 4d f4	 mov	 cl, BYTE PTR tv90[ebp]
  0004d	80 e1 07	 and	 cl, 7
  00050	80 c1 03	 add	 cl, 3
  00053	3a 4d ff	 cmp	 cl, BYTE PTR tv93[ebp]
  00056	7c 0c		 jl	 SHORT $LN4@String_val
  00058	8b 55 f4	 mov	 edx, DWORD PTR tv90[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ___asan_report_store4
  00061	83 c4 04	 add	 esp, 4
$LN4@String_val:
  00064	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  00067	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	83 c1 18	 add	 ecx, 24			; 00000018H
  00073	89 4d e8	 mov	 DWORD PTR tv75[ebp], ecx
  00076	8b 55 e8	 mov	 edx, DWORD PTR tv75[ebp]
  00079	89 55 f0	 mov	 DWORD PTR tv80[ebp], edx
  0007c	8b 45 f0	 mov	 eax, DWORD PTR tv80[ebp]
  0007f	c1 e8 03	 shr	 eax, 3
  00082	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00088	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  0008b	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008f	74 1a		 je	 SHORT $LN3@String_val
  00091	8a 55 f0	 mov	 dl, BYTE PTR tv80[ebp]
  00094	80 e2 07	 and	 dl, 7
  00097	80 c2 03	 add	 dl, 3
  0009a	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009d	7c 0c		 jl	 SHORT $LN3@String_val
  0009f	8b 45 f0	 mov	 eax, DWORD PTR tv80[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ___asan_report_store4
  000a8	83 c4 04	 add	 esp, 4
$LN3@String_val:
  000ab	8b 4d e8	 mov	 ecx, DWORD PTR tv75[ebp]
  000ae	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2284 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	83 c8 ff	 or	 eax, -1

; 729  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001e	83 c4 08	 add	 esp, 8

; 836  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2373 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2374 :     _Xlength_error("string too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2375 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 477  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 478  :         return static_cast<int_type>(EOF);

  0000d	83 c8 ff	 or	 eax, -1

; 479  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv71 = -24						; size = 4
tv68 = -20						; size = 4
tv65 = -16						; size = 4
tv74 = -12						; size = 4
tv84 = -8						; size = 4
tv77 = -2						; size = 1
tv87 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 469  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 470  :         return _Left == _Right;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv84[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv84[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@eq_int_typ
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv84[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@eq_int_typ
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv84[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@eq_int_typ:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv71[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv71[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv74[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv77[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv77[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@eq_int_typ
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv74[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv77[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@eq_int_typ
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@eq_int_typ:
  00086	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	75 09		 jne	 SHORT $LN3@eq_int_typ
  00092	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00099	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  0009b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  000a2	8a 45 f0	 mov	 al, BYTE PTR tv65[ebp]

; 471  :     }

  000a5	8b e5		 mov	 esp, ebp
  000a7	5d		 pop	 ebp
  000a8	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv65 = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 449  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 450  :         _Left = _Right;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00013	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  0002f	74 17		 je	 SHORT $LN4@assign
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  0003a	7c 0c		 jl	 SHORT $LN4@assign
  0003c	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ___asan_report_load1
  00045	83 c4 04	 add	 esp, 4
$LN4@assign:
  00048	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0004b	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  00051	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
  00054	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00057	c1 ea 03	 shr	 edx, 3
  0005a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00060	88 45 fe	 mov	 BYTE PTR tv74[ebp], al
  00063	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00067	74 17		 je	 SHORT $LN3@assign
  00069	8a 4d f4	 mov	 cl, BYTE PTR tv71[ebp]
  0006c	80 e1 07	 and	 cl, 7
  0006f	3a 4d fe	 cmp	 cl, BYTE PTR tv74[ebp]
  00072	7c 0c		 jl	 SHORT $LN3@assign
  00074	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ___asan_report_store1
  0007d	83 c4 04	 add	 esp, 4
$LN3@assign:
  00080	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00083	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00086	8a 11		 mov	 dl, BYTE PTR [ecx]
  00088	88 10		 mov	 BYTE PTR [eax], dl

; 451  :     }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 439  :         // assign _Count * _Ch to [_First, ...)
; 440  : #ifdef __cpp_lib_is_constant_evaluated
; 441  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 17		 je	 SHORT $LN2@assign

; 442  :             return _Primary_char_traits::assign(_First, _Count, _Ch);

  00019	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAPADQADID@Z ; std::_Char_traits<char,int>::assign
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	eb 15		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 443  :         }
; 444  : #endif // __cpp_lib_is_constant_evaluated
; 445  : 
; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	0f be 55 10	 movsx	 edx, BYTE PTR __Ch$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@assign:

; 447  :     }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
tv66 = -16						; size = 4
tv72 = -12						; size = 4
tv69 = -8						; size = 4
tv75 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 396  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 397  :         // find length of null-terminated string
; 398  : #if _HAS_CXX17
; 399  : #ifdef __cpp_char8_t
; 400  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 401  : #if _HAS_U8_INTRINSICS
; 402  :             return __builtin_u8strlen(_First);
; 403  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 404  :             return _Primary_char_traits::length(_First);
; 405  : #endif // _HAS_U8_INTRINSICS
; 406  :         } else
; 407  : #endif // __cpp_char8_t
; 408  :         {
; 409  :             return __builtin_strlen(_First);

  00010	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00019	83 c1 01	 add	 ecx, 1
  0001c	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
$LL3@length:
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00022	8a 02		 mov	 al, BYTE PTR [edx]
  00024	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00027	83 45 f8 01	 add	 DWORD PTR tv69[ebp], 1
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  0002f	75 ee		 jne	 SHORT $LL3@length
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00034	2b 4d f4	 sub	 ecx, DWORD PTR tv72[ebp]
  00037	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv66[ebp]

; 410  :         }
; 411  : #else // _HAS_CXX17
; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 413  : #endif // _HAS_CXX17
; 414  :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
tv76 = -20						; size = 4
tv79 = -16						; size = 4
__Next$1 = -12						; size = 4
__Next$2 = -8						; size = 4
tv82 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 167  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         // assign _Count * _Ch to [_First, ...)
; 169  : #ifdef __cpp_lib_constexpr_string
; 170  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 34		 je	 SHORT $LN8@assign

; 171  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	89 4d f4	 mov	 DWORD PTR __Next$1[ebp], ecx
  00022	eb 12		 jmp	 SHORT $LN4@assign
$LN2@assign:
  00024	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00027	83 ea 01	 sub	 edx, 1
  0002a	89 55 0c	 mov	 DWORD PTR __Count$[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Next$1[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f4	 mov	 DWORD PTR __Next$1[ebp], eax
$LN4@assign:
  00036	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003a	76 12		 jbe	 SHORT $LN3@assign

; 172  :                 _STD construct_at(_Next, _Ch);

  0003c	8d 4d 10	 lea	 ecx, DWORD PTR __Ch$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Next$1[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ??$construct_at@DABDX@std@@YAPADQADABD@Z ; std::construct_at<char,char const &,void>
  00049	83 c4 08	 add	 esp, 8

; 173  :             }

  0004c	eb d6		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 174  :         } else

  0004e	eb 62		 jmp	 SHORT $LN9@assign
$LN8@assign:

; 175  : #endif // __cpp_lib_constexpr_string
; 176  :         {
; 177  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  00050	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00053	89 45 f8	 mov	 DWORD PTR __Next$2[ebp], eax
  00056	eb 12		 jmp	 SHORT $LN7@assign
$LN5@assign:
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR __Next$2[ebp]
  00064	83 c2 01	 add	 edx, 1
  00067	89 55 f8	 mov	 DWORD PTR __Next$2[ebp], edx
$LN7@assign:
  0006a	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0006e	76 42		 jbe	 SHORT $LN9@assign

; 178  :                 *_Next = _Ch;

  00070	8b 45 f8	 mov	 eax, DWORD PTR __Next$2[ebp]
  00073	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  00076	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  00079	89 4d f0	 mov	 DWORD PTR tv79[ebp], ecx
  0007c	8b 55 f0	 mov	 edx, DWORD PTR tv79[ebp]
  0007f	c1 ea 03	 shr	 edx, 3
  00082	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00088	88 45 ff	 mov	 BYTE PTR tv82[ebp], al
  0008b	80 7d ff 00	 cmp	 BYTE PTR tv82[ebp], 0
  0008f	74 17		 je	 SHORT $LN11@assign
  00091	8a 4d f0	 mov	 cl, BYTE PTR tv79[ebp]
  00094	80 e1 07	 and	 cl, 7
  00097	3a 4d ff	 cmp	 cl, BYTE PTR tv82[ebp]
  0009a	7c 0c		 jl	 SHORT $LN11@assign
  0009c	8b 55 f0	 mov	 edx, DWORD PTR tv79[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 ___asan_report_store1
  000a5	83 c4 04	 add	 esp, 4
$LN11@assign:
  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Next$2[ebp]
  000ab	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  000ae	88 08		 mov	 BYTE PTR [eax], cl

; 179  :             }

  000b0	eb a6		 jmp	 SHORT $LN5@assign
$LN9@assign:

; 180  :         }
; 181  : 
; 182  :         return _First;

  000b2	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 183  :     }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
tv89 = -52						; size = 4
tv85 = -48						; size = 4
tv79 = -44						; size = 4
tv77 = -40						; size = 4
tv134 = -36						; size = 4
tv144 = -32						; size = 4
tv154 = -28						; size = 4
tv164 = -24						; size = 4
__Src$1 = -20						; size = 4
__Idx$2 = -16						; size = 4
__Idx$3 = -12						; size = 4
tv137 = -5						; size = 1
tv147 = -4						; size = 1
tv157 = -3						; size = 1
tv167 = -2						; size = 1
__Loop_forward$4 = -1					; size = 1
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 80   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 81   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 82   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 83   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 84   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 85   : #ifdef __cpp_lib_is_constant_evaluated
; 86   :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 ab 01 00
	00		 je	 $LN11@move

; 87   :             // dest: [_First1, _First1 + _Count)
; 88   :             // src: [_First2, _First2 + _Count)
; 89   :             // We need to handle overlapping ranges.
; 90   :             // If _First1 is in the src range, we need a backward loop.
; 91   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 92   : 
; 93   :             if (_First1 == _First2) {

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00023	3b 4d 0c	 cmp	 ecx, DWORD PTR __First2$[ebp]
  00026	75 08		 jne	 SHORT $LN12@move

; 94   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.

  00028	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0002b	e9 b2 01 00 00	 jmp	 $LN16@move
$LN12@move:

; 95   :             }
; 96   : 
; 97   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 98   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 99   :             bool _Loop_forward = true;

  00030	c6 45 ff 01	 mov	 BYTE PTR __Loop_forward$4[ebp], 1

; 100  : 
; 101  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

  00034	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00037	89 55 ec	 mov	 DWORD PTR __Src$1[ebp], edx
  0003a	eb 09		 jmp	 SHORT $LN4@move
$LN2@move:
  0003c	8b 45 ec	 mov	 eax, DWORD PTR __Src$1[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 ec	 mov	 DWORD PTR __Src$1[ebp], eax
$LN4@move:
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00048	03 4d 10	 add	 ecx, DWORD PTR __Count$[ebp]
  0004b	39 4d ec	 cmp	 DWORD PTR __Src$1[ebp], ecx
  0004e	74 10		 je	 SHORT $LN3@move

; 102  :                 if (_First1 == _Src) {

  00050	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00053	3b 55 ec	 cmp	 edx, DWORD PTR __Src$1[ebp]
  00056	75 06		 jne	 SHORT $LN13@move

; 103  :                     _Loop_forward = false;

  00058	c6 45 ff 00	 mov	 BYTE PTR __Loop_forward$4[ebp], 0

; 104  :                     break;

  0005c	eb 02		 jmp	 SHORT $LN3@move
$LN13@move:

; 105  :                 }
; 106  :             }

  0005e	eb dc		 jmp	 SHORT $LN2@move
$LN3@move:

; 107  : 
; 108  :             if (_Loop_forward) {

  00060	0f b6 45 ff	 movzx	 eax, BYTE PTR __Loop_forward$4[ebp]
  00064	85 c0		 test	 eax, eax
  00066	0f 84 a8 00 00
	00		 je	 $LN14@move

; 109  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  0006c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Idx$3[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@move
$LN5@move:
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __Idx$3[ebp]
  00078	83 c1 01	 add	 ecx, 1
  0007b	89 4d f4	 mov	 DWORD PTR __Idx$3[ebp], ecx
$LN7@move:
  0007e	8b 55 f4	 mov	 edx, DWORD PTR __Idx$3[ebp]
  00081	3b 55 10	 cmp	 edx, DWORD PTR __Count$[ebp]
  00084	0f 83 85 00 00
	00		 jae	 $LN6@move

; 110  :                     _First1[_Idx] = _First2[_Idx];

  0008a	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  0008d	03 45 f4	 add	 eax, DWORD PTR __Idx$3[ebp]
  00090	89 45 d4	 mov	 DWORD PTR tv79[ebp], eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00096	03 4d f4	 add	 ecx, DWORD PTR __Idx$3[ebp]
  00099	89 4d d8	 mov	 DWORD PTR tv77[ebp], ecx
  0009c	8b 55 d4	 mov	 edx, DWORD PTR tv79[ebp]
  0009f	89 55 e8	 mov	 DWORD PTR tv164[ebp], edx
  000a2	8b 45 e8	 mov	 eax, DWORD PTR tv164[ebp]
  000a5	c1 e8 03	 shr	 eax, 3
  000a8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000ae	88 4d fe	 mov	 BYTE PTR tv167[ebp], cl
  000b1	80 7d fe 00	 cmp	 BYTE PTR tv167[ebp], 0
  000b5	74 17		 je	 SHORT $LN20@move
  000b7	8a 55 e8	 mov	 dl, BYTE PTR tv164[ebp]
  000ba	80 e2 07	 and	 dl, 7
  000bd	3a 55 fe	 cmp	 dl, BYTE PTR tv167[ebp]
  000c0	7c 0c		 jl	 SHORT $LN20@move
  000c2	8b 45 e8	 mov	 eax, DWORD PTR tv164[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ___asan_report_load1
  000cb	83 c4 04	 add	 esp, 4
$LN20@move:
  000ce	8b 4d d8	 mov	 ecx, DWORD PTR tv77[ebp]
  000d1	89 4d e4	 mov	 DWORD PTR tv154[ebp], ecx
  000d4	8b 55 e4	 mov	 edx, DWORD PTR tv154[ebp]
  000d7	c1 ea 03	 shr	 edx, 3
  000da	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000e0	88 45 fd	 mov	 BYTE PTR tv157[ebp], al
  000e3	80 7d fd 00	 cmp	 BYTE PTR tv157[ebp], 0
  000e7	74 17		 je	 SHORT $LN19@move
  000e9	8a 4d e4	 mov	 cl, BYTE PTR tv154[ebp]
  000ec	80 e1 07	 and	 cl, 7
  000ef	3a 4d fd	 cmp	 cl, BYTE PTR tv157[ebp]
  000f2	7c 0c		 jl	 SHORT $LN19@move
  000f4	8b 55 e4	 mov	 edx, DWORD PTR tv154[ebp]
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 ___asan_report_store1
  000fd	83 c4 04	 add	 esp, 4
$LN19@move:
  00100	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  00103	8b 4d d4	 mov	 ecx, DWORD PTR tv79[ebp]
  00106	8a 11		 mov	 dl, BYTE PTR [ecx]
  00108	88 10		 mov	 BYTE PTR [eax], dl

; 111  :                 }

  0010a	e9 66 ff ff ff	 jmp	 $LN5@move
$LN6@move:

; 112  :             } else {

  0010f	e9 b2 00 00 00	 jmp	 $LN15@move
$LN14@move:

; 113  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  00114	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Idx$2[ebp], 0
  0011b	eb 09		 jmp	 SHORT $LN10@move
$LN8@move:
  0011d	8b 45 f0	 mov	 eax, DWORD PTR __Idx$2[ebp]
  00120	83 c0 01	 add	 eax, 1
  00123	89 45 f0	 mov	 DWORD PTR __Idx$2[ebp], eax
$LN10@move:
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Idx$2[ebp]
  00129	3b 4d 10	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0012c	0f 83 94 00 00
	00		 jae	 $LN15@move

; 114  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];

  00132	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00135	83 ea 01	 sub	 edx, 1
  00138	2b 55 f0	 sub	 edx, DWORD PTR __Idx$2[ebp]
  0013b	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  0013e	03 c2		 add	 eax, edx
  00140	89 45 cc	 mov	 DWORD PTR tv89[ebp], eax
  00143	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00146	83 e9 01	 sub	 ecx, 1
  00149	2b 4d f0	 sub	 ecx, DWORD PTR __Idx$2[ebp]
  0014c	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0014f	03 d1		 add	 edx, ecx
  00151	89 55 d0	 mov	 DWORD PTR tv85[ebp], edx
  00154	8b 45 cc	 mov	 eax, DWORD PTR tv89[ebp]
  00157	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
  0015a	8b 4d e0	 mov	 ecx, DWORD PTR tv144[ebp]
  0015d	c1 e9 03	 shr	 ecx, 3
  00160	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00166	88 55 fc	 mov	 BYTE PTR tv147[ebp], dl
  00169	80 7d fc 00	 cmp	 BYTE PTR tv147[ebp], 0
  0016d	74 16		 je	 SHORT $LN18@move
  0016f	8a 45 e0	 mov	 al, BYTE PTR tv144[ebp]
  00172	24 07		 and	 al, 7
  00174	3a 45 fc	 cmp	 al, BYTE PTR tv147[ebp]
  00177	7c 0c		 jl	 SHORT $LN18@move
  00179	8b 4d e0	 mov	 ecx, DWORD PTR tv144[ebp]
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 ___asan_report_load1
  00182	83 c4 04	 add	 esp, 4
$LN18@move:
  00185	8b 55 d0	 mov	 edx, DWORD PTR tv85[ebp]
  00188	89 55 dc	 mov	 DWORD PTR tv134[ebp], edx
  0018b	8b 45 dc	 mov	 eax, DWORD PTR tv134[ebp]
  0018e	c1 e8 03	 shr	 eax, 3
  00191	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00197	88 4d fb	 mov	 BYTE PTR tv137[ebp], cl
  0019a	80 7d fb 00	 cmp	 BYTE PTR tv137[ebp], 0
  0019e	74 17		 je	 SHORT $LN17@move
  001a0	8a 55 dc	 mov	 dl, BYTE PTR tv134[ebp]
  001a3	80 e2 07	 and	 dl, 7
  001a6	3a 55 fb	 cmp	 dl, BYTE PTR tv137[ebp]
  001a9	7c 0c		 jl	 SHORT $LN17@move
  001ab	8b 45 dc	 mov	 eax, DWORD PTR tv134[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ___asan_report_store1
  001b4	83 c4 04	 add	 esp, 4
$LN17@move:
  001b7	8b 4d d0	 mov	 ecx, DWORD PTR tv85[ebp]
  001ba	8b 55 cc	 mov	 edx, DWORD PTR tv89[ebp]
  001bd	8a 02		 mov	 al, BYTE PTR [edx]
  001bf	88 01		 mov	 BYTE PTR [ecx], al

; 115  :                 }

  001c1	e9 57 ff ff ff	 jmp	 $LN8@move
$LN15@move:

; 116  :             }
; 117  : 
; 118  :             return _First1;

  001c6	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  001c9	eb 17		 jmp	 SHORT $LN16@move
$LN11@move:

; 119  :         }
; 120  : #endif // __cpp_lib_is_constant_evaluated
; 121  : 
; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001cb	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  001ce	51		 push	 ecx
  001cf	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  001d2	52		 push	 edx
  001d3	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _memmove
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 124  : 
; 125  :         return _First1;

  001df	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
$LN16@move:

; 126  :     }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
tv72 = -24						; size = 4
tv70 = -20						; size = 4
tv81 = -16						; size = 4
tv91 = -12						; size = 4
__Idx$1 = -8						; size = 4
tv84 = -2						; size = 1
tv94 = -1						; size = 1
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 49   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 51   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 52   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 53   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 54   : #ifdef __cpp_lib_is_constant_evaluated
; 55   :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 a8 00 00
	00		 je	 $LN5@copy

; 56   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 57   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Idx$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@copy
$LN2@copy:
  00029	8b 4d f8	 mov	 ecx, DWORD PTR __Idx$1[ebp]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	89 4d f8	 mov	 DWORD PTR __Idx$1[ebp], ecx
$LN4@copy:
  00032	8b 55 f8	 mov	 edx, DWORD PTR __Idx$1[ebp]
  00035	3b 55 10	 cmp	 edx, DWORD PTR __Count$[ebp]
  00038	0f 83 85 00 00
	00		 jae	 $LN3@copy

; 58   :                 _First1[_Idx] = _First2[_Idx];

  0003e	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  00041	03 45 f8	 add	 eax, DWORD PTR __Idx$1[ebp]
  00044	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  0004a	03 4d f8	 add	 ecx, DWORD PTR __Idx$1[ebp]
  0004d	89 4d ec	 mov	 DWORD PTR tv70[ebp], ecx
  00050	8b 55 e8	 mov	 edx, DWORD PTR tv72[ebp]
  00053	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00056	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00059	c1 e8 03	 shr	 eax, 3
  0005c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00062	88 4d ff	 mov	 BYTE PTR tv94[ebp], cl
  00065	80 7d ff 00	 cmp	 BYTE PTR tv94[ebp], 0
  00069	74 17		 je	 SHORT $LN8@copy
  0006b	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0006e	80 e2 07	 and	 dl, 7
  00071	3a 55 ff	 cmp	 dl, BYTE PTR tv94[ebp]
  00074	7c 0c		 jl	 SHORT $LN8@copy
  00076	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ___asan_report_load1
  0007f	83 c4 04	 add	 esp, 4
$LN8@copy:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR tv70[ebp]
  00085	89 4d f0	 mov	 DWORD PTR tv81[ebp], ecx
  00088	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  0008b	c1 ea 03	 shr	 edx, 3
  0008e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00094	88 45 fe	 mov	 BYTE PTR tv84[ebp], al
  00097	80 7d fe 00	 cmp	 BYTE PTR tv84[ebp], 0
  0009b	74 17		 je	 SHORT $LN7@copy
  0009d	8a 4d f0	 mov	 cl, BYTE PTR tv81[ebp]
  000a0	80 e1 07	 and	 cl, 7
  000a3	3a 4d fe	 cmp	 cl, BYTE PTR tv84[ebp]
  000a6	7c 0c		 jl	 SHORT $LN7@copy
  000a8	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 ___asan_report_store1
  000b1	83 c4 04	 add	 esp, 4
$LN7@copy:
  000b4	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]
  000b7	8b 4d e8	 mov	 ecx, DWORD PTR tv72[ebp]
  000ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bc	88 10		 mov	 BYTE PTR [eax], dl

; 59   :             }

  000be	e9 66 ff ff ff	 jmp	 $LN2@copy
$LN3@copy:

; 60   : 
; 61   :             return _First1;

  000c3	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  000c6	eb 17		 jmp	 SHORT $LN6@copy
$LN5@copy:

; 62   :         }
; 63   : #endif // __cpp_lib_is_constant_evaluated
; 64   : 
; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c8	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 _memcpy
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 66   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 67   : 
; 68   :         return _First1;

  000dc	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
$LN6@copy:

; 69   :     }

  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv93 = -24						; size = 4
tv75 = -20						; size = 4
tv77 = -16						; size = 4
tv89 = -12						; size = 4
tv128 = -8						; size = 4
tv131 = -1						; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 30		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
  00047	83 c4 08	 add	 esp, 8

; 155  :     } else

  0004a	eb 7b		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0004c	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	6a 08		 push	 8
  00064	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00078	83 c4 04	 add	 esp, 4
  0007b	89 45 f4	 mov	 DWORD PTR tv89[ebp], eax
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR tv89[ebp]
  00081	89 4d f8	 mov	 DWORD PTR tv128[ebp], ecx
  00084	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00087	c1 ea 03	 shr	 edx, 3
  0008a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00090	88 45 ff	 mov	 BYTE PTR tv131[ebp], al
  00093	80 7d ff 00	 cmp	 BYTE PTR tv131[ebp], 0
  00097	74 1a		 je	 SHORT $LN5@Construct_
  00099	8a 4d f8	 mov	 cl, BYTE PTR tv128[ebp]
  0009c	80 e1 07	 and	 cl, 7
  0009f	80 c1 03	 add	 cl, 3
  000a2	3a 4d ff	 cmp	 cl, BYTE PTR tv131[ebp]
  000a5	7c 0c		 jl	 SHORT $LN5@Construct_
  000a7	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ___asan_report_load4
  000b0	83 c4 04	 add	 esp, 4
$LN5@Construct_:
  000b3	8b 45 f4	 mov	 eax, DWORD PTR tv89[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	89 4d e8	 mov	 DWORD PTR tv93[ebp], ecx
  000bb	8b 55 e8	 mov	 edx, DWORD PTR tv93[ebp]
  000be	52		 push	 edx
  000bf	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c2	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1316 :     _Container_proxy* _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Basic_cont
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Basic_cont
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Basic_cont:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1318 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1319 :         _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Release
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Release
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Release:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1320 :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ PROC	; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT
; _this$ = ecx

; 1229 :     void _Orphan_me_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1231 :         _Orphan_me_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1232 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ENDP	; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv141 = -96						; size = 4
tv136 = -92						; size = 4
__Temp$1 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv89 = -72						; size = 4
tv88 = -68						; size = 4
tv66 = -64						; size = 4
tv64 = -60						; size = 4
tv146 = -56						; size = 4
tv156 = -52						; size = 4
tv166 = -48						; size = 4
tv176 = -44						; size = 4
tv186 = -40						; size = 4
tv196 = -36						; size = 4
tv206 = -32						; size = 4
tv216 = -28						; size = 4
tv226 = -24						; size = 4
_this$ = -20						; size = 4
__Pnext$ = -16						; size = 4
tv149 = -9						; size = 1
tv159 = -8						; size = 1
tv169 = -7						; size = 1
tv179 = -6						; size = 1
tv189 = -5						; size = 1
tv199 = -4						; size = 1
tv209 = -3						; size = 1
tv219 = -2						; size = 1
tv229 = -1						; size = 1
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT
; _this$ = ecx

; 1212 :     _CONSTEXPR20_CONTAINER void _Orphan_me_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1213 :         if (!_Myproxy) { // already orphaned

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d e8	 mov	 DWORD PTR tv226[ebp], ecx
  0001f	8b 55 e8	 mov	 edx, DWORD PTR tv226[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv229[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv229[ebp], 0
  00032	74 1a		 je	 SHORT $LN23@Orphan_me_
  00034	8a 4d e8	 mov	 cl, BYTE PTR tv226[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv229[ebp]
  00040	7c 0c		 jl	 SHORT $LN23@Orphan_me_
  00042	8b 55 e8	 mov	 edx, DWORD PTR tv226[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN23@Orphan_me_:
  0004e	8b 45 c4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN10@Orphan_me_

; 1214 :             return;

  00056	e9 81 02 00 00	 jmp	 $LN13@Orphan_me_
$LN10@Orphan_me_:

; 1215 :         }
; 1216 : 
; 1217 :         // adopted, remove self from list
; 1218 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d c0	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 c0	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e4	 mov	 DWORD PTR tv216[ebp], edx
  00067	8b 45 e4	 mov	 eax, DWORD PTR tv216[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv219[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv219[ebp], 0
  0007a	74 1a		 je	 SHORT $LN22@Orphan_me_
  0007c	8a 55 e4	 mov	 dl, BYTE PTR tv216[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv219[ebp]
  00088	7c 0c		 jl	 SHORT $LN22@Orphan_me_
  0008a	8b 45 e4	 mov	 eax, DWORD PTR tv216[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN22@Orphan_me_:
  00096	8b 4d c0	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$[ebp], edx
$LN2@Orphan_me_:

; 1219 :         while (*_Pnext && *_Pnext != this) {

  000a1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000a7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000aa	89 4d e0	 mov	 DWORD PTR tv206[ebp], ecx
  000ad	8b 55 e0	 mov	 edx, DWORD PTR tv206[ebp]
  000b0	c1 ea 03	 shr	 edx, 3
  000b3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b9	88 45 fd	 mov	 BYTE PTR tv209[ebp], al
  000bc	80 7d fd 00	 cmp	 BYTE PTR tv209[ebp], 0
  000c0	74 1a		 je	 SHORT $LN21@Orphan_me_
  000c2	8a 4d e0	 mov	 cl, BYTE PTR tv206[ebp]
  000c5	80 e1 07	 and	 cl, 7
  000c8	80 c1 03	 add	 cl, 3
  000cb	3a 4d fd	 cmp	 cl, BYTE PTR tv209[ebp]
  000ce	7c 0c		 jl	 SHORT $LN21@Orphan_me_
  000d0	8b 55 e0	 mov	 edx, DWORD PTR tv206[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ___asan_report_load4
  000d9	83 c4 04	 add	 esp, 4
$LN21@Orphan_me_:
  000dc	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000df	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e2	0f 84 96 00 00
	00		 je	 $LN6@Orphan_me_
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000eb	89 4d b0	 mov	 DWORD PTR tv130[ebp], ecx
  000ee	8b 55 b0	 mov	 edx, DWORD PTR tv130[ebp]
  000f1	89 55 dc	 mov	 DWORD PTR tv196[ebp], edx
  000f4	8b 45 dc	 mov	 eax, DWORD PTR tv196[ebp]
  000f7	c1 e8 03	 shr	 eax, 3
  000fa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00100	88 4d fc	 mov	 BYTE PTR tv199[ebp], cl
  00103	80 7d fc 00	 cmp	 BYTE PTR tv199[ebp], 0
  00107	74 1a		 je	 SHORT $LN20@Orphan_me_
  00109	8a 55 dc	 mov	 dl, BYTE PTR tv196[ebp]
  0010c	80 e2 07	 and	 dl, 7
  0010f	80 c2 03	 add	 dl, 3
  00112	3a 55 fc	 cmp	 dl, BYTE PTR tv199[ebp]
  00115	7c 0c		 jl	 SHORT $LN20@Orphan_me_
  00117	8b 45 dc	 mov	 eax, DWORD PTR tv196[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ___asan_report_load4
  00120	83 c4 04	 add	 esp, 4
$LN20@Orphan_me_:
  00123	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00126	8b 11		 mov	 edx, DWORD PTR [ecx]
  00128	3b 55 ec	 cmp	 edx, DWORD PTR _this$[ebp]
  0012b	74 51		 je	 SHORT $LN6@Orphan_me_

; 1220 :             const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  0012d	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00130	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  00133	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00136	89 4d d8	 mov	 DWORD PTR tv186[ebp], ecx
  00139	8b 55 d8	 mov	 edx, DWORD PTR tv186[ebp]
  0013c	c1 ea 03	 shr	 edx, 3
  0013f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00145	88 45 fb	 mov	 BYTE PTR tv189[ebp], al
  00148	80 7d fb 00	 cmp	 BYTE PTR tv189[ebp], 0
  0014c	74 1a		 je	 SHORT $LN19@Orphan_me_
  0014e	8a 4d d8	 mov	 cl, BYTE PTR tv186[ebp]
  00151	80 e1 07	 and	 cl, 7
  00154	80 c1 03	 add	 cl, 3
  00157	3a 4d fb	 cmp	 cl, BYTE PTR tv189[ebp]
  0015a	7c 0c		 jl	 SHORT $LN19@Orphan_me_
  0015c	8b 55 d8	 mov	 edx, DWORD PTR tv186[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 ___asan_report_load4
  00165	83 c4 04	 add	 esp, 4
$LN19@Orphan_me_:
  00168	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	89 4d a8	 mov	 DWORD PTR __Temp$1[ebp], ecx

; 1221 :             _Pnext           = &_Temp->_Mynextiter;

  00170	8b 55 a8	 mov	 edx, DWORD PTR __Temp$1[ebp]
  00173	83 c2 04	 add	 edx, 4
  00176	89 55 f0	 mov	 DWORD PTR __Pnext$[ebp], edx

; 1222 :         }

  00179	e9 23 ff ff ff	 jmp	 $LN2@Orphan_me_
$LN6@Orphan_me_:

; 1223 : 
; 1224 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

  0017e	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00181	89 45 a4	 mov	 DWORD PTR tv136[ebp], eax
  00184	8b 4d a4	 mov	 ecx, DWORD PTR tv136[ebp]
  00187	89 4d d4	 mov	 DWORD PTR tv176[ebp], ecx
  0018a	8b 55 d4	 mov	 edx, DWORD PTR tv176[ebp]
  0018d	c1 ea 03	 shr	 edx, 3
  00190	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00196	88 45 fa	 mov	 BYTE PTR tv179[ebp], al
  00199	80 7d fa 00	 cmp	 BYTE PTR tv179[ebp], 0
  0019d	74 1a		 je	 SHORT $LN18@Orphan_me_
  0019f	8a 4d d4	 mov	 cl, BYTE PTR tv176[ebp]
  001a2	80 e1 07	 and	 cl, 7
  001a5	80 c1 03	 add	 cl, 3
  001a8	3a 4d fa	 cmp	 cl, BYTE PTR tv179[ebp]
  001ab	7c 0c		 jl	 SHORT $LN18@Orphan_me_
  001ad	8b 55 d4	 mov	 edx, DWORD PTR tv176[ebp]
  001b0	52		 push	 edx
  001b1	e8 00 00 00 00	 call	 ___asan_report_load4
  001b6	83 c4 04	 add	 esp, 4
$LN18@Orphan_me_:
  001b9	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  001bc	83 38 00	 cmp	 DWORD PTR [eax], 0
  001bf	74 02		 je	 SHORT $LN9@Orphan_me_
  001c1	eb 4a		 jmp	 SHORT $LN4@Orphan_me_
$LN9@Orphan_me_:
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  001cd	6a 00		 push	 0
  001cf	68 c8 04 00 00	 push	 1224			; 000004c8H
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  001d9	6a 02		 push	 2
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  001e1	83 c4 18	 add	 esp, 24			; 00000018H
  001e4	83 f8 01	 cmp	 eax, 1
  001e7	75 01		 jne	 SHORT $LN14@Orphan_me_
  001e9	cc		 int	 3
$LN14@Orphan_me_:
  001ea	6a 00		 push	 0
  001ec	68 c8 04 00 00	 push	 1224			; 000004c8H
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00206	83 c4 14	 add	 esp, 20			; 00000014H
  00209	33 d2		 xor	 edx, edx
  0020b	75 b6		 jne	 SHORT $LN9@Orphan_me_
$LN4@Orphan_me_:
  0020d	33 c0		 xor	 eax, eax
  0020f	0f 85 69 ff ff
	ff		 jne	 $LN6@Orphan_me_

; 1225 :         *_Pnext  = _Mynextiter;

  00215	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00218	83 c1 04	 add	 ecx, 4
  0021b	89 4d bc	 mov	 DWORD PTR tv88[ebp], ecx
  0021e	8b 55 bc	 mov	 edx, DWORD PTR tv88[ebp]
  00221	89 55 d0	 mov	 DWORD PTR tv166[ebp], edx
  00224	8b 45 d0	 mov	 eax, DWORD PTR tv166[ebp]
  00227	c1 e8 03	 shr	 eax, 3
  0022a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00230	88 4d f9	 mov	 BYTE PTR tv169[ebp], cl
  00233	80 7d f9 00	 cmp	 BYTE PTR tv169[ebp], 0
  00237	74 1a		 je	 SHORT $LN17@Orphan_me_
  00239	8a 55 d0	 mov	 dl, BYTE PTR tv166[ebp]
  0023c	80 e2 07	 and	 dl, 7
  0023f	80 c2 03	 add	 dl, 3
  00242	3a 55 f9	 cmp	 dl, BYTE PTR tv169[ebp]
  00245	7c 0c		 jl	 SHORT $LN17@Orphan_me_
  00247	8b 45 d0	 mov	 eax, DWORD PTR tv166[ebp]
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 ___asan_report_load4
  00250	83 c4 04	 add	 esp, 4
$LN17@Orphan_me_:
  00253	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00256	89 4d a0	 mov	 DWORD PTR tv141[ebp], ecx
  00259	8b 55 a0	 mov	 edx, DWORD PTR tv141[ebp]
  0025c	89 55 cc	 mov	 DWORD PTR tv156[ebp], edx
  0025f	8b 45 cc	 mov	 eax, DWORD PTR tv156[ebp]
  00262	c1 e8 03	 shr	 eax, 3
  00265	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0026b	88 4d f8	 mov	 BYTE PTR tv159[ebp], cl
  0026e	80 7d f8 00	 cmp	 BYTE PTR tv159[ebp], 0
  00272	74 1a		 je	 SHORT $LN16@Orphan_me_
  00274	8a 55 cc	 mov	 dl, BYTE PTR tv156[ebp]
  00277	80 e2 07	 and	 dl, 7
  0027a	80 c2 03	 add	 dl, 3
  0027d	3a 55 f8	 cmp	 dl, BYTE PTR tv159[ebp]
  00280	7c 0c		 jl	 SHORT $LN16@Orphan_me_
  00282	8b 45 cc	 mov	 eax, DWORD PTR tv156[ebp]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ___asan_report_store4
  0028b	83 c4 04	 add	 esp, 4
$LN16@Orphan_me_:
  0028e	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00291	8b 55 bc	 mov	 edx, DWORD PTR tv88[ebp]
  00294	8b 02		 mov	 eax, DWORD PTR [edx]
  00296	89 01		 mov	 DWORD PTR [ecx], eax

; 1226 :         _Myproxy = nullptr;

  00298	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0029b	89 4d b8	 mov	 DWORD PTR tv89[ebp], ecx
  0029e	8b 55 b8	 mov	 edx, DWORD PTR tv89[ebp]
  002a1	89 55 c8	 mov	 DWORD PTR tv146[ebp], edx
  002a4	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  002a7	c1 e8 03	 shr	 eax, 3
  002aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002b0	88 4d f7	 mov	 BYTE PTR tv149[ebp], cl
  002b3	80 7d f7 00	 cmp	 BYTE PTR tv149[ebp], 0
  002b7	74 1a		 je	 SHORT $LN15@Orphan_me_
  002b9	8a 55 c8	 mov	 dl, BYTE PTR tv146[ebp]
  002bc	80 e2 07	 and	 dl, 7
  002bf	80 c2 03	 add	 dl, 3
  002c2	3a 55 f7	 cmp	 dl, BYTE PTR tv149[ebp]
  002c5	7c 0c		 jl	 SHORT $LN15@Orphan_me_
  002c7	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ___asan_report_store4
  002d0	83 c4 04	 add	 esp, 4
$LN15@Orphan_me_:
  002d3	8b 4d b8	 mov	 ecx, DWORD PTR tv89[ebp]
  002d6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN13@Orphan_me_:

; 1227 :     }

  002dc	8b e5		 mov	 esp, ebp
  002de	5d		 pop	 ebp
  002df	c3		 ret	 0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv72 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv75 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Parent$ = 8						; size = 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT
; _this$ = ecx

; 1207 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv72[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv72[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1208 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1209 :         _Adopt_unlocked(_Parent);

  00087	8b 43 08	 mov	 eax, DWORD PTR __Parent$[ebx]
  0008a	50		 push	 eax
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1210 :     }

  00093	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0009c	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000a3	8d 4d b0	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000a6	c1 e9 03	 shr	 ecx, 3
  000a9	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  000af	89 4d f8	 mov	 DWORD PTR tv75[ebp], ecx
  000b2	6a 07		 push	 7
  000b4	8b 55 f8	 mov	 edx, DWORD PTR tv75[ebp]
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000bd	83 c4 08	 add	 esp, 8
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	8b e3		 mov	 esp, ebx
  000cf	5b		 pop	 ebx
  000d0	c2 04 00	 ret	 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
tv74 = -68						; size = 4
tv73 = -64						; size = 4
tv72 = -60						; size = 4
tv69 = -56						; size = 4
tv67 = -52						; size = 4
tv66 = -48						; size = 4
tv91 = -44						; size = 4
tv133 = -40						; size = 4
tv143 = -36						; size = 4
tv153 = -32						; size = 4
tv163 = -28						; size = 4
tv173 = -24						; size = 4
tv183 = -20						; size = 4
__Parent_proxy$ = -16					; size = 4
_this$ = -12						; size = 4
tv94 = -7						; size = 1
tv136 = -6						; size = 1
tv146 = -5						; size = 1
tv156 = -4						; size = 1
tv166 = -3						; size = 1
tv176 = -2						; size = 1
tv186 = -1						; size = 1
__Parent$ = 8						; size = 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT
; _this$ = ecx

; 1190 :     _CONSTEXPR20_CONTAINER void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1191 :         if (!_Parent) {

  00013	83 7d 08 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  00017	75 0d		 jne	 SHORT $LN2@Adopt_unlo

; 1192 :             _Orphan_me_unlocked_v3();

  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1193 :             return;

  00021	e9 e0 01 00 00	 jmp	 $LN5@Adopt_unlo
$LN2@Adopt_unlo:

; 1194 :         }
; 1195 : 
; 1196 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00029	89 45 d0	 mov	 DWORD PTR tv66[ebp], eax
  0002c	8b 4d d0	 mov	 ecx, DWORD PTR tv66[ebp]
  0002f	89 4d ec	 mov	 DWORD PTR tv183[ebp], ecx
  00032	8b 55 ec	 mov	 edx, DWORD PTR tv183[ebp]
  00035	c1 ea 03	 shr	 edx, 3
  00038	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0003e	88 45 ff	 mov	 BYTE PTR tv186[ebp], al
  00041	80 7d ff 00	 cmp	 BYTE PTR tv186[ebp], 0
  00045	74 1a		 je	 SHORT $LN12@Adopt_unlo
  00047	8a 4d ec	 mov	 cl, BYTE PTR tv183[ebp]
  0004a	80 e1 07	 and	 cl, 7
  0004d	80 c1 03	 add	 cl, 3
  00050	3a 4d ff	 cmp	 cl, BYTE PTR tv186[ebp]
  00053	7c 0c		 jl	 SHORT $LN12@Adopt_unlo
  00055	8b 55 ec	 mov	 edx, DWORD PTR tv183[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ___asan_report_load4
  0005e	83 c4 04	 add	 esp, 4
$LN12@Adopt_unlo:
  00061	8b 45 d0	 mov	 eax, DWORD PTR tv66[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	89 4d f0	 mov	 DWORD PTR __Parent_proxy$[ebp], ecx

; 1197 :         if (_Myproxy != _Parent_proxy) { // change parentage

  00069	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 55 cc	 mov	 DWORD PTR tv67[ebp], edx
  0006f	8b 45 cc	 mov	 eax, DWORD PTR tv67[ebp]
  00072	89 45 e8	 mov	 DWORD PTR tv173[ebp], eax
  00075	8b 4d e8	 mov	 ecx, DWORD PTR tv173[ebp]
  00078	c1 e9 03	 shr	 ecx, 3
  0007b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00081	88 55 fe	 mov	 BYTE PTR tv176[ebp], dl
  00084	80 7d fe 00	 cmp	 BYTE PTR tv176[ebp], 0
  00088	74 18		 je	 SHORT $LN11@Adopt_unlo
  0008a	8a 45 e8	 mov	 al, BYTE PTR tv173[ebp]
  0008d	24 07		 and	 al, 7
  0008f	04 03		 add	 al, 3
  00091	3a 45 fe	 cmp	 al, BYTE PTR tv176[ebp]
  00094	7c 0c		 jl	 SHORT $LN11@Adopt_unlo
  00096	8b 4d e8	 mov	 ecx, DWORD PTR tv173[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ___asan_report_load4
  0009f	83 c4 04	 add	 esp, 4
$LN11@Adopt_unlo:
  000a2	8b 55 cc	 mov	 edx, DWORD PTR tv67[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	3b 45 f0	 cmp	 eax, DWORD PTR __Parent_proxy$[ebp]
  000aa	0f 84 56 01 00
	00		 je	 $LN5@Adopt_unlo

; 1198 :             if (_Myproxy) { // adopted, remove self from list

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	89 4d c8	 mov	 DWORD PTR tv69[ebp], ecx
  000b6	8b 55 c8	 mov	 edx, DWORD PTR tv69[ebp]
  000b9	89 55 e4	 mov	 DWORD PTR tv163[ebp], edx
  000bc	8b 45 e4	 mov	 eax, DWORD PTR tv163[ebp]
  000bf	c1 e8 03	 shr	 eax, 3
  000c2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000c8	88 4d fd	 mov	 BYTE PTR tv166[ebp], cl
  000cb	80 7d fd 00	 cmp	 BYTE PTR tv166[ebp], 0
  000cf	74 1a		 je	 SHORT $LN10@Adopt_unlo
  000d1	8a 55 e4	 mov	 dl, BYTE PTR tv163[ebp]
  000d4	80 e2 07	 and	 dl, 7
  000d7	80 c2 03	 add	 dl, 3
  000da	3a 55 fd	 cmp	 dl, BYTE PTR tv166[ebp]
  000dd	7c 0c		 jl	 SHORT $LN10@Adopt_unlo
  000df	8b 45 e4	 mov	 eax, DWORD PTR tv163[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ___asan_report_load4
  000e8	83 c4 04	 add	 esp, 4
$LN10@Adopt_unlo:
  000eb	8b 4d c8	 mov	 ecx, DWORD PTR tv69[ebp]
  000ee	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000f1	74 08		 je	 SHORT $LN4@Adopt_unlo

; 1199 :                 _Orphan_me_unlocked_v3();

  000f3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN4@Adopt_unlo:

; 1200 :             }
; 1201 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

  000fb	8b 55 f0	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  000fe	83 c2 04	 add	 edx, 4
  00101	89 55 c0	 mov	 DWORD PTR tv73[ebp], edx
  00104	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00107	83 c0 04	 add	 eax, 4
  0010a	89 45 c4	 mov	 DWORD PTR tv72[ebp], eax
  0010d	8b 4d c0	 mov	 ecx, DWORD PTR tv73[ebp]
  00110	89 4d e0	 mov	 DWORD PTR tv153[ebp], ecx
  00113	8b 55 e0	 mov	 edx, DWORD PTR tv153[ebp]
  00116	c1 ea 03	 shr	 edx, 3
  00119	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0011f	88 45 fc	 mov	 BYTE PTR tv156[ebp], al
  00122	80 7d fc 00	 cmp	 BYTE PTR tv156[ebp], 0
  00126	74 1a		 je	 SHORT $LN9@Adopt_unlo
  00128	8a 4d e0	 mov	 cl, BYTE PTR tv153[ebp]
  0012b	80 e1 07	 and	 cl, 7
  0012e	80 c1 03	 add	 cl, 3
  00131	3a 4d fc	 cmp	 cl, BYTE PTR tv156[ebp]
  00134	7c 0c		 jl	 SHORT $LN9@Adopt_unlo
  00136	8b 55 e0	 mov	 edx, DWORD PTR tv153[ebp]
  00139	52		 push	 edx
  0013a	e8 00 00 00 00	 call	 ___asan_report_load4
  0013f	83 c4 04	 add	 esp, 4
$LN9@Adopt_unlo:
  00142	8b 45 c4	 mov	 eax, DWORD PTR tv72[ebp]
  00145	89 45 dc	 mov	 DWORD PTR tv143[ebp], eax
  00148	8b 4d dc	 mov	 ecx, DWORD PTR tv143[ebp]
  0014b	c1 e9 03	 shr	 ecx, 3
  0014e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00154	88 55 fb	 mov	 BYTE PTR tv146[ebp], dl
  00157	80 7d fb 00	 cmp	 BYTE PTR tv146[ebp], 0
  0015b	74 18		 je	 SHORT $LN8@Adopt_unlo
  0015d	8a 45 dc	 mov	 al, BYTE PTR tv143[ebp]
  00160	24 07		 and	 al, 7
  00162	04 03		 add	 al, 3
  00164	3a 45 fb	 cmp	 al, BYTE PTR tv146[ebp]
  00167	7c 0c		 jl	 SHORT $LN8@Adopt_unlo
  00169	8b 4d dc	 mov	 ecx, DWORD PTR tv143[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ___asan_report_store4
  00172	83 c4 04	 add	 esp, 4
$LN8@Adopt_unlo:
  00175	8b 55 c4	 mov	 edx, DWORD PTR tv72[ebp]
  00178	8b 45 c0	 mov	 eax, DWORD PTR tv73[ebp]
  0017b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017d	89 0a		 mov	 DWORD PTR [edx], ecx

; 1202 :             _Parent_proxy->_Myfirstiter = this;

  0017f	8b 55 f0	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  00182	83 c2 04	 add	 edx, 4
  00185	89 55 bc	 mov	 DWORD PTR tv74[ebp], edx
  00188	8b 45 bc	 mov	 eax, DWORD PTR tv74[ebp]
  0018b	89 45 d8	 mov	 DWORD PTR tv133[ebp], eax
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR tv133[ebp]
  00191	c1 e9 03	 shr	 ecx, 3
  00194	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0019a	88 55 fa	 mov	 BYTE PTR tv136[ebp], dl
  0019d	80 7d fa 00	 cmp	 BYTE PTR tv136[ebp], 0
  001a1	74 18		 je	 SHORT $LN7@Adopt_unlo
  001a3	8a 45 d8	 mov	 al, BYTE PTR tv133[ebp]
  001a6	24 07		 and	 al, 7
  001a8	04 03		 add	 al, 3
  001aa	3a 45 fa	 cmp	 al, BYTE PTR tv136[ebp]
  001ad	7c 0c		 jl	 SHORT $LN7@Adopt_unlo
  001af	8b 4d d8	 mov	 ecx, DWORD PTR tv133[ebp]
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 ___asan_report_store4
  001b8	83 c4 04	 add	 esp, 4
$LN7@Adopt_unlo:
  001bb	8b 55 bc	 mov	 edx, DWORD PTR tv74[ebp]
  001be	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001c1	89 02		 mov	 DWORD PTR [edx], eax

; 1203 :             _Myproxy                    = _Parent_proxy;

  001c3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001c6	89 4d b8	 mov	 DWORD PTR tv75[ebp], ecx
  001c9	8b 55 b8	 mov	 edx, DWORD PTR tv75[ebp]
  001cc	89 55 d4	 mov	 DWORD PTR tv91[ebp], edx
  001cf	8b 45 d4	 mov	 eax, DWORD PTR tv91[ebp]
  001d2	c1 e8 03	 shr	 eax, 3
  001d5	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001db	88 4d f9	 mov	 BYTE PTR tv94[ebp], cl
  001de	80 7d f9 00	 cmp	 BYTE PTR tv94[ebp], 0
  001e2	74 1a		 je	 SHORT $LN6@Adopt_unlo
  001e4	8a 55 d4	 mov	 dl, BYTE PTR tv91[ebp]
  001e7	80 e2 07	 and	 dl, 7
  001ea	80 c2 03	 add	 dl, 3
  001ed	3a 55 f9	 cmp	 dl, BYTE PTR tv94[ebp]
  001f0	7c 0c		 jl	 SHORT $LN6@Adopt_unlo
  001f2	8b 45 d4	 mov	 eax, DWORD PTR tv91[ebp]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 ___asan_report_store4
  001fb	83 c4 04	 add	 esp, 4
$LN6@Adopt_unlo:
  001fe	8b 4d b8	 mov	 ecx, DWORD PTR tv75[ebp]
  00201	8b 55 f0	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  00204	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@Adopt_unlo:

; 1204 :         }
; 1205 :     }

  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 04 00	 ret	 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv72 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv75 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Right$ = 8						; size = 4
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z PROC	; std::_Iterator_base12::_Assign_locked, COMDAT
; _this$ = ecx

; 1185 :     void _Assign_locked(const _Iterator_base12& _Right) noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv72[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv72[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1186 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1187 :         _Assign_unlocked(_Right);

  00087	8b 43 08	 mov	 eax, DWORD PTR __Right$[ebx]
  0008a	50		 push	 eax
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1188 :     }

  00093	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0009c	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000a3	8d 4d b0	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000a6	c1 e9 03	 shr	 ecx, 3
  000a9	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  000af	89 4d f8	 mov	 DWORD PTR tv75[ebp], ecx
  000b2	6a 07		 push	 7
  000b4	8b 55 f8	 mov	 edx, DWORD PTR tv75[ebp]
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000bd	83 c4 08	 add	 esp, 8
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	8b e3		 mov	 esp, ebx
  000cf	5b		 pop	 ebx
  000d0	c2 04 00	 ret	 4
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ENDP	; std::_Iterator_base12::_Assign_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
tv71 = -52						; size = 4
tv70 = -48						; size = 4
tv67 = -44						; size = 4
tv65 = -40						; size = 4
tv64 = -36						; size = 4
_this$ = -32						; size = 4
tv85 = -28						; size = 4
tv95 = -24						; size = 4
tv137 = -20						; size = 4
tv147 = -16						; size = 4
tv157 = -12						; size = 4
tv88 = -5						; size = 1
tv130 = -4						; size = 1
tv140 = -3						; size = 1
tv150 = -2						; size = 1
tv160 = -1						; size = 1
__Right$ = 8						; size = 4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z PROC ; std::_Iterator_base12::_Assign_unlocked, COMDAT
; _this$ = ecx

; 1173 :     _CONSTEXPR20_CONTAINER void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1174 :         if (_Myproxy == _Right._Myproxy) {

  00013	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 dc	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001c	89 4d d8	 mov	 DWORD PTR tv65[ebp], ecx
  0001f	8b 55 dc	 mov	 edx, DWORD PTR tv64[ebp]
  00022	89 55 f4	 mov	 DWORD PTR tv157[ebp], edx
  00025	8b 45 f4	 mov	 eax, DWORD PTR tv157[ebp]
  00028	c1 e8 03	 shr	 eax, 3
  0002b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00031	88 4d ff	 mov	 BYTE PTR tv160[ebp], cl
  00034	80 7d ff 00	 cmp	 BYTE PTR tv160[ebp], 0
  00038	74 1a		 je	 SHORT $LN10@Assign_unl
  0003a	8a 55 f4	 mov	 dl, BYTE PTR tv157[ebp]
  0003d	80 e2 07	 and	 dl, 7
  00040	80 c2 03	 add	 dl, 3
  00043	3a 55 ff	 cmp	 dl, BYTE PTR tv160[ebp]
  00046	7c 0c		 jl	 SHORT $LN10@Assign_unl
  00048	8b 45 f4	 mov	 eax, DWORD PTR tv157[ebp]
  0004b	50		 push	 eax
  0004c	e8 00 00 00 00	 call	 ___asan_report_load4
  00051	83 c4 04	 add	 esp, 4
$LN10@Assign_unl:
  00054	8b 4d d8	 mov	 ecx, DWORD PTR tv65[ebp]
  00057	89 4d f0	 mov	 DWORD PTR tv147[ebp], ecx
  0005a	8b 55 f0	 mov	 edx, DWORD PTR tv147[ebp]
  0005d	c1 ea 03	 shr	 edx, 3
  00060	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00066	88 45 fe	 mov	 BYTE PTR tv150[ebp], al
  00069	80 7d fe 00	 cmp	 BYTE PTR tv150[ebp], 0
  0006d	74 1a		 je	 SHORT $LN9@Assign_unl
  0006f	8a 4d f0	 mov	 cl, BYTE PTR tv147[ebp]
  00072	80 e1 07	 and	 cl, 7
  00075	80 c1 03	 add	 cl, 3
  00078	3a 4d fe	 cmp	 cl, BYTE PTR tv150[ebp]
  0007b	7c 0c		 jl	 SHORT $LN9@Assign_unl
  0007d	8b 55 f0	 mov	 edx, DWORD PTR tv147[ebp]
  00080	52		 push	 edx
  00081	e8 00 00 00 00	 call	 ___asan_report_load4
  00086	83 c4 04	 add	 esp, 4
$LN9@Assign_unl:
  00089	8b 45 dc	 mov	 eax, DWORD PTR tv64[ebp]
  0008c	8b 4d d8	 mov	 ecx, DWORD PTR tv65[ebp]
  0008f	8b 10		 mov	 edx, DWORD PTR [eax]
  00091	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00093	75 05		 jne	 SHORT $LN2@Assign_unl

; 1175 :             return;

  00095	e9 d5 00 00 00	 jmp	 $LN5@Assign_unl
$LN2@Assign_unl:

; 1176 :         }
; 1177 : 
; 1178 :         if (_Right._Myproxy) {

  0009a	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0009d	89 45 d4	 mov	 DWORD PTR tv67[ebp], eax
  000a0	8b 4d d4	 mov	 ecx, DWORD PTR tv67[ebp]
  000a3	89 4d ec	 mov	 DWORD PTR tv137[ebp], ecx
  000a6	8b 55 ec	 mov	 edx, DWORD PTR tv137[ebp]
  000a9	c1 ea 03	 shr	 edx, 3
  000ac	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b2	88 45 fd	 mov	 BYTE PTR tv140[ebp], al
  000b5	80 7d fd 00	 cmp	 BYTE PTR tv140[ebp], 0
  000b9	74 1a		 je	 SHORT $LN8@Assign_unl
  000bb	8a 4d ec	 mov	 cl, BYTE PTR tv137[ebp]
  000be	80 e1 07	 and	 cl, 7
  000c1	80 c1 03	 add	 cl, 3
  000c4	3a 4d fd	 cmp	 cl, BYTE PTR tv140[ebp]
  000c7	7c 0c		 jl	 SHORT $LN8@Assign_unl
  000c9	8b 55 ec	 mov	 edx, DWORD PTR tv137[ebp]
  000cc	52		 push	 edx
  000cd	e8 00 00 00 00	 call	 ___asan_report_load4
  000d2	83 c4 04	 add	 esp, 4
$LN8@Assign_unl:
  000d5	8b 45 d4	 mov	 eax, DWORD PTR tv67[ebp]
  000d8	83 38 00	 cmp	 DWORD PTR [eax], 0
  000db	0f 84 86 00 00
	00		 je	 $LN3@Assign_unl

; 1179 :             _Adopt_unlocked(_Right._Myproxy->_Mycont);

  000e1	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  000e4	89 4d d0	 mov	 DWORD PTR tv70[ebp], ecx
  000e7	8b 55 d0	 mov	 edx, DWORD PTR tv70[ebp]
  000ea	89 55 e8	 mov	 DWORD PTR tv95[ebp], edx
  000ed	8b 45 e8	 mov	 eax, DWORD PTR tv95[ebp]
  000f0	c1 e8 03	 shr	 eax, 3
  000f3	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000f9	88 4d fc	 mov	 BYTE PTR tv130[ebp], cl
  000fc	80 7d fc 00	 cmp	 BYTE PTR tv130[ebp], 0
  00100	74 1a		 je	 SHORT $LN7@Assign_unl
  00102	8a 55 e8	 mov	 dl, BYTE PTR tv95[ebp]
  00105	80 e2 07	 and	 dl, 7
  00108	80 c2 03	 add	 dl, 3
  0010b	3a 55 fc	 cmp	 dl, BYTE PTR tv130[ebp]
  0010e	7c 0c		 jl	 SHORT $LN7@Assign_unl
  00110	8b 45 e8	 mov	 eax, DWORD PTR tv95[ebp]
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ___asan_report_load4
  00119	83 c4 04	 add	 esp, 4
$LN7@Assign_unl:
  0011c	8b 4d d0	 mov	 ecx, DWORD PTR tv70[ebp]
  0011f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00121	89 55 cc	 mov	 DWORD PTR tv71[ebp], edx
  00124	8b 45 cc	 mov	 eax, DWORD PTR tv71[ebp]
  00127	89 45 e4	 mov	 DWORD PTR tv85[ebp], eax
  0012a	8b 4d e4	 mov	 ecx, DWORD PTR tv85[ebp]
  0012d	c1 e9 03	 shr	 ecx, 3
  00130	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00136	88 55 fb	 mov	 BYTE PTR tv88[ebp], dl
  00139	80 7d fb 00	 cmp	 BYTE PTR tv88[ebp], 0
  0013d	74 18		 je	 SHORT $LN6@Assign_unl
  0013f	8a 45 e4	 mov	 al, BYTE PTR tv85[ebp]
  00142	24 07		 and	 al, 7
  00144	04 03		 add	 al, 3
  00146	3a 45 fb	 cmp	 al, BYTE PTR tv88[ebp]
  00149	7c 0c		 jl	 SHORT $LN6@Assign_unl
  0014b	8b 4d e4	 mov	 ecx, DWORD PTR tv85[ebp]
  0014e	51		 push	 ecx
  0014f	e8 00 00 00 00	 call	 ___asan_report_load4
  00154	83 c4 04	 add	 esp, 4
$LN6@Assign_unl:
  00157	8b 55 cc	 mov	 edx, DWORD PTR tv71[ebp]
  0015a	8b 02		 mov	 eax, DWORD PTR [edx]
  0015c	50		 push	 eax
  0015d	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  00160	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1180 :         } else { // becoming invalid, disown current parent

  00165	eb 08		 jmp	 SHORT $LN5@Assign_unl
$LN3@Assign_unl:

; 1181 :             _Orphan_me_unlocked_v3();

  00167	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  0016a	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN5@Assign_unl:

; 1182 :         }
; 1183 :     }

  0016f	8b e5		 mov	 esp, ebp
  00171	5d		 pop	 ebp
  00172	c2 04 00	 ret	 4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ENDP ; std::_Iterator_base12::_Assign_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -36						; size = 4
tv66 = -32						; size = 4
tv65 = -28						; size = 4
_this$ = -24						; size = 4
tv64 = -20						; size = 4
tv76 = -16						; size = 4
tv86 = -12						; size = 4
tv128 = -8						; size = 4
tv79 = -3						; size = 1
tv89 = -2						; size = 1
tv131 = -1						; size = 1
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv128[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv131[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv131[ebp], 0
  00032	74 1a		 je	 SHORT $LN7@Getcont
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv128[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv131[ebp]
  00040	7c 0c		 jl	 SHORT $LN7@Getcont
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN7@Getcont:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	0f 84 80 00 00
	00		 je	 $LN3@Getcont
  0005a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	89 4d e4	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f4	 mov	 DWORD PTR tv86[ebp], edx
  00066	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv89[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv89[ebp], 0
  00079	74 1a		 je	 SHORT $LN6@Getcont
  0007b	8a 55 f4	 mov	 dl, BYTE PTR tv86[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv89[ebp]
  00087	7c 0c		 jl	 SHORT $LN6@Getcont
  00089	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_load4
  00092	83 c4 04	 add	 esp, 4
$LN6@Getcont:
  00095	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 55 e0	 mov	 DWORD PTR tv66[ebp], edx
  0009d	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000a0	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  000a6	c1 e9 03	 shr	 ecx, 3
  000a9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000af	88 55 fd	 mov	 BYTE PTR tv79[ebp], dl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv79[ebp], 0
  000b6	74 18		 je	 SHORT $LN5@Getcont
  000b8	8a 45 f0	 mov	 al, BYTE PTR tv76[ebp]
  000bb	24 07		 and	 al, 7
  000bd	04 03		 add	 al, 3
  000bf	3a 45 fd	 cmp	 al, BYTE PTR tv79[ebp]
  000c2	7c 0c		 jl	 SHORT $LN5@Getcont
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ___asan_report_load4
  000cd	83 c4 04	 add	 esp, 4
$LN5@Getcont:
  000d0	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000d3	8b 02		 mov	 eax, DWORD PTR [edx]
  000d5	89 45 dc	 mov	 DWORD PTR tv68[ebp], eax
  000d8	eb 07		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  000da	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Getcont:
  000e1	8b 45 dc	 mov	 eax, DWORD PTR tv68[ebp]

; 1164 :     }

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0e		 je	 SHORT $LN2@Adopt

; 1145 :             _Adopt_unlocked(_Parent);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Parent$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1146 :         } else

  00029	eb 0c		 jmp	 SHORT $LN4@Adopt
$LN2@Adopt:

; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);

  0002b	8b 55 08	 mov	 edx, DWORD PTR __Parent$[ebp]
  0002e	52		 push	 edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
$LN4@Adopt:

; 1150 :         }
; 1151 :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Iterator_b

; 1134 :             _Orphan_me_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1135 :         } else

  00025	eb 08		 jmp	 SHORT $LN4@Iterator_b
$LN2@Iterator_b:

; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
$LN4@Iterator_b:

; 1139 :         }
; 1140 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0e		 je	 SHORT $LN2@operator

; 1118 :             _Assign_unlocked(_Right);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1119 :         } else

  00029	eb 0c		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);

  0002b	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0002e	52		 push	 edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
$LN3@operator:

; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1128 :     }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 04 00	 ret	 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
tv73 = -16						; size = 4
tv83 = -12						; size = 4
_this$ = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1110 :     _CONSTEXPR20_CONTAINER _Iterator_base12(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1113 : 
; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {
; 1118 :             _Assign_unlocked(_Right);
; 1119 :         } else
; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);
; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;
; 1128 :     }
; 1129 : 
; 1130 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {
; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {
; 1134 :             _Orphan_me_unlocked_v3();
; 1135 :         } else
; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();
; 1139 :         }
; 1140 :     }
; 1141 : 
; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {
; 1145 :             _Adopt_unlocked(_Parent);
; 1146 :         } else
; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);
; 1150 :         }
; 1151 :     }
; 1152 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1153 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1154 :         if (_Parent) { // have a parent, do adoption
; 1155 :             _Myproxy = _Parent->_Myproxy;
; 1156 :         } else { // no future parent, just disown current parent
; 1157 :             _Myproxy = nullptr;
; 1158 :         }
; 1159 :     }
; 1160 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1161 : 
; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {
; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1164 :     }
; 1165 : 
; 1166 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1167 : 
; 1168 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Iterator_b
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Iterator_b
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Iterator_b:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1169 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f0	 mov	 DWORD PTR tv73[ebp], edx
  00066	8b 45 f0	 mov	 eax, DWORD PTR tv73[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00079	74 1a		 je	 SHORT $LN3@Iterator_b
  0007b	8a 55 f0	 mov	 dl, BYTE PTR tv73[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00087	7c 0c		 jl	 SHORT $LN3@Iterator_b
  00089	8b 45 f0	 mov	 eax, DWORD PTR tv73[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_store4
  00092	83 c4 04	 add	 esp, 4
$LN3@Iterator_b:
  00095	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1111 :         *this = _Right;

  0009e	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  000a1	52		 push	 edx
  000a2	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a5	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 1112 :     }

  000aa	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1108 :     _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1109 : 
; 1110 :     _CONSTEXPR20_CONTAINER _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1111 :         *this = _Right;
; 1112 :     }
; 1113 : 
; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {
; 1118 :             _Assign_unlocked(_Right);
; 1119 :         } else
; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);
; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;
; 1128 :     }
; 1129 : 
; 1130 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {
; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {
; 1134 :             _Orphan_me_unlocked_v3();
; 1135 :         } else
; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();
; 1139 :         }
; 1140 :     }
; 1141 : 
; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {
; 1145 :             _Adopt_unlocked(_Parent);
; 1146 :         } else
; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);
; 1150 :         }
; 1151 :     }
; 1152 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1153 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1154 :         if (_Parent) { // have a parent, do adoption
; 1155 :             _Myproxy = _Parent->_Myproxy;
; 1156 :         } else { // no future parent, just disown current parent
; 1157 :             _Myproxy = nullptr;
; 1158 :         }
; 1159 :     }
; 1160 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1161 : 
; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {
; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1164 :     }
; 1165 : 
; 1166 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1167 : 
; 1168 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Iterator_b
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Iterator_b
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Iterator_b:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1169 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00066	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv74[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00079	74 1a		 je	 SHORT $LN3@Iterator_b
  0007b	8a 55 f4	 mov	 dl, BYTE PTR tv71[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv74[ebp]
  00087	7c 0c		 jl	 SHORT $LN3@Iterator_b
  00089	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_store4
  00092	83 c4 04	 add	 esp, 4
$LN3@Iterator_b:
  00095	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1108 :     _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator

  0009e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1095 :     void _Orphan_all_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1096 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1097 :         _Orphan_all_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1098 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv89 = -100						; size = 4
tv86 = -96						; size = 4
tv83 = -92						; size = 4
tv78 = -88						; size = 4
tv72 = -84						; size = 4
tv71 = -80						; size = 4
tv70 = -76						; size = 4
tv68 = -72						; size = 4
tv66 = -68						; size = 4
tv64 = -64						; size = 4
tv130 = -60						; size = 4
tv140 = -56						; size = 4
_this$ = -52						; size = 4
tv150 = -48						; size = 4
tv160 = -44						; size = 4
tv170 = -40						; size = 4
tv180 = -36						; size = 4
tv190 = -32						; size = 4
tv200 = -28						; size = 4
tv210 = -24						; size = 4
tv220 = -20						; size = 4
__Pnext$1 = -16						; size = 4
tv133 = -10						; size = 1
tv143 = -9						; size = 1
tv153 = -8						; size = 1
tv163 = -7						; size = 1
tv173 = -6						; size = 1
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 :     if (!_Myproxy) { // no proxy, already done

  00013	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv220[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_all
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv220[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_all
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_all:
  0004e	8b 45 c0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN5@Orphan_all

; 1239 :         return;

  00056	e9 58 02 00 00	 jmp	 $LN6@Orphan_all
$LN5@Orphan_all:

; 1240 :     }
; 1241 : 
; 1242 :     // proxy allocated, drain it
; 1243 :     for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { // TRANSITION, VSO-1269037

  0005b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e8	 mov	 DWORD PTR tv210[ebp], edx
  00067	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv213[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  0007a	74 1a		 je	 SHORT $LN15@Orphan_all
  0007c	8a 55 e8	 mov	 dl, BYTE PTR tv210[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv213[ebp]
  00088	7c 0c		 jl	 SHORT $LN15@Orphan_all
  0008a	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN15@Orphan_all:
  00096	8b 4d bc	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$1[ebp], edx
  000a1	e9 c0 00 00 00	 jmp	 $LN4@Orphan_all
$LN2@Orphan_all:
  000a6	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000a9	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  000ac	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  000af	89 4d e4	 mov	 DWORD PTR tv200[ebp], ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000b5	c1 ea 03	 shr	 edx, 3
  000b8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000be	88 45 fd	 mov	 BYTE PTR tv203[ebp], al
  000c1	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  000c5	74 1a		 je	 SHORT $LN14@Orphan_all
  000c7	8a 4d e4	 mov	 cl, BYTE PTR tv200[ebp]
  000ca	80 e1 07	 and	 cl, 7
  000cd	80 c1 03	 add	 cl, 3
  000d0	3a 4d fd	 cmp	 cl, BYTE PTR tv203[ebp]
  000d3	7c 0c		 jl	 SHORT $LN14@Orphan_all
  000d5	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ___asan_report_load4
  000de	83 c4 04	 add	 esp, 4
$LN14@Orphan_all:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	83 c1 04	 add	 ecx, 4
  000e9	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  000ec	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  000ef	89 55 e0	 mov	 DWORD PTR tv190[ebp], edx
  000f2	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  000f5	c1 e8 03	 shr	 eax, 3
  000f8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000fe	88 4d fc	 mov	 BYTE PTR tv193[ebp], cl
  00101	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  00105	74 1a		 je	 SHORT $LN13@Orphan_all
  00107	8a 55 e0	 mov	 dl, BYTE PTR tv190[ebp]
  0010a	80 e2 07	 and	 dl, 7
  0010d	80 c2 03	 add	 dl, 3
  00110	3a 55 fc	 cmp	 dl, BYTE PTR tv193[ebp]
  00113	7c 0c		 jl	 SHORT $LN13@Orphan_all
  00115	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ___asan_report_load4
  0011e	83 c4 04	 add	 esp, 4
$LN13@Orphan_all:
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00124	89 4d a4	 mov	 DWORD PTR tv83[ebp], ecx
  00127	8b 55 a4	 mov	 edx, DWORD PTR tv83[ebp]
  0012a	89 55 dc	 mov	 DWORD PTR tv180[ebp], edx
  0012d	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00130	c1 e8 03	 shr	 eax, 3
  00133	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00139	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  0013c	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00140	74 1a		 je	 SHORT $LN12@Orphan_all
  00142	8a 55 dc	 mov	 dl, BYTE PTR tv180[ebp]
  00145	80 e2 07	 and	 dl, 7
  00148	80 c2 03	 add	 dl, 3
  0014b	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  0014e	7c 0c		 jl	 SHORT $LN12@Orphan_all
  00150	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ___asan_report_store4
  00159	83 c4 04	 add	 esp, 4
$LN12@Orphan_all:
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  0015f	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  00162	8b 02		 mov	 eax, DWORD PTR [edx]
  00164	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Orphan_all:
  00166	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00169	89 4d a0	 mov	 DWORD PTR tv86[ebp], ecx
  0016c	8b 55 a0	 mov	 edx, DWORD PTR tv86[ebp]
  0016f	89 55 d8	 mov	 DWORD PTR tv170[ebp], edx
  00172	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00175	c1 e8 03	 shr	 eax, 3
  00178	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0017e	88 4d fa	 mov	 BYTE PTR tv173[ebp], cl
  00181	80 7d fa 00	 cmp	 BYTE PTR tv173[ebp], 0
  00185	74 1a		 je	 SHORT $LN11@Orphan_all
  00187	8a 55 d8	 mov	 dl, BYTE PTR tv170[ebp]
  0018a	80 e2 07	 and	 dl, 7
  0018d	80 c2 03	 add	 dl, 3
  00190	3a 55 fa	 cmp	 dl, BYTE PTR tv173[ebp]
  00193	7c 0c		 jl	 SHORT $LN11@Orphan_all
  00195	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ___asan_report_load4
  0019e	83 c4 04	 add	 esp, 4
$LN11@Orphan_all:
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  001a4	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001a7	0f 84 84 00 00
	00		 je	 $LN3@Orphan_all

; 1244 :         _Pnext->_Myproxy = nullptr;

  001ad	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001b0	89 55 9c	 mov	 DWORD PTR tv89[ebp], edx
  001b3	8b 45 9c	 mov	 eax, DWORD PTR tv89[ebp]
  001b6	89 45 d4	 mov	 DWORD PTR tv160[ebp], eax
  001b9	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001bc	c1 e9 03	 shr	 ecx, 3
  001bf	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001c5	88 55 f9	 mov	 BYTE PTR tv163[ebp], dl
  001c8	80 7d f9 00	 cmp	 BYTE PTR tv163[ebp], 0
  001cc	74 18		 je	 SHORT $LN10@Orphan_all
  001ce	8a 45 d4	 mov	 al, BYTE PTR tv160[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 45 f9	 cmp	 al, BYTE PTR tv163[ebp]
  001d8	7c 0c		 jl	 SHORT $LN10@Orphan_all
  001da	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ___asan_report_load4
  001e3	83 c4 04	 add	 esp, 4
$LN10@Orphan_all:
  001e6	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001e9	8b 02		 mov	 eax, DWORD PTR [edx]
  001eb	89 45 b4	 mov	 DWORD PTR tv70[ebp], eax
  001ee	8b 4d b4	 mov	 ecx, DWORD PTR tv70[ebp]
  001f1	89 4d d0	 mov	 DWORD PTR tv150[ebp], ecx
  001f4	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  001f7	c1 ea 03	 shr	 edx, 3
  001fa	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00200	88 45 f8	 mov	 BYTE PTR tv153[ebp], al
  00203	80 7d f8 00	 cmp	 BYTE PTR tv153[ebp], 0
  00207	74 1a		 je	 SHORT $LN9@Orphan_all
  00209	8a 4d d0	 mov	 cl, BYTE PTR tv150[ebp]
  0020c	80 e1 07	 and	 cl, 7
  0020f	80 c1 03	 add	 cl, 3
  00212	3a 4d f8	 cmp	 cl, BYTE PTR tv153[ebp]
  00215	7c 0c		 jl	 SHORT $LN9@Orphan_all
  00217	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ___asan_report_store4
  00220	83 c4 04	 add	 esp, 4
$LN9@Orphan_all:
  00223	8b 45 b4	 mov	 eax, DWORD PTR tv70[ebp]
  00226	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1245 :     }

  0022c	e9 75 fe ff ff	 jmp	 $LN2@Orphan_all
$LN3@Orphan_all:

; 1246 :     _Myproxy->_Myfirstiter = nullptr;

  00231	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	89 4d b0	 mov	 DWORD PTR tv71[ebp], ecx
  00237	8b 55 b0	 mov	 edx, DWORD PTR tv71[ebp]
  0023a	89 55 c8	 mov	 DWORD PTR tv140[ebp], edx
  0023d	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00240	c1 e8 03	 shr	 eax, 3
  00243	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00249	88 4d f7	 mov	 BYTE PTR tv143[ebp], cl
  0024c	80 7d f7 00	 cmp	 BYTE PTR tv143[ebp], 0
  00250	74 1a		 je	 SHORT $LN8@Orphan_all
  00252	8a 55 c8	 mov	 dl, BYTE PTR tv140[ebp]
  00255	80 e2 07	 and	 dl, 7
  00258	80 c2 03	 add	 dl, 3
  0025b	3a 55 f7	 cmp	 dl, BYTE PTR tv143[ebp]
  0025e	7c 0c		 jl	 SHORT $LN8@Orphan_all
  00260	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ___asan_report_load4
  00269	83 c4 04	 add	 esp, 4
$LN8@Orphan_all:
  0026c	8b 4d b0	 mov	 ecx, DWORD PTR tv71[ebp]
  0026f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00271	83 c2 04	 add	 edx, 4
  00274	89 55 ac	 mov	 DWORD PTR tv72[ebp], edx
  00277	8b 45 ac	 mov	 eax, DWORD PTR tv72[ebp]
  0027a	89 45 c4	 mov	 DWORD PTR tv130[ebp], eax
  0027d	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  00280	c1 e9 03	 shr	 ecx, 3
  00283	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00289	88 55 f6	 mov	 BYTE PTR tv133[ebp], dl
  0028c	80 7d f6 00	 cmp	 BYTE PTR tv133[ebp], 0
  00290	74 18		 je	 SHORT $LN7@Orphan_all
  00292	8a 45 c4	 mov	 al, BYTE PTR tv130[ebp]
  00295	24 07		 and	 al, 7
  00297	04 03		 add	 al, 3
  00299	3a 45 f6	 cmp	 al, BYTE PTR tv133[ebp]
  0029c	7c 0c		 jl	 SHORT $LN7@Orphan_all
  0029e	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 ___asan_report_store4
  002a7	83 c4 04	 add	 esp, 4
$LN7@Orphan_all:
  002aa	8b 55 ac	 mov	 edx, DWORD PTR tv72[ebp]
  002ad	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Orphan_all:

; 1247 : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1250 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1251 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1252 :     if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Orphan_all

; 1253 :         _Orphan_all_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1254 :     } else

  00025	eb 08		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 1255 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1256 :     {
; 1257 :         _Orphan_all_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN4@Orphan_all:

; 1258 :     }
; 1259 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1260 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1065 : 
; 1066 :     _Container_base12(const _Container_base12&) = delete;
; 1067 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1068 : 
; 1069 :     _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept;
; 1070 :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1071 : 
; 1072 :     template <class _Alloc>
; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {
; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1075 :         _Construct_in_place(*_New_proxy, this);
; 1076 :         _Myproxy            = _New_proxy;
; 1077 :         _New_proxy->_Mycont = this;
; 1078 :     }
; 1079 : 
; 1080 :     template <class _Alloc>
; 1081 :     _CONSTEXPR20_CONTAINER void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1082 :         // pre: no iterators refer to the existing proxy
; 1083 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1084 :         _Construct_in_place(*_New_proxy, this);
; 1085 :         _New_proxy->_Mycont = this;
; 1086 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1087 :     }
; 1088 : 
; 1089 :     _Container_proxy* _Myproxy = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Container_:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 1057 : 
; 1058 :     const _Container_base12* _Mycont       = nullptr;
; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@Container_
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Container_
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Container_:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 978  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 979  :     // convert size_t to size_t, unchanged
; 980  :     return _Len;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 981  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -84					; size = 4
tv154 = -80						; size = 4
tv151 = -76						; size = 4
tv144 = -72						; size = 4
tv64 = -68						; size = 4
tv141 = -64						; size = 4
tv138 = -60						; size = 4
__Ptr_container$ = -56					; size = 4
__Back_shift$ = -52					; size = 4
tv68 = -48						; size = 4
__Ptr_user$ = -44					; size = 4
tv66 = -40						; size = 4
tv157 = -36						; size = 4
tv167 = -32						; size = 4
tv177 = -28						; size = 4
tv187 = -24						; size = 4
tv197 = -20						; size = 4
tv207 = -16						; size = 4
tv217 = -12						; size = 4
tv160 = -7						; size = 1
tv170 = -6						; size = 1
tv180 = -5						; size = 1
tv190 = -4						; size = 1
tv200 = -3						; size = 1
tv210 = -2						; size = 1
tv220 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 153  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 154  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 155  :     _Bytes += _Non_user_size;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	89 45 c4	 mov	 DWORD PTR tv138[ebp], eax
  00016	8b 4d c4	 mov	 ecx, DWORD PTR tv138[ebp]
  00019	89 4d f4	 mov	 DWORD PTR tv217[ebp], ecx
  0001c	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv220[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv220[ebp], 0
  0002f	74 1a		 je	 SHORT $LN27@Adjust_man
  00031	8a 4d f4	 mov	 cl, BYTE PTR tv217[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv220[ebp]
  0003d	7c 0c		 jl	 SHORT $LN27@Adjust_man
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN27@Adjust_man:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	83 c1 27	 add	 ecx, 39			; 00000027H
  00053	89 4d bc	 mov	 DWORD PTR tv64[ebp], ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00059	89 55 c0	 mov	 DWORD PTR tv141[ebp], edx
  0005c	8b 45 c0	 mov	 eax, DWORD PTR tv141[ebp]
  0005f	89 45 f0	 mov	 DWORD PTR tv207[ebp], eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006e	88 55 fe	 mov	 BYTE PTR tv210[ebp], dl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv210[ebp], 0
  00075	74 18		 je	 SHORT $LN26@Adjust_man
  00077	8a 45 f0	 mov	 al, BYTE PTR tv207[ebp]
  0007a	24 07		 and	 al, 7
  0007c	04 03		 add	 al, 3
  0007e	3a 45 fe	 cmp	 al, BYTE PTR tv210[ebp]
  00081	7c 0c		 jl	 SHORT $LN26@Adjust_man
  00083	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN26@Adjust_man:
  0008f	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00092	8b 45 bc	 mov	 eax, DWORD PTR tv64[ebp]
  00095	89 02		 mov	 DWORD PTR [edx], eax

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009a	89 4d b8	 mov	 DWORD PTR tv144[ebp], ecx
  0009d	8b 55 b8	 mov	 edx, DWORD PTR tv144[ebp]
  000a0	89 55 ec	 mov	 DWORD PTR tv197[ebp], edx
  000a3	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000a6	c1 e8 03	 shr	 eax, 3
  000a9	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000af	88 4d fd	 mov	 BYTE PTR tv200[ebp], cl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv200[ebp], 0
  000b6	74 1a		 je	 SHORT $LN25@Adjust_man
  000b8	8a 55 ec	 mov	 dl, BYTE PTR tv197[ebp]
  000bb	80 e2 07	 and	 dl, 7
  000be	80 c2 03	 add	 dl, 3
  000c1	3a 55 fd	 cmp	 dl, BYTE PTR tv200[ebp]
  000c4	7c 0c		 jl	 SHORT $LN25@Adjust_man
  000c6	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ___asan_report_load4
  000cf	83 c4 04	 add	 esp, 4
$LN25@Adjust_man:
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d7	89 55 d4	 mov	 DWORD PTR __Ptr_user$[ebp], edx

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000da	b8 04 00 00 00	 mov	 eax, 4
  000df	6b c8 ff	 imul	 ecx, eax, -1
  000e2	8b 55 d4	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  000e5	03 d1		 add	 edx, ecx
  000e7	89 55 d8	 mov	 DWORD PTR tv66[ebp], edx
  000ea	8b 45 d8	 mov	 eax, DWORD PTR tv66[ebp]
  000ed	89 45 e8	 mov	 DWORD PTR tv187[ebp], eax
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  000f3	c1 e9 03	 shr	 ecx, 3
  000f6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000fc	88 55 fc	 mov	 BYTE PTR tv190[ebp], dl
  000ff	80 7d fc 00	 cmp	 BYTE PTR tv190[ebp], 0
  00103	74 18		 je	 SHORT $LN24@Adjust_man
  00105	8a 45 e8	 mov	 al, BYTE PTR tv187[ebp]
  00108	24 07		 and	 al, 7
  0010a	04 03		 add	 al, 3
  0010c	3a 45 fc	 cmp	 al, BYTE PTR tv190[ebp]
  0010f	7c 0c		 jl	 SHORT $LN24@Adjust_man
  00111	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ___asan_report_load4
  0011a	83 c4 04	 add	 esp, 4
$LN24@Adjust_man:
  0011d	8b 55 d8	 mov	 edx, DWORD PTR tv66[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	89 45 c8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00125	b9 04 00 00 00	 mov	 ecx, 4
  0012a	6b d1 fe	 imul	 edx, ecx, -2
  0012d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_user$[ebp]
  00130	03 c2		 add	 eax, edx
  00132	89 45 d0	 mov	 DWORD PTR tv68[ebp], eax
  00135	8b 4d d0	 mov	 ecx, DWORD PTR tv68[ebp]
  00138	89 4d e4	 mov	 DWORD PTR tv177[ebp], ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  0013e	c1 ea 03	 shr	 edx, 3
  00141	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00147	88 45 fb	 mov	 BYTE PTR tv180[ebp], al
  0014a	80 7d fb 00	 cmp	 BYTE PTR tv180[ebp], 0
  0014e	74 1a		 je	 SHORT $LN23@Adjust_man
  00150	8a 4d e4	 mov	 cl, BYTE PTR tv177[ebp]
  00153	80 e1 07	 and	 cl, 7
  00156	80 c1 03	 add	 cl, 3
  00159	3a 4d fb	 cmp	 cl, BYTE PTR tv180[ebp]
  0015c	7c 0c		 jl	 SHORT $LN23@Adjust_man
  0015e	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN23@Adjust_man:
  0016a	8b 45 d0	 mov	 eax, DWORD PTR tv68[ebp]
  0016d	81 38 fa fa fa
	fa		 cmp	 DWORD PTR [eax], -84215046 ; fafafafaH
  00173	75 02		 jne	 SHORT $LN7@Adjust_man
  00175	eb 4a		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00181	6a 00		 push	 0
  00183	68 a2 00 00 00	 push	 162			; 000000a2H
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0018d	6a 02		 push	 2
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00195	83 c4 18	 add	 esp, 24			; 00000018H
  00198	83 f8 01	 cmp	 eax, 1
  0019b	75 01		 jne	 SHORT $LN19@Adjust_man
  0019d	cc		 int	 3
$LN19@Adjust_man:
  0019e	6a 00		 push	 0
  001a0	68 a2 00 00 00	 push	 162			; 000000a2H
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001ba	83 c4 14	 add	 esp, 20			; 00000014H
  001bd	33 d2		 xor	 edx, edx
  001bf	75 b6		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  001c1	33 c0		 xor	 eax, eax
  001c3	0f 85 5c ff ff
	ff		 jne	 $LN4@Adjust_man

; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  001c9	c7 45 ac 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  001d3	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  001d6	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  001d9	89 55 e0	 mov	 DWORD PTR tv167[ebp], edx
  001dc	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  001df	c1 e8 03	 shr	 eax, 3
  001e2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e8	88 4d fa	 mov	 BYTE PTR tv170[ebp], cl
  001eb	80 7d fa 00	 cmp	 BYTE PTR tv170[ebp], 0
  001ef	74 1a		 je	 SHORT $LN22@Adjust_man
  001f1	8a 55 e0	 mov	 dl, BYTE PTR tv167[ebp]
  001f4	80 e2 07	 and	 dl, 7
  001f7	80 c2 03	 add	 dl, 3
  001fa	3a 55 fa	 cmp	 dl, BYTE PTR tv170[ebp]
  001fd	7c 0c		 jl	 SHORT $LN22@Adjust_man
  001ff	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ___asan_report_load4
  00208	83 c4 04	 add	 esp, 4
$LN22@Adjust_man:
  0020b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	2b 55 c8	 sub	 edx, DWORD PTR __Ptr_container$[ebp]
  00213	89 55 cc	 mov	 DWORD PTR __Back_shift$[ebp], edx
$LN10@Adjust_man:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00216	83 7d cc 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  0021a	72 08		 jb	 SHORT $LN13@Adjust_man
  0021c	83 7d cc 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  00220	77 02		 ja	 SHORT $LN13@Adjust_man
  00222	eb 4a		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0022e	6a 00		 push	 0
  00230	68 ac 00 00 00	 push	 172			; 000000acH
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0023a	6a 02		 push	 2
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00242	83 c4 18	 add	 esp, 24			; 00000018H
  00245	83 f8 01	 cmp	 eax, 1
  00248	75 01		 jne	 SHORT $LN20@Adjust_man
  0024a	cc		 int	 3
$LN20@Adjust_man:
  0024b	6a 00		 push	 0
  0024d	68 ac 00 00 00	 push	 172			; 000000acH
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00267	83 c4 14	 add	 esp, 20			; 00000014H
  0026a	33 c9		 xor	 ecx, ecx
  0026c	75 b6		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0026e	33 d2		 xor	 edx, edx
  00270	75 a4		 jne	 SHORT $LN10@Adjust_man

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00272	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00275	89 45 b0	 mov	 DWORD PTR tv154[ebp], eax
  00278	8b 4d b0	 mov	 ecx, DWORD PTR tv154[ebp]
  0027b	89 4d dc	 mov	 DWORD PTR tv157[ebp], ecx
  0027e	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  00281	c1 ea 03	 shr	 edx, 3
  00284	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0028a	88 45 f9	 mov	 BYTE PTR tv160[ebp], al
  0028d	80 7d f9 00	 cmp	 BYTE PTR tv160[ebp], 0
  00291	74 1a		 je	 SHORT $LN21@Adjust_man
  00293	8a 4d dc	 mov	 cl, BYTE PTR tv157[ebp]
  00296	80 e1 07	 and	 cl, 7
  00299	80 c1 03	 add	 cl, 3
  0029c	3a 4d f9	 cmp	 cl, BYTE PTR tv160[ebp]
  0029f	7c 0c		 jl	 SHORT $LN21@Adjust_man
  002a1	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 ___asan_report_store4
  002aa	83 c4 04	 add	 esp, 4
$LN21@Adjust_man:
  002ad	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  002b0	8b 4d c8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  002b3	89 08		 mov	 DWORD PTR [eax], ecx

; 174  : }

  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 84   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 85   :         return ::operator new(_Bytes);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 86   :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 217  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 12
tv70 = -12						; size = 4
tv68 = -8						; size = 4
tv73 = -4						; size = 4
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00020	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ
  00027	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0002e	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00040	89 4d f4	 mov	 DWORD PTR tv70[ebp], ecx
  00043	8b 55 f4	 mov	 edx, DWORD PTR tv70[ebp]
  00046	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0004c	83 45 f4 04	 add	 DWORD PTR tv70[ebp], 4
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  00053	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET __FF458F76_exception
  0005e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 321  :     _THROW(bad_array_new_length{});

  00063	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00066	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0006b	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00070	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  00079	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00080	8d 55 b0	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0008c	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  0008f	6a 08		 push	 8
  00091	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0009a	83 c4 08	 add	 esp, 8
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	8b e3		 mov	 esp, ebx
  000a2	5b		 pop	 ebx
  000a3	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_array_
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_array_
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
tv87 = -1						; size = 1
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00026	8b 4d f0	 mov	 ecx, DWORD PTR tv69[ebp]
  00029	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  0002f	c1 ea 03	 shr	 edx, 3
  00032	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00038	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  0003b	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0003f	74 1a		 je	 SHORT $LN3@bad_array_
  00041	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00044	80 e1 07	 and	 cl, 7
  00047	80 c1 03	 add	 cl, 3
  0004a	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0004d	7c 0c		 jl	 SHORT $LN3@bad_array_
  0004f	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ___asan_report_store4
  00058	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_alloc
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv85 = -12						; size = 4
_this$ = -8						; size = 4
tv88 = -1						; size = 1
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

  00013	6a 01		 push	 1
  00015	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  00027	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0002a	89 55 f4	 mov	 DWORD PTR tv85[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00030	c1 e8 03	 shr	 eax, 3
  00033	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00039	88 4d ff	 mov	 BYTE PTR tv88[ebp], cl
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00040	74 1a		 je	 SHORT $LN3@bad_alloc
  00042	8a 55 f4	 mov	 dl, BYTE PTR tv85[ebp]
  00045	80 e2 07	 and	 dl, 7
  00048	80 c2 03	 add	 dl, 3
  0004b	3a 55 ff	 cmp	 dl, BYTE PTR tv88[ebp]
  0004e	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ___asan_report_store4
  00059	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv67 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv85[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv88[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00035	74 1a		 je	 SHORT $LN6@what
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv85[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv88[ebp]
  00043	7c 0c		 jl	 SHORT $LN6@what
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN6@what:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 48		 je	 SHORT $LN3@what
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 04	 add	 ecx, 4
  0005f	89 4d e8	 mov	 DWORD PTR tv67[ebp], ecx
  00062	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00065	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00068	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0006b	c1 e8 03	 shr	 eax, 3
  0006e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00074	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00077	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  0007b	74 1a		 je	 SHORT $LN5@what
  0007d	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  00080	80 e2 07	 and	 dl, 7
  00083	80 c2 03	 add	 dl, 3
  00086	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00089	7c 0c		 jl	 SHORT $LN5@what
  0008b	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ___asan_report_load4
  00094	83 c4 04	 add	 esp, 4
$LN5@what:
  00097	8b 4d e8	 mov	 ecx, DWORD PTR tv67[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
  0009f	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  000a1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  000a8	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ___std_exception_destroy
  00063	83 c4 04	 add	 esp, 4

; 91   :     }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv64 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -1						; size = 1
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv76[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv79[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv79[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv76[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv79[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	52		 push	 edx
  00071	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00074	83 c0 04	 add	 eax, 4
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___std_exception_copy
  0007d	83 c4 08	 add	 esp, 8

; 74   :     }

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
tv76 = -16						; size = 4
tv86 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -2						; size = 1
tv89 = -1						; size = 1
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv86[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv86[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv89[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@exception:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   :         _Data._What = _Message;

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  00073	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00076	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0007c	c1 e9 03	 shr	 ecx, 3
  0007f	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00085	88 55 fe	 mov	 BYTE PTR tv79[ebp], dl
  00088	80 7d fe 00	 cmp	 BYTE PTR tv79[ebp], 0
  0008c	74 18		 je	 SHORT $LN3@exception
  0008e	8a 45 f0	 mov	 al, BYTE PTR tv76[ebp]
  00091	24 07		 and	 al, 7
  00093	04 03		 add	 al, 3
  00095	3a 45 fe	 cmp	 al, BYTE PTR tv79[ebp]
  00098	7c 0c		 jl	 SHORT $LN3@exception
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ___asan_report_store4
  000a3	83 c4 04	 add	 esp, 4
$LN3@exception:
  000a6	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  000a9	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  000ac	89 02		 mov	 DWORD PTR [edx], eax

; 68   :     }

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __97D3638F_vcruntime_new@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         (void)_Size;
; 169  :         return _Where;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 556  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __7FE5F402_limits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 557  :         return INT_MAX;

  0000d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 558  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 180  : _NODISCARD constexpr bool is_constant_evaluated() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __47F37C5A_xtr1common
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 181  :     return __builtin_is_constant_evaluated();

  0000d	32 c0		 xor	 al, al

; 182  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __93DC0B45_wchar@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00010	d1 e0		 shl	 eax, 1
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
__Result$ = -16						; size = 4
tv73 = -12						; size = 4
tv75 = -8						; size = 4
__ArgList$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00010	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00013	89 45 fc	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00016	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv75[ebp], ecx
  0001c	6a 01		 push	 1
  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  00024	83 c4 04	 add	 esp, 4
  00027	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  0002a	8b 55 fc	 mov	 edx, DWORD PTR __ArgList$[ebp]
  0002d	52		 push	 edx
  0002e	6a 00		 push	 0
  00030	8b 45 f8	 mov	 eax, DWORD PTR tv75[ebp]
  00033	50		 push	 eax
  00034	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00037	51		 push	 ecx
  00038	e8 00 00 00 00	 call	 __vfprintf_l
  0003d	83 c4 10	 add	 esp, 16			; 00000010H
  00040	89 45 f0	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  00043	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  0004a	8b 45 f0	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0000d	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00014	51		 push	 ecx
  00015	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  00018	52		 push	 edx
  00019	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00022	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00025	51		 push	 ecx
  00026	8b 10		 mov	 edx, DWORD PTR [eax]
  00028	52		 push	 edx
  00029	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  0002f	83 c4 18	 add	 esp, 24			; 00000018H

; 646  :     }

  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __A2143F22_corecrt_stdio_config@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  0000d	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
