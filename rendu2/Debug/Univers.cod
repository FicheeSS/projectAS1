; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Debug\Univers.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG230665 DB	'Current Viewport : %d x %d', 00H
	ORG $+1
$SG230741 DB	'\Ressources\img', 00H
$SG230742 DB	'\Ressources\audio', 00H
	ORG $+2
$SG230743 DB	'\Ressources\img\backgrounds', 00H
$SG249891 DB	'Unable to open message catalog: ', 00H
	ORG $+3
$SG256761 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xlocale', 00H
$SG249898 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
	ORG $+2
$SG249899 DB	'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H
	ORG $+2
$SG249901 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
	ORG $+2
$SG249902 DB	'0', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'r', 00H
	DB	00H, 00H
	ORG $+2
$SG260851 DB	'invalid argument', 00H
	ORG $+3
$SG260852 DB	'%s', 00H
	ORG $+1
$SG260853 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xmemory', 00H
$SG260854 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
$SG260855 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
	ORG $+2
$SG260856 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
CONST	ENDS
msvcjmc	SEGMENT
__59466570_predefined C++ types (compiler internal) DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__47F37C5A_xtr1common DB 01H
__81812A28_cstddef DB 01H
__7FE5F402_limits DB 01H
__97D3638F_vcruntime_new@h DB 01H
__589FA321_type_traits DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__A751F051_corecrt_memory@h DB 01H
__32E5F013_string@h DB 01H
__DD5FCA34_compare DB 01H
__12269DE6_xutility DB 01H
__C69F69CF_tuple DB 01H
__79D216CD_xmemory DB 01H
__374A57BA_xpolymorphic_allocator@h DB 01H
__0D019051_xstring DB 01H
__B2D2BA86_ctype@h DB 01H
__B7987E10_string DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__C34BF88C_memory DB 01H
__60BC708E_cmath DB 01H
__68B92D9D_xbit_ops@h DB 01H
__0F13B0E8_xhash DB 01H
__BFE0F84B_functional DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__1B354CA2_system_error DB 01H
__3A667B81_error_category@hpp DB 01H
__25339F4A_generic_category_message@hpp DB 01H
__A4E336F0_generic_category@hpp DB 01H
__2DD6F2A3_error_condition@hpp DB 01H
__C6D9B9B2_system_category@hpp DB 01H
__1B11AAFA_snprintf@hpp DB 01H
__6767E947_error_handling@hpp DB 01H
__EE1D0242_system_category_message_win32@hpp DB 01H
__F4D1038E_system_category_condition_win32@hpp DB 01H
__1D2FDE06_system_category_impl@hpp DB 01H
__13E3B269_interop_category@hpp DB 01H
__EF0EAF83_xfacet DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__F4A89B3F_error_code@hpp DB 01H
__C655F023_std_category@hpp DB 01H
__51E12D41_error_category_impl@hpp DB 01H
__FE33131C_xlocmes DB 01H
__67DA974F_xlocmon DB 01H
__D96D2425_xloctime DB 01H
__147DD91B_path_traits@hpp DB 01H
__CE27CDA6_facade_iterator_category@hpp DB 01H
__FCD69F0E_ios_state@hpp DB 01H
__32E57CF6_path@hpp DB 01H
__0269C046_errc@hpp DB 01H
__38C7FDF2_throws@hpp DB 01H
__B76B1A2C_system_error@hpp DB 01H
__8868518C_atomic_count_std_atomic@hpp DB 01H
__BFCE1B3F_intrusive_ref_counter@hpp DB 01H
__203D301F_exception@hpp DB 01H
__6D84B491_file_status@hpp DB 01H
__9E7B425B_directory@hpp DB 01H
__994C2822_operations@hpp DB 01H
__85CA39D3_convenience@hpp DB 01H
__54B77B77_fstream DB 01H
__819F9458_fstream@hpp DB 01H
__807252DF_string_file@hpp DB 01H
__1589CDA2_algorithm DB 01H
__2B558C5C_implementation_help@hpp DB 01H
__53FD89EC_noncopyable@hpp DB 01H
__249AC1FF_as_literal@hpp DB 01H
__CCA81496_classification@hpp DB 01H
__9E8302C5_classification@hpp DB 01H
__291069DD_compare@hpp DB 01H
__6E0894BC_finder@hpp DB 01H
__6005BCF8_finder@hpp DB 01H
__876C1A82_exception@hpp DB 01H
__C6048E53_current_function@hpp DB 01H
__550A1F1C_source_location@hpp DB 01H
__78E6F2C5_throw_exception@hpp DB 01H
__36989B12_demangle@hpp DB 01H
__DBA21239_stl_type_index@hpp DB 01H
__DFD8B503_function_base@hpp DB 01H
__0C0FE920_ratio DB 01H
__2D75401A___msvc_tzdb@hpp DB 01H
__7BF231E7_optional DB 01H
__324884E2_vector DB 01H
__1347750E_utility DB 01H
__20D3AEFC_forward_list DB 01H
__1B08F288_chrono DB 01H
__491EF713_xfilesystem_abi@h DB 01H
__2B6093AE_list DB 01H
__B111E740_filesystem DB 01H
__B26BA995_regex DB 01H
__B2A9EE53_InputStream@hpp DB 01H
__62DD75E3_NonCopyable@hpp DB 01H
__FC4CDF9C_Thread@inl DB 01H
__69958C8C_xtree DB 01H
__C78A343B_SoundFileReader@hpp DB 01H
__5D3957BC_SoundFileWriter@hpp DB 01H
__A5341E86_regex_workaround@hpp DB 01H
__84A6C509_regex_traits_defaults@hpp DB 01H
__C72864EE_pattern_except@hpp DB 01H
__8A32E06C_stop_token DB 01H
__1806803A_thread DB 01H
__1EA2E370_mutex DB 01H
__BC8232E2_cpp_regex_traits@hpp DB 01H
__EF9A24B2_c_regex_traits@hpp DB 01H
__79C7FC57_basetsd@h DB 01H
__D545DD43_guiddef@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__D4435474_winerror@h DB 01H
__B3ED30D4_winbase@h DB 01H
__DB057BA3_winuser@h DB 01H
__A118E6DC_stralign@h DB 01H
__43AE03FC_w32_regex_traits@hpp DB 01H
__ED044598_match_flags@hpp DB 01H
__9829EA86_regex_raw_buffer@hpp DB 01H
__BA42420E_basic_regex@hpp DB 01H
__F162022C_set DB 01H
__3C41319C_indexed_bit_flag@hpp DB 01H
__A750400E_basic_regex_creator@hpp DB 01H
__CFA0C522_basic_regex_parser@hpp DB 01H
__23D98615_mem_block_cache@hpp DB 01H
__0A52C9A5_perl_matcher_non_recursive@hpp DB 01H
__C1A77E9F_perl_matcher@hpp DB 01H
__28BBFA9C_RessourcePack@h DB 01H
__3C1C7D88_ContextSettings@hpp DB 01H
__8D991C03_Drawable@hpp DB 01H
__896EE8A8_Glyph@hpp DB 01H
__E3A1A8C3_Font@hpp DB 01H
__5808F286_Player@h DB 01H
__372D2D08_initializer_list DB 01H
__E458E21C_xstddef DB 01H
__218DFE2C_Levels@h DB 01H
__9344C8DF_Block@h DB 01H
__78BC29F0_TerrainConstructor@h DB 01H
__9D99E827_Terrain@h DB 01H
__B4613F23_Sprite@hpp DB 01H
__4FA62C6D_Univers@h DB 01H
__91E4D184_Univers@cpp DB 01H
__A2FF0B9E_istream DB 01H
__FA839AC8_operator_bool@hpp DB 01H
__0FFFED91_intrusive_ptr@hpp DB 01H
__B38B2551_iterator_facade@hpp DB 01H
__68A60A21_locale DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__038A2AA6_iterator DB 01H
__B30C2184_iosfwd DB 01H
__0A631FEE_Vector2@inl DB 01H
__CBE11649_Vector2@hpp DB 01H
__C23CD225_Rect@inl DB 01H
__03BEDB82_Rect@hpp DB 01H
__F1CBF088_type_index@hpp DB 01H
__68C17CDA_primary_transform@hpp DB 01H
__F54903A0_xatomic@h DB 01H
__1CB4EB11_addressof@hpp DB 01H
__1EB17C13_integral_constant@hpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	__vfprintf_l
PUBLIC	_printf
PUBLIC	_wmemcpy
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	??0?$tuple@$$V@std@@QAE@ABV01@@Z		; std::tuple<>::tuple<>
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked
PUBLIC	?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Char_traits@DH@std@@SAPADQADID@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??1invalid_argument@std@@UAE@XZ			; std::invalid_argument::~invalid_argument
PUBLIC	??$forward@ABI@std@@YAABIABI@Z			; std::forward<unsigned int const &>
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z	; sf::Rect<int>::Rect<int>
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??0?$allocator@_N@std@@QAE@XZ			; std::allocator<bool>::allocator<bool>
PUBLIC	?deallocate@?$allocator@I@std@@QAEXQAII@Z	; std::allocator<unsigned int>::deallocate
PUBLIC	?allocate@?$allocator@I@std@@QAEPAII@Z		; std::allocator<unsigned int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
PUBLIC	??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
PUBLIC	?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
PUBLIC	?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
PUBLIC	?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
PUBLIC	?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
PUBLIC	?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
PUBLIC	?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
PUBLIC	?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
PUBLIC	?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
PUBLIC	??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
PUBLIC	?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range
PUBLIC	?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
PUBLIC	?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
PUBLIC	?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
PUBLIC	?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim
PUBLIC	?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
PUBLIC	?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xran
PUBLIC	?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::__autoclassinit2
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
PUBLIC	??0?$initializer_list@H@std@@QAE@PBH0@Z		; std::initializer_list<int>::initializer_list<int>
PUBLIC	?begin@?$initializer_list@H@std@@QBEPBHXZ	; std::initializer_list<int>::begin
PUBLIC	?end@?$initializer_list@H@std@@QBEPBHXZ		; std::initializer_list<int>::end
PUBLIC	??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
PUBLIC	?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
PUBLIC	??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
PUBLIC	?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
PUBLIC	?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
PUBLIC	??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z ; RessourcePack::getImgBackground
PUBLIC	?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z ; RessourcePack::getLevelMusic
PUBLIC	?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
PUBLIC	?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
PUBLIC	?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
PUBLIC	?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
PUBLIC	?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange
PUBLIC	??0?$Rect@M@sf@@QAE@MMMM@Z			; sf::Rect<float>::Rect<float>
PUBLIC	??_GSprite@sf@@UAEPAXI@Z			; sf::Sprite::`scalar deleting destructor'
PUBLIC	?show@Player@@QAEXPAVRenderWindow@sf@@@Z	; Player::show
PUBLIC	?getRect@Player@@QAE?AV?$Rect@H@sf@@XZ		; Player::getRect
PUBLIC	?getX@Player@@QAEHXZ				; Player::getX
PUBLIC	?getY@Player@@QAEHXZ				; Player::getY
PUBLIC	?setMaxX@Player@@QAEXH@Z			; Player::setMaxX
PUBLIC	?getSize@Player@@QAE?AV?$Vector2@I@sf@@XZ	; Player::getSize
PUBLIC	?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
PUBLIC	?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
PUBLIC	??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
PUBLIC	?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
PUBLIC	?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
PUBLIC	?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
PUBLIC	?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
PUBLIC	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
PUBLIC	??$distance@PBH@std@@YAHPBH0@Z			; std::distance<int const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z	; std::_Get_unwrapped<int const * const &>
PUBLIC	??$to_address@$$CBH@std@@YAPBHQBH@Z		; std::to_address<int const >
PUBLIC	??$to_address@H@std@@YAPAHQAH@Z			; std::to_address<int>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z	; std::_Copy_memmove<int const *,int *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$construct_at@HABHX@std@@YAPAHQAHABH@Z	; std::construct_at<int,int const &,void>
PUBLIC	??$_Voidify_iter@PAH@std@@YAPAXPAH@Z		; std::_Voidify_iter<int *>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
PUBLIC	??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
PUBLIC	??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
PUBLIC	??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
PUBLIC	??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
PUBLIC	??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
PUBLIC	??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z	; std::construct_at<int,int &,void>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
PUBLIC	?getX@Block@@QAEHXZ				; Block::getX
PUBLIC	?getY@Block@@QAEHXZ				; Block::getY
PUBLIC	?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ	; TerrainConstructor::getPlayer
PUBLIC	?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
PUBLIC	?getPlayer@Terrain@@QAEPAVPlayer@@XZ		; Terrain::getPlayer
PUBLIC	?getSizeX@Terrain@@QAEIXZ			; Terrain::getSizeX
PUBLIC	?getSizeY@Terrain@@QAEIXZ			; Terrain::getSizeY
PUBLIC	?__autoclassinit2@Terrain@@QAEXI@Z		; Terrain::__autoclassinit2
PUBLIC	??_GTerrain@@QAEPAXI@Z				; Terrain::`scalar deleting destructor'
PUBLIC	?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
PUBLIC	??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z		; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>
PUBLIC	?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ; std::tuple<enum DIRDEP>::_Get_rest
PUBLIC	??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z	; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>
PUBLIC	?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
PUBLIC	??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z ; Univers::Univers
PUBLIC	?animate@Univers@@QAEXXZ			; Univers::animate
PUBLIC	?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVPlayer@@@Z ; Univers::collision
PUBLIC	?loadTerrain@Univers@@QAEXH@Z			; Univers::loadTerrain
PUBLIC	??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
PUBLIC	??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP>
PUBLIC	??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
PUBLIC	??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
PUBLIC	??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
PUBLIC	??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
PUBLIC	??0?$Vector2@H@sf@@QAE@HH@Z			; sf::Vector2<int>::Vector2<int>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YAII@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset
PUBLIC	??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
PUBLIC	??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::__autoclassinit2
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
PUBLIC	??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2
PUBLIC	??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
PUBLIC	??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
PUBLIC	??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z	; std::_Move_unchecked<unsigned int *,unsigned int *>
PUBLIC	??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >
PUBLIC	??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
PUBLIC	??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
PUBLIC	??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>
PUBLIC	??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$construct_at@DABDX@std@@YAPADQADABD@Z	; std::construct_at<char,char const &,void>
PUBLIC	??$_Voidify_iter@PAD@std@@YAPAXPAD@Z		; std::_Voidify_iter<char *>
PUBLIC	??$forward@ABD@std@@YAABDABD@Z			; std::forward<char const &>
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
PUBLIC	??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z	; std::_Unfancy_maybe_null<unsigned int>
PUBLIC	??$_To_address@PBH@std@@YA?A_PABQBH@Z		; std::_To_address<int const *>
PUBLIC	??$_To_address@PAH@std@@YA?A_PABQAH@Z		; std::_To_address<int *>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
PUBLIC	??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z ; std::forward<std::tuple<enum DIRDEP> >
PUBLIC	??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>
PUBLIC	??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>
PUBLIC	??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
PUBLIC	??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>
PUBLIC	??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$move@AAI@std@@YA$$QAIAAI@Z			; std::move<unsigned int &>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &,void>
PUBLIC	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	??$to_address@I@std@@YAPAIQAI@Z			; std::to_address<unsigned int>
PUBLIC	??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z	; std::_Copy_memmove<unsigned int *,unsigned int *>
PUBLIC	??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ; std::forward<std::allocator<unsigned int> >
PUBLIC	??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
PUBLIC	??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z ; std::forward<std::allocator<unsigned int> const &>
PUBLIC	??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
PUBLIC	??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>
PUBLIC	??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>
PUBLIC	??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>
PUBLIC	??$_To_address@PAI@std@@YA?A_PABQAI@Z		; std::_To_address<unsigned int *>
PUBLIC	??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z	; std::_Get_unwrapped<unsigned int * const &>
PUBLIC	??$_Unfancy@I@std@@YAPAIPAI@Z			; std::_Unfancy<unsigned int>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::__autoclassinit2
PUBLIC	??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>
PUBLIC	??$_Is_all_bits_zero@I@std@@YA_NABI@Z		; std::_Is_all_bits_zero<unsigned int>
PUBLIC	??$_Fill_zero_memset@PAI@std@@YAXPAII@Z		; std::_Fill_zero_memset<unsigned int *>
PUBLIC	??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>
PUBLIC	??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
PUBLIC	??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
PUBLIC	??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
PUBLIC	??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>
PUBLIC	??$forward@AAI@std@@YAAAIAAI@Z			; std::forward<unsigned int &>
PUBLIC	??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>
PUBLIC	??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
PUBLIC	??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
PUBLIC	??$construct_at@IABIX@std@@YAPAIQAIABI@Z	; std::construct_at<unsigned int,unsigned int const &,void>
PUBLIC	??$_Voidify_iter@PAI@std@@YAPAXPAI@Z		; std::_Voidify_iter<unsigned int *>
PUBLIC	??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z	; std::construct_at<unsigned int,unsigned int &,void>
PUBLIC	??_ESprite@sf@@W3AEPAXI@Z			; [thunk]:sf::Sprite::`vector deleting destructor'
PUBLIC	__JustMyCode_Default
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_SSprite@sf@@6BDrawable@1@@			; sf::Sprite::`local vftable'
PUBLIC	??_SSprite@sf@@6BTransformable@1@@		; sf::Sprite::`local vftable'
PUBLIC	?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
PUBLIC	??_R0?AVinvalid_argument@std@@@8		; std::invalid_argument `RTTI Type Descriptor'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
PUBLIC	??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ ; `string'
PUBLIC	??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ ; `string'
PUBLIC	??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ ; `string'
PUBLIC	??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ ; `string'
PUBLIC	??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ ; `string'
PUBLIC	??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@ ; `string'
PUBLIC	??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ ; `string'
PUBLIC	??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ ; `string'
PUBLIC	??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ ; `string'
PUBLIC	??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ ; `string'
PUBLIC	??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@ ; `string'
PUBLIC	??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ ; `string'
PUBLIC	??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@ ; `string'
PUBLIC	??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@ ; `string'
PUBLIC	??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ ; `string'
PUBLIC	??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@ ; `string'
PUBLIC	??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ ; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Sprite@sf@@6BDrawable@1@@			; sf::Sprite::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSprite@sf@@@8				; sf::Sprite `RTTI Type Descriptor'
PUBLIC	??_R3Sprite@sf@@8				; sf::Sprite::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Sprite@sf@@8				; sf::Sprite::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Sprite@sf@@8			; sf::Sprite::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Drawable@sf@@8			; sf::Drawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDrawable@sf@@@8				; sf::Drawable `RTTI Type Descriptor'
PUBLIC	??_R3Drawable@sf@@8				; sf::Drawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Drawable@sf@@8				; sf::Drawable::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@Transformable@sf@@8		; sf::Transformable::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVTransformable@sf@@@8			; sf::Transformable `RTTI Type Descriptor'
PUBLIC	??_R3Transformable@sf@@8			; sf::Transformable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Transformable@sf@@8			; sf::Transformable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Transformable@sf@@8		; sf::Transformable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Sprite@sf@@6BTransformable@1@@		; sf::Sprite::`RTTI Complete Object Locator'
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp____acrt_iob_func:PROC
EXTRN	__imp____stdio_common_vfprintf:PROC
EXTRN	_memcmp:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	?uncaught_exceptions@std@@YAHXZ:PROC		; std::uncaught_exceptions
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_??0Color@sf@@QAE@EEEE@Z:PROC
EXTRN	__imp_??0Clock@sf@@QAE@XZ:PROC
EXTRN	__imp_?setLoop@SoundStream@sf@@QAEX_N@Z:PROC
EXTRN	?generateImg@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; RessourcePack::generateImg
EXTRN	?generateBackgrounds@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; RessourcePack::generateBackgrounds
EXTRN	?generateAudioData@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC ; RessourcePack::generateAudioData
EXTRN	__imp_?close@Window@sf@@QAEXXZ:PROC
EXTRN	__imp_?isOpen@Window@sf@@QBE_NXZ:PROC
EXTRN	__imp_?pollEvent@Window@sf@@QAE_NAAVEvent@2@@Z:PROC
EXTRN	__imp_?display@Window@sf@@QAEXXZ:PROC
EXTRN	__imp_??0Texture@sf@@QAE@XZ:PROC
EXTRN	__imp_?loadFromImage@Texture@sf@@QAE_NABVImage@2@ABV?$Rect@H@2@@Z:PROC
EXTRN	__imp_?setSmooth@Texture@sf@@QAEX_N@Z:PROC
EXTRN	__imp_?setRepeated@Texture@sf@@QAEX_N@Z:PROC
EXTRN	__imp_??0View@sf@@QAE@ABV?$Rect@M@1@@Z:PROC
EXTRN	__imp_?clear@RenderTarget@sf@@QAEXABVColor@2@@Z:PROC
EXTRN	__imp_?setView@RenderTarget@sf@@QAEXABVView@2@@Z:PROC
EXTRN	__imp_?draw@RenderTarget@sf@@QAEXABVDrawable@2@ABVRenderStates@2@@Z:PROC
EXTRN	__imp_??0Sprite@sf@@QAE@ABVTexture@1@@Z:PROC
EXTRN	__imp_??1Sprite@sf@@UAE@XZ:PROC
EXTRN	??_ESprite@sf@@UAEPAXI@Z:PROC			; sf::Sprite::`vector deleting destructor'
EXTRN	?move@Player@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z:PROC ; Player::move
EXTRN	?show@Block@@QAEXPAVRenderWindow@sf@@@Z:PROC	; Block::show
EXTRN	?collide@Block@@QAE_NV?$Rect@H@sf@@@Z:PROC	; Block::collide
EXTRN	??0Terrain@@QAE@PAVRessourcePack@@@Z:PROC	; Terrain::Terrain
EXTRN	?loadTerrain@Terrain@@QAEXH@Z:PROC		; Terrain::loadTerrain
EXTRN	??1Terrain@@QAE@XZ:PROC				; Terrain::~Terrain
EXTRN	?draw@Sprite@sf@@EBEXAAVRenderTarget@2@VRenderStates@2@@Z:PROC ; sf::Sprite::draw
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?Default@RenderStates@sf@@2V12@B:BYTE
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A
_BSS	SEGMENT
?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 010H DUP (?) ; level1
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?level1$initializer$@@3P6AXXZA DD FLAT:??__Elevel1@@YAXXZ ; level1$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R4Sprite@sf@@6BTransformable@1@@
rdata$r	SEGMENT
??_R4Sprite@sf@@6BTransformable@1@@ DD 00H		; sf::Sprite::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVSprite@sf@@@8
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Transformable@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Transformable@sf@@8 DD FLAT:??_R0?AVTransformable@sf@@@8 ; sf::Transformable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Transformable@sf@@8
rdata$r	SEGMENT
??_R2Transformable@sf@@8 DD FLAT:??_R1A@?0A@EA@Transformable@sf@@8 ; sf::Transformable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Transformable@sf@@8
rdata$r	SEGMENT
??_R3Transformable@sf@@8 DD 00H				; sf::Transformable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTransformable@sf@@@8
data$rs	SEGMENT
??_R0?AVTransformable@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Transformable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTransformable@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@Transformable@sf@@8
rdata$r	SEGMENT
??_R13?0A@EA@Transformable@sf@@8 DD FLAT:??_R0?AVTransformable@sf@@@8 ; sf::Transformable::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Drawable@sf@@8
rdata$r	SEGMENT
??_R2Drawable@sf@@8 DD FLAT:??_R1A@?0A@EA@Drawable@sf@@8 ; sf::Drawable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Drawable@sf@@8
rdata$r	SEGMENT
??_R3Drawable@sf@@8 DD 00H				; sf::Drawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Drawable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawable@sf@@@8
data$rs	SEGMENT
??_R0?AVDrawable@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Drawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawable@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Drawable@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Drawable@sf@@8 DD FLAT:??_R0?AVDrawable@sf@@@8 ; sf::Drawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Drawable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Sprite@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Sprite@sf@@8 DD FLAT:??_R0?AVSprite@sf@@@8 ; sf::Sprite::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Sprite@sf@@8
rdata$r	SEGMENT
??_R2Sprite@sf@@8 DD FLAT:??_R1A@?0A@EA@Sprite@sf@@8	; sf::Sprite::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Drawable@sf@@8
	DD	FLAT:??_R13?0A@EA@Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R3Sprite@sf@@8
rdata$r	SEGMENT
??_R3Sprite@sf@@8 DD 00H				; sf::Sprite::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSprite@sf@@@8
data$rs	SEGMENT
??_R0?AVSprite@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Sprite `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSprite@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Sprite@sf@@6BDrawable@1@@
rdata$r	SEGMENT
??_R4Sprite@sf@@6BDrawable@1@@ DD 00H			; sf::Sprite::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSprite@sf@@@8
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
CONST	SEGMENT
??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'e', 00H, 'k', 00H, ' ', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'a', 00H, 'f', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, ' ', 00H, 'e', 00H, 'n', 00H, 'd', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@
CONST	SEGMENT
??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@ DB 'cannot seek v'
	DB	'ector iterator after end', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
CONST	SEGMENT
??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'e', 00H, 'k', 00H, ' ', 00H, 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'f', 00H, 'o', 00H
	DB	'r', 00H, 'e', 00H, ' ', 00H, 'b', 00H, 'e', 00H, 'g', 00H, 'i'
	DB	00H, 'n', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@
CONST	SEGMENT
??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@ DB 'cannot seek v'
	DB	'ector iterator before begin', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@
CONST	SEGMENT
??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 's', 00H, 'e', 00H, 'e', 00H, 'k', 00H, ' ', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i', 00H
	DB	'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
CONST	SEGMENT
??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'r', 00H, 'i', 00H, 'f', 00H, 'y', 00H, '_', 00H, 'o'
	DB	00H, 'f', 00H, 'f', 00H, 's', 00H, 'e', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@
CONST	SEGMENT
??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@ DB 'cannot seek v'
	DB	'alue-initialized vector iterator', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's'
	DB	00H, 'i', 00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
CONST	SEGMENT
??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 's', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
CONST	SEGMENT
??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@ DB 'vector erase '
	DB	'iterator outside range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
CONST	SEGMENT
??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	' ', 00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r'
	DB	00H, 'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H
	DB	't', 00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a'
	DB	00H, 'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
CONST	SEGMENT
??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, ',', 00H, 'c', 00H, 'l'
	DB	00H, 'a', 00H, 's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H
	DB	'd', 00H, ':', 00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H
	DB	'u', 00H, 'n', 00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e'
	DB	00H, 'd', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H
	DB	' ', 00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e'
	DB	00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'[', 00H, ']', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
CONST	SEGMENT
??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@ DB 'vector subscrip'
	DB	't out of range', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@ DB 'vector<bool> too lo'
	DB	'ng', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
CONST	SEGMENT
??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'W', 00H, 'r', 00H
	DB	'a', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n', 00H, 's'
	DB	00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' '
	DB	00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
CONST	SEGMENT
??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H
	DB	':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
CONST	SEGMENT
??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DB 'vector<'
	DB	'bool> subscript out of range', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
CONST	SEGMENT
??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DB 'invalid ve'
	DB	'ctor<bool> subscript', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '"', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
CONST	SEGMENT
??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DB 'vector<b'
	DB	'ool> iterator not dereferenceable', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'"', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'b', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, '<', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'W', 00H
	DB	'r', 00H, 'a', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'G', 00H
	DB	'e', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized vector<bool> iterator', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\vector', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_R0?AVinvalid_argument@std@@@8
data$r	SEGMENT
??_R0?AVinvalid_argument@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::invalid_argument `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVinvalid_argument@std@@', 00H
data$r	ENDS
;	COMDAT ??_SSprite@sf@@6BTransformable@1@@
CONST	SEGMENT
??_SSprite@sf@@6BTransformable@1@@ DD FLAT:??_R4Sprite@sf@@6BTransformable@1@@ ; sf::Sprite::`local vftable'
	DD	FLAT:??_ESprite@sf@@W3AEPAXI@Z
CONST	ENDS
;	COMDAT ??_SSprite@sf@@6BDrawable@1@@
CONST	SEGMENT
??_SSprite@sf@@6BDrawable@1@@ DD FLAT:??_R4Sprite@sf@@6BDrawable@1@@ ; sf::Sprite::`local vftable'
	DD	FLAT:??_ESprite@sf@@UAEPAXI@Z
	DD	FLAT:?draw@Sprite@sf@@EBEXAAVRenderTarget@2@VRenderStates@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocnum', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocale', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
CONST	SEGMENT
??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'I', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '_', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '1', 00H
	DB	'2', 00H, ':', 00H, ':', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'p'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, '_', 00H, 'm', 00H, 'e', 00H
	DB	'_', 00H, 'u', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, 'e', 00H, 'd', 00H, '_', 00H, 'v', 00H, '3', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xmemory', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	06fH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	035H
	DW	0108H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z$0
__ehfuncinfo$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	012bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02dH
	DB	0fbH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$1
__ehfuncinfo$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02aH
	DW	0139H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	081H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	0454H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$0
	DD	047H
	DD	054H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?loadTerrain@Univers@@QAEXH@Z
	DD	034H
	DD	04aaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVPlayer@@@Z
	DD	026H
	DD	02f0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?animate@Univers@@QAEXXZ$2
	DD	016H
	DD	023H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:?animate@Univers@@QAEXXZ
	DD	036H
	DD	0583H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$2
	DD	025H
	DD	02fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
	DD	030H
	DD	021dH
voltbl	ENDS
xdata$x	SEGMENT
__catchsym$?animate@Univers@@QAEXXZ$4 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	0ffffffc0H
	DD	FLAT:__catch$?animate@Univers@@QAEXXZ$0
__catchsym$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$7 DD 00H
	DD	FLAT:??_R0?AVinvalid_argument@std@@@8
	DD	0ffffffd8H
	DD	FLAT:__catch$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$0
__tryblocktable$?animate@Univers@@QAEXXZ DD 00H
	DD	00H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?animate@Univers@@QAEXXZ$4
__tryblocktable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DD 01H
	DD	01H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$7
__unwindtable$?loadTerrain@Univers@@QAEXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$2
__unwindtable$?animate@Univers@@QAEXXZ DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	FLAT:__unwindfunclet$?animate@Univers@@QAEXXZ$2
__unwindtable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$2
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	02H
	DD	FLAT:__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$6
__ehfuncinfo$?loadTerrain@Univers@@QAEXH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?loadTerrain@Univers@@QAEXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$?animate@Univers@@QAEXXZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?animate@Univers@@QAEXXZ
	DD	01H
	DD	FLAT:__tryblocktable$?animate@Univers@@QAEXXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__ehfuncinfo$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0a4H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__Elevel1@@YAXXZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$??__Elevel1@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__Elevel1@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$14
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	012bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	03bH
	DB	0ebH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
	DB	0dfH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	03bH
	DW	012bH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	035H
	DB	0dfH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	08bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0ffH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	08bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0153H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0ffH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02bH
	DB	0f3H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z$0
__ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	02aH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	030H
	DB	0abH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	08bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02dH
	DW	0153H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	027H
	DB	096H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z$0
__ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	0160H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	086H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02dH
	DB	0a1H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	028H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02dH
	DB	0dbH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	072H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	076H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	076H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	072H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odsp /RTCsu
;	COMDAT ??_ESprite@sf@@W3AEPAXI@Z
_TEXT	SEGMENT
??_ESprite@sf@@W3AEPAXI@Z PROC				; [thunk]:sf::Sprite::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_ESprite@sf@@UAEPAXI@Z
??_ESprite@sf@@W3AEPAXI@Z ENDP				; [thunk]:sf::Sprite::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z PROC		; std::construct_at<unsigned int,unsigned int &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  00038	83 c4 04	 add	 esp, 4
  0003b	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 02		 mov	 DWORD PTR [edx], eax
  00042	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z ENDP		; std::construct_at<unsigned int,unsigned int &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAI@std@@YAPAXPAI@Z PROC		; std::_Voidify_iter<unsigned int *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ENDP		; std::_Voidify_iter<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@IABIX@std@@YAPAIQAIABI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@IABIX@std@@YAPAIQAIABI@Z PROC		; std::construct_at<unsigned int,unsigned int const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  00038	83 c4 04	 add	 esp, 4
  0003b	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 02		 mov	 DWORD PTR [edx], eax
  00042	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$construct_at@IABIX@std@@YAPAIQAIABI@Z ENDP		; std::construct_at<unsigned int,unsigned int const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z PROC ; std::tuple<>::tuple<><std::_Exact_args_t,0>, COMDAT
; _this$ = ecx

; 226  :     constexpr tuple(_Tag) noexcept /* strengthened */ {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ENDP ; std::tuple<>::tuple<><std::_Exact_args_t,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00015	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$construct_at@IABIX@std@@YAPAIQAIABI@Z ; std::construct_at<unsigned int,unsigned int const &,void>
  00037	83 c4 08	 add	 esp, 8

; 711  :         } else

  0003a	eb 2d		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  0005f	83 c4 04	 add	 esp, 4
  00062	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 02		 mov	 DWORD PTR [edx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  00069	83 c4 04	 add	 esp, 4
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00015	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$construct_at@IAAIX@std@@YAPAIQAIAAI@Z ; std::construct_at<unsigned int,unsigned int &,void>
  00037	83 c4 08	 add	 esp, 8

; 711  :         } else

  0003a	eb 2d		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAI@std@@YAPAXPAI@Z ; std::_Voidify_iter<unsigned int *>
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  0005f	83 c4 04	 add	 esp, 4
  00062	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 02		 mov	 DWORD PTR [edx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  00069	83 c4 04	 add	 esp, 4
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAI@std@@YAAAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAI@std@@YAAAIAAI@Z PROC			; std::forward<unsigned int &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@AAI@std@@YAAAIAAI@Z ENDP			; std::forward<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z
_TEXT	SEGMENT
tv77 = -12						; size = 4
$T1 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z PROC ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f b6 45 fb	 movzx	 eax, BYTE PTR $T1[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 4d f4	 mov	 DWORD PTR tv77[ebp], ecx
  0003b	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z ENDP ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z PROC ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>, COMDAT
; _this$ = ecx

; 170  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	89 11		 mov	 DWORD PTR [ecx], edx
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ENDP ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Arg$ = 8						; size = 4
??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z PROC ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>, COMDAT
; _this$ = ecx

; 170  :     constexpr _Tuple_val(_Other&& _Arg) : _Val(_STD forward<_Other>(_Arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	89 11		 mov	 DWORD PTR [ecx], edx
  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c2 04 00	 ret	 4
??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ENDP ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z
_TEXT	SEGMENT
tv77 = -12						; size = 4
$T1 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z PROC ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	0f b6 45 fb	 movzx	 eax, BYTE PTR $T1[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@$0A@@?$tuple@$$V@std@@QAE@U_Exact_args_t@1@@Z ; std::tuple<>::tuple<><std::_Exact_args_t,0>
  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	89 4d f4	 mov	 DWORD PTR tv77[ebp], ecx
  0003b	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  0003e	52		 push	 edx
  0003f	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00044	83 c4 04	 add	 esp, 4
  00047	50		 push	 eax
  00048	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
  00050	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c2 08 00	 ret	 8
??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ENDP ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z
_TEXT	SEGMENT
tv74 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00024	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@ABI@std@@YAABIABI@Z ; std::forward<unsigned int const &>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00051	52		 push	 edx
  00052	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00055	50		 push	 eax
  00056	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$construct@IABI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIABI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int const &>
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	83 c0 04	 add	 eax, 4
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1633 :     }

  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Fill_zero_memset@PAI@std@@YAXPAII@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
??$_Fill_zero_memset@PAI@std@@YAXPAII@Z PROC		; std::_Fill_zero_memset<unsigned int *>, COMDAT

; 4558 : void _Fill_zero_memset(_CtgIt _Dest, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4559 :     _CSTD memset(_To_address(_Dest), 0, _Count * sizeof(_Iter_value_t<_CtgIt>));

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00010	c1 e0 02	 shl	 eax, 2
  00013	50		 push	 eax
  00014	6a 00		 push	 0
  00016	8d 4d 08	 lea	 ecx, DWORD PTR __Dest$[ebp]
  00019	51		 push	 ecx
  0001a	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  0001f	83 c4 04	 add	 esp, 4
  00022	50		 push	 eax
  00023	e8 00 00 00 00	 call	 _memset
  00028	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4560 : }

  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
??$_Fill_zero_memset@PAI@std@@YAXPAII@Z ENDP		; std::_Fill_zero_memset<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Is_all_bits_zero@I@std@@YA_NABI@Z
_TEXT	SEGMENT
tv69 = -20						; size = 4
__Zero$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Val$ = 8						; size = 4
??$_Is_all_bits_zero@I@std@@YA_NABI@Z PROC		; std::_Is_all_bits_zero<unsigned int>, COMDAT

; 4563 : _NODISCARD bool _Is_all_bits_zero(const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00029	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4564 :     // checks if scalar type has all bits set to zero
; 4565 :     _STL_INTERNAL_STATIC_ASSERT(is_scalar_v<_Ty> && !is_member_pointer_v<_Ty>);
; 4566 :     constexpr _Ty _Zero{};

  0002e	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Zero$[ebp], 0

; 4567 :     return _CSTD memcmp(&_Val, &_Zero, sizeof(_Ty)) == 0;

  00035	6a 04		 push	 4
  00037	8d 45 f4	 lea	 eax, DWORD PTR __Zero$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d 08	 mov	 ecx, DWORD PTR __Val$[ebp]
  0003e	51		 push	 ecx
  0003f	e8 00 00 00 00	 call	 _memcmp
  00044	83 c4 0c	 add	 esp, 12			; 0000000cH
  00047	85 c0		 test	 eax, eax
  00049	75 09		 jne	 SHORT $LN3@Is_all_bit
  0004b	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00052	eb 07		 jmp	 SHORT $LN4@Is_all_bit
$LN3@Is_all_bit:
  00054	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN4@Is_all_bit:
  0005b	8a 45 ec	 mov	 al, BYTE PTR tv69[ebp]

; 4568 : }

  0005e	52		 push	 edx
  0005f	8b cd		 mov	 ecx, ebp
  00061	50		 push	 eax
  00062	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Is_all_bit
  00068	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006d	58		 pop	 eax
  0006e	5a		 pop	 edx
  0006f	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00072	33 cd		 xor	 ecx, ebp
  00074	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00079	83 c4 14	 add	 esp, 20			; 00000014H
  0007c	3b ec		 cmp	 ebp, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
  00087	90		 npad	 1
$LN7@Is_all_bit:
  00088	01 00 00 00	 DD	 1
  0008c	00 00 00 00	 DD	 $LN6@Is_all_bit
$LN6@Is_all_bit:
  00090	f4 ff ff ff	 DD	 -12			; fffffff4H
  00094	04 00 00 00	 DD	 4
  00098	00 00 00 00	 DD	 $LN5@Is_all_bit
$LN5@Is_all_bit:
  0009c	5f		 DB	 95			; 0000005fH
  0009d	5a		 DB	 90			; 0000005aH
  0009e	65		 DB	 101			; 00000065H
  0009f	72		 DB	 114			; 00000072H
  000a0	6f		 DB	 111			; 0000006fH
  000a1	00		 DB	 0
??$_Is_all_bits_zero@I@std@@YA_NABI@Z ENDP		; std::_Is_all_bits_zero<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z
_TEXT	SEGMENT
tv74 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00024	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@AAI@std@@YAAAIAAI@Z ; std::forward<unsigned int &>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00051	52		 push	 edx
  00052	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00055	50		 push	 eax
  00056	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$construct@IAAI@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAXAAV?$allocator@I@1@QAIAAI@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::construct<unsigned int,unsigned int &>
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	83 c0 04	 add	 eax, 4
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1633 :     }

  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1638 :     }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00026	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  0002f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@I@std@@YAPAIPAI@Z PROC			; std::_Unfancy<unsigned int>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Unfancy@I@std@@YAPAIPAI@Z ENDP			; std::_Unfancy<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z PROC		; std::_Get_unwrapped<unsigned int * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z ENDP		; std::_Get_unwrapped<unsigned int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAI@std@@YA?A_PABQAI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAI@std@@YA?A_PABQAI@Z PROC		; std::_To_address<unsigned int *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@I@std@@YAPAIQAI@Z ; std::to_address<unsigned int>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_To_address@PAI@std@@YA?A_PABQAI@Z ENDP		; std::_To_address<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv76 = -12						; size = 4
$T1 = -6						; size = 1
$T2 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00024	8b 45 10	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00033	8a 4d fb	 mov	 cl, BYTE PTR $T2[ebp]
  00036	88 4d fa	 mov	 BYTE PTR $T1[ebp], cl
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  0003c	52		 push	 edx
  0003d	0f b6 45 fa	 movzx	 eax, BYTE PTR $T1[ebp]
  00041	50		 push	 eax
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,0>
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	89 4d f0	 mov	 DWORD PTR tv83[ebp], ecx
  00053	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0005c	83 c4 04	 add	 esp, 4
  0005f	50		 push	 eax
  00060	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00063	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv76 = -12						; size = 4
$T1 = -6						; size = 1
$T2 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00024	8b 45 10	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00033	8a 4d fb	 mov	 cl, BYTE PTR $T2[ebp]
  00036	88 4d fa	 mov	 BYTE PTR $T1[ebp], cl
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  0003c	52		 push	 edx
  0003d	0f b6 45 fa	 movzx	 eax, BYTE PTR $T1[ebp]
  00041	50		 push	 eax
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	89 4d f0	 mov	 DWORD PTR tv83[ebp], ecx
  00053	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0005c	83 c4 04	 add	 esp, 4
  0005f	50		 push	 eax
  00060	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00063	e8 00 00 00 00	 call	 ??$?0AAW4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@AAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP &>
  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z
_TEXT	SEGMENT
tv83 = -16						; size = 4
tv76 = -12						; size = 4
$T1 = -6						; size = 1
$T2 = -5						; size = 1
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__This_arg$ = 12					; size = 4
_<_Rest_arg_0>$ = 16					; size = 4
??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 258  :         : _Mybase(_Exact_args_t{}, _STD forward<_Rest2>(_Rest_arg)...), _Myfirst(_STD forward<_This2>(_This_arg)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00024	8b 45 10	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00033	8a 4d fb	 mov	 cl, BYTE PTR $T2[ebp]
  00036	88 4d fa	 mov	 BYTE PTR $T1[ebp], cl
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  0003c	52		 push	 edx
  0003d	0f b6 45 fa	 movzx	 eax, BYTE PTR $T1[ebp]
  00041	50		 push	 eax
  00042	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@$$V$0A@@?$tuple@W4DIRDEP@@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP><std::_Exact_args_t,enum DIRDEP,0>
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	89 4d f0	 mov	 DWORD PTR tv83[ebp], ecx
  00053	8b 55 0c	 mov	 edx, DWORD PTR __This_arg$[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0005c	83 c4 04	 add	 esp, 4
  0005f	50		 push	 eax
  00060	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00063	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@@?$_Tuple_val@W4DIRDEP@@@std@@QAE@$$QAW4DIRDEP@@@Z ; std::_Tuple_val<enum DIRDEP>::_Tuple_val<enum DIRDEP><enum DIRDEP>
  00068	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0006b	83 c4 10	 add	 esp, 16			; 00000010H
  0006e	3b ec		 cmp	 ebp, esp
  00070	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00075	8b e5		 mov	 esp, ebp
  00077	5d		 pop	 ebp
  00078	c2 0c 00	 ret	 12			; 0000000cH
??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z PROC ; std::forward<std::tuple<> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ENDP ; std::forward<std::tuple<> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 693  :     static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 694  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 695  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 696  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN2@deallocate

; 697  :             _Al.deallocate(_Ptr, _Count);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00024	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 698  :         } else

  00029	eb 13		 jmp	 SHORT $LN1@deallocate
$LN2@deallocate:

; 699  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 700  :         {
; 701  :             (void) _Al;
; 702  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	c1 e0 03	 shl	 eax, 3
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003b	83 c4 08	 add	 esp, 8
$LN1@deallocate:

; 703  :         }
; 704  :     }

  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
$T2 = -40						; size = 4
__Backout$ = -32					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z PROC ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >, COMDAT

; 1741 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00022	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00025	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00028	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00047	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1742 :     // copy _Count copies of _Val to raw _First, using _Al
; 1743 :     using _Ty = typename _Alloc::value_type;
; 1744 :     if constexpr (_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1745 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1746 :         if (!_STD is_constant_evaluated())
; 1747 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1748 :         {
; 1749 :             _Fill_memset(_Unfancy(_First), _Val, static_cast<size_t>(_Count));
; 1750 :             return _First + _Count;
; 1751 :         }
; 1752 :     } else if constexpr (_Fill_zero_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value) {
; 1753 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1754 :         if (!_STD is_constant_evaluated())

  0004c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00051	0f b6 c0	 movzx	 eax, al
  00054	85 c0		 test	 eax, eax
  00056	75 37		 jne	 SHORT $LN5@Uninitiali

; 1755 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1756 :         {
; 1757 :             if (_Is_all_bits_zero(_Val)) {

  00058	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  0005b	51		 push	 ecx
  0005c	e8 00 00 00 00	 call	 ??$_Is_all_bits_zero@I@std@@YA_NABI@Z ; std::_Is_all_bits_zero<unsigned int>
  00061	83 c4 04	 add	 esp, 4
  00064	0f b6 d0	 movzx	 edx, al
  00067	85 d2		 test	 edx, edx
  00069	74 24		 je	 SHORT $LN5@Uninitiali

; 1758 :                 _Fill_zero_memset(_Unfancy(_First), static_cast<size_t>(_Count));

  0006b	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0006e	50		 push	 eax
  0006f	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  00078	83 c4 04	 add	 esp, 4
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ??$_Fill_zero_memset@PAI@std@@YAXPAII@Z ; std::_Fill_zero_memset<unsigned int *>
  00081	83 c4 08	 add	 esp, 8

; 1759 :                 return _First + _Count;

  00084	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00087	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0008a	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
  0008d	eb 5d		 jmp	 SHORT $LN1@Uninitiali
$LN5@Uninitiali:

; 1760 :             }
; 1761 :         }
; 1762 :     }
; 1763 : 
; 1764 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  0008f	6a 0c		 push	 12			; 0000000cH
  00091	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00094	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z
  00099	8b 4d 14	 mov	 ecx, DWORD PTR __Al$[ebp]
  0009c	51		 push	 ecx
  0009d	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  000a0	52		 push	 edx
  000a1	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000a4	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
  000a9	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1765 :     for (; 0 < _Count; --_Count) {

  000b0	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000b2	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  000b5	83 e8 01	 sub	 eax, 1
  000b8	89 45 0c	 mov	 DWORD PTR __Count$[ebp], eax
$LN4@Uninitiali:
  000bb	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000bf	76 0e		 jbe	 SHORT $LN3@Uninitiali

; 1766 :         _Backout._Emplace_back(_Val);

  000c1	8b 4d 10	 mov	 ecx, DWORD PTR __Val$[ebp]
  000c4	51		 push	 ecx
  000c5	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000c8	e8 00 00 00 00	 call	 ??$_Emplace_back@ABI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXABI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int const &>

; 1767 :     }

  000cd	eb e3		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1768 : 
; 1769 :     return _Backout._Release();

  000cf	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000d2	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
  000d7	89 45 d8	 mov	 DWORD PTR $T2[ebp], eax
  000da	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e1	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000e4	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  000e9	8b 45 d8	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1770 : }

  000ec	52		 push	 edx
  000ed	8b cd		 mov	 ecx, ebp
  000ef	50		 push	 eax
  000f0	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN12@Uninitiali
  000f6	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000fb	58		 pop	 eax
  000fc	5a		 pop	 edx
  000fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00100	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00107	59		 pop	 ecx
  00108	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0010b	33 cd		 xor	 ecx, ebp
  0010d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00112	83 c4 28	 add	 esp, 40			; 00000028H
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
$LN12@Uninitiali:
  00120	01 00 00 00	 DD	 1
  00124	00 00 00 00	 DD	 $LN11@Uninitiali
$LN11@Uninitiali:
  00128	e0 ff ff ff	 DD	 -32			; ffffffe0H
  0012c	0c 00 00 00	 DD	 12			; 0000000cH
  00130	00 00 00 00	 DD	 $LN9@Uninitiali
$LN9@Uninitiali:
  00134	5f		 DB	 95			; 0000005fH
  00135	42		 DB	 66			; 00000042H
  00136	61		 DB	 97			; 00000061H
  00137	63		 DB	 99			; 00000063H
  00138	6b		 DB	 107			; 0000006bH
  00139	6f		 DB	 111			; 0000006fH
  0013a	75		 DB	 117			; 00000075H
  0013b	74		 DB	 116			; 00000074H
  0013c	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ENDP ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z PROC ; std::forward<std::allocator<unsigned int> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z ENDP ; std::forward<std::allocator<unsigned int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 4
__Backout$ = -40					; size = 12
__ULast$ = -24						; size = 4
__UFirst$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z PROC ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d0	 mov	 DWORD PTR [ebp-48], eax
  0001c	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001f	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00022	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00025	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00028	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00031	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00039	33 c5		 xor	 eax, ebp
  0003b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003e	50		 push	 eax
  0003f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00042	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0004d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00052	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z ; std::_Get_unwrapped<unsigned int * const &>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 ec	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00061	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAI@std@@YA?A_TABQAI@Z ; std::_Get_unwrapped<unsigned int * const &>
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 e8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  00070	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00075	0f b6 d0	 movzx	 edx, al
  00078	85 d2		 test	 edx, edx
  0007a	75 34		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  0007c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Unfancy@I@std@@YAPAIPAI@Z ; std::_Unfancy<unsigned int>
  00085	83 c4 04	 add	 esp, 4
  00088	50		 push	 eax
  00089	8b 4d e8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_memmove<unsigned int *,unsigned int *>
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  00099	8b 45 e8	 mov	 eax, DWORD PTR __ULast$[ebp]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0009f	c1 f8 02	 sar	 eax, 2
  000a2	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000a5	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000a8	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx

; 1665 :             return _Dest;

  000ab	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  000ae	eb 5f		 jmp	 SHORT $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000b0	6a 0c		 push	 12			; 0000000cH
  000b2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b5	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXI@Z
  000ba	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000c1	51		 push	 ecx
  000c2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000c5	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@PAIAAV?$allocator@I@1@@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Uninitialized_backout_al<std::allocator<unsigned int> >
  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  000d1	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000d3	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000d6	83 c2 04	 add	 edx, 4
  000d9	89 55 ec	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  000dc	8b 45 ec	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000df	3b 45 e8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  000e2	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000e4	8b 4d ec	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000e7	51		 push	 ecx
  000e8	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000eb	e8 00 00 00 00	 call	 ??$_Emplace_back@AAI@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEXAAI@Z ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Emplace_back<unsigned int &>

; 1672 :     }

  000f0	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000f2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAEPAIXZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::_Release
  000fa	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00104	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00107	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  0010c	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1675 : }

  0010f	52		 push	 edx
  00110	8b cd		 mov	 ecx, ebp
  00112	50		 push	 eax
  00113	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Uninitiali
  00119	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0011e	58		 pop	 eax
  0011f	5a		 pop	 edx
  00120	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012a	59		 pop	 ecx
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	83 c4 30	 add	 esp, 48			; 00000030H
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
  00143	90		 npad	 1
$LN11@Uninitiali:
  00144	01 00 00 00	 DD	 1
  00148	00 00 00 00	 DD	 $LN10@Uninitiali
$LN10@Uninitiali:
  0014c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00150	0c 00 00 00	 DD	 12			; 0000000cH
  00154	00 00 00 00	 DD	 $LN8@Uninitiali
$LN8@Uninitiali:
  00158	5f		 DB	 95			; 0000005fH
  00159	42		 DB	 66			; 00000042H
  0015a	61		 DB	 97			; 00000061H
  0015b	63		 DB	 99			; 00000063H
  0015c	6b		 DB	 107			; 0000006bH
  0015d	6f		 DB	 111			; 0000006fH
  0015e	75		 DB	 117			; 00000075H
  0015f	74		 DB	 116			; 00000074H
  00160	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@I@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<unsigned int> >::~_Uninitialized_backout_al<std::allocator<unsigned int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ENDP ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z PROC ; std::forward<std::allocator<unsigned int> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ENDP ; std::forward<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__Count$ = -28						; size = 4
__Dest_ch$ = -24					; size = 4
__Last_ch$ = -20					; size = 4
__First_ch$ = -16					; size = 4
__DestPtr$ = -12					; size = 4
__LastPtr$ = -8						; size = 4
__FirstPtr$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z PROC		; std::_Copy_memmove<unsigned int *,unsigned int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  0002a	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 fc	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 f8	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  00048	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$_To_address@PAI@std@@YA?A_PABQAI@Z ; std::_To_address<unsigned int *>
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f4	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  00057	8b 45 fc	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  0005a	89 45 f0	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00060	89 4d ec	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00063	8b 55 f4	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  00066	89 55 e8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00069	8b 45 ec	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0006c	2b 45 f0	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0006f	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 f0	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00079	52		 push	 edx
  0007a	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _memmove
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00086	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00089	03 45 e4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  0008c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ENDP		; std::_Copy_memmove<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@I@std@@YAPAIQAI@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@I@std@@YAPAIQAI@Z PROC			; std::to_address<unsigned int>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$to_address@I@std@@YAPAIQAI@Z ENDP			; std::to_address<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z PROC		; std::_Voidify_iter<char * *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ENDP		; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z PROC	; std::construct_at<char *,char * const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00038	83 c4 04	 add	 esp, 4
  0003b	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 02		 mov	 DWORD PTR [edx], eax
  00042	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ENDP	; std::construct_at<char *,char * const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAI@std@@YA$$QAIAAI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAI@std@@YA$$QAIAAI@Z PROC			; std::move<unsigned int &>, COMDAT

; 1455 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1457 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$move@AAI@std@@YA$$QAIAAI@Z ENDP			; std::move<unsigned int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Ptr$ = -12						; size = 4
__Ptr_container$ = -8					; size = 4
__Block_size$ = -4					; size = 4
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00029	83 c0 27	 add	 eax, 39			; 00000027H
  0002c	89 45 fc	 mov	 DWORD PTR __Block_size$[ebp], eax

; 137  :     if (_Block_size <= _Bytes) {

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  00032	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  00035	77 05		 ja	 SHORT $LN8@Allocate_m

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00037	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  0003c	8b 55 fc	 mov	 edx, DWORD PTR __Block_size$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 f8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  0004b	83 7d f8 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  0004f	74 02		 je	 SHORT $LN7@Allocate_m
  00051	eb 5c		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  00053	8b f4		 mov	 esi, esp
  00055	68 00 00 00 00	 push	 OFFSET $SG260851
  0005a	68 00 00 00 00	 push	 OFFSET $SG260852
  0005f	6a 00		 push	 0
  00061	68 8e 00 00 00	 push	 142			; 0000008eH
  00066	68 00 00 00 00	 push	 OFFSET $SG260853
  0006b	6a 02		 push	 2
  0006d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00073	83 c4 18	 add	 esp, 24			; 00000018H
  00076	3b f4		 cmp	 esi, esp
  00078	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007d	83 f8 01	 cmp	 eax, 1
  00080	75 01		 jne	 SHORT $LN12@Allocate_m
  00082	cc		 int	 3
$LN12@Allocate_m:
  00083	8b f4		 mov	 esi, esp
  00085	6a 00		 push	 0
  00087	68 8e 00 00 00	 push	 142			; 0000008eH
  0008c	68 00 00 00 00	 push	 OFFSET $SG260854
  00091	68 00 00 00 00	 push	 OFFSET $SG260855
  00096	68 00 00 00 00	 push	 OFFSET $SG260856
  0009b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000a1	83 c4 14	 add	 esp, 20			; 00000014H
  000a4	3b f4		 cmp	 esi, esp
  000a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ab	33 c9		 xor	 ecx, ecx
  000ad	75 a4		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  000af	33 d2		 xor	 edx, edx
  000b1	75 98		 jne	 SHORT $LN4@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  000b3	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  000b6	83 c0 27	 add	 eax, 39			; 00000027H
  000b9	83 e0 e0	 and	 eax, -32		; ffffffe0H
  000bc	89 45 f4	 mov	 DWORD PTR __Ptr$[ebp], eax

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  000bf	b9 04 00 00 00	 mov	 ecx, 4
  000c4	6b d1 ff	 imul	 edx, ecx, -1
  000c7	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000ca	8b 4d f8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000cd	89 0c 10	 mov	 DWORD PTR [eax+edx], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000d0	ba 04 00 00 00	 mov	 edx, 4
  000d5	6b c2 fe	 imul	 eax, edx, -2
  000d8	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000db	c7 04 01 fa fa
	fa fa		 mov	 DWORD PTR [ecx+eax], -84215046 ; fafafafaH

; 148  : #endif // _DEBUG
; 149  :     return _Ptr;

  000e2	8b 45 f4	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 150  : }

  000e5	5e		 pop	 esi
  000e6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e9	3b ec		 cmp	 ebp, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z
_TEXT	SEGMENT
tv75 = -28						; size = 4
tv78 = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>, COMDAT
; _this$ = ecx

; 340  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0001f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00022	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c5		 xor	 eax, ebp
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00039	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0003e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0004c	83 c4 04	 add	 esp, 4
  0004f	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __This_arg$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00061	8a 55 ef	 mov	 dl, BYTE PTR $T4[ebp]
  00064	88 55 ee	 mov	 BYTE PTR $T3[ebp], dl
  00067	8a 45 ee	 mov	 al, BYTE PTR $T3[ebp]
  0006a	88 45 ed	 mov	 BYTE PTR $T2[ebp], al
  0006d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00070	51		 push	 ecx
  00071	8b 55 e4	 mov	 edx, DWORD PTR tv75[ebp]
  00074	52		 push	 edx
  00075	0f b6 45 ed	 movzx	 eax, BYTE PTR $T2[ebp]
  00079	50		 push	 eax
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@AAW42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@AAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP &,0>
  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	83 c4 1c	 add	 esp, 28			; 0000001cH
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
  000a0	cc		 int	 3
  000a1	cc		 int	 3
  000a2	cc		 int	 3
  000a3	cc		 int	 3
  000a4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z
_TEXT	SEGMENT
tv75 = -28						; size = 4
tv78 = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 340  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0001f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00022	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c5		 xor	 eax, ebp
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00039	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0003e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0004c	83 c4 04	 add	 esp, 4
  0004f	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __This_arg$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00061	8a 55 ef	 mov	 dl, BYTE PTR $T4[ebp]
  00064	88 55 ee	 mov	 BYTE PTR $T3[ebp], dl
  00067	8a 45 ee	 mov	 al, BYTE PTR $T3[ebp]
  0006a	88 45 ed	 mov	 BYTE PTR $T2[ebp], al
  0006d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00070	51		 push	 ecx
  00071	8b 55 e4	 mov	 edx, DWORD PTR tv75[ebp]
  00074	52		 push	 edx
  00075	0f b6 45 ed	 movzx	 eax, BYTE PTR $T2[ebp]
  00079	50		 push	 eax
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@AAW4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@AAW4DIRDEP@@$$QAW43@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP &,enum DIRDEP,0>
  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	83 c4 1c	 add	 esp, 28			; 0000001cH
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
  000a0	cc		 int	 3
  000a1	cc		 int	 3
  000a2	cc		 int	 3
  000a3	cc		 int	 3
  000a4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z PROC ; std::forward<enum DIRDEP &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ENDP ; std::forward<enum DIRDEP &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z
_TEXT	SEGMENT
tv75 = -28						; size = 4
tv78 = -24						; size = 4
$T2 = -19						; size = 1
$T3 = -18						; size = 1
$T4 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__This_arg$ = 8						; size = 4
_<_Rest_arg_0>$ = 12					; size = 4
??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 340  :         : tuple(_Exact_args_t{}, _STD forward<_This2>(_This_arg), _STD forward<_Rest2>(_Rest_arg)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 10	 sub	 esp, 16			; 00000010H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0001c	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0001f	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00022	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00025	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002a	33 c5		 xor	 eax, ebp
  0002c	50		 push	 eax
  0002d	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00030	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00036	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00039	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0003e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00043	8b 45 0c	 mov	 eax, DWORD PTR _<_Rest_arg_0>$[ebp]
  00046	50		 push	 eax
  00047	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0004c	83 c4 04	 add	 esp, 4
  0004f	89 45 e8	 mov	 DWORD PTR tv78[ebp], eax
  00052	8b 4d 08	 mov	 ecx, DWORD PTR __This_arg$[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00061	8a 55 ef	 mov	 dl, BYTE PTR $T4[ebp]
  00064	88 55 ee	 mov	 BYTE PTR $T3[ebp], dl
  00067	8a 45 ee	 mov	 al, BYTE PTR $T3[ebp]
  0006a	88 45 ed	 mov	 BYTE PTR $T2[ebp], al
  0006d	8b 4d e8	 mov	 ecx, DWORD PTR tv78[ebp]
  00070	51		 push	 ecx
  00071	8b 55 e4	 mov	 edx, DWORD PTR tv75[ebp]
  00074	52		 push	 edx
  00075	0f b6 45 ed	 movzx	 eax, BYTE PTR $T2[ebp]
  00079	50		 push	 eax
  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ??$?0U_Exact_args_t@std@@W4DIRDEP@@W42@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@U_Exact_args_t@1@$$QAW4DIRDEP@@1@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><std::_Exact_args_t,enum DIRDEP,enum DIRDEP,0>
  00082	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00085	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00088	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0008f	59		 pop	 ecx
  00090	83 c4 1c	 add	 esp, 28			; 0000001cH
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c2 08 00	 ret	 8
  000a0	cc		 int	 3
  000a1	cc		 int	 3
  000a2	cc		 int	 3
  000a3	cc		 int	 3
  000a4	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 623  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 624  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 10		 mov	 edx, DWORD PTR [eax]
  00029	89 11		 mov	 DWORD PTR [ecx], edx

; 625  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002e	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ; std::tuple<enum DIRDEP>::_Get_rest
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??$forward@V?$tuple@$$V@std@@@std@@YA$$QAV?$tuple@$$V@0@AAV10@@Z ; std::forward<std::tuple<> >
  00039	83 c4 04	 add	 esp, 4
  0003c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ; std::tuple<enum DIRDEP>::_Get_rest

; 626  :         return *this;

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 627  :     }

  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z PROC ; std::forward<std::tuple<enum DIRDEP> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z ENDP ; std::forward<std::tuple<enum DIRDEP> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z PROC ; std::forward<enum DIRDEP>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ENDP ; std::forward<enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::destroy_at<std::vector<int,std::allocator<int> > >, COMDAT

; 318  : _CONSTEXPR20_DYNALLOC void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 319  : #if _HAS_CXX20
; 320  :     if constexpr (is_array_v<_Ty>) {
; 321  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 322  :     } else
; 323  : #endif // _HAS_CXX20
; 324  :     {
; 325  :         _Location->~_Ty();

  0000d	6a 00		 push	 0
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Location$[ebp]
  00012	e8 00 00 00 00	 call	 ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z

; 326  :     }
; 327  : }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::destroy_at<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 985  : _CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 986  :     // deallocate a plain pointer using an allocator
; 987  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 988  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 989  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  0002c	6a 01		 push	 1
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 990  :     } else {
; 991  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 992  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 993  :     }
; 994  : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	83 c4 0c	 add	 esp, 12			; 0000000cH
  0004c	3b ec		 cmp	 ebp, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
  00057	cc		 int	 3
  00058	cc		 int	 3
  00059	cc		 int	 3
  0005a	cc		 int	 3
  0005b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAH@std@@YA?A_PABQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAH@std@@YA?A_PABQAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@H@std@@YAPAHQAH@Z ; std::to_address<int>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_To_address@PAH@std@@YA?A_PABQAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PBH@std@@YA?A_PABQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PBH@std@@YA?A_PABQBH@Z PROC		; std::_To_address<int const *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@$$CBH@std@@YAPBHQBH@Z ; std::to_address<int const >
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??$_To_address@PBH@std@@YA?A_PABQBH@Z ENDP		; std::_To_address<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z PROC		; std::_Unfancy_maybe_null<unsigned int>, COMDAT

; 437  : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 438  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 439  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ENDP		; std::_Unfancy_maybe_null<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABD@std@@YAABDABD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABD@std@@YAABDABD@Z PROC			; std::forward<char const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABD@std@@YAABDABD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAD@std@@YAPAXPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAD@std@@YAPAXPAD@Z PROC		; std::_Voidify_iter<char *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Voidify_iter@PAD@std@@YAPAXPAD@Z ENDP		; std::_Voidify_iter<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@DABDX@std@@YAPADQADABD@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@DABDX@std@@YAPADQADABD@Z PROC		; std::construct_at<char,char const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAD@std@@YAPAXPAD@Z ; std::_Voidify_iter<char *>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	6a 01		 push	 1
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??$forward@ABD@std@@YAABDABD@Z ; std::forward<char const &>
  00038	83 c4 04	 add	 esp, 4
  0003b	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003e	8a 00		 mov	 al, BYTE PTR [eax]
  00040	88 02		 mov	 BYTE PTR [edx], al
  00042	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$construct_at@DABDX@std@@YAPADQADABD@Z ENDP		; std::construct_at<char,char const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00015	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 64   :         if (_Count > _Max_possible) {
; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00019	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 70   : }

  0001c	83 c4 04	 add	 esp, 4
  0001f	3b ec		 cmp	 ebp, esp
  00021	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
_TEXT	SEGMENT
__Guard$2 = -64						; size = 4
__Proxy$ = -52						; size = 8
__My_data$ = -40					; size = 4
_$S48$ = -29						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>, COMDAT
; _this$ = ecx

; 486  :     _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 38	 sub	 esp, 56			; 00000038H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d bc	 lea	 edi, DWORD PTR [ebp-68]
  00019	b9 0e 00 00 00	 mov	 ecx, 14			; 0000000eH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 487  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00047	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  0004f	50		 push	 eax
  00050	8d 4d e3	 lea	 ecx, DWORD PTR _$S48$[ebp]
  00053	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  00058	8d 45 e3	 lea	 eax, DWORD PTR _$S48$[ebp]
  0005b	89 45 e8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 488  :         auto& _My_data  = _Mypair._Myval2;

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	89 4d d8	 mov	 DWORD PTR __My_data$[ebp], ecx

; 489  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  00064	8b 55 d8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00067	52		 push	 edx
  00068	8b 45 e8	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  0006b	50		 push	 eax
  0006c	8d 4d cc	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0006f	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00074	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 490  :         if (_Count != 0) {

  0007b	83 7d 08 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0007f	74 46		 je	 SHORT $LN2@Construct_

; 491  :             _Buy_nonzero(_Count);

  00081	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00084	51		 push	 ecx
  00085	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00088	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero

; 492  :             _Tidy_guard<vector> _Guard{this};

  0008d	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00090	89 55 c0	 mov	 DWORD PTR __Guard$2[ebp], edx
  00093	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 493  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);

  00097	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  0009a	50		 push	 eax
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  0009e	51		 push	 ecx
  0009f	8b 55 d8	 mov	 edx, DWORD PTR __My_data$[ebp]
  000a2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a5	50		 push	 eax
  000a6	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a9	e8 00 00 00 00	 call	 ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000b1	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 494  :             _Guard._Target   = nullptr;

  000b4	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR __Guard$2[ebp], 0

; 495  :         }

  000bb	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000bf	8d 4d c0	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  000c2	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
$LN2@Construct_:

; 496  : 
; 497  :         _Proxy._Release();

  000c7	8d 4d cc	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000ca	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 498  :     }

  000cf	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d6	8d 4d cc	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000d9	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000de	52		 push	 edx
  000df	8b cd		 mov	 ecx, ebp
  000e1	50		 push	 eax
  000e2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Construct_
  000e8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000ed	58		 pop	 eax
  000ee	5a		 pop	 edx
  000ef	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f9	59		 pop	 ecx
  000fa	5f		 pop	 edi
  000fb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000fe	33 cd		 xor	 ecx, ebp
  00100	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00105	83 c4 44	 add	 esp, 68			; 00000044H
  00108	3b ec		 cmp	 ebp, esp
  0010a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0010f	8b e5		 mov	 esp, ebp
  00111	5d		 pop	 ebp
  00112	c2 08 00	 ret	 8
  00115	0f 1f 00	 npad	 3
$LN11@Construct_:
  00118	03 00 00 00	 DD	 3
  0011c	00 00 00 00	 DD	 $LN10@Construct_
$LN10@Construct_:
  00120	e3 ff ff ff	 DD	 -29			; ffffffe3H
  00124	01 00 00 00	 DD	 1
  00128	00 00 00 00	 DD	 $LN6@Construct_
  0012c	cc ff ff ff	 DD	 -52			; ffffffccH
  00130	08 00 00 00	 DD	 8
  00134	00 00 00 00	 DD	 $LN7@Construct_
  00138	c0 ff ff ff	 DD	 -64			; ffffffc0H
  0013c	04 00 00 00	 DD	 4
  00140	00 00 00 00	 DD	 $LN8@Construct_
$LN8@Construct_:
  00144	5f		 DB	 95			; 0000005fH
  00145	47		 DB	 71			; 00000047H
  00146	75		 DB	 117			; 00000075H
  00147	61		 DB	 97			; 00000061H
  00148	72		 DB	 114			; 00000072H
  00149	64		 DB	 100			; 00000064H
  0014a	00		 DB	 0
$LN7@Construct_:
  0014b	5f		 DB	 95			; 0000005fH
  0014c	50		 DB	 80			; 00000050H
  0014d	72		 DB	 114			; 00000072H
  0014e	6f		 DB	 111			; 0000006fH
  0014f	78		 DB	 120			; 00000078H
  00150	79		 DB	 121			; 00000079H
  00151	00		 DB	 0
$LN6@Construct_:
  00152	24		 DB	 36			; 00000024H
  00153	53		 DB	 83			; 00000053H
  00154	34		 DB	 52			; 00000034H
  00155	38		 DB	 56			; 00000038H
  00156	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$0:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z$1:
  00008	8d 4d c0	 lea	 ecx, DWORD PTR __Guard$2[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c0	 mov	 ecx, DWORD PTR [edx-64]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@I@std@@@std@@YAABV?$allocator@I@0@ABV10@@Z ; std::forward<std::allocator<unsigned int> const &>
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00020	50		 push	 eax
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAIV?$allocator@I@std@@@std@@YAPAIQAI0PAIAAV?$allocator@I@0@@Z ; std::_Uninitialized_copy<unsigned int *,std::allocator<unsigned int> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 0a		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00025	e8 00 00 00 00	 call	 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@V?$allocator@I@std@@@std@@YA$$QAV?$allocator@I@0@AAV10@@Z ; std::forward<std::allocator<unsigned int> >
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z PROC	; std::_Move_unchecked<unsigned int *,unsigned int *>, COMDAT

; 4417 : _CONSTEXPR20 _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4418 :     // move [_First, _Last) to [_Dest, ...)
; 4419 :     // note: _Move_unchecked has callers other than the move family
; 4420 :     if constexpr (_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable) {
; 4421 : #ifdef __cpp_lib_is_constant_evaluated
; 4422 :         if (!_STD is_constant_evaluated())

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 16		 jne	 SHORT $LN5@Move_unche

; 4423 : #endif // __cpp_lib_is_constant_evaluated
; 4424 :         {
; 4425 :             return _Copy_memmove(_First, _Last, _Dest);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Last$[ebp]
  00020	52		 push	 edx
  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAIPAI@std@@YAPAIPAI00@Z ; std::_Copy_memmove<unsigned int *,unsigned int *>
  0002a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002d	eb 34		 jmp	 SHORT $LN1@Move_unche
$LN5@Move_unche:

; 4426 :         }
; 4427 :     }
; 4428 : 
; 4429 :     for (; _First != _Last; ++_Dest, (void) ++_First) {

  0002f	eb 12		 jmp	 SHORT $LN4@Move_unche
$LN2@Move_unche:
  00031	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00034	83 c1 04	 add	 ecx, 4
  00037	89 4d 10	 mov	 DWORD PTR __Dest$[ebp], ecx
  0003a	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0003d	83 c2 04	 add	 edx, 4
  00040	89 55 08	 mov	 DWORD PTR __First$[ebp], edx
$LN4@Move_unche:
  00043	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00046	3b 45 0c	 cmp	 eax, DWORD PTR __Last$[ebp]
  00049	74 15		 je	 SHORT $LN3@Move_unche

; 4430 :         *_Dest = _STD move(*_First);

  0004b	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0004e	51		 push	 ecx
  0004f	e8 00 00 00 00	 call	 ??$move@AAI@std@@YA$$QAIAAI@Z ; std::move<unsigned int &>
  00054	83 c4 04	 add	 esp, 4
  00057	8b 55 10	 mov	 edx, DWORD PTR __Dest$[ebp]
  0005a	8b 00		 mov	 eax, DWORD PTR [eax]
  0005c	89 02		 mov	 DWORD PTR [edx], eax

; 4431 :     }

  0005e	eb d1		 jmp	 SHORT $LN2@Move_unche
$LN3@Move_unche:

; 4432 : 
; 4433 :     return _Dest;

  00060	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
$LN1@Move_unche:

; 4434 : }

  00063	3b ec		 cmp	 ebp, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	5d		 pop	 ebp
  0006b	c3		 ret	 0
??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ENDP	; std::_Move_unchecked<unsigned int *,unsigned int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z PROC ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ENDP ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
tv75 = -12						; size = 4
tv77 = -8						; size = 4
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00025	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0002a	0f b6 c0	 movzx	 eax, al
  0002d	85 c0		 test	 eax, eax
  0002f	74 30		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00034	51		 push	 ecx
  00035	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  00040	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00049	83 c4 04	 add	 esp, 4
  0004c	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  0004f	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  00052	50		 push	 eax
  00053	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &,void>
  0005c	83 c4 08	 add	 esp, 8

; 155  :     } else

  0005f	eb 36		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00061	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  0006a	83 c4 04	 add	 esp, 4
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
  00073	83 c4 04	 add	 esp, 4
  00076	50		 push	 eax
  00077	6a 04		 push	 4
  00079	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0007e	83 c4 08	 add	 esp, 8
  00081	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00084	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00093	8b 10		 mov	 edx, DWORD PTR [eax]
  00095	89 11		 mov	 DWORD PTR [ecx], edx
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  00097	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009a	3b ec		 cmp	 ebp, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
_TEXT	SEGMENT
__New_ptr$ = -28					; size = 4
__Al$ = -20						; size = 4
__New_capacity$ = -16					; size = 4
__Old_capacity$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT
; _this$ = ecx

; 4505 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000e	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00011	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00014	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00017	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001a	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001d	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00020	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00030	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00035	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4506 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4507 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4508 :         if (_New_size > max_size()) {

  0003a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003d	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00042	39 45 08	 cmp	 DWORD PTR __New_size$[ebp], eax
  00045	76 05		 jbe	 SHORT $LN2@Reallocate

; 4509 :             _Xlen_string(); // result too long

  00047	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4510 :         }
; 4511 : 
; 4512 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00052	89 4d f4	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4513 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  00055	8b 55 08	 mov	 edx, DWORD PTR __New_size$[ebp]
  00058	52		 push	 edx
  00059	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00061	89 45 f0	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4514 :         auto& _Al                     = _Getal();

  00064	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00067	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0006c	89 45 ec	 mov	 DWORD PTR __Al$[ebp], eax

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  0006f	33 c0		 xor	 eax, eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00074	83 c1 01	 add	 ecx, 1
  00077	0f 92 c0	 setb	 al
  0007a	f7 d8		 neg	 eax
  0007c	0b c1		 or	 eax, ecx
  0007e	50		 push	 eax
  0007f	8b 4d ec	 mov	 ecx, DWORD PTR __Al$[ebp]
  00082	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  00087	89 45 e4	 mov	 DWORD PTR __New_ptr$[ebp], eax

; 4516 : 
; 4517 : #ifdef __cpp_lib_constexpr_string
; 4518 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  0008a	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0008f	0f b6 d0	 movzx	 edx, al
  00092	85 d2		 test	 edx, edx
  00094	74 1e		 je	 SHORT $LN3@Reallocate

; 4519 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  00096	6a 00		 push	 0
  00098	8b 45 f0	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  0009b	83 c0 01	 add	 eax, 1
  0009e	50		 push	 eax
  0009f	8b 4d e4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  000a2	51		 push	 ecx
  000a3	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000a8	83 c4 04	 add	 esp, 4
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  000b1	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Reallocate:

; 4520 :         }
; 4521 : #endif // __cpp_lib_constexpr_string
; 4522 :         _Mypair._Myval2._Orphan_all();

  000b4	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  000bc	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000bf	8b 45 08	 mov	 eax, DWORD PTR __New_size$[ebp]
  000c2	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  000c5	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000c8	8b 55 f0	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  000cb	89 51 18	 mov	 DWORD PTR [ecx+24], edx

; 4525 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  000ce	8b 45 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  000d1	50		 push	 eax
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __New_size$[ebp]
  000d5	51		 push	 ecx
  000d6	8b 55 e4	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  000d9	52		 push	 edx
  000da	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  000df	83 c4 04	 add	 esp, 4
  000e2	50		 push	 eax
  000e3	8d 4d 0c	 lea	 ecx, DWORD PTR __Fn$[ebp]
  000e6	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  000eb	83 7d f4 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  000ef	72 21		 jb	 SHORT $LN4@Reallocate

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  000f1	8b 45 f4	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  000f4	83 c0 01	 add	 eax, 1
  000f7	50		 push	 eax
  000f8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000fb	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000fe	52		 push	 edx
  000ff	8b 4d ec	 mov	 ecx, DWORD PTR __Al$[ebp]
  00102	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4528 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  00107	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0010a	8b 4d e4	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0010d	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 4529 :         } else {

  00110	eb 13		 jmp	 SHORT $LN5@Reallocate
$LN4@Reallocate:

; 4530 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  00112	8d 55 e4	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  00115	52		 push	 edx
  00116	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00119	83 c0 04	 add	 eax, 4
  0011c	50		 push	 eax
  0011d	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  00122	83 c4 08	 add	 esp, 8
$LN5@Reallocate:

; 4531 :         }
; 4532 : 
; 4533 :         return *this;

  00125	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
$LN6@Reallocate:

; 4534 :     }

  00128	52		 push	 edx
  00129	8b cd		 mov	 ecx, ebp
  0012b	50		 push	 eax
  0012c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@Reallocate
  00132	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00137	58		 pop	 eax
  00138	5a		 pop	 edx
  00139	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013c	33 cd		 xor	 ecx, ebp
  0013e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00143	83 c4 20	 add	 esp, 32			; 00000020H
  00146	3b ec		 cmp	 ebp, esp
  00148	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c2 0c 00	 ret	 12			; 0000000cH
  00153	90		 npad	 1
$LN9@Reallocate:
  00154	01 00 00 00	 DD	 1
  00158	00 00 00 00	 DD	 $LN8@Reallocate
$LN8@Reallocate:
  0015c	e4 ff ff ff	 DD	 -28			; ffffffe4H
  00160	04 00 00 00	 DD	 4
  00164	00 00 00 00	 DD	 $LN7@Reallocate
$LN7@Reallocate:
  00168	5f		 DB	 95			; 0000005fH
  00169	4e		 DB	 78			; 0000004eH
  0016a	65		 DB	 101			; 00000065H
  0016b	77		 DB	 119			; 00000077H
  0016c	5f		 DB	 95			; 0000005fH
  0016d	70		 DB	 112			; 00000070H
  0016e	74		 DB	 116			; 00000074H
  0016f	72		 DB	 114			; 00000072H
  00170	00		 DB	 0
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z
_TEXT	SEGMENT
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT
; _this$ = ecx

; 3259 :             },

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3257 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00021	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 10	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00035	c6 45 fb 00	 mov	 BYTE PTR $T1[ebp], 0
  00039	8d 45 fb	 lea	 eax, DWORD PTR $T1[ebp]
  0003c	50		 push	 eax
  0003d	8b 4d 08	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  00040	03 4d 0c	 add	 ecx, DWORD PTR __Count$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00049	83 c4 08	 add	 esp, 8

; 3259 :             },

  0004c	83 c4 08	 add	 esp, 8
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z PROC ; std::allocator<unsigned int>::allocator<unsigned int><bool>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ENDP ; std::allocator<unsigned int>::allocator<unsigned int><bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ
_TEXT	SEGMENT
__Cont$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 2329 :     _NODISCARD _CONSTEXPR20_CONTAINER reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2330 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2331 :         const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002a	89 45 f8	 mov	 DWORD PTR __Cont$[ebp], eax
$LN4@operator:

; 2332 :         _STL_VERIFY(_Cont, "cannot dereference value-initialized vector<bool> iterator");

  0002d	83 7d f8 00	 cmp	 DWORD PTR __Cont$[ebp], 0
  00031	74 02		 je	 SHORT $LN7@operator
  00033	eb 5c		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00035	8b f4		 mov	 esi, esp
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00041	6a 00		 push	 0
  00043	68 1c 09 00 00	 push	 2332			; 0000091cH
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0004d	6a 02		 push	 2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00055	83 c4 18	 add	 esp, 24			; 00000018H
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	83 f8 01	 cmp	 eax, 1
  00062	75 01		 jne	 SHORT $LN19@operator
  00064	cc		 int	 3
$LN19@operator:
  00065	8b f4		 mov	 esi, esp
  00067	6a 00		 push	 0
  00069	68 1c 09 00 00	 push	 2332			; 0000091cH
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00083	83 c4 14	 add	 esp, 20			; 00000014H
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	33 c9		 xor	 ecx, ecx
  0008f	75 a4		 jne	 SHORT $LN7@operator
$LN2@operator:
  00091	33 d2		 xor	 edx, edx
  00093	75 98		 jne	 SHORT $LN4@operator
$LN10@operator:

; 2333 :         _STL_VERIFY(this->_Total_off(_Cont) < static_cast<_Difference_type>(_Cont->_Mysize),

  00095	8b 45 f8	 mov	 eax, DWORD PTR __Cont$[ebp]
  00098	50		 push	 eax
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR __Cont$[ebp]
  000a4	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  000a7	7d 02		 jge	 SHORT $LN13@operator
  000a9	eb 5c		 jmp	 SHORT $LN8@operator
$LN13@operator:
  000ab	8b f4		 mov	 esi, esp
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000b7	6a 00		 push	 0
  000b9	68 1e 09 00 00	 push	 2334			; 0000091eH
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000c3	6a 02		 push	 2
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	75 01		 jne	 SHORT $LN20@operator
  000da	cc		 int	 3
$LN20@operator:
  000db	8b f4		 mov	 esi, esp
  000dd	6a 00		 push	 0
  000df	68 1e 09 00 00	 push	 2334			; 0000091eH
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000f9	83 c4 14	 add	 esp, 20			; 00000014H
  000fc	3b f4		 cmp	 esi, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	33 c0		 xor	 eax, eax
  00105	75 a4		 jne	 SHORT $LN13@operator
$LN8@operator:
  00107	33 c9		 xor	 ecx, ecx
  00109	75 8a		 jne	 SHORT $LN10@operator

; 2334 :             "vector<bool> iterator not dereferenceable");
; 2335 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2336 : 
; 2337 :         return _Reft(*this);

  0010b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010e	52		 push	 edx
  0010f	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00112	e8 00 00 00 00	 call	 ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00117	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2338 :     }

  0011a	5e		 pop	 esi
  0011b	83 c4 08	 add	 esp, 8
  0011e	3b ec		 cmp	 ebp, esp
  00120	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00125	8b e5		 mov	 esp, ebp
  00127	5d		 pop	 ebp
  00128	c2 04 00	 ret	 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Mypvbool$ = 12					; size = 4
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2124 :     _CONSTEXPR20_CONTAINER _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2125 :         : _Mybase(_Ptr, 0, _Mypvbool) {}

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Mypvbool$[ebp]
  0001b	50		 push	 eax
  0001c	6a 00		 push	 0
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00021	51		 push	 ecx
  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 08 00	 ret	 8
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  00011	50		 push	 eax
  00012	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  00015	51		 push	 ecx
  00016	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00019	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
  0001e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 08 00	 ret	 8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c2 04 00	 ret	 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
__Tmp$ = -24						; size = 12
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+, COMDAT
; _this$ = ecx

; 310  :     _NODISCARD _CONSTEXPR20_CONTAINER _Vector_iterator operator+(const difference_type _Off) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 311  :         _Vector_iterator _Tmp = *this;

  00037	6a 0c		 push	 12			; 0000000cH
  00039	8d 4d e8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  0003c	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEXI@Z
  00041	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00044	50		 push	 eax
  00045	8d 4d e8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00048	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z

; 312  :         _Tmp += _Off; // TRANSITION, LLVM-49342

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00050	51		 push	 ecx
  00051	8d 4d e8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00054	e8 00 00 00 00	 call	 ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=

; 313  :         return _Tmp;

  00059	8d 55 e8	 lea	 edx, DWORD PTR __Tmp$[ebp]
  0005c	52		 push	 edx
  0005d	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00060	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  00065	8d 4d e8	 lea	 ecx, DWORD PTR __Tmp$[ebp]
  00068	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  0006d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 314  :     }

  00070	52		 push	 edx
  00071	8b cd		 mov	 ecx, ebp
  00073	50		 push	 eax
  00074	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@operator
  0007a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0007f	58		 pop	 eax
  00080	5a		 pop	 edx
  00081	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00084	33 cd		 xor	 ecx, ebp
  00086	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0008b	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c2 08 00	 ret	 8
  0009b	90		 npad	 1
$LN5@operator:
  0009c	01 00 00 00	 DD	 1
  000a0	00 00 00 00	 DD	 $LN4@operator
$LN4@operator:
  000a4	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000a8	0c 00 00 00	 DD	 12			; 0000000cH
  000ac	00 00 00 00	 DD	 $LN3@operator
$LN3@operator:
  000b0	5f		 DB	 95			; 0000005fH
  000b1	54		 DB	 84			; 00000054H
  000b2	6d		 DB	 109			; 0000006dH
  000b3	70		 DB	 112			; 00000070H
  000b4	00		 DB	 0
??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 305  :     _CONSTEXPR20_CONTAINER _Vector_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 306  :         _Mybase::operator+=(_Off);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=

; 307  :         return *this;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 308  :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??Y?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@ABU01@@Z ; std::_Iterator_base12::_Iterator_base12
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	8b 55 08	 mov	 edx, DWORD PTR ___that$[ebp]
  00020	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00023	89 41 08	 mov	 DWORD PTR [ecx+8], eax
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=, COMDAT
; _this$ = ecx

; 121  :     _CONSTEXPR20_CONTAINER _Vector_const_iterator& operator+=(const difference_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 122  :         _Verify_offset(_Off);

  00018	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset

; 123  :         _Ptr += _Off;

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0002a	8b 45 08	 mov	 eax, DWORD PTR __Off$[ebp]
  0002d	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 124  :         return *this;

  00036	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 125  :     }

  00039	83 c4 04	 add	 esp, 4
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
??Y?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z
_TEXT	SEGMENT
__Mycont$ = -8						; size = 4
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset, COMDAT
; _this$ = ecx

; 105  :     _CONSTEXPR20_CONTAINER void _Verify_offset(const difference_type _Off) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 106  : #if _ITERATOR_DEBUG_LEVEL == 0
; 107  :         (void) _Off;
; 108  : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
; 109  :         const auto _Mycont = static_cast<const _Myvec*>(this->_Getcont());

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002a	89 45 f8	 mov	 DWORD PTR __Mycont$[ebp], eax
$LN4@Verify_off:

; 110  :         _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");

  0002d	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  00031	74 09		 je	 SHORT $LN22@Verify_off
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0003a	74 02		 je	 SHORT $LN7@Verify_off
$LN22@Verify_off:
  0003c	eb 56		 jmp	 SHORT $LN2@Verify_off
$LN7@Verify_off:
  0003e	8b f4		 mov	 esi, esp
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0CO@LHPFLLJB@cannot?5seek?5value?9initialized?5v@
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0004a	6a 00		 push	 0
  0004c	6a 6e		 push	 110			; 0000006eH
  0004e	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00065	83 f8 01	 cmp	 eax, 1
  00068	75 01		 jne	 SHORT $LN30@Verify_off
  0006a	cc		 int	 3
$LN30@Verify_off:
  0006b	8b f4		 mov	 esi, esp
  0006d	6a 00		 push	 0
  0006f	6a 6e		 push	 110			; 0000006eH
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1GA@EIHBFEJD@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAa@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	33 d2		 xor	 edx, edx
  00092	75 aa		 jne	 SHORT $LN7@Verify_off
$LN2@Verify_off:
  00094	33 c0		 xor	 eax, eax
  00096	75 95		 jne	 SHORT $LN4@Verify_off

; 111  :         if (_Off < 0) {

  00098	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  0009c	7d 70		 jge	 SHORT $LN23@Verify_off
$LN10@Verify_off:

; 112  :             _STL_VERIFY(_Off >= _Mycont->_Myfirst - _Ptr, "cannot seek vector iterator before begin");

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  000a1	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a4	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  000a7	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  000aa	c1 f8 02	 sar	 eax, 2
  000ad	39 45 08	 cmp	 DWORD PTR __Off$[ebp], eax
  000b0	7c 02		 jl	 SHORT $LN13@Verify_off
  000b2	eb 56		 jmp	 SHORT $LN8@Verify_off
$LN13@Verify_off:
  000b4	8b f4		 mov	 esi, esp
  000b6	68 00 00 00 00	 push	 OFFSET ??_C@_0CJ@DIFMEJBE@cannot?5seek?5vector?5iterator?5bef@
  000bb	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000c0	6a 00		 push	 0
  000c2	6a 70		 push	 112			; 00000070H
  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000c9	6a 02		 push	 2
  000cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000d1	83 c4 18	 add	 esp, 24			; 00000018H
  000d4	3b f4		 cmp	 esi, esp
  000d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000db	83 f8 01	 cmp	 eax, 1
  000de	75 01		 jne	 SHORT $LN31@Verify_off
  000e0	cc		 int	 3
$LN31@Verify_off:
  000e1	8b f4		 mov	 esi, esp
  000e3	6a 00		 push	 0
  000e5	6a 70		 push	 112			; 00000070H
  000e7	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000ec	68 00 00 00 00	 push	 OFFSET ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_1FG@JCGKNFIB@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
  000f6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000fc	83 c4 14	 add	 esp, 20			; 00000014H
  000ff	3b f4		 cmp	 esi, esp
  00101	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00106	33 d2		 xor	 edx, edx
  00108	75 aa		 jne	 SHORT $LN13@Verify_off
$LN8@Verify_off:
  0010a	33 c0		 xor	 eax, eax
  0010c	75 90		 jne	 SHORT $LN10@Verify_off
$LN23@Verify_off:

; 113  :         }
; 114  : 
; 115  :         if (_Off > 0) {

  0010e	83 7d 08 00	 cmp	 DWORD PTR __Off$[ebp], 0
  00112	7e 70		 jle	 SHORT $LN29@Verify_off
$LN16@Verify_off:

; 116  :             _STL_VERIFY(_Off <= _Mycont->_Mylast - _Ptr, "cannot seek vector iterator after end");

  00114	8b 4d f8	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  00117	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0011a	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0011d	2b 42 08	 sub	 eax, DWORD PTR [edx+8]
  00120	c1 f8 02	 sar	 eax, 2
  00123	39 45 08	 cmp	 DWORD PTR __Off$[ebp], eax
  00126	7f 02		 jg	 SHORT $LN19@Verify_off
  00128	eb 56		 jmp	 SHORT $LN14@Verify_off
$LN19@Verify_off:
  0012a	8b f4		 mov	 esi, esp
  0012c	68 00 00 00 00	 push	 OFFSET ??_C@_0CG@JDIOCKHH@cannot?5seek?5vector?5iterator?5aft@
  00131	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00136	6a 00		 push	 0
  00138	6a 74		 push	 116			; 00000074H
  0013a	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0013f	6a 02		 push	 2
  00141	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00147	83 c4 18	 add	 esp, 24			; 00000018H
  0014a	3b f4		 cmp	 esi, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	83 f8 01	 cmp	 eax, 1
  00154	75 01		 jne	 SHORT $LN32@Verify_off
  00156	cc		 int	 3
$LN32@Verify_off:
  00157	8b f4		 mov	 esi, esp
  00159	6a 00		 push	 0
  0015b	6a 74		 push	 116			; 00000074H
  0015d	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00162	68 00 00 00 00	 push	 OFFSET ??_C@_1NO@FMJOGJCJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo@
  00167	68 00 00 00 00	 push	 OFFSET ??_C@_1FA@LCODAPOP@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAs?$AAe?$AAe?$AAk?$AA?5?$AAv?$AAe@
  0016c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00172	83 c4 14	 add	 esp, 20			; 00000014H
  00175	3b f4		 cmp	 esi, esp
  00177	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0017c	33 d2		 xor	 edx, edx
  0017e	75 aa		 jne	 SHORT $LN19@Verify_off
$LN14@Verify_off:
  00180	33 c0		 xor	 eax, eax
  00182	75 90		 jne	 SHORT $LN16@Verify_off
$LN29@Verify_off:

; 117  :         }
; 118  : #endif // _ITERATOR_DEBUG_LEVEL == 0
; 119  :     }

  00184	5e		 pop	 esi
  00185	83 c4 08	 add	 esp, 8
  00188	3b ec		 cmp	 ebp, esp
  0018a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0018f	8b e5		 mov	 esp, ebp
  00191	5d		 pop	 ebp
  00192	c2 04 00	 ret	 4
?_Verify_offset@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBEXH@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Verify_offset
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >, COMDAT
; _this$ = ecx

; 42   :     _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Parg$[ebp]
  00026	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 43   :         this->_Adopt(_Pvector);

  00029	8b 55 0c	 mov	 edx, DWORD PTR __Pvector$[ebp]
  0002c	52		 push	 edx
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00030	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 44   :     }

  00035	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00038	83 c4 04	 add	 esp, 4
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c2 08 00	 ret	 8
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 251  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  0002c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4

; 256  :     } else

  00044	eb 29		 jmp	 SHORT $LN5@Deallocate
$LN2@Deallocate:

; 257  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00046	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0004d	72 10		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004f	8d 55 0c	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00052	52		 push	 edx
  00053	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0005c	83 c4 08	 add	 esp, 8
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006c	83 c4 08	 add	 esp, 8
$LN5@Deallocate:

; 265  :     }
; 266  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
  00088	cc		 int	 3
  00089	cc		 int	 3
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1390 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 124  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 125  :             return _Ok;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 126  :         }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -18						; size = 1
__Zero_uncaught_exceptions$ = -17			; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 109  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001c	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	50		 push	 eax
  0002b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00034	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 110  : #if !_HAS_EXCEPTIONS
; 111  :             const bool _Zero_uncaught_exceptions = true;
; 112  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 113  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909
; 114  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 115  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;

  00041	e8 00 00 00 00	 call	 ?uncaught_exceptions@std@@YAHXZ ; std::uncaught_exceptions
  00046	85 c0		 test	 eax, eax
  00048	75 06		 jne	 SHORT $LN4@sentry
  0004a	c6 45 ee 01	 mov	 BYTE PTR tv71[ebp], 1
  0004e	eb 04		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  00050	c6 45 ee 00	 mov	 BYTE PTR tv71[ebp], 0
$LN5@sentry:
  00054	8a 45 ee	 mov	 al, BYTE PTR tv71[ebp]
  00057	88 45 ef	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], al

; 116  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 117  : 
; 118  :             if (_Zero_uncaught_exceptions) {

  0005a	0f b6 4d ef	 movzx	 ecx, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  0005e	85 c9		 test	 ecx, ecx
  00060	74 14		 je	 SHORT $LN1@sentry

; 119  :                 this->_Myostr._Osfx();

  00062	8b f4		 mov	 esi, esp
  00064	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00067	8b 0a		 mov	 ecx, DWORD PTR [edx]
  00069	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  0006f	3b f4		 cmp	 esi, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@sentry:

; 120  :             }
; 121  :         }

  00076	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00081	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00088	59		 pop	 ecx
  00089	5e		 pop	 esi
  0008a	83 c4 14	 add	 esp, 20			; 00000014H
  0008d	3b ec		 cmp	 ebp, esp
  0008f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00094	8b e5		 mov	 esp, ebp
  00096	5d		 pop	 ebp
  00097	c3		 ret	 0
  00098	cc		 int	 3
  00099	cc		 int	 3
  0009a	cc		 int	 3
  0009b	cc		 int	 3
  0009c	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 92   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	56		 push	 esi
  00015	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001c	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00023	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00028	33 c5		 xor	 eax, ebp
  0002a	50		 push	 eax
  0002b	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002e	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00034	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00041	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00044	50		 push	 eax
  00045	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  0004d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 93   :             if (!_Ostr.good()) {

  00054	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00057	8b 11		 mov	 edx, DWORD PTR [ecx]
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0005c	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0005f	8b f4		 mov	 esi, esp
  00061	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00067	3b f4		 cmp	 esi, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	0f b6 c0	 movzx	 eax, al
  00071	85 c0		 test	 eax, eax
  00073	75 09		 jne	 SHORT $LN2@sentry

; 94   :                 _Ok = false;

  00075	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	c6 41 04 00	 mov	 BYTE PTR [ecx+4], 0

; 95   :                 return;

  0007c	eb 68		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 96   :             }
; 97   : 
; 98   :             const auto _Tied = _Ostr.tie();

  0007e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00081	8b 02		 mov	 eax, DWORD PTR [edx]
  00083	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00086	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00089	8b f4		 mov	 esi, esp
  0008b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  00091	3b f4		 cmp	 esi, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	89 45 ec	 mov	 DWORD PTR __Tied$[ebp], eax

; 99   :             if (!_Tied || _Tied == &_Ostr) {

  0009b	83 7d ec 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  0009f	74 08		 je	 SHORT $LN4@sentry
  000a1	8b 4d ec	 mov	 ecx, DWORD PTR __Tied$[ebp]
  000a4	3b 4d 08	 cmp	 ecx, DWORD PTR __Ostr$[ebp]
  000a7	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 100  :                 _Ok = true;

  000a9	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	c6 42 04 01	 mov	 BYTE PTR [edx+4], 1

; 101  :                 return;

  000b0	eb 34		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 102  :             }
; 103  : 
; 104  :             _Tied->flush();

  000b2	8b f4		 mov	 esi, esp
  000b4	8b 4d ec	 mov	 ecx, DWORD PTR __Tied$[ebp]
  000b7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000bd	3b f4		 cmp	 esi, esp
  000bf	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 105  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000c4	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000c9	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000cc	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000cf	8b f4		 mov	 esi, esp
  000d1	8b ca		 mov	 ecx, edx
  000d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000d9	3b f4		 cmp	 esi, esp
  000db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e0	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000e3	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN1@sentry:

; 106  :         }

  000e6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ed	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000f0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fa	59		 pop	 ecx
  000fb	5e		 pop	 esi
  000fc	83 c4 14	 add	 esp, 20			; 00000014H
  000ff	3b ec		 cmp	 ebp, esp
  00101	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00106	8b e5		 mov	 esp, ebp
  00108	5d		 pop	 ebp
  00109	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -24						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 78   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	56		 push	 esi
  00015	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001c	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00023	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  0002a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002f	33 c5		 xor	 eax, ebp
  00031	50		 push	 eax
  00032	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00035	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003b	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003e	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  00043	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 79   :             const auto _Rdbuf = _Myostr.rdbuf();

  00048	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004d	89 4d e8	 mov	 DWORD PTR tv72[ebp], ecx
  00050	8b 55 e8	 mov	 edx, DWORD PTR tv72[ebp]
  00053	8b 02		 mov	 eax, DWORD PTR [edx]
  00055	8b 4d e8	 mov	 ecx, DWORD PTR tv72[ebp]
  00058	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0005b	8b f4		 mov	 esi, esp
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00063	3b f4		 cmp	 esi, esp
  00065	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006a	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 80   :             if (_Rdbuf) {

  0006d	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00071	74 16		 je	 SHORT $LN3@Sentry_bas

; 81   :                 _Rdbuf->_Unlock();

  00073	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00076	8b 11		 mov	 edx, DWORD PTR [ecx]
  00078	8b f4		 mov	 esi, esp
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  0007d	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00080	ff d0		 call	 eax
  00082	3b f4		 cmp	 esi, esp
  00084	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Sentry_bas:

; 82   :             }
; 83   :         }

  00089	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00093	59		 pop	 ecx
  00094	5e		 pop	 esi
  00095	83 c4 18	 add	 esp, 24			; 00000018H
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
  000a3	cc		 int	 3
  000a4	cc		 int	 3
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a ec	 mov	 ecx, DWORD PTR [edx-20]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -12						; size = 4
__Rdbuf$ = -8						; size = 4
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 71   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  00024	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0002f	89 08		 mov	 DWORD PTR [eax], ecx

; 72   :             const auto _Rdbuf = _Myostr.rdbuf();

  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	8b 02		 mov	 eax, DWORD PTR [edx]
  00036	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00039	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  0003c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003e	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  00041	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00044	8b f4		 mov	 esi, esp
  00046	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0004c	3b f4		 cmp	 esi, esp
  0004e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00053	89 45 f8	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 73   :             if (_Rdbuf) {

  00056	83 7d f8 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0005a	74 16		 je	 SHORT $LN1@Sentry_bas

; 74   :                 _Rdbuf->_Lock();

  0005c	8b 45 f8	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  0005f	8b 10		 mov	 edx, DWORD PTR [eax]
  00061	8b f4		 mov	 esi, esp
  00063	8b 4d f8	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00066	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00069	ff d0		 call	 eax
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Sentry_bas:

; 75   :             }
; 76   :         }

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	5e		 pop	 esi
  00076	83 c4 0c	 add	 esp, 12			; 0000000cH
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001e	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00022	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 64   :         if (_Count > _Max_possible) {

  00029	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00030	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00032	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00037	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	c1 e0 02	 shl	 eax, 2
$LN3@Get_size_o:

; 70   : }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
$T1 = -12						; size = 4
__New_proxy$ = -8					; size = 4
_this$ = -4						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00028	6a 01		 push	 1
  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0002d	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  00032	50		 push	 eax
  00033	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00038	83 c4 04	 add	 esp, 4
  0003b	89 45 f8	 mov	 DWORD PTR __New_proxy$[ebp], eax

; 1075 :         _Construct_in_place(*_New_proxy, this);

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00044	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00047	51		 push	 ecx
  00048	8b 55 f8	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00051	83 c4 08	 add	 esp, 8

; 1076 :         _Myproxy            = _New_proxy;

  00054	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00057	8b 4d f8	 mov	 ecx, DWORD PTR __New_proxy$[ebp]
  0005a	89 08		 mov	 DWORD PTR [eax], ecx

; 1077 :         _New_proxy->_Mycont = this;

  0005c	8b 55 f8	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00062	89 02		 mov	 DWORD PTR [edx], eax

; 1078 :     }

  00064	83 c4 0c	 add	 esp, 12			; 0000000cH
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BA@@std@@YAII@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001e	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00022	c7 45 f8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 64   :         if (_Count > _Max_possible) {

  00029	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  00030	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00032	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00037	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	c1 e0 04	 shl	 eax, 4
$LN3@Get_size_o:

; 70   : }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -4						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 614  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00018	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001a	89 4d fc	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  0001d	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  00020	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  00023	8b 08		 mov	 ecx, DWORD PTR [eax]
  00025	89 0a		 mov	 DWORD PTR [edx], ecx

; 618  :     return _Old_val;

  00027	8b 45 fc	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 619  : }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 17		 jne	 SHORT $LN2@Allocate

; 235  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00020	72 0e		 jb	 SHORT $LN2@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0002b	83 c4 04	 add	 esp, 4
  0002e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00030	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00034	74 0e		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00036	8b 55 08	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003f	83 c4 04	 add	 esp, 4
  00042	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00044	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00046	3b ec		 cmp	 ebp, esp
  00048	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0001e	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00022	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 64   :         if (_Count > _Max_possible) {

  00029	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00030	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00032	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00037	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0003a	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 70   : }

  0003d	83 c4 08	 add	 esp, 8
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
tv79 = -4						; size = 4
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 978  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  00011	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 979  :     _Ostr.put(_Ostr.widen('\n'));

  00016	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00019	8b 08		 mov	 ecx, DWORD PTR [eax]
  0001b	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0001e	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00021	89 55 fc	 mov	 DWORD PTR tv79[ebp], edx
  00024	8b f4		 mov	 esi, esp
  00026	6a 0a		 push	 10			; 0000000aH
  00028	8b 4d fc	 mov	 ecx, DWORD PTR tv79[ebp]
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00031	3b f4		 cmp	 esi, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b f4		 mov	 esi, esp
  0003a	0f b6 c0	 movzx	 eax, al
  0003d	50		 push	 eax
  0003e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00041	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  00047	3b f4		 cmp	 esi, esp
  00049	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 980  :     _Ostr.flush();

  0004e	8b f4		 mov	 esi, esp
  00050	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 981  :     return _Ostr;

  00060	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 982  : }

  00063	5e		 pop	 esi
  00064	83 c4 04	 add	 esp, 4
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv295 = -164						; size = 4
tv281 = -160						; size = 4
tv268 = -156						; size = 4
tv307 = -152						; size = 4
tv246 = -146						; size = 1
tv306 = -145						; size = 1
tv248 = -144						; size = 4
tv305 = -140						; size = 4
tv304 = -136						; size = 8
tv213 = -128						; size = 4
tv303 = -124						; size = 4
tv302 = -120						; size = 4
tv187 = -114						; size = 1
tv301 = -113						; size = 1
tv189 = -112						; size = 4
tv300 = -108						; size = 4
tv137 = -104						; size = 4
tv135 = -100						; size = 8
tv359 = -92						; size = 8
tv345 = -84						; size = 8
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -64						; size = 4
$T6 = -60						; size = 4
__Ok$ = -52						; size = 8
__Pad$ = -40						; size = 8
__Count$ = -32						; size = 8
__State$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 734  :     const char* _Val) { // insert NTBS into char stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 94 00 00
	00		 sub	 esp, 148		; 00000094H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd 5c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-164]
  00021	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET __C12F3EA4_ostream
  00049	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 735  :     using _Elem = char;
; 736  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 737  : 
; 738  :     ios_base::iostate _State = ios_base::goodbit;

  0004e	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 739  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00055	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0005e	83 c4 04	 add	 esp, 4
  00061	33 c9		 xor	 ecx, ecx
  00063	89 45 e0	 mov	 DWORD PTR __Count$[ebp], eax
  00066	89 4d e4	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 740  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00069	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0006c	8b 02		 mov	 eax, DWORD PTR [edx]
  0006e	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00071	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00074	8b f4		 mov	 esi, esp
  00076	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0007c	3b f4		 cmp	 esi, esp
  0007e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00083	89 45 ac	 mov	 DWORD PTR tv345[ebp], eax
  00086	89 55 b0	 mov	 DWORD PTR tv345[ebp+4], edx
  00089	83 7d b0 00	 cmp	 DWORD PTR tv345[ebp+4], 0
  0008d	7c 62		 jl	 SHORT $LN17@operator
  0008f	7f 06		 jg	 SHORT $LN24@operator
  00091	83 7d ac 00	 cmp	 DWORD PTR tv345[ebp], 0
  00095	76 5a		 jbe	 SHORT $LN17@operator
$LN24@operator:
  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0009f	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000a2	8b f4		 mov	 esi, esp
  000a4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000aa	3b f4		 cmp	 esi, esp
  000ac	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b1	89 45 a4	 mov	 DWORD PTR tv359[ebp], eax
  000b4	89 55 a8	 mov	 DWORD PTR tv359[ebp+4], edx
  000b7	8b 45 a8	 mov	 eax, DWORD PTR tv359[ebp+4]
  000ba	3b 45 e4	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  000bd	7c 32		 jl	 SHORT $LN17@operator
  000bf	7f 08		 jg	 SHORT $LN25@operator
  000c1	8b 4d a4	 mov	 ecx, DWORD PTR tv359[ebp]
  000c4	3b 4d e0	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000c7	76 28		 jbe	 SHORT $LN17@operator
$LN25@operator:
  000c9	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000cc	8b 02		 mov	 eax, DWORD PTR [edx]
  000ce	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000d1	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000d4	8b f4		 mov	 esi, esp
  000d6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000dc	3b f4		 cmp	 esi, esp
  000de	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e3	2b 45 e0	 sub	 eax, DWORD PTR __Count$[ebp]
  000e6	1b 55 e4	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  000e9	89 45 9c	 mov	 DWORD PTR tv135[ebp], eax
  000ec	89 55 a0	 mov	 DWORD PTR tv135[ebp+4], edx
  000ef	eb 08		 jmp	 SHORT $LN18@operator
$LN17@operator:
  000f1	0f 57 c0	 xorps	 xmm0, xmm0
  000f4	66 0f 13 45 9c	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  000f9	8b 4d 9c	 mov	 ecx, DWORD PTR tv135[ebp]
  000fc	8b 55 a0	 mov	 edx, DWORD PTR tv135[ebp+4]
  000ff	89 4d d8	 mov	 DWORD PTR __Pad$[ebp], ecx
  00102	89 55 dc	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 741  :     const typename _Myos::sentry _Ok(_Ostr);

  00105	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00108	50		 push	 eax
  00109	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0010c	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  00111	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 742  : 
; 743  :     if (!_Ok) {

  00118	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0011b	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  00120	0f b6 c8	 movzx	 ecx, al
  00123	85 c9		 test	 ecx, ecx
  00125	75 0e		 jne	 SHORT $LN8@operator

; 744  :         _State |= ios_base::badbit;

  00127	8b 55 e8	 mov	 edx, DWORD PTR __State$[ebp]
  0012a	83 ca 04	 or	 edx, 4
  0012d	89 55 e8	 mov	 DWORD PTR __State$[ebp], edx

; 745  :     } else { // state okay, insert

  00130	e9 bc 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 746  :         _TRY_IO_BEGIN

  00135	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 747  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00139	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0013c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0013e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00141	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00144	8b f4		 mov	 esi, esp
  00146	8b ca		 mov	 ecx, edx
  00148	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  0014e	3b f4		 cmp	 esi, esp
  00150	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00155	89 45 98	 mov	 DWORD PTR tv137[ebp], eax
  00158	8b 45 98	 mov	 eax, DWORD PTR tv137[ebp]
  0015b	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00160	83 f8 40	 cmp	 eax, 64			; 00000040H
  00163	0f 84 c1 00 00
	00		 je	 $LN11@operator

; 748  :             for (; 0 < _Pad; --_Pad) { // pad on left

  00169	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0016b	8b 4d d8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  0016e	83 e9 01	 sub	 ecx, 1
  00171	8b 55 dc	 mov	 edx, DWORD PTR __Pad$[ebp+4]
  00174	83 da 00	 sbb	 edx, 0
  00177	89 4d d8	 mov	 DWORD PTR __Pad$[ebp], ecx
  0017a	89 55 dc	 mov	 DWORD PTR __Pad$[ebp+4], edx
$LN4@operator:
  0017d	83 7d dc 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00181	0f 8c a3 00 00
	00		 jl	 $LN11@operator
  00187	7f 0a		 jg	 SHORT $LN26@operator
  00189	83 7d d8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  0018d	0f 86 97 00 00
	00		 jbe	 $LN11@operator
$LN26@operator:

; 749  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00193	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00196	8b 08		 mov	 ecx, DWORD PTR [eax]
  00198	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0019b	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0019e	8b f4		 mov	 esi, esp
  001a0	8b ca		 mov	 ecx, edx
  001a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001a8	3b f4		 cmp	 esi, esp
  001aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001af	89 45 94	 mov	 DWORD PTR tv300[ebp], eax
  001b2	8b 45 94	 mov	 eax, DWORD PTR tv300[ebp]
  001b5	89 45 90	 mov	 DWORD PTR tv189[ebp], eax
  001b8	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  001bd	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  001c0	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  001c3	8b f4		 mov	 esi, esp
  001c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  001cb	3b f4		 cmp	 esi, esp
  001cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001d2	88 45 8f	 mov	 BYTE PTR tv301[ebp], al
  001d5	8a 45 8f	 mov	 al, BYTE PTR tv301[ebp]
  001d8	88 45 8e	 mov	 BYTE PTR tv187[ebp], al
  001db	8b f4		 mov	 esi, esp
  001dd	0f b6 4d 8e	 movzx	 ecx, BYTE PTR tv187[ebp]
  001e1	51		 push	 ecx
  001e2	8b 4d 90	 mov	 ecx, DWORD PTR tv189[ebp]
  001e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  001eb	3b f4		 cmp	 esi, esp
  001ed	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001f2	89 45 88	 mov	 DWORD PTR tv302[ebp], eax
  001f5	8b 55 88	 mov	 edx, DWORD PTR tv302[ebp]
  001f8	89 55 c4	 mov	 DWORD PTR $T6[ebp], edx
  001fb	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  00200	89 45 c0	 mov	 DWORD PTR $T5[ebp], eax
  00203	8d 45 c4	 lea	 eax, DWORD PTR $T6[ebp]
  00206	50		 push	 eax
  00207	8d 4d c0	 lea	 ecx, DWORD PTR $T5[ebp]
  0020a	51		 push	 ecx
  0020b	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00210	83 c4 08	 add	 esp, 8
  00213	0f b6 d0	 movzx	 edx, al
  00216	85 d2		 test	 edx, edx
  00218	74 0b		 je	 SHORT $LN12@operator

; 750  :                     _State |= ios_base::badbit; // insertion failed, quit

  0021a	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  0021d	83 c8 04	 or	 eax, 4
  00220	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 751  :                     break;

  00223	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 752  :                 }
; 753  :             }

  00225	e9 41 ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 754  :         }
; 755  : 
; 756  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0022a	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  0022e	75 6c		 jne	 SHORT $LN13@operator
  00230	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00233	8b 11		 mov	 edx, DWORD PTR [ecx]
  00235	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00238	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0023b	8b f4		 mov	 esi, esp
  0023d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00243	3b f4		 cmp	 esi, esp
  00245	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0024a	89 45 84	 mov	 DWORD PTR tv303[ebp], eax
  0024d	8b 45 84	 mov	 eax, DWORD PTR tv303[ebp]
  00250	89 45 80	 mov	 DWORD PTR tv213[ebp], eax
  00253	8b f4		 mov	 esi, esp
  00255	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp+4]
  00258	51		 push	 ecx
  00259	8b 55 e0	 mov	 edx, DWORD PTR __Count$[ebp]
  0025c	52		 push	 edx
  0025d	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00260	50		 push	 eax
  00261	8b 4d 80	 mov	 ecx, DWORD PTR tv213[ebp]
  00264	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  0026a	3b f4		 cmp	 esi, esp
  0026c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00271	89 85 78 ff ff
	ff		 mov	 DWORD PTR tv304[ebp], eax
  00277	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv304[ebp+4], edx
  0027d	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv304[ebp]
  00283	3b 4d e0	 cmp	 ecx, DWORD PTR __Count$[ebp]
  00286	75 0b		 jne	 SHORT $LN27@operator
  00288	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv304[ebp+4]
  0028e	3b 55 e4	 cmp	 edx, DWORD PTR __Count$[ebp+4]
  00291	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 757  :             _State |= ios_base::badbit;

  00293	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00296	83 c8 04	 or	 eax, 4
  00299	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 758  :         }
; 759  : 
; 760  :         if (_State == ios_base::goodbit) {

  0029c	83 7d e8 00	 cmp	 DWORD PTR __State$[ebp], 0
  002a0	0f 85 df 00 00
	00		 jne	 $LN14@operator

; 761  :             for (; 0 < _Pad; --_Pad) { // pad on right

  002a6	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002a8	8b 4d d8	 mov	 ecx, DWORD PTR __Pad$[ebp]
  002ab	83 e9 01	 sub	 ecx, 1
  002ae	8b 55 dc	 mov	 edx, DWORD PTR __Pad$[ebp+4]
  002b1	83 da 00	 sbb	 edx, 0
  002b4	89 4d d8	 mov	 DWORD PTR __Pad$[ebp], ecx
  002b7	89 55 dc	 mov	 DWORD PTR __Pad$[ebp+4], edx
$LN7@operator:
  002ba	83 7d dc 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  002be	0f 8c c1 00 00
	00		 jl	 $LN14@operator
  002c4	7f 0a		 jg	 SHORT $LN28@operator
  002c6	83 7d d8 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  002ca	0f 86 b5 00 00
	00		 jbe	 $LN14@operator
$LN28@operator:

; 762  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  002d0	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  002d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  002d8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  002db	8b f4		 mov	 esi, esp
  002dd	8b ca		 mov	 ecx, edx
  002df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  002e5	3b f4		 cmp	 esi, esp
  002e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002ec	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv305[ebp], eax
  002f2	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv305[ebp]
  002f8	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv248[ebp], eax
  002fe	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00301	8b 11		 mov	 edx, DWORD PTR [ecx]
  00303	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00306	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  00309	8b f4		 mov	 esi, esp
  0030b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  00311	3b f4		 cmp	 esi, esp
  00313	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00318	88 85 6f ff ff
	ff		 mov	 BYTE PTR tv306[ebp], al
  0031e	8a 85 6f ff ff
	ff		 mov	 al, BYTE PTR tv306[ebp]
  00324	88 85 6e ff ff
	ff		 mov	 BYTE PTR tv246[ebp], al
  0032a	8b f4		 mov	 esi, esp
  0032c	0f b6 8d 6e ff
	ff ff		 movzx	 ecx, BYTE PTR tv246[ebp]
  00333	51		 push	 ecx
  00334	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv248[ebp]
  0033a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00340	3b f4		 cmp	 esi, esp
  00342	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00347	89 85 68 ff ff
	ff		 mov	 DWORD PTR tv307[ebp], eax
  0034d	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv307[ebp]
  00353	89 55 bc	 mov	 DWORD PTR $T4[ebp], edx
  00356	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0035b	89 45 b8	 mov	 DWORD PTR $T3[ebp], eax
  0035e	8d 45 bc	 lea	 eax, DWORD PTR $T4[ebp]
  00361	50		 push	 eax
  00362	8d 4d b8	 lea	 ecx, DWORD PTR $T3[ebp]
  00365	51		 push	 ecx
  00366	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  0036b	83 c4 08	 add	 esp, 8
  0036e	0f b6 d0	 movzx	 edx, al
  00371	85 d2		 test	 edx, edx
  00373	74 0b		 je	 SHORT $LN15@operator

; 763  :                     _State |= ios_base::badbit; // insertion failed, quit

  00375	8b 45 e8	 mov	 eax, DWORD PTR __State$[ebp]
  00378	83 c8 04	 or	 eax, 4
  0037b	89 45 e8	 mov	 DWORD PTR __State$[ebp], eax

; 764  :                     break;

  0037e	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 765  :                 }
; 766  :             }

  00380	e9 23 ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 767  :         }
; 768  : 
; 769  :         _Ostr.width(0);

  00385	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00388	8b 11		 mov	 edx, DWORD PTR [ecx]
  0038a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0038d	03 42 04	 add	 eax, DWORD PTR [edx+4]
  00390	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv268[ebp], eax
  00396	8b f4		 mov	 esi, esp
  00398	6a 00		 push	 0
  0039a	6a 00		 push	 0
  0039c	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv268[ebp]
  003a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  003a8	3b f4		 cmp	 esi, esp
  003aa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003af	eb 30		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 770  :         _CATCH_IO_(ios_base, _Ostr)

  003b1	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003b4	8b 11		 mov	 edx, DWORD PTR [ecx]
  003b6	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003b9	03 42 04	 add	 eax, DWORD PTR [edx+4]
  003bc	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv281[ebp], eax
  003c2	8b f4		 mov	 esi, esp
  003c4	6a 01		 push	 1
  003c6	6a 04		 push	 4
  003c8	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv281[ebp]
  003ce	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003d4	3b f4		 cmp	 esi, esp
  003d6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003db	b8 00 00 00 00	 mov	 eax, $LN23@operator
  003e0	c3		 ret	 0
$LN19@operator:
  003e1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  003e8	eb 07		 jmp	 SHORT $LN9@operator
$LN23@operator:
  003ea	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 771  :     }
; 772  : 
; 773  :     _Ostr.setstate(_State);

  003f1	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  003f4	8b 11		 mov	 edx, DWORD PTR [ecx]
  003f6	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003f9	03 42 04	 add	 eax, DWORD PTR [edx+4]
  003fc	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv295[ebp], eax
  00402	8b f4		 mov	 esi, esp
  00404	6a 00		 push	 0
  00406	8b 4d e8	 mov	 ecx, DWORD PTR __State$[ebp]
  00409	51		 push	 ecx
  0040a	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv295[ebp]
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00416	3b f4		 cmp	 esi, esp
  00418	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 774  :     return _Ostr;

  0041d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00420	89 55 b4	 mov	 DWORD PTR $T2[ebp], edx
  00423	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0042a	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0042d	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00432	8b 45 b4	 mov	 eax, DWORD PTR $T2[ebp]

; 775  : }

  00435	52		 push	 edx
  00436	8b cd		 mov	 ecx, ebp
  00438	50		 push	 eax
  00439	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@operator
  0043f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00444	58		 pop	 eax
  00445	5a		 pop	 edx
  00446	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00449	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00450	59		 pop	 ecx
  00451	5f		 pop	 edi
  00452	5e		 pop	 esi
  00453	5b		 pop	 ebx
  00454	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00457	33 cd		 xor	 ecx, ebp
  00459	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0045e	81 c4 a4 00 00
	00		 add	 esp, 164		; 000000a4H
  00464	3b ec		 cmp	 ebp, esp
  00466	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0046b	8b e5		 mov	 esp, ebp
  0046d	5d		 pop	 ebp
  0046e	c3		 ret	 0
  0046f	90		 npad	 1
$LN32@operator:
  00470	01 00 00 00	 DD	 1
  00474	00 00 00 00	 DD	 $LN31@operator
$LN31@operator:
  00478	cc ff ff ff	 DD	 -52			; ffffffccH
  0047c	08 00 00 00	 DD	 8
  00480	00 00 00 00	 DD	 $LN29@operator
$LN29@operator:
  00484	5f		 DB	 95			; 0000005fH
  00485	4f		 DB	 79			; 0000004fH
  00486	6b		 DB	 107			; 0000006bH
  00487	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d cc	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 58 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-168]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\System\Vector2.inl
;	COMDAT ??0?$Vector2@H@sf@@QAE@HH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_X$ = 8							; size = 4
_Y$ = 12						; size = 4
??0?$Vector2@H@sf@@QAE@HH@Z PROC			; sf::Vector2<int>::Vector2<int>, COMDAT
; _this$ = ecx

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0A631FEE_Vector2@inl
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   : x(X),

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _X$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx

; 40   : y(Y)

  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 45 0c	 mov	 eax, DWORD PTR _Y$[ebp]
  00026	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 42   : 
; 43   : }

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??0?$Vector2@H@sf@@QAE@HH@Z ENDP			; sf::Vector2<int>::Vector2<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z PROC ; std::make_tuple<enum DIRDEP,enum DIRDEP &>, COMDAT

; 888  : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 889  :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 890  :     return _Ttype(_STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0003c	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  0003f	52		 push	 edx
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00043	50		 push	 eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00047	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@AAW40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@AAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP &,0>
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 891  : }

  0004f	83 c4 08	 add	 esp, 8
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ENDP ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z PROC ; std::get<1,enum DIRDEP,enum DIRDEP>, COMDAT

; 816  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 817  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 818  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]

; 819  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ENDP ; std::get<1,enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z PROC ; std::make_tuple<enum DIRDEP &,enum DIRDEP>, COMDAT

; 888  : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 889  :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 890  :     return _Ttype(_STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$forward@AAW4DIRDEP@@@std@@YAAAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP &>
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0003c	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  0003f	52		 push	 edx
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00043	50		 push	 eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00047	e8 00 00 00 00	 call	 ??$?0AAW4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@AAW4DIRDEP@@$$QAW42@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP &,enum DIRDEP,0>
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 891  : }

  0004f	83 c4 08	 add	 esp, 8
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ENDP ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z PROC ; std::get<0,enum DIRDEP,enum DIRDEP>, COMDAT

; 816  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 817  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 818  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00010	83 c0 04	 add	 eax, 4

; 819  : }

  00013	3b ec		 cmp	 ebp, esp
  00015	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001a	5d		 pop	 ebp
  0001b	c3		 ret	 0
??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ENDP ; std::get<0,enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z
_TEXT	SEGMENT
tv73 = -8						; size = 4
tv75 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_<_Args_0>$ = 12					; size = 4
_<_Args_1>$ = 16					; size = 4
??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z PROC ; std::make_tuple<enum DIRDEP,enum DIRDEP>, COMDAT

; 888  : _NODISCARD constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args) { // make tuple from elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 889  :     using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
; 890  :     return _Ttype(_STD forward<_Types>(_Args)...);

  0001e	8b 45 10	 mov	 eax, DWORD PTR _<_Args_1>$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00027	83 c4 04	 add	 esp, 4
  0002a	89 45 fc	 mov	 DWORD PTR tv75[ebp], eax
  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR tv73[ebp], eax
  0003c	8b 55 fc	 mov	 edx, DWORD PTR tv75[ebp]
  0003f	52		 push	 edx
  00040	8b 45 f8	 mov	 eax, DWORD PTR tv73[ebp]
  00043	50		 push	 eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00047	e8 00 00 00 00	 call	 ??$?0W4DIRDEP@@W40@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAE@$$QAW4DIRDEP@@0@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP><enum DIRDEP,enum DIRDEP,0>
  0004c	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 891  : }

  0004f	83 c4 08	 add	 esp, 8
  00052	3b ec		 cmp	 ebp, esp
  00054	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z ENDP ; std::make_tuple<enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
tv80 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>, COMDAT
; _this$ = ecx

; 623  :         conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 624  :         _Myfirst._Val = _STD forward<_This>(_Right._Myfirst._Val);

  00021	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00024	83 c0 04	 add	 eax, 4
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@W4DIRDEP@@@std@@YA$$QAW4DIRDEP@@AAW41@@Z ; std::forward<enum DIRDEP>
  0002d	83 c4 04	 add	 esp, 4
  00030	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00033	8b 10		 mov	 edx, DWORD PTR [eax]
  00035	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 625  :         _Get_rest()   = _STD forward<_Mybase>(_Right._Get_rest());

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0003b	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
  00040	50		 push	 eax
  00041	e8 00 00 00 00	 call	 ??$forward@V?$tuple@W4DIRDEP@@@std@@@std@@YA$$QAV?$tuple@W4DIRDEP@@@0@AAV10@@Z ; std::forward<std::tuple<enum DIRDEP> >
  00046	83 c4 04	 add	 esp, 4
  00049	89 45 f8	 mov	 DWORD PTR tv80[ebp], eax
  0004c	8b 45 f8	 mov	 eax, DWORD PTR tv80[ebp]
  0004f	50		 push	 eax
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
  00058	8b c8		 mov	 ecx, eax
  0005a	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP>::operator=<std::tuple<enum DIRDEP>,enum DIRDEP,0>

; 626  :         return *this;

  0005f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 627  :     }

  00062	83 c4 08	 add	 esp, 8
  00065	3b ec		 cmp	 ebp, esp
  00067	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c2 04 00	 ret	 4
??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
tv259 = -384						; size = 4
tv261 = -380						; size = 4
tv250 = -376						; size = 4
tv240 = -372						; size = 4
tv242 = -368						; size = 4
tv224 = -364						; size = 4
tv353 = -360						; size = 8
tv350 = -352						; size = 4
tv226 = -348						; size = 4
tv343 = -344						; size = 8
tv340 = -336						; size = 4
tv201 = -332						; size = 4
tv186 = -328						; size = 4
tv183 = -324						; size = 4
tv188 = -320						; size = 4
tv190 = -316						; size = 4
tv165 = -312						; size = 4
tv160 = -308						; size = 4
tv154 = -304						; size = 4
tv156 = -300						; size = 4
tv141 = -296						; size = 4
tv92 = -292						; size = 4
tv88 = -288						; size = 4
tv71 = -284						; size = 4
$T2 = -280						; size = 16
$T3 = -264						; size = 4
$T4 = -260						; size = 4
$T5 = -256						; size = 8
$T6 = -248						; size = 16
$T7 = -232						; size = 4
$T8 = -228						; size = 4
$T9 = -224						; size = 4
$T10 = -220						; size = 4
$T11 = -216						; size = 4
_View$ = -208						; size = 168
_si$ = -32						; size = 8
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_lvl$ = 8						; size = 4
?loadTerrain@Univers@@QAEXH@Z PROC			; Univers::loadTerrain
; _this$ = ecx

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?loadTerrain@Univers@@QAEXH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 74 01 00
	00		 sub	 esp, 372		; 00000174H
  00017	56		 push	 esi
  00018	57		 push	 edi
  00019	51		 push	 ecx
  0001a	8d bd 80 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-384]
  00020	b9 5d 00 00 00	 mov	 ecx, 93			; 0000005dH
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	59		 pop	 ecx
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00049	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 120  :     if (ter != nullptr) {

  0004e	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  00055	74 34		 je	 SHORT $LN5@loadTerrai

; 121  :         delete(ter);

  00057	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0005d	89 95 28 ff ff
	ff		 mov	 DWORD PTR $T11[ebp], edx
  00063	83 bd 28 ff ff
	ff 00		 cmp	 DWORD PTR $T11[ebp], 0
  0006a	74 15		 je	 SHORT $LN4@loadTerrai
  0006c	6a 01		 push	 1
  0006e	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  00074	e8 00 00 00 00	 call	 ??_GTerrain@@QAEPAXI@Z
  00079	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv71[ebp], eax
  0007f	eb 0a		 jmp	 SHORT $LN5@loadTerrai
$LN4@loadTerrai:
  00081	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv71[ebp], 0
$LN5@loadTerrai:

; 122  :     }
; 123  :     ter = new Terrain(RP);

  0008b	6a 18		 push	 24			; 00000018H
  0008d	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00092	83 c4 04	 add	 esp, 4
  00095	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0009b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000a2	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T9[ebp], 0
  000a9	74 27		 je	 SHORT $LN6@loadTerrai
  000ab	6a 18		 push	 24			; 00000018H
  000ad	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  000b3	e8 00 00 00 00	 call	 ?__autoclassinit2@Terrain@@QAEXI@Z
  000b8	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000bb	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000be	51		 push	 ecx
  000bf	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  000c5	e8 00 00 00 00	 call	 ??0Terrain@@QAE@PAVRessourcePack@@@Z ; Terrain::Terrain
  000ca	89 85 e0 fe ff
	ff		 mov	 DWORD PTR tv88[ebp], eax
  000d0	eb 0a		 jmp	 SHORT $LN7@loadTerrai
$LN6@loadTerrai:
  000d2	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv88[ebp], 0
$LN7@loadTerrai:
  000dc	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv88[ebp]
  000e2	89 95 24 ff ff
	ff		 mov	 DWORD PTR $T10[ebp], edx
  000e8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000ef	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000f2	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  000f8	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 124  :     ter->loadTerrain(1);

  000fb	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  000fe	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00101	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv92[ebp], eax
  00107	6a 01		 push	 1
  00109	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv92[ebp]
  0010f	e8 00 00 00 00	 call	 ?loadTerrain@Terrain@@QAEXH@Z ; Terrain::loadTerrain

; 125  :     p = ter->getPlayer();

  00114	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00117	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0011a	e8 00 00 00 00	 call	 ?getPlayer@Terrain@@QAEPAVPlayer@@XZ ; Terrain::getPlayer
  0011f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00122	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 126  :     backgroundTex = new sf::Texture();

  00125	6a 28		 push	 40			; 00000028H
  00127	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0012c	83 c4 04	 add	 esp, 4
  0012f	89 85 18 ff ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00135	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0013c	83 bd 18 ff ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  00143	74 1d		 je	 SHORT $LN8@loadTerrai
  00145	8b f4		 mov	 esi, esp
  00147	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  0014d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Texture@sf@@QAE@XZ
  00153	3b f4		 cmp	 esi, esp
  00155	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0015a	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv141[ebp], eax
  00160	eb 0a		 jmp	 SHORT $LN9@loadTerrai
$LN8@loadTerrai:
  00162	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv141[ebp], 0
$LN9@loadTerrai:
  0016c	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  00172	89 85 1c ff ff
	ff		 mov	 DWORD PTR $T8[ebp], eax
  00178	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00182	8b 95 1c ff ff
	ff		 mov	 edx, DWORD PTR $T8[ebp]
  00188	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 127  :     sf::Vector2i si = sf::Vector2i(ter->getSizeY() * BLOCKWIDTH, ter->getSizeX() * BLOCKHEIGHT);

  0018b	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018e	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00191	e8 00 00 00 00	 call	 ?getSizeX@Terrain@@QAEIXZ ; Terrain::getSizeX
  00196	6b c8 28	 imul	 ecx, eax, 40
  00199	89 8d d4 fe ff
	ff		 mov	 DWORD PTR tv156[ebp], ecx
  0019f	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001a2	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  001a5	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  001aa	6b c0 32	 imul	 eax, eax, 50
  001ad	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv154[ebp], eax
  001b3	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv156[ebp]
  001b9	51		 push	 ecx
  001ba	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv154[ebp]
  001c0	52		 push	 edx
  001c1	8d 4d e0	 lea	 ecx, DWORD PTR _si$[ebp]
  001c4	e8 00 00 00 00	 call	 ??0?$Vector2@H@sf@@QAE@HH@Z ; sf::Vector2<int>::Vector2<int>

; 128  :     backgroundTex->setSmooth(true);

  001c9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  001cc	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  001cf	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv160[ebp], ecx
  001d5	8b f4		 mov	 esi, esp
  001d7	6a 01		 push	 1
  001d9	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv160[ebp]
  001df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setSmooth@Texture@sf@@QAEX_N@Z
  001e5	3b f4		 cmp	 esi, esp
  001e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 129  :     backgroundTex->setRepeated(true);

  001ec	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  001ef	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  001f2	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv165[ebp], eax
  001f8	8b f4		 mov	 esi, esp
  001fa	6a 01		 push	 1
  001fc	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv165[ebp]
  00202	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setRepeated@Texture@sf@@QAEX_N@Z
  00208	3b f4		 cmp	 esi, esp
  0020a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 130  :     backgroundTex->loadFromImage(*RP->getImgBackground(1), sf::IntRect(sf::Vector2i(0,0),si));

  0020f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00212	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00215	89 95 c4 fe ff
	ff		 mov	 DWORD PTR tv190[ebp], edx
  0021b	8d 45 e0	 lea	 eax, DWORD PTR _si$[ebp]
  0021e	50		 push	 eax
  0021f	6a 00		 push	 0
  00221	6a 00		 push	 0
  00223	8d 8d 00 ff ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00229	e8 00 00 00 00	 call	 ??0?$Vector2@H@sf@@QAE@HH@Z ; sf::Vector2<int>::Vector2<int>
  0022e	50		 push	 eax
  0022f	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00235	e8 00 00 00 00	 call	 ??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z ; sf::Rect<int>::Rect<int>
  0023a	89 85 c0 fe ff
	ff		 mov	 DWORD PTR tv188[ebp], eax
  00240	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00243	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  00246	89 95 bc fe ff
	ff		 mov	 DWORD PTR tv183[ebp], edx
  0024c	6a 01		 push	 1
  0024e	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv183[ebp]
  00254	e8 00 00 00 00	 call	 ?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z ; RessourcePack::getImgBackground
  00259	89 85 b8 fe ff
	ff		 mov	 DWORD PTR tv186[ebp], eax
  0025f	8b f4		 mov	 esi, esp
  00261	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv188[ebp]
  00267	50		 push	 eax
  00268	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR tv186[ebp]
  0026e	51		 push	 ecx
  0026f	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv190[ebp]
  00275	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?loadFromImage@Texture@sf@@QAE_NABVImage@2@ABV?$Rect@H@2@@Z
  0027b	3b f4		 cmp	 esi, esp
  0027d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 131  :     background = new sf::Sprite(*backgroundTex);

  00282	68 10 01 00 00	 push	 272			; 00000110H
  00287	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0028c	83 c4 04	 add	 esp, 4
  0028f	89 85 f8 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00295	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  0029c	83 bd f8 fe ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  002a3	74 43		 je	 SHORT $LN10@loadTerrai
  002a5	8b f4		 mov	 esi, esp
  002a7	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  002aa	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  002ad	50		 push	 eax
  002ae	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  002b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Sprite@sf@@QAE@ABVTexture@1@@Z
  002ba	3b f4		 cmp	 esi, esp
  002bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002c1	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  002c7	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_SSprite@sf@@6BDrawable@1@@
  002cd	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR $T3[ebp]
  002d3	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], OFFSET ??_SSprite@sf@@6BTransformable@1@@
  002da	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  002e0	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv201[ebp], eax
  002e6	eb 0a		 jmp	 SHORT $LN11@loadTerrai
$LN10@loadTerrai:
  002e8	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
$LN11@loadTerrai:
  002f2	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv201[ebp]
  002f8	89 8d fc fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  002fe	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00305	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00308	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR $T4[ebp]
  0030e	89 42 20	 mov	 DWORD PTR [edx+32], eax

; 132  :     sf::View View(sf::FloatRect(0, 0, ter->getSizeY() * BLOCKWIDTH, ter->getSizeX() * BLOCKHEIGHT));

  00311	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00314	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  00317	e8 00 00 00 00	 call	 ?getSizeX@Terrain@@QAEIXZ ; Terrain::getSizeX
  0031c	6b d0 28	 imul	 edx, eax, 40
  0031f	89 95 b0 fe ff
	ff		 mov	 DWORD PTR tv340[ebp], edx
  00325	f2 0f 2a 85 b0
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv340[ebp]
  0032d	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv340[ebp]
  00333	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  00336	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  0033f	f2 0f 11 85 a8
	fe ff ff	 movsd	 QWORD PTR tv343[ebp], xmm0
  00347	f2 0f 5a 85 a8
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv343[ebp]
  0034f	f3 0f 11 85 a4
	fe ff ff	 movss	 DWORD PTR tv226[ebp], xmm0
  00357	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0035a	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  0035d	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  00362	6b d0 32	 imul	 edx, eax, 50
  00365	89 95 a0 fe ff
	ff		 mov	 DWORD PTR tv350[ebp], edx
  0036b	f2 0f 2a 85 a0
	fe ff ff	 cvtsi2sd xmm0, DWORD PTR tv350[ebp]
  00373	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR tv350[ebp]
  00379	c1 e8 1f	 shr	 eax, 31			; 0000001fH
  0037c	f2 0f 58 04 c5
	00 00 00 00	 addsd	 xmm0, QWORD PTR __xmm@41f00000000000000000000000000000[eax*8]
  00385	f2 0f 11 85 98
	fe ff ff	 movsd	 QWORD PTR tv353[ebp], xmm0
  0038d	f2 0f 5a 85 98
	fe ff ff	 cvtsd2ss xmm0, QWORD PTR tv353[ebp]
  00395	f3 0f 11 85 94
	fe ff ff	 movss	 DWORD PTR tv224[ebp], xmm0
  0039d	51		 push	 ecx
  0039e	f3 0f 10 85 a4
	fe ff ff	 movss	 xmm0, DWORD PTR tv226[ebp]
  003a6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003ab	51		 push	 ecx
  003ac	f3 0f 10 85 94
	fe ff ff	 movss	 xmm0, DWORD PTR tv224[ebp]
  003b4	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003b9	51		 push	 ecx
  003ba	0f 57 c0	 xorps	 xmm0, xmm0
  003bd	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003c2	51		 push	 ecx
  003c3	0f 57 c0	 xorps	 xmm0, xmm0
  003c6	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  003cb	8d 8d e8 fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  003d1	e8 00 00 00 00	 call	 ??0?$Rect@M@sf@@QAE@MMMM@Z ; sf::Rect<float>::Rect<float>
  003d6	8b f4		 mov	 esi, esp
  003d8	50		 push	 eax
  003d9	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _View$[ebp]
  003df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0View@sf@@QAE@ABV?$Rect@M@1@@Z
  003e5	3b f4		 cmp	 esi, esp
  003e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 133  :     std::printf("Current Viewport : %d x %d", ter->getSizeY() * BLOCKWIDTH, ter->getSizeX() * BLOCKHEIGHT);

  003ec	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  003ef	8b 49 08	 mov	 ecx, DWORD PTR [ecx+8]
  003f2	e8 00 00 00 00	 call	 ?getSizeX@Terrain@@QAEIXZ ; Terrain::getSizeX
  003f7	6b d0 28	 imul	 edx, eax, 40
  003fa	89 95 90 fe ff
	ff		 mov	 DWORD PTR tv242[ebp], edx
  00400	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00403	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00406	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  0040b	6b c8 32	 imul	 ecx, eax, 50
  0040e	89 8d 8c fe ff
	ff		 mov	 DWORD PTR tv240[ebp], ecx
  00414	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR tv242[ebp]
  0041a	52		 push	 edx
  0041b	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv240[ebp]
  00421	50		 push	 eax
  00422	68 00 00 00 00	 push	 OFFSET $SG230665
  00427	e8 00 00 00 00	 call	 _printf
  0042c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 134  :     RW->setView(View);

  0042f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00432	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00435	83 c2 30	 add	 edx, 48			; 00000030H
  00438	89 95 88 fe ff
	ff		 mov	 DWORD PTR tv250[ebp], edx
  0043e	8b f4		 mov	 esi, esp
  00440	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _View$[ebp]
  00446	50		 push	 eax
  00447	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv250[ebp]
  0044d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setView@RenderTarget@sf@@QAEXABVView@2@@Z
  00453	3b f4		 cmp	 esi, esp
  00455	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 135  :     p->setMaxX(ter->getSizeY() * BLOCKWIDTH);

  0045a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0045d	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00460	89 95 84 fe ff
	ff		 mov	 DWORD PTR tv261[ebp], edx
  00466	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00469	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0046c	e8 00 00 00 00	 call	 ?getSizeY@Terrain@@QAEIXZ ; Terrain::getSizeY
  00471	6b c8 32	 imul	 ecx, eax, 50
  00474	89 8d 80 fe ff
	ff		 mov	 DWORD PTR tv259[ebp], ecx
  0047a	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR tv259[ebp]
  00480	52		 push	 edx
  00481	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv261[ebp]
  00487	e8 00 00 00 00	 call	 ?setMaxX@Player@@QAEXH@Z ; Player::setMaxX

; 136  : }

  0048c	52		 push	 edx
  0048d	8b cd		 mov	 ecx, ebp
  0048f	50		 push	 eax
  00490	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN19@loadTerrai
  00496	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0049b	58		 pop	 eax
  0049c	5a		 pop	 edx
  0049d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  004a0	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  004a7	59		 pop	 ecx
  004a8	5f		 pop	 edi
  004a9	5e		 pop	 esi
  004aa	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  004ad	33 cd		 xor	 ecx, ebp
  004af	e8 00 00 00 00	 call	 @__security_check_cookie@4
  004b4	81 c4 80 01 00
	00		 add	 esp, 384		; 00000180H
  004ba	3b ec		 cmp	 ebp, esp
  004bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  004c1	8b e5		 mov	 esp, ebp
  004c3	5d		 pop	 ebp
  004c4	c2 04 00	 ret	 4
  004c7	90		 npad	 1
$LN19@loadTerrai:
  004c8	02 00 00 00	 DD	 2
  004cc	00 00 00 00	 DD	 $LN18@loadTerrai
$LN18@loadTerrai:
  004d0	e0 ff ff ff	 DD	 -32			; ffffffe0H
  004d4	08 00 00 00	 DD	 8
  004d8	00 00 00 00	 DD	 $LN15@loadTerrai
  004dc	30 ff ff ff	 DD	 -208			; ffffff30H
  004e0	a8 00 00 00	 DD	 168			; 000000a8H
  004e4	00 00 00 00	 DD	 $LN16@loadTerrai
$LN16@loadTerrai:
  004e8	56		 DB	 86			; 00000056H
  004e9	69		 DB	 105			; 00000069H
  004ea	65		 DB	 101			; 00000065H
  004eb	77		 DB	 119			; 00000077H
  004ec	00		 DB	 0
$LN15@loadTerrai:
  004ed	73		 DB	 115			; 00000073H
  004ee	69		 DB	 105			; 00000069H
  004ef	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$0:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T9[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$1:
  00012	6a 28		 push	 40			; 00000028H
  00014	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	83 c4 08	 add	 esp, 8
  00023	c3		 ret	 0
__unwindfunclet$?loadTerrain@Univers@@QAEXH@Z$2:
  00024	68 10 01 00 00	 push	 272			; 00000110H
  00029	8b 85 f8 fe ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  0002f	50		 push	 eax
  00030	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00035	83 c4 08	 add	 esp, 8
  00038	c3		 ret	 0
  00039	cc		 int	 3
  0003a	cc		 int	 3
  0003b	cc		 int	 3
  0003c	cc		 int	 3
  0003d	cc		 int	 3
__ehhandler$?loadTerrain@Univers@@QAEXH@Z:
  0003e	90		 npad	 1
  0003f	90		 npad	 1
  00040	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00044	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00047	8b 8a 80 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-384]
  0004d	33 c8		 xor	 ecx, eax
  0004f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00054	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00057	33 c8		 xor	 ecx, eax
  00059	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0005e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?loadTerrain@Univers@@QAEXH@Z
  00063	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?loadTerrain@Univers@@QAEXH@Z ENDP			; Univers::loadTerrain
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
tv221 = -224						; size = 4
tv203 = -220						; size = 4
tv219 = -216						; size = 4
tv192 = -212						; size = 4
tv217 = -208						; size = 4
tv177 = -204						; size = 4
tv215 = -200						; size = 4
tv163 = -196						; size = 4
tv213 = -192						; size = 4
tv149 = -188						; size = 4
tv211 = -184						; size = 4
tv75 = -180						; size = 4
$T1 = -176						; size = 16
$T2 = -160						; size = 16
$T3 = -144						; size = 16
$T4 = -128						; size = 16
$T5 = -112						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
_size$8 = -60						; size = 8
_yp$9 = -48						; size = 4
_xp$10 = -44						; size = 4
_yb$11 = -40						; size = 4
_xb$12 = -36						; size = 4
_e$13 = -32						; size = 4
_t$14 = -28						; size = 4
_<end>$L0$15 = -24					; size = 4
_<begin>$L0$16 = -20					; size = 4
_<range>$L0$17 = -16					; size = 4
_i$18 = -12						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
_p$ = 8							; size = 4
?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVPlayer@@@Z PROC ; Univers::collision
; _this$ = ecx

; 77   : std::vector<bool>* Univers::collision(Player* p) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e0 00 00
	00		 sub	 esp, 224		; 000000e0H
  00009	56		 push	 esi
  0000a	57		 push	 edi
  0000b	51		 push	 ecx
  0000c	8d bd 20 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-224]
  00012	b9 38 00 00 00	 mov	 ecx, 56			; 00000038H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	59		 pop	 ecx
  0001f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00024	33 c5		 xor	 eax, ebp
  00026	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00029	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0002c	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00031	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 78   :     for (uint32_t i = 0; i < res->size(); i++) {

  00036	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$18[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN4@collision
$LN2@collision:
  0003f	8b 45 f4	 mov	 eax, DWORD PTR _i$18[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 f4	 mov	 DWORD PTR _i$18[ebp], eax
$LN4@collision:
  00048	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	8b 49 1c	 mov	 ecx, DWORD PTR [ecx+28]
  0004e	e8 00 00 00 00	 call	 ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00053	39 45 f4	 cmp	 DWORD PTR _i$18[ebp], eax
  00056	73 3c		 jae	 SHORT $LN3@collision

; 79   :         res->at(i) = false;

  00058	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0005b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0005e	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00064	6a 00		 push	 0
  00066	8b 4d f4	 mov	 ecx, DWORD PTR _i$18[ebp]
  00069	51		 push	 ecx
  0006a	8d 55 b0	 lea	 edx, DWORD PTR $T7[ebp]
  0006d	52		 push	 edx
  0006e	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00074	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00079	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
  0007f	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv211[ebp]
  00085	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  0008a	8d 4d b0	 lea	 ecx, DWORD PTR $T7[ebp]
  0008d	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ

; 80   :     }

  00092	eb ab		 jmp	 SHORT $LN2@collision
$LN3@collision:

; 81   :     for (auto t : *ter->getTerrain()) {

  00094	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00097	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009a	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  0009f	89 45 f0	 mov	 DWORD PTR _<range>$L0$17[ebp], eax
  000a2	8b 4d f0	 mov	 ecx, DWORD PTR _<range>$L0$17[ebp]
  000a5	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
  000aa	89 45 ec	 mov	 DWORD PTR _<begin>$L0$16[ebp], eax
  000ad	8b 4d f0	 mov	 ecx, DWORD PTR _<range>$L0$17[ebp]
  000b0	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
  000b5	89 45 e8	 mov	 DWORD PTR _<end>$L0$15[ebp], eax
  000b8	eb 09		 jmp	 SHORT $LN7@collision
$LN5@collision:
  000ba	8b 4d ec	 mov	 ecx, DWORD PTR _<begin>$L0$16[ebp]
  000bd	83 c1 04	 add	 ecx, 4
  000c0	89 4d ec	 mov	 DWORD PTR _<begin>$L0$16[ebp], ecx
$LN7@collision:
  000c3	8b 55 ec	 mov	 edx, DWORD PTR _<begin>$L0$16[ebp]
  000c6	3b 55 e8	 cmp	 edx, DWORD PTR _<end>$L0$15[ebp]
  000c9	0f 84 08 02 00
	00		 je	 $LN6@collision
  000cf	8b 45 ec	 mov	 eax, DWORD PTR _<begin>$L0$16[ebp]
  000d2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d4	89 4d e4	 mov	 DWORD PTR _t$14[ebp], ecx

; 82   : 
; 83   :         Block* e = static_cast<Block*>(t);

  000d7	8b 55 e4	 mov	 edx, DWORD PTR _t$14[ebp]
  000da	89 55 e0	 mov	 DWORD PTR _e$13[ebp], edx

; 84   :         if (e->collide(p->getRect())) {

  000dd	8d 45 a0	 lea	 eax, DWORD PTR $T6[ebp]
  000e0	50		 push	 eax
  000e1	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  000e4	e8 00 00 00 00	 call	 ?getRect@Player@@QAE?AV?$Rect@H@sf@@XZ ; Player::getRect
  000e9	83 ec 10	 sub	 esp, 16			; 00000010H
  000ec	8b cc		 mov	 ecx, esp
  000ee	8b 10		 mov	 edx, DWORD PTR [eax]
  000f0	89 11		 mov	 DWORD PTR [ecx], edx
  000f2	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  000f5	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  000f8	8b 50 08	 mov	 edx, DWORD PTR [eax+8]
  000fb	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  000fe	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00101	89 41 0c	 mov	 DWORD PTR [ecx+12], eax
  00104	8b 4d e0	 mov	 ecx, DWORD PTR _e$13[ebp]
  00107	e8 00 00 00 00	 call	 ?collide@Block@@QAE_NV?$Rect@H@sf@@@Z ; Block::collide
  0010c	0f b6 c8	 movzx	 ecx, al
  0010f	85 c9		 test	 ecx, ecx
  00111	0f 84 bb 01 00
	00		 je	 $LN8@collision

; 85   :             #ifdef DEBUG
; 86   :             e->colliding = true;
; 87   :             #endif // DEBUG
; 88   :             //On suppose que tous les obj font la mme taille
; 89   :             int xb = e->getX();

  00117	8b 4d e0	 mov	 ecx, DWORD PTR _e$13[ebp]
  0011a	e8 00 00 00 00	 call	 ?getX@Block@@QAEHXZ	; Block::getX
  0011f	89 45 dc	 mov	 DWORD PTR _xb$12[ebp], eax

; 90   :             int yb = e->getY();

  00122	8b 4d e0	 mov	 ecx, DWORD PTR _e$13[ebp]
  00125	e8 00 00 00 00	 call	 ?getY@Block@@QAEHXZ	; Block::getY
  0012a	89 45 d8	 mov	 DWORD PTR _yb$11[ebp], eax

; 91   :             int xp = p->getX();

  0012d	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  00130	e8 00 00 00 00	 call	 ?getX@Player@@QAEHXZ	; Player::getX
  00135	89 45 d4	 mov	 DWORD PTR _xp$10[ebp], eax

; 92   :             int yp = p->getY();

  00138	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0013b	e8 00 00 00 00	 call	 ?getY@Player@@QAEHXZ	; Player::getY
  00140	89 45 d0	 mov	 DWORD PTR _yp$9[ebp], eax

; 93   :             sf::Vector2u size = p->getSize();

  00143	8d 55 c4	 lea	 edx, DWORD PTR _size$8[ebp]
  00146	52		 push	 edx
  00147	8b 4d 08	 mov	 ecx, DWORD PTR _p$[ebp]
  0014a	e8 00 00 00 00	 call	 ?getSize@Player@@QAE?AV?$Vector2@I@sf@@XZ ; Player::getSize

; 94   :              if (yb + size.y <= yp + size.y / 3 ) {

  0014f	8b 4d d8	 mov	 ecx, DWORD PTR _yb$11[ebp]
  00152	03 4d c8	 add	 ecx, DWORD PTR _size$8[ebp+4]
  00155	8b 45 c8	 mov	 eax, DWORD PTR _size$8[ebp+4]
  00158	33 d2		 xor	 edx, edx
  0015a	be 03 00 00 00	 mov	 esi, 3
  0015f	f7 f6		 div	 esi
  00161	03 45 d0	 add	 eax, DWORD PTR _yp$9[ebp]
  00164	3b c8		 cmp	 ecx, eax
  00166	77 3d		 ja	 SHORT $LN9@collision

; 95   :                 res->at(COLDIR::TOP) = true;

  00168	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0016b	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  0016e	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv149[ebp], eax
  00174	6a 01		 push	 1
  00176	6a 00		 push	 0
  00178	8d 4d 90	 lea	 ecx, DWORD PTR $T5[ebp]
  0017b	51		 push	 ecx
  0017c	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv149[ebp]
  00182	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00187	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], eax
  0018d	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv213[ebp]
  00193	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  00198	8d 4d 90	 lea	 ecx, DWORD PTR $T5[ebp]
  0019b	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ

; 96   :              }

  001a0	e9 2d 01 00 00	 jmp	 $LN8@collision
$LN9@collision:

; 97   :             else if (yb >= yp + size.y / 4 ) {

  001a5	8b 55 c8	 mov	 edx, DWORD PTR _size$8[ebp+4]
  001a8	c1 ea 02	 shr	 edx, 2
  001ab	03 55 d0	 add	 edx, DWORD PTR _yp$9[ebp]
  001ae	39 55 d8	 cmp	 DWORD PTR _yb$11[ebp], edx
  001b1	72 3d		 jb	 SHORT $LN11@collision

; 98   :                 res->at(COLDIR::BOTTOM) = true;

  001b3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  001b6	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  001b9	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv163[ebp], ecx
  001bf	6a 01		 push	 1
  001c1	6a 01		 push	 1
  001c3	8d 55 80	 lea	 edx, DWORD PTR $T4[ebp]
  001c6	52		 push	 edx
  001c7	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR tv163[ebp]
  001cd	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  001d2	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv215[ebp], eax
  001d8	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv215[ebp]
  001de	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  001e3	8d 4d 80	 lea	 ecx, DWORD PTR $T4[ebp]
  001e6	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ

; 99   :             }

  001eb	e9 e2 00 00 00	 jmp	 $LN8@collision
$LN11@collision:

; 100  :             else if (xp > xb + size.x/4) {

  001f0	8b 45 c4	 mov	 eax, DWORD PTR _size$8[ebp]
  001f3	c1 e8 02	 shr	 eax, 2
  001f6	03 45 dc	 add	 eax, DWORD PTR _xb$12[ebp]
  001f9	39 45 d4	 cmp	 DWORD PTR _xp$10[ebp], eax
  001fc	76 43		 jbe	 SHORT $LN13@collision

; 101  :                 res->at(COLDIR::LEFT) = true;

  001fe	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00201	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00204	89 95 34 ff ff
	ff		 mov	 DWORD PTR tv177[ebp], edx
  0020a	6a 01		 push	 1
  0020c	6a 02		 push	 2
  0020e	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00214	50		 push	 eax
  00215	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv177[ebp]
  0021b	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00220	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv217[ebp], eax
  00226	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv217[ebp]
  0022c	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  00231	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00237	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ

; 102  :             }

  0023c	e9 91 00 00 00	 jmp	 $LN8@collision
$LN13@collision:

; 103  :             else if (xp+ size.x <= xb + size.x /4 ) {

  00241	8b 4d d4	 mov	 ecx, DWORD PTR _xp$10[ebp]
  00244	03 4d c4	 add	 ecx, DWORD PTR _size$8[ebp]
  00247	8b 55 c4	 mov	 edx, DWORD PTR _size$8[ebp]
  0024a	c1 ea 02	 shr	 edx, 2
  0024d	03 55 dc	 add	 edx, DWORD PTR _xb$12[ebp]
  00250	3b ca		 cmp	 ecx, edx
  00252	77 40		 ja	 SHORT $LN15@collision

; 104  :                 res->at(COLDIR::RIGHT) = true;

  00254	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00257	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0025a	89 8d 2c ff ff
	ff		 mov	 DWORD PTR tv192[ebp], ecx
  00260	6a 01		 push	 1
  00262	6a 03		 push	 3
  00264	8d 95 60 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0026a	52		 push	 edx
  0026b	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv192[ebp]
  00271	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00276	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv219[ebp], eax
  0027c	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv219[ebp]
  00282	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  00287	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  0028d	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ

; 105  :             }

  00292	eb 3e		 jmp	 SHORT $LN8@collision
$LN15@collision:

; 106  : 
; 107  :             else {
; 108  :                  res->at(COLDIR::TOP) = true;

  00294	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00297	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0029a	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv203[ebp], ecx
  002a0	6a 01		 push	 1
  002a2	6a 00		 push	 0
  002a4	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR $T1[ebp]
  002aa	52		 push	 edx
  002ab	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv203[ebp]
  002b1	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  002b6	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv221[ebp], eax
  002bc	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR tv221[ebp]
  002c2	e8 00 00 00 00	 call	 ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
  002c7	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  002cd	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
$LN8@collision:

; 109  : 
; 110  :             }
; 111  :         }
; 112  :     }

  002d2	e9 e3 fd ff ff	 jmp	 $LN5@collision
$LN6@collision:

; 113  :        // std::printf("Collision BOTTOM : %s, UP : %s ,LEFT : %s , RIGHT %s\n", res->at(COLDIR::BOTTOM) ? "true" : "false", res->at(COLDIR::TOP) ? "true" : "false", res->at(COLDIR::LEFT) ? "true" : "false", res->at(COLDIR::RIGHT) ? "true" : "false");
; 114  :         return res;

  002d7	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  002da	8b 40 1c	 mov	 eax, DWORD PTR [eax+28]

; 115  :   
; 116  : }

  002dd	52		 push	 edx
  002de	8b cd		 mov	 ecx, ebp
  002e0	50		 push	 eax
  002e1	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN26@collision
  002e7	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  002ec	58		 pop	 eax
  002ed	5a		 pop	 edx
  002ee	5f		 pop	 edi
  002ef	5e		 pop	 esi
  002f0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002f3	33 cd		 xor	 ecx, ebp
  002f5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002fa	81 c4 e0 00 00
	00		 add	 esp, 224		; 000000e0H
  00300	3b ec		 cmp	 ebp, esp
  00302	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00307	8b e5		 mov	 esp, ebp
  00309	5d		 pop	 ebp
  0030a	c2 04 00	 ret	 4
  0030d	0f 1f 00	 npad	 3
$LN26@collision:
  00310	01 00 00 00	 DD	 1
  00314	00 00 00 00	 DD	 $LN25@collision
$LN25@collision:
  00318	c4 ff ff ff	 DD	 -60			; ffffffc4H
  0031c	08 00 00 00	 DD	 8
  00320	00 00 00 00	 DD	 $LN24@collision
$LN24@collision:
  00324	73		 DB	 115			; 00000073H
  00325	69		 DB	 105			; 00000069H
  00326	7a		 DB	 122			; 0000007aH
  00327	65		 DB	 101			; 00000065H
  00328	00		 DB	 0
?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVPlayer@@@Z ENDP ; Univers::collision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
tv375 = -280						; size = 4
tv368 = -276						; size = 4
tv289 = -272						; size = 4
tv277 = -268						; size = 4
tv245 = -264						; size = 4
tv241 = -260						; size = 4
tv229 = -256						; size = 4
tv197 = -252						; size = 4
tv181 = -248						; size = 4
tv178 = -244						; size = 4
tv168 = -240						; size = 4
tv149 = -236						; size = 4
tv151 = -232						; size = 4
tv72 = -228						; size = 4
$T2 = -224						; size = 4
$T3 = -220						; size = 4
$T4 = -216						; size = 8
$T5 = -208						; size = 4
$T6 = -204						; size = 8
$T7 = -196						; size = 4
$T8 = -192						; size = 8
$T9 = -184						; size = 4
$T10 = -180						; size = 8
$T11 = -172						; size = 4
$T12 = -168						; size = 8
$T13 = -160						; size = 4
$T14 = -156						; size = 8
$T15 = -148						; size = 4
$T16 = -144						; size = 8
$T17 = -136						; size = 4
$T18 = -132						; size = 8
$T19 = -124						; size = 4
$T20 = -120						; size = 4
_listCollision$21 = -116				; size = 4
_t$22 = -112						; size = 4
_<end>$L0$23 = -108					; size = 4
_<begin>$L0$24 = -104					; size = 4
_<range>$L0$25 = -100					; size = 4
_event$26 = -92						; size = 20
_e$27 = -64						; size = 12
_currentMusic$ = -48					; size = 4
_lastTime$ = -44					; size = 4
_clock$ = -36						; size = 8
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
?animate@Univers@@QAEXXZ PROC				; Univers::animate
; _this$ = ecx

; 6    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?animate@Univers@@QAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 08 01 00
	00		 sub	 esp, 264		; 00000108H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	51		 push	 ecx
  0001c	8d bd e8 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-280]
  00022	b9 42 00 00 00	 mov	 ecx, 66			; 00000042H
  00027	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002c	f3 ab		 rep stosd
  0002e	59		 pop	 ecx
  0002f	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00034	33 c5		 xor	 eax, ebp
  00036	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00039	50		 push	 eax
  0003a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00043	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00046	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00049	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  0004e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 7    :     sf::Clock clock;

  00053	8b f4		 mov	 esi, esp
  00055	8d 4d dc	 lea	 ecx, DWORD PTR _clock$[ebp]
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Clock@sf@@QAE@XZ
  0005e	3b f4		 cmp	 esi, esp
  00060	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 8    :     float lastTime = 0;

  00065	0f 57 c0	 xorps	 xmm0, xmm0
  00068	f3 0f 11 45 d4	 movss	 DWORD PTR _lastTime$[ebp], xmm0

; 9    :     //sf::Font font;
; 10   :     //font.loadFromFile("\\Ressources\\DS-DIGI.TTF");
; 11   :     auto currentMusic = RP->getLevelMusic(lvl - 1);

  0006d	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00070	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00073	89 8d 1c ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00079	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0007c	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  0007f	83 e8 01	 sub	 eax, 1
  00082	50		 push	 eax
  00083	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00089	e8 00 00 00 00	 call	 ?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z ; RessourcePack::getLevelMusic
  0008e	89 45 d0	 mov	 DWORD PTR _currentMusic$[ebp], eax

; 12   :     try{

  00091	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 13   :         currentMusic->play();

  00098	8b f4		 mov	 esi, esp
  0009a	8b 4d d0	 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  0009d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009f	8b 4d d0	 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  000a2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a5	ff d0		 call	 eax
  000a7	3b f4		 cmp	 esi, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 14   :         currentMusic->setLoop(true);

  000ae	8b f4		 mov	 esi, esp
  000b0	6a 01		 push	 1
  000b2	8b 4d d0	 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  000b5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setLoop@SoundStream@sf@@QAEX_N@Z
  000bb	3b f4		 cmp	 esi, esp
  000bd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c2	eb 2c		 jmp	 SHORT $LN30@animate
__catch$?animate@Univers@@QAEXXZ$0:

; 15   :     }catch(std::exception e){

  000c4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2

; 16   :         currentMusic->stop();

  000c8	8b f4		 mov	 esi, esp
  000ca	8b 4d d0	 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  000cd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000cf	8b 4d d0	 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  000d2	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  000d5	ff d0		 call	 eax
  000d7	3b f4		 cmp	 esi, esp
  000d9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 17   :     }

  000de	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1
  000e2	8d 4d c0	 lea	 ecx, DWORD PTR _e$27[ebp]
  000e5	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  000ea	b8 00 00 00 00	 mov	 eax, $LN35@animate
  000ef	c3		 ret	 0
$LN30@animate:
  000f0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000f7	eb 07		 jmp	 SHORT $LN34@animate
$LN35@animate:
  000f9	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
$LN34@animate:

; 18   :     while (RW->isOpen()) {

  00100	8b f4		 mov	 esi, esp
  00102	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	8b 49 10	 mov	 ecx, DWORD PTR [ecx+16]
  00108	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?isOpen@Window@sf@@QBE_NXZ
  0010e	3b f4		 cmp	 esi, esp
  00110	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00115	0f b6 d0	 movzx	 edx, al
  00118	85 d2		 test	 edx, edx
  0011a	0f 84 44 04 00
	00		 je	 $LN3@animate

; 19   :         RW->clear();

  00120	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00123	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00126	83 c1 30	 add	 ecx, 48			; 00000030H
  00129	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv151[ebp], ecx
  0012f	8b f4		 mov	 esi, esp
  00131	68 ff 00 00 00	 push	 255			; 000000ffH
  00136	6a 00		 push	 0
  00138	6a 00		 push	 0
  0013a	6a 00		 push	 0
  0013c	8d 4d 88	 lea	 ecx, DWORD PTR $T20[ebp]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Color@sf@@QAE@EEEE@Z
  00145	3b f4		 cmp	 esi, esp
  00147	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0014c	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv149[ebp], eax
  00152	8b f4		 mov	 esi, esp
  00154	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv149[ebp]
  0015a	52		 push	 edx
  0015b	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv151[ebp]
  00161	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?clear@RenderTarget@sf@@QAEXABVColor@2@@Z
  00167	3b f4		 cmp	 esi, esp
  00169	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 20   :         if (background != nullptr) {

  0016e	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00171	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  00175	74 31		 je	 SHORT $LN16@animate

; 21   :             RW->draw(*background);

  00177	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0017a	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0017d	83 c2 30	 add	 edx, 48			; 00000030H
  00180	89 95 10 ff ff
	ff		 mov	 DWORD PTR tv168[ebp], edx
  00186	8b f4		 mov	 esi, esp
  00188	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?Default@RenderStates@sf@@2V12@B
  0018d	50		 push	 eax
  0018e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00191	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00194	52		 push	 edx
  00195	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv168[ebp]
  0019b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?draw@RenderTarget@sf@@QAEXABVDrawable@2@ABVRenderStates@2@@Z
  001a1	3b f4		 cmp	 esi, esp
  001a3	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN16@animate:

; 22   :         }
; 23   :         sf::Event event;
; 24   :         while (RW->pollEvent(event))

  001a8	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001ab	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  001ae	89 8d 0c ff ff
	ff		 mov	 DWORD PTR tv178[ebp], ecx
  001b4	8b f4		 mov	 esi, esp
  001b6	8d 55 a4	 lea	 edx, DWORD PTR _event$26[ebp]
  001b9	52		 push	 edx
  001ba	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv178[ebp]
  001c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?pollEvent@Window@sf@@QAE_NAAVEvent@2@@Z
  001c6	3b f4		 cmp	 esi, esp
  001c8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001cd	0f b6 c0	 movzx	 eax, al
  001d0	85 c0		 test	 eax, eax
  001d2	0f 84 b3 02 00
	00		 je	 $LN5@animate

; 25   :         {
; 26   :             switch (event.type) {

  001d8	8b 4d a4	 mov	 ecx, DWORD PTR _event$26[ebp]
  001db	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv181[ebp], ecx
  001e1	83 bd 08 ff ff
	ff 00		 cmp	 DWORD PTR tv181[ebp], 0
  001e8	74 02		 je	 SHORT $LN17@animate
  001ea	eb 2b		 jmp	 SHORT $LN6@animate
$LN17@animate:

; 27   :             case sf::Event::Closed: [[unlikely]];
; 28   :                 RW->close();

  001ec	8b f4		 mov	 esi, esp
  001ee	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  001f1	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  001f4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?close@Window@sf@@QAEXXZ
  001fa	3b f4		 cmp	 esi, esp
  001fc	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 29   :                 currentMusic->stop();

  00201	8b f4		 mov	 esi, esp
  00203	8b 45 d0	 mov	 eax, DWORD PTR _currentMusic$[ebp]
  00206	8b 10		 mov	 edx, DWORD PTR [eax]
  00208	8b 4d d0	 mov	 ecx, DWORD PTR _currentMusic$[ebp]
  0020b	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0020e	ff d0		 call	 eax
  00210	3b f4		 cmp	 esi, esp
  00212	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@animate:

; 30   :                 break;
; 31   :             }
; 32   :             if (event.type == sf::Event::KeyPressed) {

  00217	83 7d a4 05	 cmp	 DWORD PTR _event$26[ebp], 5
  0021b	0f 85 2d 01 00
	00		 jne	 $LN18@animate

; 33   :                 switch (event.key.code) {

  00221	8b 4d a8	 mov	 ecx, DWORD PTR _event$26[ebp+4]
  00224	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], ecx
  0022a	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv197[ebp]
  00230	83 ea 47	 sub	 edx, 71			; 00000047H
  00233	89 95 04 ff ff
	ff		 mov	 DWORD PTR tv197[ebp], edx
  00239	83 bd 04 ff ff
	ff 03		 cmp	 DWORD PTR tv197[ebp], 3
  00240	0f 87 03 01 00
	00		 ja	 $LN8@animate
  00246	8b 85 04 ff ff
	ff		 mov	 eax, DWORD PTR tv197[ebp]
  0024c	ff 24 85 00 00
	00 00		 jmp	 DWORD PTR $LN36@animate[eax*4]
$LN20@animate:

; 34   :                 case sf::Keyboard::Left:
; 35   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::LEFT);

  00253	c7 45 84 00 00
	00 00		 mov	 DWORD PTR $T19[ebp], 0
  0025a	8d 4d 84	 lea	 ecx, DWORD PTR $T19[ebp]
  0025d	51		 push	 ecx
  0025e	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00261	52		 push	 edx
  00262	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  00267	83 c4 04	 add	 esp, 4
  0026a	50		 push	 eax
  0026b	8d 85 7c ff ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  00271	50		 push	 eax
  00272	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  00277	83 c4 0c	 add	 esp, 12			; 0000000cH
  0027a	50		 push	 eax
  0027b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0027e	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>

; 36   :                     break;

  00283	e9 c1 00 00 00	 jmp	 $LN8@animate
$LN21@animate:

; 37   :                 case sf::Keyboard::Right:
; 38   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::RIGHT);

  00288	c7 85 78 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR $T17[ebp], 1
  00292	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00298	51		 push	 ecx
  00299	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  002a2	83 c4 04	 add	 esp, 4
  002a5	50		 push	 eax
  002a6	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  002ac	50		 push	 eax
  002ad	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  002b2	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b5	50		 push	 eax
  002b6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002b9	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>

; 39   :                     break;

  002be	e9 86 00 00 00	 jmp	 $LN8@animate
$LN22@animate:

; 40   :                 case sf::Keyboard::Up:
; 41   :                     dir = std::make_tuple(DIRDEP::UP, std::get<1>(dir));

  002c3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  002c6	51		 push	 ecx
  002c7	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  002cc	83 c4 04	 add	 esp, 4
  002cf	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv229[ebp], eax
  002d5	c7 85 6c ff ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp], 2
  002df	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv229[ebp]
  002e5	52		 push	 edx
  002e6	8d 85 6c ff ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  002ec	50		 push	 eax
  002ed	8d 8d 64 ff ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  002f3	51		 push	 ecx
  002f4	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  002f9	83 c4 0c	 add	 esp, 12			; 0000000cH
  002fc	50		 push	 eax
  002fd	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00300	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>

; 42   :                     break;

  00305	eb 42		 jmp	 SHORT $LN8@animate
$LN23@animate:

; 43   :                 case sf::Keyboard::Down:
; 44   :                     dir = std::make_tuple(DIRDEP::DOWN, std::get<1>(dir));

  00307	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0030a	52		 push	 edx
  0030b	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  00310	83 c4 04	 add	 esp, 4
  00313	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  00319	c7 85 60 ff ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp], 3
  00323	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv241[ebp]
  00329	50		 push	 eax
  0032a	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  00330	51		 push	 ecx
  00331	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00337	52		 push	 edx
  00338	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  0033d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00340	50		 push	 eax
  00341	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00344	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
$LN8@animate:

; 45   :                     break;
; 46   :                 }
; 47   :             }

  00349	e9 38 01 00 00	 jmp	 $LN10@animate
$LN18@animate:

; 48   :             else if (event.type == sf::Event::KeyReleased) {

  0034e	83 7d a4 06	 cmp	 DWORD PTR _event$26[ebp], 6
  00352	0f 85 2e 01 00
	00		 jne	 $LN10@animate

; 49   :                 switch (event.key.code) {

  00358	8b 45 a8	 mov	 eax, DWORD PTR _event$26[ebp+4]
  0035b	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv245[ebp], eax
  00361	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv245[ebp]
  00367	83 e9 47	 sub	 ecx, 71			; 00000047H
  0036a	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv245[ebp], ecx
  00370	83 bd f8 fe ff
	ff 03		 cmp	 DWORD PTR tv245[ebp], 3
  00377	0f 87 09 01 00
	00		 ja	 $LN10@animate
  0037d	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv245[ebp]
  00383	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN37@animate[edx*4]
$LN25@animate:

; 50   :                 case sf::Keyboard::Left:
; 51   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::NONE);

  0038a	c7 85 54 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T11[ebp], 4
  00394	8d 85 54 ff ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  0039a	50		 push	 eax
  0039b	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0039e	51		 push	 ecx
  0039f	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  003a4	83 c4 04	 add	 esp, 4
  003a7	50		 push	 eax
  003a8	8d 95 4c ff ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  003ae	52		 push	 edx
  003af	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  003b4	83 c4 0c	 add	 esp, 12			; 0000000cH
  003b7	50		 push	 eax
  003b8	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003bb	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>

; 52   :                     break;

  003c0	e9 c1 00 00 00	 jmp	 $LN10@animate
$LN26@animate:

; 53   :                 case sf::Keyboard::Right:
; 54   :                     dir = std::make_tuple(std::get<0>(dir), DIRDEP::NONE);

  003c5	c7 85 48 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T9[ebp], 4
  003cf	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  003d5	50		 push	 eax
  003d6	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003d9	51		 push	 ecx
  003da	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  003df	83 c4 04	 add	 esp, 4
  003e2	50		 push	 eax
  003e3	8d 95 40 ff ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  003e9	52		 push	 edx
  003ea	e8 00 00 00 00	 call	 ??$make_tuple@AAW4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@AAW4DIRDEP@@$$QAW42@@Z ; std::make_tuple<enum DIRDEP &,enum DIRDEP>
  003ef	83 c4 0c	 add	 esp, 12			; 0000000cH
  003f2	50		 push	 eax
  003f3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  003f6	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>

; 55   :                     break;

  003fb	e9 86 00 00 00	 jmp	 $LN10@animate
$LN27@animate:

; 56   :                 case sf::Keyboard::Up:
; 57   :                     dir = std::make_tuple(DIRDEP::NONE, std::get<1>(dir));

  00400	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00403	50		 push	 eax
  00404	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  00409	83 c4 04	 add	 esp, 4
  0040c	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv277[ebp], eax
  00412	c7 85 3c ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T7[ebp], 4
  0041c	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv277[ebp]
  00422	51		 push	 ecx
  00423	8d 95 3c ff ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  00429	52		 push	 edx
  0042a	8d 85 34 ff ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  00430	50		 push	 eax
  00431	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  00436	83 c4 0c	 add	 esp, 12			; 0000000cH
  00439	50		 push	 eax
  0043a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0043d	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>

; 58   :                     break;

  00442	eb 42		 jmp	 SHORT $LN10@animate
$LN28@animate:

; 59   :                 case sf::Keyboard::Down:
; 60   :                     dir = std::make_tuple(DIRDEP::NONE, std::get<1>(dir));

  00444	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00447	51		 push	 ecx
  00448	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  0044d	83 c4 04	 add	 esp, 4
  00450	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
  00456	c7 85 30 ff ff
	ff 04 00 00 00	 mov	 DWORD PTR $T5[ebp], 4
  00460	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv289[ebp]
  00466	52		 push	 edx
  00467	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0046d	50		 push	 eax
  0046e	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00474	51		 push	 ecx
  00475	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@AAW41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@AAW42@@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP &>
  0047a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0047d	50		 push	 eax
  0047e	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00481	e8 00 00 00 00	 call	 ??$?4V?$tuple@W4DIRDEP@@W41@@std@@W4DIRDEP@@$0A@@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV01@$$QAV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::operator=<std::tuple<enum DIRDEP,enum DIRDEP>,enum DIRDEP,0>
$LN10@animate:

; 61   :                     break;
; 62   : 
; 63   :                 }
; 64   :             }
; 65   :         }

  00486	e9 1d fd ff ff	 jmp	 $LN16@animate
$LN5@animate:

; 66   :         for (auto t : *ter->getTerrain()) {

  0048b	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0048e	8b 4a 08	 mov	 ecx, DWORD PTR [edx+8]
  00491	e8 00 00 00 00	 call	 ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ; Terrain::getTerrain
  00496	89 45 9c	 mov	 DWORD PTR _<range>$L0$25[ebp], eax
  00499	8b 4d 9c	 mov	 ecx, DWORD PTR _<range>$L0$25[ebp]
  0049c	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
  004a1	89 45 98	 mov	 DWORD PTR _<begin>$L0$24[ebp], eax
  004a4	8b 4d 9c	 mov	 ecx, DWORD PTR _<range>$L0$25[ebp]
  004a7	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
  004ac	89 45 94	 mov	 DWORD PTR _<end>$L0$23[ebp], eax
  004af	eb 09		 jmp	 SHORT $LN14@animate
$LN12@animate:
  004b1	8b 45 98	 mov	 eax, DWORD PTR _<begin>$L0$24[ebp]
  004b4	83 c0 04	 add	 eax, 4
  004b7	89 45 98	 mov	 DWORD PTR _<begin>$L0$24[ebp], eax
$LN14@animate:
  004ba	8b 4d 98	 mov	 ecx, DWORD PTR _<begin>$L0$24[ebp]
  004bd	3b 4d 94	 cmp	 ecx, DWORD PTR _<end>$L0$23[ebp]
  004c0	74 19		 je	 SHORT $LN13@animate
  004c2	8b 55 98	 mov	 edx, DWORD PTR _<begin>$L0$24[ebp]
  004c5	8b 02		 mov	 eax, DWORD PTR [edx]
  004c7	89 45 90	 mov	 DWORD PTR _t$22[ebp], eax

; 67   :             t->show(RW);

  004ca	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004cd	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  004d0	52		 push	 edx
  004d1	8b 4d 90	 mov	 ecx, DWORD PTR _t$22[ebp]
  004d4	e8 00 00 00 00	 call	 ?show@Block@@QAEXPAVRenderWindow@sf@@@Z ; Block::show

; 68   :         }

  004d9	eb d6		 jmp	 SHORT $LN12@animate
$LN13@animate:

; 69   :             
; 70   :         std::vector<bool>* listCollision = collision(p);

  004db	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  004de	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  004e1	51		 push	 ecx
  004e2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  004e5	e8 00 00 00 00	 call	 ?collision@Univers@@QAEPAV?$vector@_NV?$allocator@_N@std@@@std@@PAVPlayer@@@Z ; Univers::collision
  004ea	89 45 8c	 mov	 DWORD PTR _listCollision$21[ebp], eax

; 71   :         p->move(dir,*listCollision);

  004ed	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  004f0	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  004f3	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv368[ebp], eax
  004f9	83 ec 18	 sub	 esp, 24			; 00000018H
  004fc	8b cc		 mov	 ecx, esp
  004fe	89 a5 24 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], esp
  00504	8b 55 8c	 mov	 edx, DWORD PTR _listCollision$21[ebp]
  00507	52		 push	 edx
  00508	e8 00 00 00 00	 call	 ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
  0050d	83 ec 08	 sub	 esp, 8
  00510	8b cc		 mov	 ecx, esp
  00512	89 a5 20 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], esp
  00518	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 ??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z ; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>
  00521	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv368[ebp]
  00527	e8 00 00 00 00	 call	 ?move@Player@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z ; Player::move

; 72   :         p->show(RW);

  0052c	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0052f	8b 51 14	 mov	 edx, DWORD PTR [ecx+20]
  00532	89 95 e8 fe ff
	ff		 mov	 DWORD PTR tv375[ebp], edx
  00538	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0053b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0053e	51		 push	 ecx
  0053f	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv375[ebp]
  00545	e8 00 00 00 00	 call	 ?show@Player@@QAEXPAVRenderWindow@sf@@@Z ; Player::show

; 73   :         RW->display();

  0054a	8b f4		 mov	 esi, esp
  0054c	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  0054f	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  00552	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?display@Window@sf@@QAEXXZ
  00558	3b f4		 cmp	 esi, esp
  0055a	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   :     }

  0055f	e9 9c fb ff ff	 jmp	 $LN34@animate
$LN3@animate:

; 75   : }

  00564	52		 push	 edx
  00565	8b cd		 mov	 ecx, ebp
  00567	50		 push	 eax
  00568	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN43@animate
  0056e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00573	58		 pop	 eax
  00574	5a		 pop	 edx
  00575	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00578	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0057f	59		 pop	 ecx
  00580	5f		 pop	 edi
  00581	5e		 pop	 esi
  00582	5b		 pop	 ebx
  00583	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00586	33 cd		 xor	 ecx, ebp
  00588	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0058d	81 c4 18 01 00
	00		 add	 esp, 280		; 00000118H
  00593	3b ec		 cmp	 ebp, esp
  00595	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0059a	8b e5		 mov	 esp, ebp
  0059c	5d		 pop	 ebp
  0059d	c3		 ret	 0
  0059e	66 90		 npad	 2
$LN43@animate:
  005a0	03 00 00 00	 DD	 3
  005a4	00 00 00 00	 DD	 $LN42@animate
$LN42@animate:
  005a8	dc ff ff ff	 DD	 -36			; ffffffdcH
  005ac	08 00 00 00	 DD	 8
  005b0	00 00 00 00	 DD	 $LN38@animate
  005b4	c0 ff ff ff	 DD	 -64			; ffffffc0H
  005b8	0c 00 00 00	 DD	 12			; 0000000cH
  005bc	00 00 00 00	 DD	 $LN39@animate
  005c0	a4 ff ff ff	 DD	 -92			; ffffffa4H
  005c4	14 00 00 00	 DD	 20			; 00000014H
  005c8	00 00 00 00	 DD	 $LN40@animate
$LN40@animate:
  005cc	65		 DB	 101			; 00000065H
  005cd	76		 DB	 118			; 00000076H
  005ce	65		 DB	 101			; 00000065H
  005cf	6e		 DB	 110			; 0000006eH
  005d0	74		 DB	 116			; 00000074H
  005d1	00		 DB	 0
$LN39@animate:
  005d2	65		 DB	 101			; 00000065H
  005d3	00		 DB	 0
$LN38@animate:
  005d4	63		 DB	 99			; 00000063H
  005d5	6c		 DB	 108			; 0000006cH
  005d6	6f		 DB	 111			; 0000006fH
  005d7	63		 DB	 99			; 00000063H
  005d8	6b		 DB	 107			; 0000006bH
  005d9	00		 DB	 0
  005da	66 90		 npad	 2
$LN36@animate:
  005dc	00 00 00 00	 DD	 $LN20@animate
  005e0	00 00 00 00	 DD	 $LN21@animate
  005e4	00 00 00 00	 DD	 $LN22@animate
  005e8	00 00 00 00	 DD	 $LN23@animate
$LN37@animate:
  005ec	00 00 00 00	 DD	 $LN25@animate
  005f0	00 00 00 00	 DD	 $LN26@animate
  005f4	00 00 00 00	 DD	 $LN27@animate
  005f8	00 00 00 00	 DD	 $LN28@animate
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?animate@Univers@@QAEXXZ$2:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR _e$27[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?animate@Univers@@QAEXXZ:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a e4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-284]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?animate@Univers@@QAEXXZ
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?animate@Univers@@QAEXXZ ENDP				; Univers::animate
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.h
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
_TEXT	SEGMENT
tv197 = -108						; size = 4
tv192 = -104						; size = 4
tv190 = -100						; size = 4
tv177 = -96						; size = 4
tv159 = -92						; size = 4
tv141 = -88						; size = 4
tv89 = -84						; size = 4
tv88 = -80						; size = 4
$T2 = -76						; size = 4
$T3 = -72						; size = 4
$T4 = -68						; size = 4
$T5 = -61						; size = 1
$T6 = -60						; size = 4
$T7 = -56						; size = 4
$T8 = -52						; size = 4
$T9 = -48						; size = 4
_e$10 = -40						; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
_rp$ = 8						; size = 4
_rw$ = 12						; size = 4
??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z PROC ; Univers::Univers
; _this$ = ecx

; 140  : {   

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	51		 push	 ecx
  00019	8d 7d 94	 lea	 edi, DWORD PTR [ebp-108]
  0001c	b9 17 00 00 00	 mov	 ecx, 23			; 00000017H
  00021	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00026	f3 ab		 rep stosd
  00028	59		 pop	 ecx
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00040	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00043	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00048	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.h

; 7    : 	std::tuple<DIRDEP, DIRDEP> dir = std::make_tuple(DIRDEP::NONE, DIRDEP::NONE); // O pour UP ou DOWN et 1 pour LEFT ou RIGHT

  0004d	c7 45 d0 04 00
	00 00		 mov	 DWORD PTR $T9[ebp], 4
  00054	c7 45 cc 04 00
	00 00		 mov	 DWORD PTR $T8[ebp], 4
  0005b	8d 45 d0	 lea	 eax, DWORD PTR $T9[ebp]
  0005e	50		 push	 eax
  0005f	8d 4d cc	 lea	 ecx, DWORD PTR $T8[ebp]
  00062	51		 push	 ecx
  00063	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??$make_tuple@W4DIRDEP@@W41@@std@@YA?AV?$tuple@W4DIRDEP@@W41@@0@$$QAW4DIRDEP@@0@Z ; std::make_tuple<enum DIRDEP,enum DIRDEP>
  0006c	83 c4 0c	 add	 esp, 12			; 0000000cH

; 8    : 	Terrain* ter;
; 9    : 	RessourcePack* RP;
; 10   : 	sf::RenderWindow* RW;
; 11   : 	
; 12   : 	Player* p;
; 13   : 	int lvl = 1 ;

  0006f	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00072	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [eax+24], 1

; 14   : 	std::vector<bool>* res = new std::vector<bool>(4);

  00079	6a 18		 push	 24			; 00000018H
  0007b	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00080	83 c4 04	 add	 esp, 4
  00083	89 45 c4	 mov	 DWORD PTR $T6[ebp], eax
  00086	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  0008d	83 7d c4 00	 cmp	 DWORD PTR $T6[ebp], 0
  00091	74 28		 je	 SHORT $LN4@Univers
  00093	6a 18		 push	 24			; 00000018H
  00095	8b 4d c4	 mov	 ecx, DWORD PTR $T6[ebp]
  00098	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
  0009d	8d 4d c3	 lea	 ecx, DWORD PTR $T5[ebp]
  000a0	e8 00 00 00 00	 call	 ??0?$allocator@_N@std@@QAE@XZ ; std::allocator<bool>::allocator<bool>
  000a5	89 45 b0	 mov	 DWORD PTR tv88[ebp], eax
  000a8	8b 4d b0	 mov	 ecx, DWORD PTR tv88[ebp]
  000ab	51		 push	 ecx
  000ac	6a 04		 push	 4
  000ae	8b 4d c4	 mov	 ecx, DWORD PTR $T6[ebp]
  000b1	e8 00 00 00 00	 call	 ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
  000b6	89 45 ac	 mov	 DWORD PTR tv89[ebp], eax
  000b9	eb 07		 jmp	 SHORT $LN5@Univers
$LN4@Univers:
  000bb	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR tv89[ebp], 0
$LN5@Univers:
  000c2	8b 55 ac	 mov	 edx, DWORD PTR tv89[ebp]
  000c5	89 55 c8	 mov	 DWORD PTR $T7[ebp], edx
  000c8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  000cf	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000d2	8b 4d c8	 mov	 ecx, DWORD PTR $T7[ebp]
  000d5	89 48 1c	 mov	 DWORD PTR [eax+28], ecx

; 15   : 	sf::Sprite* background = nullptr;

  000d8	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  000db	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 16   : 	sf::Texture* backgroundTex = nullptr;

  000e2	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000e5	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp

; 141  :     RW = rw;

  000ec	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	8b 55 0c	 mov	 edx, DWORD PTR _rw$[ebp]
  000f2	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 142  :     RP = rp;

  000f5	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000f8	8b 4d 08	 mov	 ecx, DWORD PTR _rp$[ebp]
  000fb	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 143  : 
; 144  :     try {

  000fe	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 1

; 145  :         RP->generateImg("\\Ressources\\img");

  00105	8b 55 e8	 mov	 edx, DWORD PTR _this$[ebp]
  00108	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0010b	89 45 a8	 mov	 DWORD PTR tv141[ebp], eax
  0010e	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00111	8b cc		 mov	 ecx, esp
  00113	89 65 bc	 mov	 DWORD PTR $T4[ebp], esp
  00116	68 00 00 00 00	 push	 OFFSET $SG230741
  0011b	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00120	8b 4d a8	 mov	 ecx, DWORD PTR tv141[ebp]
  00123	e8 00 00 00 00	 call	 ?generateImg@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::generateImg

; 146  :         RP->generateAudioData("\\Ressources\\audio");

  00128	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0012b	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0012e	89 55 a4	 mov	 DWORD PTR tv159[ebp], edx
  00131	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00134	8b cc		 mov	 ecx, esp
  00136	89 65 b8	 mov	 DWORD PTR $T3[ebp], esp
  00139	68 00 00 00 00	 push	 OFFSET $SG230742
  0013e	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00143	8b 4d a4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	e8 00 00 00 00	 call	 ?generateAudioData@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::generateAudioData

; 147  :         RP->generateBackgrounds("\\Ressources\\img\\backgrounds");

  0014b	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  0014e	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00151	89 4d a0	 mov	 DWORD PTR tv177[ebp], ecx
  00154	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00157	8b cc		 mov	 ecx, esp
  00159	89 65 b4	 mov	 DWORD PTR $T2[ebp], esp
  0015c	68 00 00 00 00	 push	 OFFSET $SG230743
  00161	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00166	8b 4d a0	 mov	 ecx, DWORD PTR tv177[ebp]
  00169	e8 00 00 00 00	 call	 ?generateBackgrounds@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::generateBackgrounds

; 148  :     }

  0016e	eb 66		 jmp	 SHORT $LN6@Univers
__catch$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$0:

; 149  :     catch (std::invalid_argument e) {

  00170	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+12], 3

; 150  :         std::cerr << e.what() << std::endl;

  00174	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR __imp_?cerr@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0017a	89 55 9c	 mov	 DWORD PTR tv190[ebp], edx
  0017d	8d 4d d8	 lea	 ecx, DWORD PTR _e$10[ebp]
  00180	e8 00 00 00 00	 call	 ?what@exception@std@@UBEPBDXZ ; std::exception::what
  00185	89 45 98	 mov	 DWORD PTR tv192[ebp], eax
  00188	8b 45 98	 mov	 eax, DWORD PTR tv192[ebp]
  0018b	50		 push	 eax
  0018c	8b 4d 9c	 mov	 ecx, DWORD PTR tv190[ebp]
  0018f	51		 push	 ecx
  00190	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00195	83 c4 08	 add	 esp, 8
  00198	89 45 94	 mov	 DWORD PTR tv197[ebp], eax
  0019b	8b f4		 mov	 esi, esp
  0019d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  001a2	8b 4d 94	 mov	 ecx, DWORD PTR tv197[ebp]
  001a5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  001ab	3b f4		 cmp	 esi, esp
  001ad	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 151  :         return;

  001b2	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001b6	8d 4d d8	 lea	 ecx, DWORD PTR _e$10[ebp]
  001b9	e8 00 00 00 00	 call	 ??1invalid_argument@std@@UAE@XZ
  001be	b8 00 00 00 00	 mov	 eax, $LN14@Univers
  001c3	c3		 ret	 0

; 152  :     }

  001c4	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+12], 2
  001c8	8d 4d d8	 lea	 ecx, DWORD PTR _e$10[ebp]
  001cb	e8 00 00 00 00	 call	 ??1invalid_argument@std@@UAE@XZ
  001d0	b8 00 00 00 00	 mov	 eax, $LN16@Univers
  001d5	c3		 ret	 0
$LN6@Univers:
  001d6	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  001dd	eb 07		 jmp	 SHORT __tryend$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$1
$LN16@Univers:
  001df	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$1:
  001e6	eb 09		 jmp	 SHORT $LN13@Univers
$LN14@Univers:
  001e8	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1

; 151  :         return;

  001ef	eb 0a		 jmp	 SHORT $LN1@Univers
$LN13@Univers:

; 153  :     loadTerrain(1);

  001f1	6a 01		 push	 1
  001f3	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  001f6	e8 00 00 00 00	 call	 ?loadTerrain@Univers@@QAEXH@Z ; Univers::loadTerrain
$LN1@Univers:

; 154  : 
; 155  : }

  001fb	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  001fe	52		 push	 edx
  001ff	8b cd		 mov	 ecx, ebp
  00201	50		 push	 eax
  00202	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN20@Univers
  00208	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0020d	58		 pop	 eax
  0020e	5a		 pop	 edx
  0020f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  00212	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00219	59		 pop	 ecx
  0021a	5f		 pop	 edi
  0021b	5e		 pop	 esi
  0021c	5b		 pop	 ebx
  0021d	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00220	33 cd		 xor	 ecx, ebp
  00222	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00227	83 c4 6c	 add	 esp, 108		; 0000006cH
  0022a	3b ec		 cmp	 ebp, esp
  0022c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00231	8b e5		 mov	 esp, ebp
  00233	5d		 pop	 ebp
  00234	c2 08 00	 ret	 8
  00237	90		 npad	 1
$LN20@Univers:
  00238	01 00 00 00	 DD	 1
  0023c	00 00 00 00	 DD	 $LN19@Univers
$LN19@Univers:
  00240	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00244	0c 00 00 00	 DD	 12			; 0000000cH
  00248	00 00 00 00	 DD	 $LN17@Univers
$LN17@Univers:
  0024c	65		 DB	 101			; 00000065H
  0024d	00		 DB	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$2:
  00000	6a 18		 push	 24			; 00000018H
  00002	8b 45 c4	 mov	 eax, DWORD PTR $T6[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
__unwindfunclet$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z$6:
  0000f	8d 4d d8	 lea	 ecx, DWORD PTR _e$10[ebp]
  00012	e9 00 00 00 00	 jmp	 ??1invalid_argument@std@@UAE@XZ
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
  0001b	cc		 int	 3
__ehhandler$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z:
  0001c	90		 npad	 1
  0001d	90		 npad	 1
  0001e	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00022	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00025	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  00028	33 c8		 xor	 ecx, eax
  0002a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002f	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00032	33 c8		 xor	 ecx, eax
  00034	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00039	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z
  0003e	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z ENDP ; Univers::Univers
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ PROC ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest, COMDAT
; _this$ = ecx

; 672  :     constexpr _Mybase& _Get_rest() noexcept { // get reference to rest of elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 673  :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 674  :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_rest@?$tuple@W4DIRDEP@@W41@@std@@QAEAAV?$tuple@W4DIRDEP@@@2@XZ ENDP ; std::tuple<enum DIRDEP,enum DIRDEP>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z PROC	; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>, COMDAT
; _this$ = ecx

; 359  :     tuple(const tuple&) = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z ; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00027	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00030	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00033	83 c4 04	 add	 esp, 4
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
??0?$tuple@W4DIRDEP@@W41@@std@@QAE@ABV01@@Z ENDP	; std::tuple<enum DIRDEP,enum DIRDEP>::tuple<enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ PROC ; std::tuple<enum DIRDEP>::_Get_rest, COMDAT
; _this$ = ecx

; 672  :     constexpr _Mybase& _Get_rest() noexcept { // get reference to rest of elements

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 673  :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 674  :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_rest@?$tuple@W4DIRDEP@@@std@@QAEAAV?$tuple@$$V@2@XZ ENDP ; std::tuple<enum DIRDEP>::_Get_rest
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z PROC		; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>, COMDAT
; _this$ = ecx

; 359  :     tuple(const tuple&) = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$tuple@$$V@std@@QAE@ABV01@@Z ; std::tuple<>::tuple<>
  00024	8b 4d 08	 mov	 ecx, DWORD PTR ___that$[ebp]
  00027	8b 11		 mov	 edx, DWORD PTR [ecx]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	89 10		 mov	 DWORD PTR [eax], edx
  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 c4 04	 add	 esp, 4
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 04 00	 ret	 4
??0?$tuple@W4DIRDEP@@@std@@QAE@ABV01@@Z ENDP		; std::tuple<enum DIRDEP>::tuple<enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1534 :     _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1535 :         return _Mypair._Myval2._Mylast;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 08	 mov	 eax, DWORD PTR [eax+8]

; 1536 :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1526 :     _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1527 :         return _Mypair._Myval2._Myfirst;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1528 :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GTerrain@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GTerrain@@QAEPAXI@Z PROC				; Terrain::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1Terrain@@QAE@XZ	; Terrain::~Terrain
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 18		 push	 24			; 00000018H
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_GTerrain@@QAEPAXI@Z ENDP				; Terrain::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@Terrain@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@Terrain@@QAEXI@Z PROC			; Terrain::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@Terrain@@QAEXI@Z ENDP			; Terrain::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getSizeY@Terrain@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSizeY@Terrain@@QAEIXZ PROC				; Terrain::getSizeY, COMDAT
; _this$ = ecx

; 25   : 	inline unsigned int getSizeY() { return TC.sizeY; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]
  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?getSizeY@Terrain@@QAEIXZ ENDP				; Terrain::getSizeY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getSizeX@Terrain@@QAEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getSizeX@Terrain@@QAEIXZ PROC				; Terrain::getSizeX, COMDAT
; _this$ = ecx

; 24   : 	inline unsigned int getSizeX() { return TC.sizeX; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 10	 mov	 eax, DWORD PTR [eax+16]
  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?getSizeX@Terrain@@QAEIXZ ENDP				; Terrain::getSizeX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getPlayer@Terrain@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPlayer@Terrain@@QAEPAVPlayer@@XZ PROC		; Terrain::getPlayer, COMDAT
; _this$ = ecx

; 21   : 	inline Player* getPlayer() { return TC.getPlayer(); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 08	 add	 ecx, 8
  0001e	e8 00 00 00 00	 call	 ?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ ; TerrainConstructor::getPlayer
  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?getPlayer@Terrain@@QAEPAVPlayer@@XZ ENDP		; Terrain::getPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
;	COMDAT ?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ PROC ; Terrain::getTerrain, COMDAT
; _this$ = ecx

; 20   : 	inline std::vector<Block*>* getTerrain() { return terrain; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __9D99E827_Terrain@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?getTerrain@Terrain@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@XZ ENDP ; Terrain::getTerrain
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\TerrainConstructor.h
;	COMDAT ?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ PROC	; TerrainConstructor::getPlayer, COMDAT
; _this$ = ecx

; 21   : 	inline Player* getPlayer() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __78BC29F0_TerrainConstructor@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 22   : 		return p;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]

; 23   : 	}

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?getPlayer@TerrainConstructor@@QAEPAVPlayer@@XZ ENDP	; TerrainConstructor::getPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Block.h
;	COMDAT ?getY@Block@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getY@Block@@QAEHXZ PROC				; Block::getY, COMDAT
; _this$ = ecx

; 19   : 	inline int getY() { return _y; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __9344C8DF_Block@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?getY@Block@@QAEHXZ ENDP				; Block::getY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Block.h
;	COMDAT ?getX@Block@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getX@Block@@QAEHXZ PROC				; Block::getX, COMDAT
; _this$ = ecx

; 18   : 	inline int getX() { return _x; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __9344C8DF_Block@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?getX@Block@@QAEHXZ ENDP				; Block::getX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??__Flevel1@@YAXXZ
text$yd	SEGMENT
??__Flevel1@@YAXXZ PROC					; `dynamic atexit destructor for 'level1'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  00008	e8 00 00 00 00	 call	 ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??__Flevel1@@YAXXZ ENDP					; `dynamic atexit destructor for 'level1''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Levels.h
;	COMDAT ??__Elevel1@@YAXXZ
text$di	SEGMENT
tv568 = -1220						; size = 4
tv553 = -1216						; size = 4
tv474 = -1212						; size = 4
tv459 = -1208						; size = 4
tv412 = -1204						; size = 4
tv397 = -1200						; size = 4
tv350 = -1196						; size = 4
tv335 = -1192						; size = 4
tv320 = -1188						; size = 4
tv241 = -1184						; size = 4
tv226 = -1180						; size = 4
tv179 = -1176						; size = 4
tv164 = -1172						; size = 4
tv84 = -1168						; size = 4
tv612 = -1164						; size = 4
$T2 = -1160						; size = 8
$T3 = -1152						; size = 8
$T4 = -1144						; size = 8
$T5 = -1132						; size = 8
$T6 = -1121						; size = 1
$T7 = -1120						; size = 8
$T8 = -1108						; size = 8
$T9 = -1097						; size = 1
$T10 = -1096						; size = 8
$T11 = -1084						; size = 8
$T12 = -1073						; size = 1
$T13 = -1072						; size = 8
$T14 = -1060						; size = 8
$T15 = -1049						; size = 1
$T16 = -1048						; size = 8
$T17 = -1036						; size = 8
$T18 = -1025						; size = 1
$T19 = -1024						; size = 8
$T20 = -1012						; size = 8
$T21 = -1001						; size = 1
$T22 = -1000						; size = 8
$T23 = -988						; size = 8
$T24 = -977						; size = 1
$T25 = -976						; size = 8
$T26 = -964						; size = 8
$T27 = -953						; size = 1
$T28 = -952						; size = 8
$T29 = -940						; size = 8
$T30 = -929						; size = 1
$T31 = -928						; size = 8
$T32 = -916						; size = 8
$T33 = -905						; size = 1
$T34 = -904						; size = 8
$T35 = -892						; size = 8
$T36 = -881						; size = 1
$T37 = -880						; size = 8
$T38 = -868						; size = 8
$T39 = -857						; size = 1
$T40 = -856						; size = 8
$T41 = -844						; size = 8
$T42 = -833						; size = 1
$T43 = -832						; size = 8
$T44 = -820						; size = 8
$T45 = -810						; size = 1
$T46 = -809						; size = 1
$T47 = -808						; size = 36
$T48 = -768						; size = 36
$T49 = -728						; size = 36
$T50 = -688						; size = 36
$T51 = -648						; size = 36
$T52 = -608						; size = 36
$T53 = -568						; size = 36
$T54 = -528						; size = 36
$T55 = -488						; size = 36
$T56 = -448						; size = 36
$T57 = -408						; size = 36
$T58 = -368						; size = 36
$T59 = -328						; size = 36
$T60 = -288						; size = 36
$T61 = -248						; size = 224
__$EHRec$ = -12						; size = 12
??__Elevel1@@YAXXZ PROC					; `dynamic initializer for 'level1'', COMDAT

; 19   : };

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 f8	 and	 esp, -8			; fffffff8H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??__Elevel1@@YAXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 ec b8 04 00
	00		 sub	 esp, 1208		; 000004b8H
  0002b	57		 push	 edi
  0002c	8d bd 38 fb ff
	ff		 lea	 edi, DWORD PTR [ebp-1224]
  00032	b9 2e 01 00 00	 mov	 ecx, 302		; 0000012eH
  00037	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0003c	f3 ab		 rep stosd
  0003e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00043	33 c5		 xor	 eax, ebp
  00045	50		 push	 eax
  00046	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00049	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0004f	b9 00 00 00 00	 mov	 ecx, OFFSET __218DFE2C_Levels@h
  00054	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4    : inline std::vector<std::vector<int>> level1 = {

  00059	6a 10		 push	 16			; 00000010H
  0005b	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  00060	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
  00065	8d 8d d7 fc ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  0006b	e8 00 00 00 00	 call	 ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
  00070	89 85 74 fb ff
	ff		 mov	 DWORD PTR tv612[ebp], eax
  00076	8d 8d d6 fc ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  0007c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00081	89 85 70 fb ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  00087	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp], 0
  00091	c7 85 e4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+4], 0
  0009b	c7 85 e8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+8], 0
  000a5	c7 85 ec fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+12], 0
  000af	c7 85 f0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+16], 0
  000b9	c7 85 f4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+20], 0
  000c3	c7 85 f8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+24], 0
  000cd	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+28], 0
  000d7	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T60[ebp+32], 0
  000e1	8d 85 04 ff ff
	ff		 lea	 eax, DWORD PTR $T60[ebp+36]
  000e7	50		 push	 eax
  000e8	8d 8d e0 fe ff
	ff		 lea	 ecx, DWORD PTR $T60[ebp]
  000ee	51		 push	 ecx
  000ef	8d 8d cc fc ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  000f5	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  000fa	8b 10		 mov	 edx, DWORD PTR [eax]
  000fc	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  000ff	89 95 c0 fc ff
	ff		 mov	 DWORD PTR $T43[ebp], edx
  00105	89 85 c4 fc ff
	ff		 mov	 DWORD PTR $T43[ebp+4], eax
  0010b	8b 8d 70 fb ff
	ff		 mov	 ecx, DWORD PTR tv84[ebp]
  00111	51		 push	 ecx
  00112	8b 95 c4 fc ff
	ff		 mov	 edx, DWORD PTR $T43[ebp+4]
  00118	52		 push	 edx
  00119	8b 85 c0 fc ff
	ff		 mov	 eax, DWORD PTR $T43[ebp]
  0011f	50		 push	 eax
  00120	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  00126	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0012b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00132	8d 8d bf fc ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0013d	89 85 6c fb ff
	ff		 mov	 DWORD PTR tv164[ebp], eax
  00143	c7 85 b8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp], 0
  0014d	c7 85 bc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+4], 0
  00157	c7 85 c0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+8], 0
  00161	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+12], 0
  0016b	c7 85 c8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+16], 0
  00175	c7 85 cc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+20], 0
  0017f	c7 85 d0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+24], 0
  00189	c7 85 d4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+28], 0
  00193	c7 85 d8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T59[ebp+32], 0
  0019d	8d 8d dc fe ff
	ff		 lea	 ecx, DWORD PTR $T59[ebp+36]
  001a3	51		 push	 ecx
  001a4	8d 95 b8 fe ff
	ff		 lea	 edx, DWORD PTR $T59[ebp]
  001aa	52		 push	 edx
  001ab	8d 8d b4 fc ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  001b1	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  001b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  001b8	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  001bb	89 8d a8 fc ff
	ff		 mov	 DWORD PTR $T40[ebp], ecx
  001c1	89 95 ac fc ff
	ff		 mov	 DWORD PTR $T40[ebp+4], edx
  001c7	8b 85 6c fb ff
	ff		 mov	 eax, DWORD PTR tv164[ebp]
  001cd	50		 push	 eax
  001ce	8b 8d ac fc ff
	ff		 mov	 ecx, DWORD PTR $T40[ebp+4]
  001d4	51		 push	 ecx
  001d5	8b 95 a8 fc ff
	ff		 mov	 edx, DWORD PTR $T40[ebp]
  001db	52		 push	 edx
  001dc	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+16]
  001e2	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  001e7	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  001eb	8d 8d a7 fc ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  001f1	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  001f6	89 85 68 fb ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  001fc	c7 85 90 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp], 0
  00206	c7 85 94 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+4], 0
  00210	c7 85 98 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+8], 0
  0021a	c7 85 9c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+12], 0
  00224	c7 85 a0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+16], 0
  0022e	c7 85 a4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+20], 0
  00238	c7 85 a8 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+24], 0
  00242	c7 85 ac fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+28], 0
  0024c	c7 85 b0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T58[ebp+32], 0
  00256	8d 85 b4 fe ff
	ff		 lea	 eax, DWORD PTR $T58[ebp+36]
  0025c	50		 push	 eax
  0025d	8d 8d 90 fe ff
	ff		 lea	 ecx, DWORD PTR $T58[ebp]
  00263	51		 push	 ecx
  00264	8d 8d 9c fc ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  0026a	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  0026f	8b 10		 mov	 edx, DWORD PTR [eax]
  00271	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00274	89 95 90 fc ff
	ff		 mov	 DWORD PTR $T37[ebp], edx
  0027a	89 85 94 fc ff
	ff		 mov	 DWORD PTR $T37[ebp+4], eax
  00280	8b 8d 68 fb ff
	ff		 mov	 ecx, DWORD PTR tv179[ebp]
  00286	51		 push	 ecx
  00287	8b 95 94 fc ff
	ff		 mov	 edx, DWORD PTR $T37[ebp+4]
  0028d	52		 push	 edx
  0028e	8b 85 90 fc ff
	ff		 mov	 eax, DWORD PTR $T37[ebp]
  00294	50		 push	 eax
  00295	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+32]
  0029b	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  002a0	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  002a4	8d 8d 8f fc ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  002aa	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  002af	89 85 64 fb ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  002b5	c7 85 68 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp], 0
  002bf	c7 85 6c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+4], 0
  002c9	c7 85 70 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+8], 0
  002d3	c7 85 74 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+12], 0
  002dd	c7 85 78 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+16], 0
  002e7	c7 85 7c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+20], 0
  002f1	c7 85 80 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+24], 0
  002fb	c7 85 84 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+28], 0
  00305	c7 85 88 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T57[ebp+32], 0
  0030f	8d 8d 8c fe ff
	ff		 lea	 ecx, DWORD PTR $T57[ebp+36]
  00315	51		 push	 ecx
  00316	8d 95 68 fe ff
	ff		 lea	 edx, DWORD PTR $T57[ebp]
  0031c	52		 push	 edx
  0031d	8d 8d 84 fc ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  00323	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00328	8b 08		 mov	 ecx, DWORD PTR [eax]
  0032a	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0032d	89 8d 78 fc ff
	ff		 mov	 DWORD PTR $T34[ebp], ecx
  00333	89 95 7c fc ff
	ff		 mov	 DWORD PTR $T34[ebp+4], edx
  00339	8b 85 64 fb ff
	ff		 mov	 eax, DWORD PTR tv226[ebp]
  0033f	50		 push	 eax
  00340	8b 8d 7c fc ff
	ff		 mov	 ecx, DWORD PTR $T34[ebp+4]
  00346	51		 push	 ecx
  00347	8b 95 78 fc ff
	ff		 mov	 edx, DWORD PTR $T34[ebp]
  0034d	52		 push	 edx
  0034e	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+48]
  00354	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00359	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0035d	8d 8d 77 fc ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00363	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00368	89 85 60 fb ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  0036e	c7 85 40 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp], 0
  00378	c7 85 44 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+4], 0
  00382	c7 85 48 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+8], 0
  0038c	c7 85 4c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+12], 0
  00396	c7 85 50 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+16], 0
  003a0	c7 85 54 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+20], 0
  003aa	c7 85 58 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+24], 0
  003b4	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+28], 0
  003be	c7 85 60 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T56[ebp+32], 0
  003c8	8d 85 64 fe ff
	ff		 lea	 eax, DWORD PTR $T56[ebp+36]
  003ce	50		 push	 eax
  003cf	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T56[ebp]
  003d5	51		 push	 ecx
  003d6	8d 8d 6c fc ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  003dc	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  003e1	8b 10		 mov	 edx, DWORD PTR [eax]
  003e3	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  003e6	89 95 60 fc ff
	ff		 mov	 DWORD PTR $T31[ebp], edx
  003ec	89 85 64 fc ff
	ff		 mov	 DWORD PTR $T31[ebp+4], eax
  003f2	8b 8d 60 fb ff
	ff		 mov	 ecx, DWORD PTR tv241[ebp]
  003f8	51		 push	 ecx
  003f9	8b 95 64 fc ff
	ff		 mov	 edx, DWORD PTR $T31[ebp+4]
  003ff	52		 push	 edx
  00400	8b 85 60 fc ff
	ff		 mov	 eax, DWORD PTR $T31[ebp]
  00406	50		 push	 eax
  00407	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+64]
  0040d	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00412	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00416	8d 8d 5f fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  0041c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00421	89 85 5c fb ff
	ff		 mov	 DWORD PTR tv320[ebp], eax
  00427	c7 85 18 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp], 0
  00431	c7 85 1c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+4], 0
  0043b	c7 85 20 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+8], 0
  00445	c7 85 24 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+12], 0
  0044f	c7 85 28 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+16], 0
  00459	c7 85 2c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+20], 0
  00463	c7 85 30 fe ff
	ff 03 00 00 00	 mov	 DWORD PTR $T55[ebp+24], 3
  0046d	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+28], 0
  00477	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T55[ebp+32], 0
  00481	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T55[ebp+36]
  00487	51		 push	 ecx
  00488	8d 95 18 fe ff
	ff		 lea	 edx, DWORD PTR $T55[ebp]
  0048e	52		 push	 edx
  0048f	8d 8d 54 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00495	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  0049a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0049c	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0049f	89 8d 48 fc ff
	ff		 mov	 DWORD PTR $T28[ebp], ecx
  004a5	89 95 4c fc ff
	ff		 mov	 DWORD PTR $T28[ebp+4], edx
  004ab	8b 85 5c fb ff
	ff		 mov	 eax, DWORD PTR tv320[ebp]
  004b1	50		 push	 eax
  004b2	8b 8d 4c fc ff
	ff		 mov	 ecx, DWORD PTR $T28[ebp+4]
  004b8	51		 push	 ecx
  004b9	8b 95 48 fc ff
	ff		 mov	 edx, DWORD PTR $T28[ebp]
  004bf	52		 push	 edx
  004c0	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+80]
  004c6	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  004cb	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  004cf	8d 8d 47 fc ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  004d5	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  004da	89 85 58 fb ff
	ff		 mov	 DWORD PTR tv335[ebp], eax
  004e0	c7 85 f0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp], 0
  004ea	c7 85 f4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+4], 0
  004f4	c7 85 f8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+8], 0
  004fe	c7 85 fc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+12], 0
  00508	c7 85 00 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+16], 0
  00512	c7 85 04 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+20], 0
  0051c	c7 85 08 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR $T54[ebp+24], 5
  00526	c7 85 0c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+28], 0
  00530	c7 85 10 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T54[ebp+32], 0
  0053a	8d 85 14 fe ff
	ff		 lea	 eax, DWORD PTR $T54[ebp+36]
  00540	50		 push	 eax
  00541	8d 8d f0 fd ff
	ff		 lea	 ecx, DWORD PTR $T54[ebp]
  00547	51		 push	 ecx
  00548	8d 8d 3c fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0054e	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00553	8b 10		 mov	 edx, DWORD PTR [eax]
  00555	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00558	89 95 30 fc ff
	ff		 mov	 DWORD PTR $T25[ebp], edx
  0055e	89 85 34 fc ff
	ff		 mov	 DWORD PTR $T25[ebp+4], eax
  00564	8b 8d 58 fb ff
	ff		 mov	 ecx, DWORD PTR tv335[ebp]
  0056a	51		 push	 ecx
  0056b	8b 95 34 fc ff
	ff		 mov	 edx, DWORD PTR $T25[ebp+4]
  00571	52		 push	 edx
  00572	8b 85 30 fc ff
	ff		 mov	 eax, DWORD PTR $T25[ebp]
  00578	50		 push	 eax
  00579	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+96]
  0057f	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00584	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00588	8d 8d 2f fc ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  0058e	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00593	89 85 54 fb ff
	ff		 mov	 DWORD PTR tv350[ebp], eax
  00599	c7 85 c8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp], 0
  005a3	c7 85 cc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+4], 0
  005ad	c7 85 d0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+8], 0
  005b7	c7 85 d4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+12], 0
  005c1	c7 85 d8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+16], 0
  005cb	c7 85 dc fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+20], 0
  005d5	c7 85 e0 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR $T53[ebp+24], 3
  005df	c7 85 e4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+28], 0
  005e9	c7 85 e8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T53[ebp+32], 0
  005f3	8d 8d ec fd ff
	ff		 lea	 ecx, DWORD PTR $T53[ebp+36]
  005f9	51		 push	 ecx
  005fa	8d 95 c8 fd ff
	ff		 lea	 edx, DWORD PTR $T53[ebp]
  00600	52		 push	 edx
  00601	8d 8d 24 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00607	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  0060c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0060e	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00611	89 8d 18 fc ff
	ff		 mov	 DWORD PTR $T22[ebp], ecx
  00617	89 95 1c fc ff
	ff		 mov	 DWORD PTR $T22[ebp+4], edx
  0061d	8b 85 54 fb ff
	ff		 mov	 eax, DWORD PTR tv350[ebp]
  00623	50		 push	 eax
  00624	8b 8d 1c fc ff
	ff		 mov	 ecx, DWORD PTR $T22[ebp+4]
  0062a	51		 push	 ecx
  0062b	8b 95 18 fc ff
	ff		 mov	 edx, DWORD PTR $T22[ebp]
  00631	52		 push	 edx
  00632	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+112]
  00638	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0063d	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00641	8d 8d 17 fc ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00647	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0064c	89 85 50 fb ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
  00652	c7 85 a0 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T52[ebp], 2
  0065c	c7 85 a4 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T52[ebp+4], 0
  00666	c7 85 a8 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T52[ebp+8], 0
  00670	c7 85 ac fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T52[ebp+12], 2
  0067a	c7 85 b0 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T52[ebp+16], 0
  00684	c7 85 b4 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T52[ebp+20], 2
  0068e	c7 85 b8 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T52[ebp+24], 2
  00698	c7 85 bc fd ff
	ff 06 00 00 00	 mov	 DWORD PTR $T52[ebp+28], 6
  006a2	c7 85 c0 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T52[ebp+32], 2
  006ac	8d 85 c4 fd ff
	ff		 lea	 eax, DWORD PTR $T52[ebp+36]
  006b2	50		 push	 eax
  006b3	8d 8d a0 fd ff
	ff		 lea	 ecx, DWORD PTR $T52[ebp]
  006b9	51		 push	 ecx
  006ba	8d 8d 0c fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  006c0	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  006c5	8b 10		 mov	 edx, DWORD PTR [eax]
  006c7	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  006ca	89 95 00 fc ff
	ff		 mov	 DWORD PTR $T19[ebp], edx
  006d0	89 85 04 fc ff
	ff		 mov	 DWORD PTR $T19[ebp+4], eax
  006d6	8b 8d 50 fb ff
	ff		 mov	 ecx, DWORD PTR tv397[ebp]
  006dc	51		 push	 ecx
  006dd	8b 95 04 fc ff
	ff		 mov	 edx, DWORD PTR $T19[ebp+4]
  006e3	52		 push	 edx
  006e4	8b 85 00 fc ff
	ff		 mov	 eax, DWORD PTR $T19[ebp]
  006ea	50		 push	 eax
  006eb	8d 4d 88	 lea	 ecx, DWORD PTR $T61[ebp+128]
  006ee	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  006f3	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  006f7	8d 8d ff fb ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  006fd	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00702	89 85 4c fb ff
	ff		 mov	 DWORD PTR tv412[ebp], eax
  00708	c7 85 78 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51[ebp], 0
  00712	c7 85 7c fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T51[ebp+4], 2
  0071c	c7 85 80 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51[ebp+8], 0
  00726	c7 85 84 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51[ebp+12], 0
  00730	c7 85 88 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T51[ebp+16], 0
  0073a	c7 85 8c fd ff
	ff 03 00 00 00	 mov	 DWORD PTR $T51[ebp+20], 3
  00744	c7 85 90 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR $T51[ebp+24], 3
  0074e	c7 85 94 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T51[ebp+28], 2
  00758	c7 85 98 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T51[ebp+32], 2
  00762	8d 8d 9c fd ff
	ff		 lea	 ecx, DWORD PTR $T51[ebp+36]
  00768	51		 push	 ecx
  00769	8d 95 78 fd ff
	ff		 lea	 edx, DWORD PTR $T51[ebp]
  0076f	52		 push	 edx
  00770	8d 8d f4 fb ff
	ff		 lea	 ecx, DWORD PTR $T17[ebp]
  00776	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  0077b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0077d	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00780	89 8d e8 fb ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
  00786	89 95 ec fb ff
	ff		 mov	 DWORD PTR $T16[ebp+4], edx
  0078c	8b 85 4c fb ff
	ff		 mov	 eax, DWORD PTR tv412[ebp]
  00792	50		 push	 eax
  00793	8b 8d ec fb ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp+4]
  00799	51		 push	 ecx
  0079a	8b 95 e8 fb ff
	ff		 mov	 edx, DWORD PTR $T16[ebp]
  007a0	52		 push	 edx
  007a1	8d 4d 98	 lea	 ecx, DWORD PTR $T61[ebp+144]
  007a4	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  007a9	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  007ad	8d 8d e7 fb ff
	ff		 lea	 ecx, DWORD PTR $T15[ebp]
  007b3	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  007b8	89 85 48 fb ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  007be	c7 85 50 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp], 0
  007c8	c7 85 54 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp+4], 0
  007d2	c7 85 58 fd ff
	ff 05 00 00 00	 mov	 DWORD PTR $T50[ebp+8], 5
  007dc	c7 85 5c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp+12], 0
  007e6	c7 85 60 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp+16], 0
  007f0	c7 85 64 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp+20], 0
  007fa	c7 85 68 fd ff
	ff 04 00 00 00	 mov	 DWORD PTR $T50[ebp+24], 4
  00804	c7 85 6c fd ff
	ff 03 00 00 00	 mov	 DWORD PTR $T50[ebp+28], 3
  0080e	c7 85 70 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T50[ebp+32], 0
  00818	8d 85 74 fd ff
	ff		 lea	 eax, DWORD PTR $T50[ebp+36]
  0081e	50		 push	 eax
  0081f	8d 8d 50 fd ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  00825	51		 push	 ecx
  00826	8d 8d dc fb ff
	ff		 lea	 ecx, DWORD PTR $T14[ebp]
  0082c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00831	8b 10		 mov	 edx, DWORD PTR [eax]
  00833	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00836	89 95 d0 fb ff
	ff		 mov	 DWORD PTR $T13[ebp], edx
  0083c	89 85 d4 fb ff
	ff		 mov	 DWORD PTR $T13[ebp+4], eax
  00842	8b 8d 48 fb ff
	ff		 mov	 ecx, DWORD PTR tv459[ebp]
  00848	51		 push	 ecx
  00849	8b 95 d4 fb ff
	ff		 mov	 edx, DWORD PTR $T13[ebp+4]
  0084f	52		 push	 edx
  00850	8b 85 d0 fb ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  00856	50		 push	 eax
  00857	8d 4d a8	 lea	 ecx, DWORD PTR $T61[ebp+160]
  0085a	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  0085f	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00863	8d 8d cf fb ff
	ff		 lea	 ecx, DWORD PTR $T12[ebp]
  00869	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0086e	89 85 44 fb ff
	ff		 mov	 DWORD PTR tv474[ebp], eax
  00874	c7 85 28 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T49[ebp], 0
  0087e	c7 85 2c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T49[ebp+4], 0
  00888	c7 85 30 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR $T49[ebp+8], 3
  00892	c7 85 34 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T49[ebp+12], 2
  0089c	c7 85 38 fd ff
	ff ff ff ff ff	 mov	 DWORD PTR $T49[ebp+16], -1
  008a6	c7 85 3c fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T49[ebp+20], 0
  008b0	c7 85 40 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T49[ebp+24], 0
  008ba	c7 85 44 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T49[ebp+28], 2
  008c4	c7 85 48 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T49[ebp+32], 0
  008ce	8d 8d 4c fd ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp+36]
  008d4	51		 push	 ecx
  008d5	8d 95 28 fd ff
	ff		 lea	 edx, DWORD PTR $T49[ebp]
  008db	52		 push	 edx
  008dc	8d 8d c4 fb ff
	ff		 lea	 ecx, DWORD PTR $T11[ebp]
  008e2	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  008e7	8b 08		 mov	 ecx, DWORD PTR [eax]
  008e9	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  008ec	89 8d b8 fb ff
	ff		 mov	 DWORD PTR $T10[ebp], ecx
  008f2	89 95 bc fb ff
	ff		 mov	 DWORD PTR $T10[ebp+4], edx
  008f8	8b 85 44 fb ff
	ff		 mov	 eax, DWORD PTR tv474[ebp]
  008fe	50		 push	 eax
  008ff	8b 8d bc fb ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp+4]
  00905	51		 push	 ecx
  00906	8b 95 b8 fb ff
	ff		 mov	 edx, DWORD PTR $T10[ebp]
  0090c	52		 push	 edx
  0090d	8d 4d b8	 lea	 ecx, DWORD PTR $T61[ebp+176]
  00910	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00915	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00919	8d 8d b7 fb ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  0091f	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00924	89 85 40 fb ff
	ff		 mov	 DWORD PTR tv553[ebp], eax
  0092a	c7 85 00 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T48[ebp], 0
  00934	c7 85 04 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T48[ebp+4], 0
  0093e	c7 85 08 fd ff
	ff 02 00 00 00	 mov	 DWORD PTR $T48[ebp+8], 2
  00948	c7 85 0c fd ff
	ff 04 00 00 00	 mov	 DWORD PTR $T48[ebp+12], 4
  00952	c7 85 10 fd ff
	ff 03 00 00 00	 mov	 DWORD PTR $T48[ebp+16], 3
  0095c	c7 85 14 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T48[ebp+20], 0
  00966	c7 85 18 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T48[ebp+24], 0
  00970	c7 85 1c fd ff
	ff 04 00 00 00	 mov	 DWORD PTR $T48[ebp+28], 4
  0097a	c7 85 20 fd ff
	ff 00 00 00 00	 mov	 DWORD PTR $T48[ebp+32], 0
  00984	8d 85 24 fd ff
	ff		 lea	 eax, DWORD PTR $T48[ebp+36]
  0098a	50		 push	 eax
  0098b	8d 8d 00 fd ff
	ff		 lea	 ecx, DWORD PTR $T48[ebp]
  00991	51		 push	 ecx
  00992	8d 8d ac fb ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00998	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  0099d	8b 10		 mov	 edx, DWORD PTR [eax]
  0099f	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  009a2	89 95 a0 fb ff
	ff		 mov	 DWORD PTR $T7[ebp], edx
  009a8	89 85 a4 fb ff
	ff		 mov	 DWORD PTR $T7[ebp+4], eax
  009ae	8b 8d 40 fb ff
	ff		 mov	 ecx, DWORD PTR tv553[ebp]
  009b4	51		 push	 ecx
  009b5	8b 95 a4 fb ff
	ff		 mov	 edx, DWORD PTR $T7[ebp+4]
  009bb	52		 push	 edx
  009bc	8b 85 a0 fb ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  009c2	50		 push	 eax
  009c3	8d 4d c8	 lea	 ecx, DWORD PTR $T61[ebp+192]
  009c6	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  009cb	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  009cf	8d 8d 9f fb ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  009d5	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  009da	89 85 3c fb ff
	ff		 mov	 DWORD PTR tv568[ebp], eax
  009e0	c7 85 d8 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T47[ebp], 2
  009ea	c7 85 dc fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T47[ebp+4], 2
  009f4	c7 85 e0 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T47[ebp+8], 3
  009fe	c7 85 e4 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T47[ebp+12], 3
  00a08	c7 85 e8 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T47[ebp+16], 2
  00a12	c7 85 ec fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T47[ebp+20], 3
  00a1c	c7 85 f0 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T47[ebp+24], 3
  00a26	c7 85 f4 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T47[ebp+28], 2
  00a30	c7 85 f8 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR $T47[ebp+32], 4
  00a3a	8d 8d fc fc ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp+36]
  00a40	51		 push	 ecx
  00a41	8d 95 d8 fc ff
	ff		 lea	 edx, DWORD PTR $T47[ebp]
  00a47	52		 push	 edx
  00a48	8d 8d 94 fb ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00a4e	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00a53	8b 08		 mov	 ecx, DWORD PTR [eax]
  00a55	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  00a58	89 8d 88 fb ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  00a5e	89 95 8c fb ff
	ff		 mov	 DWORD PTR $T4[ebp+4], edx
  00a64	8b 85 3c fb ff
	ff		 mov	 eax, DWORD PTR tv568[ebp]
  00a6a	50		 push	 eax
  00a6b	8b 8d 8c fb ff
	ff		 mov	 ecx, DWORD PTR $T4[ebp+4]
  00a71	51		 push	 ecx
  00a72	8b 95 88 fb ff
	ff		 mov	 edx, DWORD PTR $T4[ebp]
  00a78	52		 push	 edx
  00a79	8d 4d d8	 lea	 ecx, DWORD PTR $T61[ebp+208]
  00a7c	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00a81	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  00a88	8d 45 e8	 lea	 eax, DWORD PTR $T61[ebp+224]
  00a8b	50		 push	 eax
  00a8c	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  00a92	51		 push	 ecx
  00a93	8d 8d 80 fb ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00a99	e8 00 00 00 00	 call	 ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
  00a9e	8b 10		 mov	 edx, DWORD PTR [eax]
  00aa0	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  00aa3	89 95 78 fb ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  00aa9	89 85 7c fb ff
	ff		 mov	 DWORD PTR $T2[ebp+4], eax
  00aaf	8b 8d 74 fb ff
	ff		 mov	 ecx, DWORD PTR tv612[ebp]
  00ab5	51		 push	 ecx
  00ab6	8b 95 7c fb ff
	ff		 mov	 edx, DWORD PTR $T2[ebp+4]
  00abc	52		 push	 edx
  00abd	8b 85 78 fb ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]
  00ac3	50		 push	 eax
  00ac4	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  00ac9	e8 00 00 00 00	 call	 ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  00ace	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00ad5	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00ada	6a 0e		 push	 14			; 0000000eH
  00adc	6a 10		 push	 16			; 00000010H
  00ade	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  00ae4	51		 push	 ecx
  00ae5	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00aea	68 00 00 00 00	 push	 OFFSET ??__Flevel1@@YAXXZ ; `dynamic atexit destructor for 'level1''
  00aef	e8 00 00 00 00	 call	 _atexit
  00af4	83 c4 04	 add	 esp, 4
  00af7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00afa	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00b01	59		 pop	 ecx
  00b02	5f		 pop	 edi
  00b03	8b e5		 mov	 esp, ebp
  00b05	5d		 pop	 ebp
  00b06	8b e3		 mov	 esp, ebx
  00b08	5b		 pop	 ebx
  00b09	c3		 ret	 0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Elevel1@@YAXXZ$0:
  00000	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$1:
  0000b	8d 8d 18 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+16]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$2:
  00016	8d 8d 28 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+32]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$3:
  00021	8d 8d 38 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+48]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$4:
  0002c	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+64]
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$5:
  00037	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+80]
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$6:
  00042	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+96]
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$7:
  0004d	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T61[ebp+112]
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$8:
  00058	8d 4d 88	 lea	 ecx, DWORD PTR $T61[ebp+128]
  0005b	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$9:
  00060	8d 4d 98	 lea	 ecx, DWORD PTR $T61[ebp+144]
  00063	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$10:
  00068	8d 4d a8	 lea	 ecx, DWORD PTR $T61[ebp+160]
  0006b	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$11:
  00070	8d 4d b8	 lea	 ecx, DWORD PTR $T61[ebp+176]
  00073	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$12:
  00078	8d 4d c8	 lea	 ecx, DWORD PTR $T61[ebp+192]
  0007b	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$14:
  00080	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00085	6a 0e		 push	 14			; 0000000eH
  00087	6a 10		 push	 16			; 00000010H
  00089	8d 85 08 ff ff
	ff		 lea	 eax, DWORD PTR $T61[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  00095	c3		 ret	 0
  00096	cc		 int	 3
  00097	cc		 int	 3
  00098	cc		 int	 3
  00099	cc		 int	 3
  0009a	cc		 int	 3
__ehhandler$??__Elevel1@@YAXXZ:
  0009b	90		 npad	 1
  0009c	90		 npad	 1
  0009d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000a1	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000a4	8b 8a 3c fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1220]
  000aa	33 c8		 xor	 ecx, eax
  000ac	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b1	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Elevel1@@YAXXZ
  000b6	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Elevel1@@YAXXZ ENDP					; `dynamic initializer for 'level1''
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >, COMDAT

; 719  :     static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 720  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 721  :         _STD destroy_at(_Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
  00016	83 c4 04	 add	 esp, 4

; 722  : #else // __cpp_lib_constexpr_dynamic_alloc
; 723  :         _Ptr->~_Uty();
; 724  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 725  :     }

  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {

  0002c	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	83 c0 10	 add	 eax, 16			; 00000010H
  00034	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003a	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0003d	74 1b		 je	 SHORT $LN5@Destroy_ra

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
  00055	83 c4 08	 add	 esp, 8

; 951  :         }

  00058	eb d4		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 952  :     }
; 953  : }

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	83 c4 0c	 add	 esp, 12			; 0000000cH
  00068	3b ec		 cmp	 ebp, esp
  0006a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
  00076	cc		 int	 3
  00077	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z PROC		; std::construct_at<int,int &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00038	83 c4 04	 add	 esp, 4
  0003b	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 02		 mov	 DWORD PTR [edx], eax
  00042	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ENDP		; std::construct_at<int,int &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00015	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ; std::construct_at<int,int &,void>
  00037	83 c4 08	 add	 esp, 8

; 711  :         } else

  0003a	eb 2d		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0005f	83 c4 04	 add	 esp, 4
  00062	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 02		 mov	 DWORD PTR [edx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  00069	83 c4 04	 add	 esp, 4
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z
_TEXT	SEGMENT
tv74 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00024	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00051	52		 push	 edx
  00052	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00055	50		 push	 eax
  00056	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	83 c0 04	 add	 eax, 4
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1633 :     }

  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Count$ = -28						; size = 4
__Dest_ch$ = -24					; size = 4
__Last_ch$ = -20					; size = 4
__First_ch$ = -16					; size = 4
__DestPtr$ = -12					; size = 4
__LastPtr$ = -8						; size = 4
__FirstPtr$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  0002a	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 fc	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 f8	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  00048	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f4	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  00057	8b 45 fc	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  0005a	89 45 f0	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00060	89 4d ec	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00063	8b 55 f4	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  00066	89 55 e8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00069	8b 45 ec	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0006c	2b 45 f0	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0006f	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 f0	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00079	52		 push	 edx
  0007a	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _memmove
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00086	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00089	03 45 e4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  0008c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z PROC		; std::_Get_unwrapped<int * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ENDP		; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 4
__Backout$ = -40					; size = 12
__ULast$ = -24						; size = 4
__UFirst$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d0	 mov	 DWORD PTR [ebp-48], eax
  0001c	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001f	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00022	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00025	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00028	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00031	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00039	33 c5		 xor	 eax, ebp
  0003b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003e	50		 push	 eax
  0003f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00042	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0004d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00052	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 ec	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00061	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 e8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  00070	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00075	0f b6 d0	 movzx	 edx, al
  00078	85 d2		 test	 edx, edx
  0007a	75 34		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  0007c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  00085	83 c4 04	 add	 esp, 4
  00088	50		 push	 eax
  00089	8b 4d e8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  00099	8b 45 e8	 mov	 eax, DWORD PTR __ULast$[ebp]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0009f	c1 f8 02	 sar	 eax, 2
  000a2	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000a5	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000a8	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx

; 1665 :             return _Dest;

  000ab	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  000ae	eb 5f		 jmp	 SHORT $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000b0	6a 0c		 push	 12			; 0000000cH
  000b2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b5	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  000ba	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000c1	51		 push	 ecx
  000c2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000c5	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  000d1	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000d3	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000d6	83 c2 04	 add	 edx, 4
  000d9	89 55 ec	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  000dc	8b 45 ec	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000df	3b 45 e8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  000e2	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000e4	8b 4d ec	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000e7	51		 push	 ecx
  000e8	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000eb	e8 00 00 00 00	 call	 ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>

; 1672 :     }

  000f0	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000f2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  000fa	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00104	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00107	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0010c	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1675 : }

  0010f	52		 push	 edx
  00110	8b cd		 mov	 ecx, ebp
  00112	50		 push	 eax
  00113	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Uninitiali
  00119	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0011e	58		 pop	 eax
  0011f	5a		 pop	 edx
  00120	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012a	59		 pop	 ecx
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	83 c4 30	 add	 esp, 48			; 00000030H
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
  00143	90		 npad	 1
$LN11@Uninitiali:
  00144	01 00 00 00	 DD	 1
  00148	00 00 00 00	 DD	 $LN10@Uninitiali
$LN10@Uninitiali:
  0014c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00150	0c 00 00 00	 DD	 12			; 0000000cH
  00154	00 00 00 00	 DD	 $LN8@Uninitiali
$LN8@Uninitiali:
  00158	5f		 DB	 95			; 0000005fH
  00159	42		 DB	 66			; 00000042H
  0015a	61		 DB	 97			; 00000061H
  0015b	63		 DB	 99			; 00000063H
  0015c	6b		 DB	 107			; 0000006bH
  0015d	6f		 DB	 111			; 0000006fH
  0015e	75		 DB	 117			; 00000075H
  0015f	74		 DB	 116			; 00000074H
  00160	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,std::allocator<int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z PROC ; std::forward<std::allocator<int> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ENDP ; std::forward<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00020	50		 push	 eax
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z PROC ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	6a 10		 push	 16			; 00000010H
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00041	83 c4 04	 add	 esp, 4
  00044	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00047	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  0004a	52		 push	 edx
  0004b	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  0004e	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 145  : }

  00053	83 c4 08	 add	 esp, 8
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ENDP ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z
_TEXT	SEGMENT
tv85 = -8						; size = 4
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  0001e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00023	0f b6 c0	 movzx	 eax, al
  00026	85 c0		 test	 eax, eax
  00028	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0002a	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00033	83 c4 04	 add	 esp, 4
  00036	50		 push	 eax
  00037	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0003a	52		 push	 edx
  0003b	e8 00 00 00 00	 call	 ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
  00040	83 c4 08	 add	 esp, 8

; 711  :         } else

  00043	eb 35		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00045	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  0004e	83 c4 04	 add	 esp, 4
  00051	50		 push	 eax
  00052	6a 10		 push	 16			; 00000010H
  00054	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00059	83 c4 08	 add	 esp, 8
  0005c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0005f	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00068	83 c4 04	 add	 esp, 4
  0006b	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  0006e	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00071	52		 push	 edx
  00072	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00075	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  0007a	83 c4 08	 add	 esp, 8
  0007d	3b ec		 cmp	 ebp, esp
  0007f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z PROC ; std::_Unfancy<std::vector<int,std::allocator<int> > >, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
tv74 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00024	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00051	52		 push	 edx
  00052	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00055	50		 push	 eax
  00056	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	83 c0 10	 add	 eax, 16			; 00000010H
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1633 :     }

  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1638 :     }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00026	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  0002f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 4
__Backout$ = -40					; size = 12
__ULast$ = -24						; size = 4
__UFirst$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d0	 mov	 DWORD PTR [ebp-48], eax
  0001c	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001f	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00022	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00025	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00028	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00031	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00039	33 c5		 xor	 eax, ebp
  0003b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003e	50		 push	 eax
  0003f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00042	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0004d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00052	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 ec	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00061	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 e8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())
; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1664 :             _Dest += _ULast - _UFirst;
; 1665 :             return _Dest;
; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00070	6a 0c		 push	 12			; 0000000cH
  00072	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00075	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
  0007a	8b 55 14	 mov	 edx, DWORD PTR __Al$[ebp]
  0007d	52		 push	 edx
  0007e	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00081	50		 push	 eax
  00082	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00085	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  0008a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00091	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00093	8b 4d ec	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00096	83 c1 10	 add	 ecx, 16			; 00000010H
  00099	89 4d ec	 mov	 DWORD PTR __UFirst$[ebp], ecx
$LN4@Uninitiali:
  0009c	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0009f	3b 55 e8	 cmp	 edx, DWORD PTR __ULast$[ebp]
  000a2	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000a4	8b 45 ec	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000a7	50		 push	 eax
  000a8	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000ab	e8 00 00 00 00	 call	 ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>

; 1672 :     }

  000b0	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000b2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b5	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
  000ba	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  000bd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000c4	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000c7	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  000cc	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]

; 1675 : }

  000cf	52		 push	 edx
  000d0	8b cd		 mov	 ecx, ebp
  000d2	50		 push	 eax
  000d3	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@Uninitiali
  000d9	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000de	58		 pop	 eax
  000df	5a		 pop	 edx
  000e0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ea	59		 pop	 ecx
  000eb	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ee	33 cd		 xor	 ecx, ebp
  000f0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000f5	83 c4 30	 add	 esp, 48			; 00000030H
  000f8	3b ec		 cmp	 ebp, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	c3		 ret	 0
  00103	90		 npad	 1
$LN10@Uninitiali:
  00104	01 00 00 00	 DD	 1
  00108	00 00 00 00	 DD	 $LN9@Uninitiali
$LN9@Uninitiali:
  0010c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00110	0c 00 00 00	 DD	 12			; 0000000cH
  00114	00 00 00 00	 DD	 $LN7@Uninitiali
$LN7@Uninitiali:
  00118	5f		 DB	 95			; 0000005fH
  00119	42		 DB	 66			; 00000042H
  0011a	61		 DB	 97			; 00000061H
  0011b	63		 DB	 99			; 00000063H
  0011c	6b		 DB	 107			; 0000006bH
  0011d	6f		 DB	 111			; 0000006fH
  0011e	75		 DB	 117			; 00000075H
  0011f	74		 DB	 116			; 00000074H
  00120	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00020	50		 push	 eax
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 0a		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00025	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z PROC ; std::distance<std::vector<int,std::allocator<int> > const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 04	 sar	 eax, 4

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ENDP ; std::distance<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__My_data$2 = -40					; size = 4
__Guard$3 = -32						; size = 4
__Count$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00022	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00025	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00028	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  0004f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
  0005c	83 c4 08	 add	 esp, 8
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00065	83 c4 04	 add	 esp, 4
  00068	89 45 e8	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  0006b	83 7d e8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0006f	74 52		 je	 SHORT $LN1@Range_cons

; 527  :             _Buy_nonzero(_Count);

  00071	8b 55 e8	 mov	 edx, DWORD PTR __Count$[ebp]
  00074	52		 push	 edx
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00080	89 45 e0	 mov	 DWORD PTR __Guard$3[ebp], eax
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	89 4d d8	 mov	 DWORD PTR __My_data$2[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00090	8b 55 d8	 mov	 edx, DWORD PTR __My_data$2[ebp]
  00093	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00096	50		 push	 eax
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0009e	52		 push	 edx
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
  000a7	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 531  :             _Guard._Target   = nullptr;

  000ad	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8d 4d e0	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000be	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
$LN1@Range_cons:

; 533  :     }

  000c3	52		 push	 edx
  000c4	8b cd		 mov	 ecx, ebp
  000c6	50		 push	 eax
  000c7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Range_cons
  000cd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d2	58		 pop	 eax
  000d3	5a		 pop	 edx
  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	83 c4 28	 add	 esp, 40			; 00000028H
  000ec	3b ec		 cmp	 ebp, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
  000f9	0f 1f 00	 npad	 3
$LN8@Range_cons:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $LN7@Range_cons
$LN7@Range_cons:
  00104	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00108	04 00 00 00	 DD	 4
  0010c	00 00 00 00	 DD	 $LN5@Range_cons
$LN5@Range_cons:
  00110	5f		 DB	 95			; 0000005fH
  00111	47		 DB	 71			; 00000047H
  00112	75		 DB	 117			; 00000075H
  00113	61		 DB	 97			; 00000061H
  00114	72		 DB	 114			; 00000072H
  00115	64		 DB	 100			; 00000064H
  00116	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : _CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 999  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1000 :     using _Ty = typename _Alloc::value_type;
; 1001 :     _Ptr->~_Ty();
; 1002 :     _Deallocate_plain(_Al, _Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0001a	83 c4 08	 add	 esp, 8

; 1003 : }

  0001d	3b ec		 cmp	 ebp, esp
  0001f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z PROC		; std::_Voidify_iter<int *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ENDP		; std::_Voidify_iter<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HABHX@std@@YAPAHQAHABH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HABHX@std@@YAPAHQAHABH@Z PROC		; std::construct_at<int,int const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00015	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00018	50		 push	 eax
  00019	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  0001e	83 c4 04	 add	 esp, 4
  00021	50		 push	 eax
  00022	6a 04		 push	 4
  00024	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00029	83 c4 08	 add	 esp, 8
  0002c	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  0002f	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00032	51		 push	 ecx
  00033	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00038	83 c4 04	 add	 esp, 4
  0003b	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  0003e	8b 00		 mov	 eax, DWORD PTR [eax]
  00040	89 02		 mov	 DWORD PTR [edx], eax
  00042	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00045	83 c4 04	 add	 esp, 4
  00048	3b ec		 cmp	 ebp, esp
  0004a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004f	8b e5		 mov	 esp, ebp
  00051	5d		 pop	 ebp
  00052	c3		 ret	 0
??$construct_at@HABHX@std@@YAPAHQAHABH@Z ENDP		; std::construct_at<int,int const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00015	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  00021	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00024	51		 push	 ecx
  00025	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$construct_at@HABHX@std@@YAPAHQAHABH@Z ; std::construct_at<int,int const &,void>
  00037	83 c4 08	 add	 esp, 8

; 711  :         } else

  0003a	eb 2d		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003c	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00045	83 c4 04	 add	 esp, 4
  00048	50		 push	 eax
  00049	6a 04		 push	 4
  0004b	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00050	83 c4 08	 add	 esp, 8
  00053	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00056	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0005f	83 c4 04	 add	 esp, 4
  00062	8b 55 fc	 mov	 edx, DWORD PTR $T1[ebp]
  00065	8b 00		 mov	 eax, DWORD PTR [eax]
  00067	89 02		 mov	 DWORD PTR [edx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  00069	83 c4 04	 add	 esp, 4
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv74 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
_this$ = -4						; size = 4
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00024	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00027	50		 push	 eax
  00028	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0002d	83 c4 04	 add	 esp, 4
  00030	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0003f	83 c4 04	 add	 esp, 4
  00042	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0004b	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  0004e	8b 55 f8	 mov	 edx, DWORD PTR tv78[ebp]
  00051	52		 push	 edx
  00052	8b 45 f4	 mov	 eax, DWORD PTR tv76[ebp]
  00055	50		 push	 eax
  00056	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
  0005f	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  00062	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00065	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00068	83 c0 04	 add	 eax, 4
  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006e	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 1633 :     }

  00071	83 c4 10	 add	 esp, 16			; 00000010H
  00074	3b ec		 cmp	 ebp, esp
  00076	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00021	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 1638 :     }

  00029	83 c4 04	 add	 esp, 4
  0002c	3b ec		 cmp	 ebp, esp
  0002e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001e	51		 push	 ecx
  0001f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00022	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00025	50		 push	 eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	52		 push	 edx
  0002c	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00031	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00026	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  0002f	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  00032	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z
_TEXT	SEGMENT
__Count$ = -28						; size = 4
__Dest_ch$ = -24					; size = 4
__Last_ch$ = -20					; size = 4
__First_ch$ = -16					; size = 4
__DestPtr$ = -12					; size = 4
__LastPtr$ = -8						; size = 4
__FirstPtr$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z PROC	; std::_Copy_memmove<int const *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  0002a	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  0002d	50		 push	 eax
  0002e	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 fc	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  00039	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  0003c	51		 push	 ecx
  0003d	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00042	83 c4 04	 add	 esp, 4
  00045	89 45 f8	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  00048	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  0004b	52		 push	 edx
  0004c	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00051	83 c4 04	 add	 esp, 4
  00054	89 45 f4	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  00057	8b 45 fc	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  0005a	89 45 f0	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  0005d	8b 4d f8	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00060	89 4d ec	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00063	8b 55 f4	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  00066	89 55 e8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  00069	8b 45 ec	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  0006c	2b 45 f0	 sub	 eax, DWORD PTR __First_ch$[ebp]
  0006f	89 45 e4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00072	8b 4d e4	 mov	 ecx, DWORD PTR __Count$[ebp]
  00075	51		 push	 ecx
  00076	8b 55 f0	 mov	 edx, DWORD PTR __First_ch$[ebp]
  00079	52		 push	 edx
  0007a	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0007d	50		 push	 eax
  0007e	e8 00 00 00 00	 call	 _memmove
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  00086	8b 45 e8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00089	03 45 e4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  0008c	83 c4 1c	 add	 esp, 28			; 0000001cH
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c3		 ret	 0
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ENDP	; std::_Copy_memmove<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@H@std@@YAPAHQAH@Z PROC			; std::to_address<int>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$to_address@H@std@@YAPAHQAH@Z ENDP			; std::to_address<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@$$CBH@std@@YAPBHQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@$$CBH@std@@YAPBHQBH@Z PROC		; std::to_address<int const >, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$to_address@$$CBH@std@@YAPBHQBH@Z ENDP		; std::to_address<int const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z PROC		; std::_Get_unwrapped<int const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00010	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ENDP		; std::_Get_unwrapped<int const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
$T2 = -48						; size = 4
__Backout$ = -40					; size = 12
__ULast$ = -24						; size = 4
__UFirst$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int const *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 24	 sub	 esp, 36			; 00000024H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d0	 mov	 DWORD PTR [ebp-48], eax
  0001c	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001f	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  00022	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00025	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00028	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0002b	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002e	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00031	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00039	33 c5		 xor	 eax, ebp
  0003b	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0003e	50		 push	 eax
  0003f	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00042	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00048	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0004d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00052	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00055	50		 push	 eax
  00056	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  0005b	83 c4 04	 add	 esp, 4
  0005e	89 45 ec	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00061	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00064	51		 push	 ecx
  00065	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  0006a	83 c4 04	 add	 esp, 4
  0006d	89 45 e8	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  00070	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00075	0f b6 d0	 movzx	 edx, al
  00078	85 d2		 test	 edx, edx
  0007a	75 34		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  0007c	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0007f	50		 push	 eax
  00080	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  00085	83 c4 04	 add	 esp, 4
  00088	50		 push	 eax
  00089	8b 4d e8	 mov	 ecx, DWORD PTR __ULast$[ebp]
  0008c	51		 push	 ecx
  0008d	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00090	52		 push	 edx
  00091	e8 00 00 00 00	 call	 ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ; std::_Copy_memmove<int const *,int *>
  00096	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  00099	8b 45 e8	 mov	 eax, DWORD PTR __ULast$[ebp]
  0009c	2b 45 ec	 sub	 eax, DWORD PTR __UFirst$[ebp]
  0009f	c1 f8 02	 sar	 eax, 2
  000a2	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000a5	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000a8	89 55 10	 mov	 DWORD PTR __Dest$[ebp], edx

; 1665 :             return _Dest;

  000ab	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  000ae	eb 5f		 jmp	 SHORT $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000b0	6a 0c		 push	 12			; 0000000cH
  000b2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b5	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  000ba	8b 45 14	 mov	 eax, DWORD PTR __Al$[ebp]
  000bd	50		 push	 eax
  000be	8b 4d 10	 mov	 ecx, DWORD PTR __Dest$[ebp]
  000c1	51		 push	 ecx
  000c2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000c5	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  000d1	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000d3	8b 55 ec	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000d6	83 c2 04	 add	 edx, 4
  000d9	89 55 ec	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  000dc	8b 45 ec	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000df	3b 45 e8	 cmp	 eax, DWORD PTR __ULast$[ebp]
  000e2	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000e4	8b 4d ec	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000e7	51		 push	 ecx
  000e8	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000eb	e8 00 00 00 00	 call	 ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>

; 1672 :     }

  000f0	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000f2	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  000fa	89 45 d0	 mov	 DWORD PTR $T2[ebp], eax
  000fd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00104	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00107	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0010c	8b 45 d0	 mov	 eax, DWORD PTR $T2[ebp]
$LN1@Uninitiali:

; 1675 : }

  0010f	52		 push	 edx
  00110	8b cd		 mov	 ecx, ebp
  00112	50		 push	 eax
  00113	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@Uninitiali
  00119	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0011e	58		 pop	 eax
  0011f	5a		 pop	 edx
  00120	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00123	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0012a	59		 pop	 ecx
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0012e	33 cd		 xor	 ecx, ebp
  00130	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00135	83 c4 30	 add	 esp, 48			; 00000030H
  00138	3b ec		 cmp	 ebp, esp
  0013a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0013f	8b e5		 mov	 esp, ebp
  00141	5d		 pop	 ebp
  00142	c3		 ret	 0
  00143	90		 npad	 1
$LN11@Uninitiali:
  00144	01 00 00 00	 DD	 1
  00148	00 00 00 00	 DD	 $LN10@Uninitiali
$LN10@Uninitiali:
  0014c	d8 ff ff ff	 DD	 -40			; ffffffd8H
  00150	0c 00 00 00	 DD	 12			; 0000000cH
  00154	00 00 00 00	 DD	 $LN8@Uninitiali
$LN8@Uninitiali:
  00158	5f		 DB	 95			; 0000005fH
  00159	42		 DB	 66			; 00000042H
  0015a	61		 DB	 97			; 00000061H
  0015b	63		 DB	 99			; 00000063H
  0015c	6b		 DB	 107			; 0000006bH
  0015d	6f		 DB	 111			; 0000006fH
  0015e	75		 DB	 117			; 00000075H
  0015f	74		 DB	 116			; 00000074H
  00160	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d d8	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a d8	 mov	 ecx, DWORD PTR [edx-40]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int const *,std::allocator<int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 66   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 67   :     // return smaller of _Left and _Right
; 68   :     return _Right < _Left ? _Right : _Left;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00028	73 08		 jae	 SHORT $LN3@min
  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0002d	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00030	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00035	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  00038	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  0003b	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 69   : }

  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00020	50		 push	 eax
  00021	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 0a		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00025	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0002a	83 c4 04	 add	 esp, 4
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBH@std@@YAHPBH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBH@std@@YAHPBH0@Z PROC			; std::distance<int const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 02	 sar	 eax, 2

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$distance@PBH@std@@YAHPBH0@Z ENDP			; std::distance<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z PROC ; std::_Voidify_iter<std::_Container_proxy *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ENDP ; std::_Voidify_iter<std::_Container_proxy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
tv78 = -8						; size = 4
$T1 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00021	50		 push	 eax
  00022	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  00027	83 c4 04	 add	 esp, 4
  0002a	50		 push	 eax
  0002b	6a 08		 push	 8
  0002d	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00032	83 c4 08	 add	 esp, 8
  00035	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00038	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00041	83 c4 04	 add	 esp, 4
  00044	8b 10		 mov	 edx, DWORD PTR [eax]
  00046	89 55 f8	 mov	 DWORD PTR tv78[ebp], edx
  00049	8b 45 f8	 mov	 eax, DWORD PTR tv78[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 145  : }

  00055	83 c4 08	 add	 esp, 8
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__My_data$2 = -40					; size = 4
__Guard$3 = -32						; size = 4
__Count$ = -24						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001c	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001f	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00022	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00025	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00028	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  0004f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00052	50		 push	 eax
  00053	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$distance@PBH@std@@YAHPBH0@Z ; std::distance<int const *>
  0005c	83 c4 08	 add	 esp, 8
  0005f	50		 push	 eax
  00060	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00065	83 c4 04	 add	 esp, 4
  00068	89 45 e8	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  0006b	83 7d e8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0006f	74 52		 je	 SHORT $LN1@Range_cons

; 527  :             _Buy_nonzero(_Count);

  00071	8b 55 e8	 mov	 edx, DWORD PTR __Count$[ebp]
  00074	52		 push	 edx
  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  0007d	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00080	89 45 e0	 mov	 DWORD PTR __Guard$3[ebp], eax
  00083	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	89 4d d8	 mov	 DWORD PTR __My_data$2[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00090	8b 55 d8	 mov	 edx, DWORD PTR __My_data$2[ebp]
  00093	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00096	50		 push	 eax
  00097	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0009a	51		 push	 ecx
  0009b	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0009e	52		 push	 edx
  0009f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000a2	e8 00 00 00 00	 call	 ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
  000a7	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$2[ebp]
  000aa	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 531  :             _Guard._Target   = nullptr;

  000ad	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8d 4d e0	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000be	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
$LN1@Range_cons:

; 533  :     }

  000c3	52		 push	 edx
  000c4	8b cd		 mov	 ecx, ebp
  000c6	50		 push	 eax
  000c7	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@Range_cons
  000cd	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000d2	58		 pop	 eax
  000d3	5a		 pop	 edx
  000d4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000de	59		 pop	 ecx
  000df	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000e2	33 cd		 xor	 ecx, ebp
  000e4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e9	83 c4 28	 add	 esp, 40			; 00000028H
  000ec	3b ec		 cmp	 ebp, esp
  000ee	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f3	8b e5		 mov	 esp, ebp
  000f5	5d		 pop	 ebp
  000f6	c2 0c 00	 ret	 12			; 0000000cH
  000f9	0f 1f 00	 npad	 3
$LN8@Range_cons:
  000fc	01 00 00 00	 DD	 1
  00100	00 00 00 00	 DD	 $LN7@Range_cons
$LN7@Range_cons:
  00104	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00108	04 00 00 00	 DD	 4
  0010c	00 00 00 00	 DD	 $LN5@Range_cons
$LN5@Range_cons:
  00110	5f		 DB	 95			; 0000005fH
  00111	47		 DB	 71			; 00000047H
  00112	75		 DB	 117			; 00000075H
  00113	61		 DB	 97			; 00000061H
  00114	72		 DB	 114			; 00000072H
  00115	64		 DB	 100			; 00000064H
  00116	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0:
  00000	8d 4d e0	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1353 :     _CONSTEXPR20_CONTAINER ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1354 :         if (_Ptr) {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 38 00	 cmp	 DWORD PTR [eax], 0
  0001e	74 15		 je	 SHORT $LN3@Container_

; 1355 :             _Delete_plain_internal(_Al, _Ptr);

  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	8b 11		 mov	 edx, DWORD PTR [ecx]
  00025	52		 push	 edx
  00026	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00029	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00032	83 c4 08	 add	 esp, 8
$LN3@Container_:

; 1356 :         }
; 1357 :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1339 :     _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  0002f	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 1340 :         // create a new _Container_proxy pointing at _Mycont
; 1341 :         _Ptr = _Unfancy(_Al_.allocate(1));

  00032	6a 01		 push	 1
  00034	8b 4d 08	 mov	 ecx, DWORD PTR __Al_$[ebp]
  00037	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00042	83 c4 04	 add	 esp, 4
  00045	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00048	89 02		 mov	 DWORD PTR [edx], eax

; 1342 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  0004a	8b 45 0c	 mov	 eax, DWORD PTR __Mycont$[ebp]
  0004d	50		 push	 eax
  0004e	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00053	83 c4 04	 add	 esp, 4
  00056	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00059	8d 4d f8	 lea	 ecx, DWORD PTR $T1[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00060	8b 02		 mov	 eax, DWORD PTR [edx]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00068	83 c4 08	 add	 esp, 8

; 1343 :         _Mycont._Myproxy = _Ptr;

  0006b	8b 4d 0c	 mov	 ecx, DWORD PTR __Mycont$[ebp]
  0006e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00071	8b 02		 mov	 eax, DWORD PTR [edx]
  00073	89 01		 mov	 DWORD PTR [ecx], eax

; 1344 :     }

  00075	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c4 08	 add	 esp, 8
  0007b	3b ec		 cmp	 ebp, esp
  0007d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00018	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0002a	83 c4 04	 add	 esp, 4

; 840  :     }

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	c1 e0 03	 shl	 eax, 3
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	83 c4 08	 add	 esp, 8

; 836  :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
  00021	83 c4 04	 add	 esp, 4
  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 08 00	 ret	 8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 44   :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00026	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00034	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c4 04	 add	 esp, 4
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1823 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1819 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
tv86 = -44						; size = 4
tv88 = -40						; size = 4
tv90 = -36						; size = 4
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001c	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001f	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00022	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00025	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00028	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00055	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00058	83 c1 04	 add	 ecx, 4
  0005b	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  0005e	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  00061	83 c2 08	 add	 edx, 8
  00064	89 55 e4	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  00067	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0006d	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00070	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00078	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0007b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0007e	74 62		 je	 SHORT $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  00080	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00089	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008b	52		 push	 edx
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00094	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0009c	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  0009f	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a5	8b 10		 mov	 edx, DWORD PTR [eax]
  000a7	2b 11		 sub	 edx, DWORD PTR [ecx]
  000a9	c1 fa 04	 sar	 edx, 4
  000ac	89 55 d8	 mov	 DWORD PTR tv88[ebp], edx
  000af	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d d4	 mov	 DWORD PTR tv86[ebp], ecx
  000b7	8b 55 d8	 mov	 edx, DWORD PTR tv88[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR tv86[ebp]
  000be	50		 push	 eax
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR tv90[ebp]
  000c2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  000c7	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ca	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  000d0	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000d3	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  000d9	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000dc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	83 c4 2c	 add	 esp, 44			; 0000002cH
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
  000fb	cc		 int	 3
  000fc	cc		 int	 3
  000fd	cc		 int	 3
  000fe	cc		 int	 3
  000ff	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00020	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  00023	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  00025	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
__Newvec$ = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	83 c1 04	 add	 ecx, 4
  00039	89 4d f4	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  0003c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0003f	83 c2 08	 add	 edx, 8
  00042	89 55 f0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004b	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00056	89 45 e4	 mov	 DWORD PTR tv77[ebp], eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 4d e4	 mov	 ecx, DWORD PTR tv77[ebp]
  00060	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
  00065	89 45 e8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  00068	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0006b	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0006e	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  00070	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00073	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00076	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  00078	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007b	c1 e0 04	 shl	 eax, 4
  0007e	03 45 e8	 add	 eax, DWORD PTR __Newvec$[ebp]
  00081	8b 4d ec	 mov	 ecx, DWORD PTR __Myend$[ebp]
  00084	89 01		 mov	 DWORD PTR [ecx], eax

; 1715 :     }

  00086	83 c4 1c	 add	 esp, 28			; 0000001cH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00020	50		 push	 eax
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  00031	83 c4 04	 add	 esp, 4
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0003c	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00041	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00044	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00051	83 c4 08	 add	 esp, 8
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_$S10$ = -17						; size = 1
__Alproxy$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00047	50		 push	 eax
  00048	8d 4d ef	 lea	 ecx, DWORD PTR _$S10$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  00050	8d 45 ef	 lea	 eax, DWORD PTR _$S10$[ebp]
  00053	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  00056	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0005d	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00060	51		 push	 ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0006a	83 c4 08	 add	 esp, 8
  0006d	50		 push	 eax
  0006e	8b 45 f4	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00077	83 c4 08	 add	 esp, 8

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@vector
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	83 c4 1c	 add	 esp, 28			; 0000001cH
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
  000a3	90		 npad	 1
$LN5@vector:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN4@vector
$LN4@vector:
  000ac	ef ff ff ff	 DD	 -17			; ffffffefH
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN3@vector
$LN3@vector:
  000b8	24		 DB	 36			; 00000024H
  000b9	53		 DB	 83			; 00000053H
  000ba	31		 DB	 49			; 00000031H
  000bb	30		 DB	 48			; 00000030H
  000bc	00		 DB	 0
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv133 = -72						; size = 4
tv135 = -68						; size = 4
tv70 = -64						; size = 4
$T2 = -57						; size = 1
$T3 = -56						; size = 1
$T4 = -55						; size = 1
$T5 = -54						; size = 1
$T6 = -53						; size = 1
__Proxy$ = -48						; size = 8
_$S8$ = -29						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d b8	 lea	 edi, DWORD PTR [ebp-72]
  00019	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	89 45 c0	 mov	 DWORD PTR tv70[ebp], eax
  0004d	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00050	51		 push	 ecx
  00051	0f b6 55 cb	 movzx	 edx, BYTE PTR $T6[ebp]
  00055	52		 push	 edx
  00056	8b 4d c0	 mov	 ecx, DWORD PTR tv70[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00066	50		 push	 eax
  00067	8d 4d e3	 lea	 ecx, DWORD PTR _$S8$[ebp]
  0006a	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  0006f	8d 45 e3	 lea	 eax, DWORD PTR _$S8$[ebp]
  00072	89 45 e8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0007c	52		 push	 edx
  0007d	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00080	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0008c	33 c0		 xor	 eax, eax
  0008e	88 45 ca	 mov	 BYTE PTR $T5[ebp], al
  00091	8a 4d c9	 mov	 cl, BYTE PTR $T4[ebp]
  00094	88 4d c8	 mov	 BYTE PTR $T3[ebp], cl
  00097	8a 55 c8	 mov	 dl, BYTE PTR $T3[ebp]
  0009a	88 55 c7	 mov	 BYTE PTR $T2[ebp], dl
  0009d	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  000a0	e8 00 00 00 00	 call	 ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
  000a5	89 45 bc	 mov	 DWORD PTR tv135[ebp], eax
  000a8	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  000ab	e8 00 00 00 00	 call	 ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
  000b0	89 45 b8	 mov	 DWORD PTR tv133[ebp], eax
  000b3	0f b6 45 c7	 movzx	 eax, BYTE PTR $T2[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 b8	 mov	 edx, DWORD PTR tv133[ebp]
  000bf	52		 push	 edx
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>

; 551  :         _Proxy._Release();

  000c8	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000cb	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  000d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d7	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000da	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000df	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	52		 push	 edx
  000e3	8b cd		 mov	 ecx, ebp
  000e5	50		 push	 eax
  000e6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@vector
  000ec	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f1	58		 pop	 eax
  000f2	5a		 pop	 edx
  000f3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fd	59		 pop	 ecx
  000fe	5f		 pop	 edi
  000ff	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	83 c4 48	 add	 esp, 72			; 00000048H
  0010c	3b ec		 cmp	 ebp, esp
  0010e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 0c 00	 ret	 12			; 0000000cH
  00119	0f 1f 00	 npad	 3
$LN8@vector:
  0011c	02 00 00 00	 DD	 2
  00120	00 00 00 00	 DD	 $LN7@vector
$LN7@vector:
  00124	e3 ff ff ff	 DD	 -29			; ffffffe3H
  00128	01 00 00 00	 DD	 1
  0012c	00 00 00 00	 DD	 $LN4@vector
  00130	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00134	08 00 00 00	 DD	 8
  00138	00 00 00 00	 DD	 $LN5@vector
$LN5@vector:
  0013c	5f		 DB	 95			; 0000005fH
  0013d	50		 DB	 80			; 00000050H
  0013e	72		 DB	 114			; 00000072H
  0013f	6f		 DB	 111			; 0000006fH
  00140	78		 DB	 120			; 00000078H
  00141	79		 DB	 121			; 00000079H
  00142	00		 DB	 0
$LN4@vector:
  00143	24		 DB	 36			; 00000024H
  00144	53		 DB	 83			; 00000053H
  00145	38		 DB	 56			; 00000038H
  00146	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 729  :     }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00018	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YAII@Z ; std::_Get_size_of_n<16>
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0002a	83 c4 04	 add	 esp, 4

; 840  :     }

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	c1 e0 04	 shl	 eax, 4
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	83 c4 08	 add	 esp, 8

; 836  :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00033	c1 f8 02	 sar	 eax, 2
  00036	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  00039	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  0003b	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  00040	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00046	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00049	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
$LN3@at:

; 1589 :     }

  0004c	83 c4 08	 add	 esp, 8
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.h
;	COMDAT ?getSize@Player@@QAE?AV?$Vector2@I@sf@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getSize@Player@@QAE?AV?$Vector2@I@sf@@XZ PROC		; Player::getSize, COMDAT
; _this$ = ecx

; 28   : 	inline sf::Vector2u getSize() { return _size; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __5808F286_Player@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0001e	8b 50 24	 mov	 edx, DWORD PTR [eax+36]
  00021	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  00024	89 08		 mov	 DWORD PTR [eax], ecx
  00026	89 50 04	 mov	 DWORD PTR [eax+4], edx
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 04 00	 ret	 4
?getSize@Player@@QAE?AV?$Vector2@I@sf@@XZ ENDP		; Player::getSize
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.h
;	COMDAT ?setMaxX@Player@@QAEXH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_x$ = 8							; size = 4
?setMaxX@Player@@QAEXH@Z PROC				; Player::setMaxX, COMDAT
; _this$ = ecx

; 27   : 	inline void setMaxX(int x) { _maxX = x; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __5808F286_Player@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  0001e	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c2 04 00	 ret	 4
?setMaxX@Player@@QAEXH@Z ENDP				; Player::setMaxX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.h
;	COMDAT ?getY@Player@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getY@Player@@QAEHXZ PROC				; Player::getY, COMDAT
; _this$ = ecx

; 26   : 	inline int getY() { return _y; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __5808F286_Player@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]
  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?getY@Player@@QAEHXZ ENDP				; Player::getY
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.h
;	COMDAT ?getX@Player@@QAEHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?getX@Player@@QAEHXZ PROC				; Player::getX, COMDAT
; _this$ = ecx

; 25   : 	inline int getX() { return _x; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __5808F286_Player@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]
  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?getX@Player@@QAEHXZ ENDP				; Player::getX
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.h
;	COMDAT ?getRect@Player@@QAE?AV?$Rect@H@sf@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getRect@Player@@QAE?AV?$Rect@H@sf@@XZ PROC		; Player::getRect, COMDAT
; _this$ = ecx

; 24   : 	inline sf::IntRect getRect() { return *_rect; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __5808F286_Player@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001e	8b 55 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebp]
  00021	8b 01		 mov	 eax, DWORD PTR [ecx]
  00023	89 02		 mov	 DWORD PTR [edx], eax
  00025	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00028	89 42 04	 mov	 DWORD PTR [edx+4], eax
  0002b	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  0002e	89 42 08	 mov	 DWORD PTR [edx+8], eax
  00031	8b 49 0c	 mov	 ecx, DWORD PTR [ecx+12]
  00034	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx
  00037	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?getRect@Player@@QAE?AV?$Rect@H@sf@@XZ ENDP		; Player::getRect
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.h
;	COMDAT ?show@Player@@QAEXPAVRenderWindow@sf@@@Z
_TEXT	SEGMENT
tv83 = -20						; size = 4
tv79 = -16						; size = 4
tv85 = -12						; size = 4
tv87 = -8						; size = 4
_this$ = -4						; size = 4
_rw$ = 8						; size = 4
?show@Player@@QAEXPAVRenderWindow@sf@@@Z PROC		; Player::show, COMDAT
; _this$ = ecx

; 22   : 	inline void show(sf::RenderWindow* rw) {rw->draw(*_sprite->at(_place));};	

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __5808F286_Player@h
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 08	 mov	 eax, DWORD PTR _rw$[ebp]
  0002b	83 c0 30	 add	 eax, 48			; 00000030H
  0002e	89 45 f8	 mov	 DWORD PTR tv87[ebp], eax
  00031	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?Default@RenderStates@sf@@2V12@B
  00037	89 4d f4	 mov	 DWORD PTR tv85[ebp], ecx
  0003a	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003d	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00040	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00049	52		 push	 edx
  0004a	8b 4d f0	 mov	 ecx, DWORD PTR tv79[ebp]
  0004d	e8 00 00 00 00	 call	 ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
  00052	8b 00		 mov	 eax, DWORD PTR [eax]
  00054	89 45 ec	 mov	 DWORD PTR tv83[ebp], eax
  00057	8b f4		 mov	 esi, esp
  00059	8b 4d f4	 mov	 ecx, DWORD PTR tv85[ebp]
  0005c	51		 push	 ecx
  0005d	8b 55 ec	 mov	 edx, DWORD PTR tv83[ebp]
  00060	52		 push	 edx
  00061	8b 4d f8	 mov	 ecx, DWORD PTR tv87[ebp]
  00064	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?draw@RenderTarget@sf@@QAEXABVDrawable@2@ABVRenderStates@2@@Z
  0006a	3b f4		 cmp	 esi, esp
  0006c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00071	5e		 pop	 esi
  00072	83 c4 14	 add	 esp, 20			; 00000014H
  00075	3b ec		 cmp	 ebp, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c2 04 00	 ret	 4
?show@Player@@QAEXPAVRenderWindow@sf@@@Z ENDP		; Player::show
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_GSprite@sf@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSprite@sf@@UAEPAXI@Z PROC				; sf::Sprite::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	56		 push	 esi
  00005	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000f	8b f4		 mov	 esi, esp
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1Sprite@sf@@UAE@XZ
  0001a	3b f4		 cmp	 esi, esp
  0001c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00021	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00024	83 e0 01	 and	 eax, 1
  00027	74 11		 je	 SHORT $LN2@scalar
  00029	68 10 01 00 00	 push	 272			; 00000110H
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00037	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0003a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003d	5e		 pop	 esi
  0003e	83 c4 04	 add	 esp, 4
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
??_GSprite@sf@@UAEPAXI@Z ENDP				; sf::Sprite::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Graphics\Rect.inl
;	COMDAT ??0?$Rect@M@sf@@QAE@MMMM@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_rectLeft$ = 8						; size = 4
_rectTop$ = 12						; size = 4
_rectWidth$ = 16					; size = 4
_rectHeight$ = 20					; size = 4
??0?$Rect@M@sf@@QAE@MMMM@Z PROC				; sf::Rect<float>::Rect<float>, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C23CD225_Rect@inl
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 41   : left  (rectLeft),

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	f3 0f 10 45 08	 movss	 xmm0, DWORD PTR _rectLeft$[ebp]
  00020	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 42   : top   (rectTop),

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	f3 0f 10 45 0c	 movss	 xmm0, DWORD PTR _rectTop$[ebp]
  0002c	f3 0f 11 41 04	 movss	 DWORD PTR [ecx+4], xmm0

; 43   : width (rectWidth),

  00031	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00034	f3 0f 10 45 10	 movss	 xmm0, DWORD PTR _rectWidth$[ebp]
  00039	f3 0f 11 42 08	 movss	 DWORD PTR [edx+8], xmm0

; 44   : height(rectHeight)

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	f3 0f 10 45 14	 movss	 xmm0, DWORD PTR _rectHeight$[ebp]
  00046	f3 0f 11 40 0c	 movss	 DWORD PTR [eax+12], xmm0

; 46   : 
; 47   : }

  0004b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0004e	83 c4 04	 add	 esp, 4
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 10 00	 ret	 16			; 00000010H
??0?$Rect@M@sf@@QAE@MMMM@Z ENDP				; sf::Rect<float>::Rect<float>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z PROC ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00033	c1 f8 02	 sar	 eax, 2
  00036	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  00039	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  0003b	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  00040	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00046	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00049	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
$LN3@at:

; 1589 :     }

  0004c	83 c4 08	 add	 esp, 8
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ENDP ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ PROC ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size, COMDAT
; _this$ = ecx

; 1547 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1548 :         auto& _My_data = _Mypair._Myval2;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00033	c1 f8 02	 sar	 eax, 2

; 1550 :     }

  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ENDP ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00033	c1 f8 02	 sar	 eax, 2
  00036	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  00039	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  0003b	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  00040	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00043	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00046	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  00049	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
$LN3@at:

; 1589 :     }

  0004c	83 c4 08	 add	 esp, 8
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c2 04 00	 ret	 4
?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\RessourcePack.h
;	COMDAT ?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z
_TEXT	SEGMENT
tv85 = -20						; size = 4
tv86 = -16						; size = 4
tv77 = -12						; size = 4
tv79 = -8						; size = 4
_this$ = -4						; size = 4
_lvl$ = 8						; size = 4
?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z PROC	; RessourcePack::getLevelMusic, COMDAT
; _this$ = ecx

; 46   : 	{ return (lvl >= musicList->size()) ? musicList->at(musicList->size() - 1) : musicList->at(lvl); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET __28BBFA9C_RessourcePack@h
  00022	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	e8 00 00 00 00	 call	 ?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
  00032	39 45 08	 cmp	 DWORD PTR _lvl$[ebp], eax
  00035	72 2d		 jb	 SHORT $LN3@getLevelMu
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0003d	89 55 f8	 mov	 DWORD PTR tv79[ebp], edx
  00040	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00043	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00046	e8 00 00 00 00	 call	 ?size@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Music *,std::allocator<sf::Music *> >::size
  0004b	83 e8 01	 sub	 eax, 1
  0004e	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  00051	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  00054	51		 push	 ecx
  00055	8b 4d f8	 mov	 ecx, DWORD PTR tv79[ebp]
  00058	e8 00 00 00 00	 call	 ?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
  0005d	8b 10		 mov	 edx, DWORD PTR [eax]
  0005f	89 55 f0	 mov	 DWORD PTR tv86[ebp], edx
  00062	eb 1a		 jmp	 SHORT $LN4@getLevelMu
$LN3@getLevelMu:
  00064	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0006a	89 4d ec	 mov	 DWORD PTR tv85[ebp], ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _lvl$[ebp]
  00070	52		 push	 edx
  00071	8b 4d ec	 mov	 ecx, DWORD PTR tv85[ebp]
  00074	e8 00 00 00 00	 call	 ?at@?$vector@PAVMusic@sf@@V?$allocator@PAVMusic@sf@@@std@@@std@@QAEAAPAVMusic@sf@@I@Z ; std::vector<sf::Music *,std::allocator<sf::Music *> >::at
  00079	8b 00		 mov	 eax, DWORD PTR [eax]
  0007b	89 45 f0	 mov	 DWORD PTR tv86[ebp], eax
$LN4@getLevelMu:
  0007e	8b 45 f0	 mov	 eax, DWORD PTR tv86[ebp]
  00081	83 c4 14	 add	 esp, 20			; 00000014H
  00084	3b ec		 cmp	 ebp, esp
  00086	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008b	8b e5		 mov	 esp, ebp
  0008d	5d		 pop	 ebp
  0008e	c2 04 00	 ret	 4
?getLevelMusic@RessourcePack@@QAEPAVMusic@sf@@H@Z ENDP	; RessourcePack::getLevelMusic
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\RessourcePack.h
;	COMDAT ?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
_n$ = 8							; size = 4
?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z PROC ; RessourcePack::getImgBackground, COMDAT
; _this$ = ecx

; 43   : 	inline sf::Image* getImgBackground(int n) { return backgroundImages->at(n - 1); };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __28BBFA9C_RessourcePack@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00027	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  0002a	8b 55 08	 mov	 edx, DWORD PTR _n$[ebp]
  0002d	83 ea 01	 sub	 edx, 1
  00030	52		 push	 edx
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv70[ebp]
  00034	e8 00 00 00 00	 call	 ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
  00039	8b 00		 mov	 eax, DWORD PTR [eax]
  0003b	83 c4 08	 add	 esp, 8
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?getImgBackground@RessourcePack@@QAEPAVImage@sf@@H@Z ENDP ; RessourcePack::getImgBackground
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20_CONTAINER _Vbase _Mask() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2099 :         return static_cast<_Vbase>(1) << this->_Myoff;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	ba 01 00 00 00	 mov	 edx, 1
  00020	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00023	d3 e2		 shl	 edx, cl
  00025	8b c2		 mov	 eax, edx

; 2100 :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
__Cont$ = -8						; size = 4
_this$ = -4						; size = 4
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr, COMDAT
; _this$ = ecx

; 2080 :     _CONSTEXPR20_CONTAINER const _Vbase* _Getptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2081 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2082 :         const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());

  00022	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002a	89 45 f8	 mov	 DWORD PTR __Cont$[ebp], eax
$LN4@Getptr:

; 2083 :         _STL_VERIFY(_Cont, "cannot dereference value-initialized vector<bool> iterator");

  0002d	83 7d f8 00	 cmp	 DWORD PTR __Cont$[ebp], 0
  00031	74 02		 je	 SHORT $LN7@Getptr
  00033	eb 5c		 jmp	 SHORT $LN2@Getptr
$LN7@Getptr:
  00035	8b f4		 mov	 esi, esp
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00041	6a 00		 push	 0
  00043	68 23 08 00 00	 push	 2083			; 00000823H
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0004d	6a 02		 push	 2
  0004f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00055	83 c4 18	 add	 esp, 24			; 00000018H
  00058	3b f4		 cmp	 esi, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	83 f8 01	 cmp	 eax, 1
  00062	75 01		 jne	 SHORT $LN19@Getptr
  00064	cc		 int	 3
$LN19@Getptr:
  00065	8b f4		 mov	 esi, esp
  00067	6a 00		 push	 0
  00069	68 23 08 00 00	 push	 2083			; 00000823H
  0006e	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00073	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00083	83 c4 14	 add	 esp, 20			; 00000014H
  00086	3b f4		 cmp	 esi, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	33 c9		 xor	 ecx, ecx
  0008f	75 a4		 jne	 SHORT $LN7@Getptr
$LN2@Getptr:
  00091	33 d2		 xor	 edx, edx
  00093	75 98		 jne	 SHORT $LN4@Getptr
$LN10@Getptr:

; 2084 :         _STL_VERIFY(this->_Total_off(_Cont) <= static_cast<_Difference_type>(_Cont->_Mysize),

  00095	8b 45 f8	 mov	 eax, DWORD PTR __Cont$[ebp]
  00098	50		 push	 eax
  00099	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0009c	e8 00 00 00 00	 call	 ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
  000a1	8b 4d f8	 mov	 ecx, DWORD PTR __Cont$[ebp]
  000a4	3b 41 14	 cmp	 eax, DWORD PTR [ecx+20]
  000a7	7f 02		 jg	 SHORT $LN13@Getptr
  000a9	eb 5c		 jmp	 SHORT $LN8@Getptr
$LN13@Getptr:
  000ab	8b f4		 mov	 esi, esp
  000ad	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
  000b2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000b7	6a 00		 push	 0
  000b9	68 25 08 00 00	 push	 2085			; 00000825H
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000c3	6a 02		 push	 2
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000cb	83 c4 18	 add	 esp, 24			; 00000018H
  000ce	3b f4		 cmp	 esi, esp
  000d0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d5	83 f8 01	 cmp	 eax, 1
  000d8	75 01		 jne	 SHORT $LN20@Getptr
  000da	cc		 int	 3
$LN20@Getptr:
  000db	8b f4		 mov	 esi, esp
  000dd	6a 00		 push	 0
  000df	68 25 08 00 00	 push	 2085			; 00000825H
  000e4	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000e9	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  000ee	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
  000f3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000f9	83 c4 14	 add	 esp, 20			; 00000014H
  000fc	3b f4		 cmp	 esi, esp
  000fe	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00103	33 c0		 xor	 eax, eax
  00105	75 a4		 jne	 SHORT $LN13@Getptr
$LN8@Getptr:
  00107	33 c9		 xor	 ecx, ecx
  00109	75 8a		 jne	 SHORT $LN10@Getptr

; 2085 :             "vector<bool> iterator not dereferenceable");
; 2086 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2087 : 
; 2088 :         return this->_Myptr;

  0010b	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0010e	8b 42 08	 mov	 eax, DWORD PTR [edx+8]

; 2089 :     }

  00111	5e		 pop	 esi
  00112	83 c4 08	 add	 esp, 8
  00115	3b ec		 cmp	 ebp, esp
  00117	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011c	8b e5		 mov	 esp, ebp
  0011e	5d		 pop	 ebp
  0011f	c3		 ret	 0
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z
_TEXT	SEGMENT
tv83 = -28						; size = 4
tv81 = -24						; size = 4
tv85 = -20						; size = 4
tv72 = -16						; size = 4
tv70 = -12						; size = 4
tv74 = -8						; size = 4
_this$ = -4						; size = 4
__Val$ = 8						; size = 1
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=, COMDAT
; _this$ = ecx

; 2062 :     _CONSTEXPR20_CONTAINER _Vb_reference& operator=(bool _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2063 :         if (_Val) {

  0002d	0f b6 45 08	 movzx	 eax, BYTE PTR __Val$[ebp]
  00031	85 c0		 test	 eax, eax
  00033	74 2b		 je	 SHORT $LN2@operator

; 2064 :             *const_cast<_Vbase*>(_Getptr()) |= _Mask();

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  0003d	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  00048	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  0004b	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  0004e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00050	89 55 f0	 mov	 DWORD PTR tv72[ebp], edx
  00053	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  00056	0b 45 f8	 or	 eax, DWORD PTR tv74[ebp]
  00059	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  0005c	89 01		 mov	 DWORD PTR [ecx], eax

; 2065 :         } else {

  0005e	eb 2b		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 2066 :             *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();

  00060	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00063	e8 00 00 00 00	 call	 ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  00068	f7 d0		 not	 eax
  0006a	89 45 ec	 mov	 DWORD PTR tv85[ebp], eax
  0006d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  00075	89 45 e8	 mov	 DWORD PTR tv81[ebp], eax
  00078	8b 55 e8	 mov	 edx, DWORD PTR tv81[ebp]
  0007b	8b 02		 mov	 eax, DWORD PTR [edx]
  0007d	89 45 e4	 mov	 DWORD PTR tv83[ebp], eax
  00080	8b 4d e4	 mov	 ecx, DWORD PTR tv83[ebp]
  00083	23 4d ec	 and	 ecx, DWORD PTR tv85[ebp]
  00086	8b 55 e8	 mov	 edx, DWORD PTR tv81[ebp]
  00089	89 0a		 mov	 DWORD PTR [edx], ecx
$LN3@operator:

; 2067 :         }
; 2068 : 
; 2069 :         return *this;

  0008b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 2070 :     }

  0008e	83 c4 1c	 add	 esp, 28			; 0000001cH
  00091	3b ec		 cmp	 ebp, esp
  00093	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 04 00	 ret	 4
??4?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEAAV01@_N@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv82 = -16						; size = 4
tv86 = -12						; size = 4
tv84 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2055 :     _CONSTEXPR20_CONTAINER _Vb_reference(const _Mybase& _Right) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2056 :         : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0002c	89 45 f8	 mov	 DWORD PTR tv84[ebp], eax
  0002f	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00032	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00035	89 4d f4	 mov	 DWORD PTR tv86[ebp], ecx
  00038	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0003b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003e	89 45 f0	 mov	 DWORD PTR tv82[ebp], eax
  00041	8b 4d f8	 mov	 ecx, DWORD PTR tv84[ebp]
  00044	51		 push	 ecx
  00045	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00048	52		 push	 edx
  00049	8b 45 f0	 mov	 eax, DWORD PTR tv82[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00055	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00058	83 c4 10	 add	 esp, 16			; 00000010H
  0005b	3b ec		 cmp	 ebp, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c2 04 00	 ret	 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Cont$ = 8						; size = 4
?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off, COMDAT
; _this$ = ecx

; 2032 :     _CONSTEXPR20_CONTAINER _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2033 :         return static_cast<_Difference_type>(_VBITS * (_Myptr - _Cont->_Myvec.data()) + _Myoff);

  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	e8 00 00 00 00	 call	 ?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
  00023	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00029	2b d0		 sub	 edx, eax
  0002b	c1 fa 02	 sar	 edx, 2
  0002e	c1 e2 05	 shl	 edx, 5
  00031	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00034	03 50 0c	 add	 edx, DWORD PTR [eax+12]
  00037	8b c2		 mov	 eax, edx

; 2034 :     }

  00039	83 c4 04	 add	 esp, 4
  0003c	3b ec		 cmp	 ebp, esp
  0003e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00043	8b e5		 mov	 esp, ebp
  00045	5d		 pop	 ebp
  00046	c2 04 00	 ret	 4
?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance, COMDAT
; _this$ = ecx

; 2025 :     _CONSTEXPR20_CONTAINER void _Advance(_Size_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2026 :         _Myoff += _Off;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0001e	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  00021	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00024	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 2027 :         _Myptr += _Myoff / _VBITS;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0002d	c1 e9 05	 shr	 ecx, 5
  00030	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00033	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00036	8d 0c 88	 lea	 ecx, DWORD PTR [eax+ecx*4]
  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 2028 :         _Myoff %= _VBITS;

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	8b 40 0c	 mov	 eax, DWORD PTR [eax+12]
  00045	33 d2		 xor	 edx, edx
  00047	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004c	f7 f1		 div	 ecx
  0004e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00051	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 2029 :     }

  00054	83 c4 04	 add	 esp, 4
  00057	3b ec		 cmp	 ebp, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	8b e5		 mov	 esp, ebp
  00060	5d		 pop	 ebp
  00061	c2 04 00	 ret	 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Mypvbool$ = 16					; size = 4
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2018 :         : _Myptr(_Ptr), _Myoff(_Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00026	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  00029	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0002c	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  0002f	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 2019 :         this->_Adopt(_Mypvbool);

  00032	8b 4d 10	 mov	 ecx, DWORD PTR __Mypvbool$[ebp]
  00035	51		 push	 ecx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 2020 :     }

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c4 04	 add	 esp, 4
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 0c 00	 ret	 12			; 0000000cH
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?end@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 04	 mov	 eax, DWORD PTR [eax+4]

; 44   :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?end@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?begin@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  0001d	83 c4 04	 add	 esp, 4
  00020	3b ec		 cmp	 ebp, esp
  00022	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00027	8b e5		 mov	 esp, ebp
  00029	5d		 pop	 ebp
  0002a	c3		 ret	 0
?begin@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@H@std@@QAE@PBH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@H@std@@QAE@PBH0@Z PROC		; std::initializer_list<int>::initializer_list<int>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx
  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00026	89 42 04	 mov	 DWORD PTR [edx+4], eax
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 c4 04	 add	 esp, 4
  0002f	3b ec		 cmp	 ebp, esp
  00031	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c2 08 00	 ret	 8
??0?$initializer_list@H@std@@QAE@PBH0@Z ENDP		; std::initializer_list<int>::initializer_list<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 10		 push	 16			; 00000010H
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00034	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c4 04	 add	 esp, 4
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1823 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1819 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv86 = -44						; size = 4
tv88 = -40						; size = 4
tv90 = -36						; size = 4
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001c	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001f	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00022	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00025	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00028	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00055	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00058	83 c1 04	 add	 ecx, 4
  0005b	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  0005e	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  00061	83 c2 08	 add	 edx, 8
  00064	89 55 e4	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  00067	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0006d	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00070	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00078	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0007b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0007e	74 62		 je	 SHORT $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  00080	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00089	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008b	52		 push	 edx
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00094	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0009c	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  0009f	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a5	8b 10		 mov	 edx, DWORD PTR [eax]
  000a7	2b 11		 sub	 edx, DWORD PTR [ecx]
  000a9	c1 fa 02	 sar	 edx, 2
  000ac	89 55 d8	 mov	 DWORD PTR tv88[ebp], edx
  000af	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d d4	 mov	 DWORD PTR tv86[ebp], ecx
  000b7	8b 55 d8	 mov	 edx, DWORD PTR tv88[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR tv86[ebp]
  000be	50		 push	 eax
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR tv90[ebp]
  000c2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  000c7	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ca	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  000d0	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000d3	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  000d9	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000dc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	83 c4 2c	 add	 esp, 44			; 0000002cH
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
  000fb	cc		 int	 3
  000fc	cc		 int	 3
  000fd	cc		 int	 3
  000fe	cc		 int	 3
  000ff	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00020	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  00023	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  00025	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
__Newvec$ = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	83 c1 04	 add	 ecx, 4
  00039	89 4d f4	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  0003c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0003f	83 c2 08	 add	 edx, 8
  00042	89 55 f0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004b	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00056	89 45 e4	 mov	 DWORD PTR tv77[ebp], eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 4d e4	 mov	 ecx, DWORD PTR tv77[ebp]
  00060	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  00065	89 45 e8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  00068	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0006b	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0006e	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  00070	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00073	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00076	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  00078	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00081	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00084	89 10		 mov	 DWORD PTR [eax], edx

; 1715 :     }

  00086	83 c4 1c	 add	 esp, 28			; 0000001cH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00020	50		 push	 eax
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  00031	83 c4 04	 add	 esp, 4
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0003c	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00041	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00044	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00051	83 c4 08	 add	 esp, 8
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_$S13$ = -17						; size = 1
__Alproxy$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00047	50		 push	 eax
  00048	8d 4d ef	 lea	 ecx, DWORD PTR _$S13$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  00050	8d 45 ef	 lea	 eax, DWORD PTR _$S13$[ebp]
  00053	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  00056	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0005d	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00060	51		 push	 ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0006a	83 c4 08	 add	 esp, 8
  0006d	50		 push	 eax
  0006e	8b 45 f4	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00077	83 c4 08	 add	 esp, 8

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@vector
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	83 c4 1c	 add	 esp, 28			; 0000001cH
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
  000a3	90		 npad	 1
$LN5@vector:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN4@vector
$LN4@vector:
  000ac	ef ff ff ff	 DD	 -17			; ffffffefH
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN3@vector
$LN3@vector:
  000b8	24		 DB	 36			; 00000024H
  000b9	53		 DB	 83			; 00000053H
  000ba	31		 DB	 49			; 00000031H
  000bb	33		 DB	 51			; 00000033H
  000bc	00		 DB	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
tv78 = -88						; size = 4
$T2 = -83						; size = 1
$T3 = -82						; size = 1
$T4 = -81						; size = 1
__Guard$5 = -76						; size = 4
__Proxy$ = -64						; size = 8
__Rightlast$ = -52					; size = 4
__Rightfirst$ = -48					; size = 4
__Right_data$ = -44					; size = 4
__My_data$ = -40					; size = 4
_$S9$ = -29						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 555  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d a4	 lea	 edi, DWORD PTR [ebp-92]
  00019	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00055	50		 push	 eax
  00056	8d 4d af	 lea	 ecx, DWORD PTR $T4[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
  0005f	83 c4 08	 add	 esp, 8
  00062	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00065	8a 55 ae	 mov	 dl, BYTE PTR $T3[ebp]
  00068	88 55 ad	 mov	 BYTE PTR $T2[ebp], dl
  0006b	8b 45 a4	 mov	 eax, DWORD PTR tv76[ebp]
  0006e	50		 push	 eax
  0006f	0f b6 4d ad	 movzx	 ecx, BYTE PTR $T2[ebp]
  00073	51		 push	 ecx
  00074	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  00077	e8 00 00 00 00	 call	 ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >

; 556  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0007c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00084	50		 push	 eax
  00085	8d 4d e3	 lea	 ecx, DWORD PTR _$S9$[ebp]
  00088	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  0008d	8d 55 e3	 lea	 edx, DWORD PTR _$S9$[ebp]
  00090	89 55 e8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 557  :         auto& _My_data            = _Mypair._Myval2;

  00093	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00096	89 45 d8	 mov	 DWORD PTR __My_data$[ebp], eax

; 558  :         const auto& _Right_data   = _Right._Mypair._Myval2;

  00099	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009c	89 4d d4	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 559  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0009f	8b 55 d4	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000a2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a5	89 45 d0	 mov	 DWORD PTR __Rightfirst$[ebp], eax

; 560  :         const pointer _Rightlast  = _Right_data._Mylast;

  000a8	8b 4d d4	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000ab	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ae	89 55 cc	 mov	 DWORD PTR __Rightlast$[ebp], edx

; 561  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  000b1	8b 45 d8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d e8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000b8	51		 push	 ecx
  000b9	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000bc	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 562  :         if (_Rightfirst != _Rightlast) {

  000c8	8b 55 d0	 mov	 edx, DWORD PTR __Rightfirst$[ebp]
  000cb	3b 55 cc	 cmp	 edx, DWORD PTR __Rightlast$[ebp]
  000ce	74 4c		 je	 SHORT $LN2@vector

; 563  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000d0	8b 45 cc	 mov	 eax, DWORD PTR __Rightlast$[ebp]
  000d3	2b 45 d0	 sub	 eax, DWORD PTR __Rightfirst$[ebp]
  000d6	c1 f8 02	 sar	 eax, 2
  000d9	50		 push	 eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 564  :             _Tidy_guard<vector> _Guard{this};

  000e2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	89 4d b4	 mov	 DWORD PTR __Guard$5[ebp], ecx
  000e8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 565  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000ec	8b 55 d8	 mov	 edx, DWORD PTR __My_data$[ebp]
  000ef	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f2	50		 push	 eax
  000f3	8b 4d cc	 mov	 ecx, DWORD PTR __Rightlast$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 d0	 mov	 edx, DWORD PTR __Rightfirst$[ebp]
  000fa	52		 push	 edx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  00103	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00106	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 566  :             _Guard._Target   = nullptr;

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __Guard$5[ebp], 0

; 567  :         }

  00110	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00114	8d 4d b4	 lea	 ecx, DWORD PTR __Guard$5[ebp]
  00117	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
$LN2@vector:

; 568  : 
; 569  :         _Proxy._Release();

  0011c	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0011f	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 570  :     }

  00124	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0012b	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0012e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00133	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00136	52		 push	 edx
  00137	8b cd		 mov	 ecx, ebp
  00139	50		 push	 eax
  0013a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@vector
  00140	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00145	58		 pop	 eax
  00146	5a		 pop	 edx
  00147	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00151	59		 pop	 ecx
  00152	5f		 pop	 edi
  00153	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	83 c4 5c	 add	 esp, 92			; 0000005cH
  00160	3b ec		 cmp	 ebp, esp
  00162	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 04 00	 ret	 4
  0016d	0f 1f 00	 npad	 3
$LN11@vector:
  00170	03 00 00 00	 DD	 3
  00174	00 00 00 00	 DD	 $LN10@vector
$LN10@vector:
  00178	e3 ff ff ff	 DD	 -29			; ffffffe3H
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN6@vector
  00184	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00188	08 00 00 00	 DD	 8
  0018c	00 00 00 00	 DD	 $LN7@vector
  00190	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00194	04 00 00 00	 DD	 4
  00198	00 00 00 00	 DD	 $LN8@vector
$LN8@vector:
  0019c	5f		 DB	 95			; 0000005fH
  0019d	47		 DB	 71			; 00000047H
  0019e	75		 DB	 117			; 00000075H
  0019f	61		 DB	 97			; 00000061H
  001a0	72		 DB	 114			; 00000072H
  001a1	64		 DB	 100			; 00000064H
  001a2	00		 DB	 0
$LN7@vector:
  001a3	5f		 DB	 95			; 0000005fH
  001a4	50		 DB	 80			; 00000050H
  001a5	72		 DB	 114			; 00000072H
  001a6	6f		 DB	 111			; 0000006fH
  001a7	78		 DB	 120			; 00000078H
  001a8	79		 DB	 121			; 00000079H
  001a9	00		 DB	 0
$LN6@vector:
  001aa	24		 DB	 36			; 00000024H
  001ab	53		 DB	 83			; 00000053H
  001ac	39		 DB	 57			; 00000039H
  001ad	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1:
  00008	8d 4d b4	 lea	 ecx, DWORD PTR __Guard$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
tv133 = -72						; size = 4
tv135 = -68						; size = 4
tv70 = -64						; size = 4
$T2 = -57						; size = 1
$T3 = -56						; size = 1
$T4 = -55						; size = 1
$T5 = -54						; size = 1
$T6 = -53						; size = 1
__Proxy$ = -48						; size = 8
_$S7$ = -29						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d b8	 lea	 edi, DWORD PTR [ebp-72]
  00019	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	89 45 c0	 mov	 DWORD PTR tv70[ebp], eax
  0004d	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00050	51		 push	 ecx
  00051	0f b6 55 cb	 movzx	 edx, BYTE PTR $T6[ebp]
  00055	52		 push	 edx
  00056	8b 4d c0	 mov	 ecx, DWORD PTR tv70[ebp]
  00059	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0005e	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00066	50		 push	 eax
  00067	8d 4d e3	 lea	 ecx, DWORD PTR _$S7$[ebp]
  0006a	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  0006f	8d 45 e3	 lea	 eax, DWORD PTR _$S7$[ebp]
  00072	89 45 e8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00075	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	51		 push	 ecx
  00079	8b 55 e8	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0007c	52		 push	 edx
  0007d	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00080	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00085	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0008c	33 c0		 xor	 eax, eax
  0008e	88 45 ca	 mov	 BYTE PTR $T5[ebp], al
  00091	8a 4d c9	 mov	 cl, BYTE PTR $T4[ebp]
  00094	88 4d c8	 mov	 BYTE PTR $T3[ebp], cl
  00097	8a 55 c8	 mov	 dl, BYTE PTR $T3[ebp]
  0009a	88 55 c7	 mov	 BYTE PTR $T2[ebp], dl
  0009d	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  000a0	e8 00 00 00 00	 call	 ?end@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::end
  000a5	89 45 bc	 mov	 DWORD PTR tv135[ebp], eax
  000a8	8d 4d 08	 lea	 ecx, DWORD PTR __Ilist$[ebp]
  000ab	e8 00 00 00 00	 call	 ?begin@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::begin
  000b0	89 45 b8	 mov	 DWORD PTR tv133[ebp], eax
  000b3	0f b6 45 c7	 movzx	 eax, BYTE PTR $T2[ebp]
  000b7	50		 push	 eax
  000b8	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp]
  000bb	51		 push	 ecx
  000bc	8b 55 b8	 mov	 edx, DWORD PTR tv133[ebp]
  000bf	52		 push	 edx
  000c0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000c3	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>

; 551  :         _Proxy._Release();

  000c8	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000cb	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  000d0	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000d7	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000da	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000df	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000e2	52		 push	 edx
  000e3	8b cd		 mov	 ecx, ebp
  000e5	50		 push	 eax
  000e6	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@vector
  000ec	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f1	58		 pop	 eax
  000f2	5a		 pop	 edx
  000f3	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000f6	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000fd	59		 pop	 ecx
  000fe	5f		 pop	 edi
  000ff	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00102	33 cd		 xor	 ecx, ebp
  00104	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00109	83 c4 48	 add	 esp, 72			; 00000048H
  0010c	3b ec		 cmp	 ebp, esp
  0010e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00113	8b e5		 mov	 esp, ebp
  00115	5d		 pop	 ebp
  00116	c2 0c 00	 ret	 12			; 0000000cH
  00119	0f 1f 00	 npad	 3
$LN8@vector:
  0011c	02 00 00 00	 DD	 2
  00120	00 00 00 00	 DD	 $LN7@vector
$LN7@vector:
  00124	e3 ff ff ff	 DD	 -29			; ffffffe3H
  00128	01 00 00 00	 DD	 1
  0012c	00 00 00 00	 DD	 $LN4@vector
  00130	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00134	08 00 00 00	 DD	 8
  00138	00 00 00 00	 DD	 $LN5@vector
$LN5@vector:
  0013c	5f		 DB	 95			; 0000005fH
  0013d	50		 DB	 80			; 00000050H
  0013e	72		 DB	 114			; 00000072H
  0013f	6f		 DB	 111			; 0000006fH
  00140	78		 DB	 120			; 00000078H
  00141	79		 DB	 121			; 00000079H
  00142	00		 DB	 0
$LN4@vector:
  00143	24		 DB	 36			; 00000024H
  00144	53		 DB	 83			; 00000053H
  00145	37		 DB	 55			; 00000037H
  00146	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0:
  00000	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a bc	 mov	 ecx, DWORD PTR [edx-68]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction, COMDAT

; 731  :     _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :         return _Al;

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 733  :     }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00018	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0002a	83 c4 04	 add	 esp, 4

; 840  :     }

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	c1 e0 02	 shl	 eax, 2
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	83 c4 08	 add	 esp, 8

; 836  :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00011	50		 push	 eax
  00012	6a 00		 push	 0
  00014	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00017	51		 push	 ecx
  00018	e8 00 00 00 00	 call	 _memset
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xran, COMDAT
; _this$ = ecx

; 3096 :     [[noreturn]] void _Xran() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3097 :         _Xout_of_range("invalid vector<bool> subscript");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
  0001d	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 3098 :     }

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xlen, COMDAT
; _this$ = ecx

; 3092 :     [[noreturn]] void _Xlen() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3093 :         _Xlength_error("vector<bool> too long");

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@EOMJEIFA@vector?$DMbool?$DO?5too?5long@
  0001d	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen:

; 3094 :     }

  00022	83 c4 04	 add	 esp, 4
  00025	3b ec		 cmp	 ebp, esp
  00027	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c3		 ret	 0
?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv208 = -104						; size = 4
tv205 = -100						; size = 4
tv217 = -96						; size = 4
tv219 = -92						; size = 4
tv214 = -88						; size = 4
tv174 = -84						; size = 4
tv212 = -80						; size = 4
tv166 = -76						; size = 4
tv137 = -72						; size = 4
tv185 = -68						; size = 4
$T1 = -64						; size = 12
$T2 = -52						; size = 12
$T3 = -40						; size = 12
$T4 = -28						; size = 4
$T5 = -24						; size = 12
$T6 = -12						; size = 4
__Words$ = -8						; size = 4
_this$ = -4						; size = 4
__Size$ = 8						; size = 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z PROC ; std::vector<bool,std::allocator<bool> >::_Trim, COMDAT
; _this$ = ecx

; 3075 :     _CONSTEXPR20_CONTAINER void _Trim(size_type _Size) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d 98	 lea	 edi, DWORD PTR [ebp-104]
  0000c	b9 1a 00 00 00	 mov	 ecx, 26			; 0000001aH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3076 :         if (max_size() < _Size) {

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	e8 00 00 00 00	 call	 ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::max_size
  0002e	3b 45 08	 cmp	 eax, DWORD PTR __Size$[ebp]
  00031	73 08		 jae	 SHORT $LN2@Trim

; 3077 :             _Xlen(); // result too long

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Xlen@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xlen
$LN2@Trim:

; 3078 :         }
; 3079 : 
; 3080 :         const size_type _Words = this->_Nw(_Size);

  0003b	8b 45 08	 mov	 eax, DWORD PTR __Size$[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  00044	83 c4 04	 add	 esp, 4
  00047	89 45 f8	 mov	 DWORD PTR __Words$[ebp], eax

; 3081 :         if (_Words < this->_Myvec.size()) {

  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	e8 00 00 00 00	 call	 ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::size
  00055	39 45 f8	 cmp	 DWORD PTR __Words$[ebp], eax
  00058	0f 83 a7 00 00
	00		 jae	 $LN3@Trim

; 3082 :             this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());

  0005e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	83 c1 04	 add	 ecx, 4
  00064	89 4d bc	 mov	 DWORD PTR tv185[ebp], ecx
  00067	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0006a	83 c2 04	 add	 edx, 4
  0006d	89 55 b8	 mov	 DWORD PTR tv137[ebp], edx
  00070	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00073	83 c0 04	 add	 eax, 4
  00076	89 45 b4	 mov	 DWORD PTR tv166[ebp], eax
  00079	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  0007c	51		 push	 ecx
  0007d	8b 4d b4	 mov	 ecx, DWORD PTR tv166[ebp]
  00080	e8 00 00 00 00	 call	 ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
  00085	89 45 b0	 mov	 DWORD PTR tv212[ebp], eax
  00088	8b 55 b0	 mov	 edx, DWORD PTR tv212[ebp]
  0008b	89 55 ac	 mov	 DWORD PTR tv174[ebp], edx
  0008e	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00091	8b f4		 mov	 esi, esp
  00093	89 65 f4	 mov	 DWORD PTR $T6[ebp], esp
  00096	8d 45 e8	 lea	 eax, DWORD PTR $T5[ebp]
  00099	50		 push	 eax
  0009a	8b 4d b8	 mov	 ecx, DWORD PTR tv137[ebp]
  0009d	e8 00 00 00 00	 call	 ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::end
  000a2	89 45 a8	 mov	 DWORD PTR tv214[ebp], eax
  000a5	8b 4d a8	 mov	 ecx, DWORD PTR tv214[ebp]
  000a8	51		 push	 ecx
  000a9	8b ce		 mov	 ecx, esi
  000ab	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  000b0	83 ec 0c	 sub	 esp, 12			; 0000000cH
  000b3	8b f4		 mov	 esi, esp
  000b5	89 65 e4	 mov	 DWORD PTR $T4[ebp], esp
  000b8	8b 55 f8	 mov	 edx, DWORD PTR __Words$[ebp]
  000bb	52		 push	 edx
  000bc	8d 45 cc	 lea	 eax, DWORD PTR $T2[ebp]
  000bf	50		 push	 eax
  000c0	8b 4d ac	 mov	 ecx, DWORD PTR tv174[ebp]
  000c3	e8 00 00 00 00	 call	 ??H?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<unsigned int> > >::operator+
  000c8	89 45 a4	 mov	 DWORD PTR tv219[ebp], eax
  000cb	8b 4d a4	 mov	 ecx, DWORD PTR tv219[ebp]
  000ce	51		 push	 ecx
  000cf	8b ce		 mov	 ecx, esi
  000d1	e8 00 00 00 00	 call	 ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@ABV01@@Z
  000d6	8d 55 c0	 lea	 edx, DWORD PTR $T1[ebp]
  000d9	52		 push	 edx
  000da	8b 4d bc	 mov	 ecx, DWORD PTR tv185[ebp]
  000dd	e8 00 00 00 00	 call	 ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
  000e2	89 45 a0	 mov	 DWORD PTR tv217[ebp], eax
  000e5	8d 4d c0	 lea	 ecx, DWORD PTR $T1[ebp]
  000e8	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  000ed	8d 4d cc	 lea	 ecx, DWORD PTR $T2[ebp]
  000f0	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  000f5	8d 4d e8	 lea	 ecx, DWORD PTR $T5[ebp]
  000f8	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  000fd	8d 4d d8	 lea	 ecx, DWORD PTR $T3[ebp]
  00100	e8 00 00 00 00	 call	 ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
$LN3@Trim:

; 3083 :         }
; 3084 : 
; 3085 :         this->_Mysize = _Size;

  00105	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00108	8b 4d 08	 mov	 ecx, DWORD PTR __Size$[ebp]
  0010b	89 48 14	 mov	 DWORD PTR [eax+20], ecx

; 3086 :         _Size %= _VBITS;

  0010e	8b 45 08	 mov	 eax, DWORD PTR __Size$[ebp]
  00111	33 d2		 xor	 edx, edx
  00113	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00118	f7 f1		 div	 ecx
  0011a	89 55 08	 mov	 DWORD PTR __Size$[ebp], edx

; 3087 :         if (0 < _Size) {

  0011d	83 7d 08 00	 cmp	 DWORD PTR __Size$[ebp], 0
  00121	76 32		 jbe	 SHORT $LN5@Trim

; 3088 :             this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;

  00123	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00126	83 c2 04	 add	 edx, 4
  00129	89 55 9c	 mov	 DWORD PTR tv205[ebp], edx
  0012c	8b 45 f8	 mov	 eax, DWORD PTR __Words$[ebp]
  0012f	83 e8 01	 sub	 eax, 1
  00132	50		 push	 eax
  00133	8b 4d 9c	 mov	 ecx, DWORD PTR tv205[ebp]
  00136	e8 00 00 00 00	 call	 ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
  0013b	89 45 98	 mov	 DWORD PTR tv208[ebp], eax
  0013e	ba 01 00 00 00	 mov	 edx, 1
  00143	8b 4d 08	 mov	 ecx, DWORD PTR __Size$[ebp]
  00146	d3 e2		 shl	 edx, cl
  00148	83 ea 01	 sub	 edx, 1
  0014b	8b 45 98	 mov	 eax, DWORD PTR tv208[ebp]
  0014e	23 10		 and	 edx, DWORD PTR [eax]
  00150	8b 4d 98	 mov	 ecx, DWORD PTR tv208[ebp]
  00153	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@Trim:

; 3089 :         }
; 3090 :     }

  00155	5f		 pop	 edi
  00156	5e		 pop	 esi
  00157	83 c4 68	 add	 esp, 104		; 00000068H
  0015a	3b ec		 cmp	 ebp, esp
  0015c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00161	8b e5		 mov	 esp, ebp
  00163	5d		 pop	 ebp
  00164	c2 04 00	 ret	 4
?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ENDP ; std::vector<bool,std::allocator<bool> >::_Trim
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__It$ = -28						; size = 16
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2834 :     _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](size_type _Off) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0000f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00012	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00015	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00018	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001b	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001e	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00021	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00024	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00029	33 c5		 xor	 eax, ebp
  0002b	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002e	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00031	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00036	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@operator:

; 2835 : #if _CONTAINER_DEBUG_LEVEL > 0
; 2836 :         _STL_VERIFY(_Off < this->_Mysize, "vector<bool> subscript out of range");

  0003b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 4d 0c	 mov	 ecx, DWORD PTR __Off$[ebp]
  00041	3b 48 14	 cmp	 ecx, DWORD PTR [eax+20]
  00044	73 02		 jae	 SHORT $LN7@operator
  00046	eb 5c		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00048	8b f4		 mov	 esi, esp
  0004a	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
  0004f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00054	6a 00		 push	 0
  00056	68 14 0b 00 00	 push	 2836			; 00000b14H
  0005b	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00060	6a 02		 push	 2
  00062	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00068	83 c4 18	 add	 esp, 24			; 00000018H
  0006b	3b f4		 cmp	 esi, esp
  0006d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00072	83 f8 01	 cmp	 eax, 1
  00075	75 01		 jne	 SHORT $LN11@operator
  00077	cc		 int	 3
$LN11@operator:
  00078	8b f4		 mov	 esi, esp
  0007a	6a 00		 push	 0
  0007c	68 14 0b 00 00	 push	 2836			; 00000b14H
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00086	68 00 00 00 00	 push	 OFFSET ??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
  00090	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00096	83 c4 14	 add	 esp, 20			; 00000014H
  00099	3b f4		 cmp	 esi, esp
  0009b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a0	33 c0		 xor	 eax, eax
  000a2	75 a4		 jne	 SHORT $LN7@operator
$LN2@operator:
  000a4	33 c9		 xor	 ecx, ecx
  000a6	75 93		 jne	 SHORT $LN4@operator

; 2837 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 2838 : 
; 2839 :         iterator _It = begin();

  000a8	6a 10		 push	 16			; 00000010H
  000aa	8d 4d e4	 lea	 ecx, DWORD PTR __It$[ebp]
  000ad	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
  000b2	8d 55 e4	 lea	 edx, DWORD PTR __It$[ebp]
  000b5	52		 push	 edx
  000b6	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin

; 2840 :         _It._Advance(_Off);

  000be	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  000c1	50		 push	 eax
  000c2	8d 4d e4	 lea	 ecx, DWORD PTR __It$[ebp]
  000c5	e8 00 00 00 00	 call	 ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance

; 2841 :         return *_It;

  000ca	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  000cd	51		 push	 ecx
  000ce	8d 4d e4	 lea	 ecx, DWORD PTR __It$[ebp]
  000d1	e8 00 00 00 00	 call	 ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  000d6	8d 4d e4	 lea	 ecx, DWORD PTR __It$[ebp]
  000d9	e8 00 00 00 00	 call	 ??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  000de	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2842 :     }

  000e1	52		 push	 edx
  000e2	8b cd		 mov	 ecx, ebp
  000e4	50		 push	 eax
  000e5	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN14@operator
  000eb	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000f0	58		 pop	 eax
  000f1	5a		 pop	 edx
  000f2	5e		 pop	 esi
  000f3	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f6	33 cd		 xor	 ecx, ebp
  000f8	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000fd	83 c4 20	 add	 esp, 32			; 00000020H
  00100	3b ec		 cmp	 ebp, esp
  00102	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00107	8b e5		 mov	 esp, ebp
  00109	5d		 pop	 ebp
  0010a	c2 08 00	 ret	 8
  0010d	0f 1f 00	 npad	 3
$LN14@operator:
  00110	01 00 00 00	 DD	 1
  00114	00 00 00 00	 DD	 $LN13@operator
$LN13@operator:
  00118	e4 ff ff ff	 DD	 -28			; ffffffe4H
  0011c	10 00 00 00	 DD	 16			; 00000010H
  00120	00 00 00 00	 DD	 $LN12@operator
$LN12@operator:
  00124	5f		 DB	 95			; 0000005fH
  00125	49		 DB	 73			; 00000049H
  00126	74		 DB	 116			; 00000074H
  00127	00		 DB	 0
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::at, COMDAT
; _this$ = ecx

; 2816 :     _NODISCARD _CONSTEXPR20_CONTAINER reference at(size_type _Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2817 :         if (size() <= _Off) {

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00030	3b 45 0c	 cmp	 eax, DWORD PTR __Off$[ebp]
  00033	77 08		 ja	 SHORT $LN2@at

; 2818 :             _Xran();

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	e8 00 00 00 00	 call	 ?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xran
$LN2@at:

; 2819 :         }
; 2820 : 
; 2821 :         return (*this)[_Off];

  0003d	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00040	50		 push	 eax
  00041	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00044	51		 push	 ecx
  00045	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  0004d	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00050	83 ca 01	 or	 edx, 1
  00053	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00056	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@at:

; 2822 :     }

  00059	83 c4 08	 add	 esp, 8
  0005c	3b ec		 cmp	 ebp, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00063	8b e5		 mov	 esp, ebp
  00065	5d		 pop	 ebp
  00066	c2 08 00	 ret	 8
?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__Ints_max$ = -12					; size = 4
__Diff_max$ = -8					; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC ; std::vector<bool,std::allocator<bool> >::max_size, COMDAT
; _this$ = ecx

; 2789 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2790 :         constexpr auto _Diff_max  = static_cast<size_type>((numeric_limits<difference_type>::max)());

  00028	c7 45 f8 ff ff
	ff 7f		 mov	 DWORD PTR __Diff_max$[ebp], 2147483647 ; 7fffffffH

; 2791 :         const size_type _Ints_max = this->_Myvec.max_size();

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	83 c1 04	 add	 ecx, 4
  00035	e8 00 00 00 00	 call	 ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
  0003a	89 45 f4	 mov	 DWORD PTR __Ints_max$[ebp], eax

; 2792 :         if (_Ints_max > _Diff_max / _VBITS) { // max_size bound by difference_type limits

  0003d	81 7d f4 ff ff
	ff 03		 cmp	 DWORD PTR __Ints_max$[ebp], 67108863 ; 03ffffffH
  00044	76 07		 jbe	 SHORT $LN2@max_size

; 2793 :             return _Diff_max;

  00046	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  0004b	eb 06		 jmp	 SHORT $LN3@max_size
$LN2@max_size:

; 2794 :         }
; 2795 : 
; 2796 :         // max_size bound by underlying storage limits
; 2797 :         return _Ints_max * _VBITS;

  0004d	8b 45 f4	 mov	 eax, DWORD PTR __Ints_max$[ebp]
  00050	c1 e0 05	 shl	 eax, 5
$LN3@max_size:

; 2798 :     }

  00053	83 c4 0c	 add	 esp, 12			; 0000000cH
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?max_size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP ; std::vector<bool,std::allocator<bool> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2785 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2786 :         return this->_Mysize;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 40 14	 mov	 eax, DWORD PTR [eax+20]

; 2787 :     }

  0001e	83 c4 04	 add	 esp, 4
  00021	3b ec		 cmp	 ebp, esp
  00023	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 2697 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2698 :         return iterator(this->_Myvec.data(), this);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	83 c1 04	 add	 ecx, 4
  00022	e8 00 00 00 00	 call	 ?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0002b	e8 00 00 00 00	 call	 ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
  00030	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2699 :     }

  00033	83 c4 04	 add	 esp, 4
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2529 :     _CONSTEXPR20_CONTAINER vector(const vector& _Right) : _Mybase(_Right) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c2 04 00	 ret	 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z PROC ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2519 :     _CONSTEXPR20_CONTAINER explicit vector(_CRT_GUARDOVERFLOW size_type _Count, const _Alloc& _Al = _Alloc())

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 08	 sub	 esp, 8
  00014	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  0001b	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00022	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00027	33 c5		 xor	 eax, ebp
  00029	50		 push	 eax
  0002a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0002d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00033	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00036	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0003b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2520 :         : _Mybase(_Count, false, _Al) {

  00040	c6 45 ef 00	 mov	 BYTE PTR $T2[ebp], 0
  00044	8b 45 0c	 mov	 eax, DWORD PTR __Al$[ebp]
  00047	50		 push	 eax
  00048	8d 4d ef	 lea	 ecx, DWORD PTR $T2[ebp]
  0004b	51		 push	 ecx
  0004c	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  0004f	52		 push	 edx
  00050	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	e8 00 00 00 00	 call	 ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
  00058	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2521 :         _Trim(_Count);

  0005f	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00062	50		 push	 eax
  00063	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00066	e8 00 00 00 00	 call	 ?_Trim@?$vector@_NV?$allocator@_N@std@@@std@@QAEXI@Z ; std::vector<bool,std::allocator<bool> >::_Trim

; 2522 :     }

  0006b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00072	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00078	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0007f	59		 pop	 ecx
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f4	 mov	 ecx, DWORD PTR [edx-12]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@_NV?$allocator@_N@std@@@std@@QAE@IABV?$allocator@_N@1@@Z ENDP ; std::vector<bool,std::allocator<bool> >::vector<bool,std::allocator<bool> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00020	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00023	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	c7 41 08 00 00
	00 00		 mov	 DWORD PTR [ecx+8], 0
  00034	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00037	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0
  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00041	83 c4 04	 add	 esp, 4
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@I@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<unsigned int> >::_Vector_val<std::_Simple_types<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QBEABV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 1823 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 1819 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1802 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1803 :         // orphan iterators within specified (inclusive) range
; 1804 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1805 :         if (_STD is_constant_evaluated()) {

  00018	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 12		 je	 SHORT $LN2@Orphan_ran

; 1806 :             _Orphan_range_unlocked(_First, _Last);

  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00027	51		 push	 ecx
  00028	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  0002b	52		 push	 edx
  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002f	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked

; 1807 :         } else

  00034	eb 10		 jmp	 SHORT $LN1@Orphan_ran
$LN2@Orphan_ran:

; 1808 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1809 :         {
; 1810 :             _Orphan_range_locked(_First, _Last);

  00036	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00039	50		 push	 eax
  0003a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003d	51		 push	 ecx
  0003e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00041	e8 00 00 00 00	 call	 ?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
$LN1@Orphan_ran:

; 1811 :         }
; 1812 :     }

  00046	83 c4 04	 add	 esp, 4
  00049	3b ec		 cmp	 ebp, esp
  0004b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c2 08 00	 ret	 8
?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
__Lock$ = -28						; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 1797 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001d	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00020	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00023	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00026	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1798 :         _Lockit _Lock(_LOCK_DEBUG);

  0004a	8b f4		 mov	 esi, esp
  0004c	6a 03		 push	 3
  0004e	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00051	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1799 :         _Orphan_range_unlocked(_First, _Last);

  00065	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00068	50		 push	 eax
  00069	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0006c	51		 push	 ecx
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked

; 1800 :     }

  00075	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0007c	8b f4		 mov	 esi, esp
  0007e	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00087	3b f4		 cmp	 esi, esp
  00089	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008e	52		 push	 edx
  0008f	8b cd		 mov	 ecx, ebp
  00091	50		 push	 eax
  00092	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Orphan_ran
  00098	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009d	58		 pop	 eax
  0009e	5a		 pop	 edx
  0009f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a9	59		 pop	 ecx
  000aa	5e		 pop	 esi
  000ab	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000ae	33 cd		 xor	 ecx, ebp
  000b0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000b5	83 c4 20	 add	 esp, 32			; 00000020H
  000b8	3b ec		 cmp	 ebp, esp
  000ba	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 08 00	 ret	 8
  000c5	0f 1f 00	 npad	 3
$LN7@Orphan_ran:
  000c8	01 00 00 00	 DD	 1
  000cc	00 00 00 00	 DD	 $LN6@Orphan_ran
$LN6@Orphan_ran:
  000d0	e4 ff ff ff	 DD	 -28			; ffffffe4H
  000d4	04 00 00 00	 DD	 4
  000d8	00 00 00 00	 DD	 $LN4@Orphan_ran
$LN4@Orphan_ran:
  000dc	5f		 DB	 95			; 0000005fH
  000dd	4c		 DB	 76			; 0000004cH
  000de	6f		 DB	 111			; 0000006fH
  000df	63		 DB	 99			; 00000063H
  000e0	6b		 DB	 107			; 0000006bH
  000e1	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z$0:
  00000	8b f4		 mov	 esi, esp
  00002	8d 4d e4	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00005	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0000b	3b f4		 cmp	 esi, esp
  0000d	e9 00 00 00 00	 jmp	 __RTC_CheckEsp
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
__ehhandler$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z:
  00017	90		 npad	 1
  00018	90		 npad	 1
  00019	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001d	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00020	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002d	33 c8		 xor	 ecx, eax
  0002f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00034	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
  00039	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z
_TEXT	SEGMENT
__Temp$1 = -20						; size = 4
__Temp$2 = -16						; size = 4
__Pnextptr$3 = -12					; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 1782 :     _CONSTEXPR20_CONTAINER void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00022	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1783 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  00027	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002c	83 c1 04	 add	 ecx, 4
  0002f	89 4d f8	 mov	 DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 1784 :         while (*_Pnext) {

  00032	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00035	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00038	74 4c		 je	 SHORT $LN1@Orphan_ran

; 1785 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$[ebp]
  0003d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003f	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  00042	89 55 f4	 mov	 DWORD PTR __Pnextptr$3[ebp], edx

; 1786 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

  00045	8b 45 f4	 mov	 eax, DWORD PTR __Pnextptr$3[ebp]
  00048	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  0004b	72 08		 jb	 SHORT $LN6@Orphan_ran
  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00050	3b 4d f4	 cmp	 ecx, DWORD PTR __Pnextptr$3[ebp]
  00053	73 13		 jae	 SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 1787 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00055	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00058	8b 02		 mov	 eax, DWORD PTR [edx]
  0005a	89 45 f0	 mov	 DWORD PTR __Temp$2[ebp], eax

; 1788 :                 _Pnext           = &_Temp->_Mynextiter;

  0005d	8b 4d f0	 mov	 ecx, DWORD PTR __Temp$2[ebp]
  00060	83 c1 04	 add	 ecx, 4
  00063	89 4d f8	 mov	 DWORD PTR __Pnext$[ebp], ecx

; 1789 :             } else { // orphan the iterator

  00066	eb 1c		 jmp	 SHORT $LN5@Orphan_ran
$LN4@Orphan_ran:

; 1790 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00068	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0006b	8b 02		 mov	 eax, DWORD PTR [edx]
  0006d	89 45 ec	 mov	 DWORD PTR __Temp$1[ebp], eax

; 1791 :                 _Temp->_Myproxy  = nullptr;

  00070	8b 4d ec	 mov	 ecx, DWORD PTR __Temp$1[ebp]
  00073	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1792 :                 *_Pnext          = _Temp->_Mynextiter;

  00079	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0007c	8b 45 ec	 mov	 eax, DWORD PTR __Temp$1[ebp]
  0007f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00082	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@Orphan_ran:

; 1793 :             }
; 1794 :         }

  00084	eb ac		 jmp	 SHORT $LN2@Orphan_ran
$LN1@Orphan_ran:

; 1795 :     }

  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 08 00	 ret	 8
?_Orphan_range_unlocked@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv86 = -44						; size = 4
tv88 = -40						; size = 4
tv90 = -36						; size = 4
__Myend$ = -32						; size = 4
__Mylast$ = -28						; size = 4
__Myfirst$ = -24					; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001c	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001f	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00022	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00025	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00028	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00055	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00058	83 c1 04	 add	 ecx, 4
  0005b	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  0005e	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  00061	83 c2 08	 add	 edx, 8
  00064	89 55 e4	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  00067	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  0006a	83 c0 0c	 add	 eax, 12			; 0000000cH
  0006d	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00070	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00073	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  00078	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0007b	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0007e	74 62		 je	 SHORT $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  00080	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00083	8b 02		 mov	 eax, DWORD PTR [edx]
  00085	50		 push	 eax
  00086	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00089	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008b	52		 push	 edx
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00094	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00097	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  0009c	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  0009f	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a2	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000a5	8b 10		 mov	 edx, DWORD PTR [eax]
  000a7	2b 11		 sub	 edx, DWORD PTR [ecx]
  000a9	c1 fa 02	 sar	 edx, 2
  000ac	89 55 d8	 mov	 DWORD PTR tv88[ebp], edx
  000af	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d d4	 mov	 DWORD PTR tv86[ebp], ecx
  000b7	8b 55 d8	 mov	 edx, DWORD PTR tv88[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d4	 mov	 eax, DWORD PTR tv86[ebp]
  000be	50		 push	 eax
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR tv90[ebp]
  000c2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@I@std@@QAEXQAII@Z ; std::allocator<unsigned int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  000c7	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ca	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  000d0	8b 55 e4	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000d3	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  000d9	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000dc	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  000e2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ec	59		 pop	 ecx
  000ed	83 c4 2c	 add	 esp, 44			; 0000002cH
  000f0	3b ec		 cmp	 ebp, esp
  000f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c3		 ret	 0
  000fb	cc		 int	 3
  000fc	cc		 int	 3
  000fd	cc		 int	 3
  000fe	cc		 int	 3
  000ff	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
  00020	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  00023	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  00025	e8 00 00 00 00	 call	 ?_Xlength@?$vector@IV?$allocator@I@std@@@std@@CAXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  0002a	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0002d	50		 push	 eax
  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv77 = -28						; size = 4
__Newvec$ = -24						; size = 4
__Myend$ = -20						; size = 4
__Mylast$ = -16						; size = 4
__Myfirst$ = -12					; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00028	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00030	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00033	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00036	83 c1 04	 add	 ecx, 4
  00039	89 4d f4	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  0003c	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0003f	83 c2 08	 add	 edx, 8
  00042	89 55 f0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  00045	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  00048	83 c0 0c	 add	 eax, 12			; 0000000cH
  0004b	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  0004e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00056	89 45 e4	 mov	 DWORD PTR tv77[ebp], eax
  00059	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  0005c	51		 push	 ecx
  0005d	8b 4d e4	 mov	 ecx, DWORD PTR tv77[ebp]
  00060	e8 00 00 00 00	 call	 ?allocate@?$allocator@I@std@@QAEPAII@Z ; std::allocator<unsigned int>::allocate
  00065	89 45 e8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  00068	8b 55 f4	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0006b	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0006e	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  00070	8b 4d f0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00073	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00076	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  00078	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0007b	8b 4d e8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0007e	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  00081	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00084	89 10		 mov	 DWORD PTR [eax], edx

; 1715 :     }

  00086	83 c4 1c	 add	 esp, 28			; 0000001cH
  00089	3b ec		 cmp	 ebp, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	8b e5		 mov	 esp, ebp
  00092	5d		 pop	 ebp
  00093	c2 04 00	 ret	 4
?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00020	50		 push	 eax
  00021	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
  0002e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  00031	83 c4 04	 add	 esp, 4
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c2 08 00	 ret	 8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill, COMDAT
; _this$ = ecx

; 1641 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1642 :         // fill raw _Dest with _Count copies of _Val, using allocator
; 1643 :         return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00020	50		 push	 eax
  00021	8b 45 10	 mov	 eax, DWORD PTR __Val$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00028	51		 push	 ecx
  00029	8b 55 08	 mov	 edx, DWORD PTR __Dest$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$_Uninitialized_fill_n@V?$allocator@I@std@@@std@@YAPAIPAIIABIAAV?$allocator@I@0@@Z ; std::_Uninitialized_fill_n<std::allocator<unsigned int> >
  00032	83 c4 10	 add	 esp, 16			; 00000010H

; 1644 :     }

  00035	83 c4 04	 add	 esp, 4
  00038	3b ec		 cmp	 ebp, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAIIABI@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[], COMDAT
; _this$ = ecx

; 1562 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& operator[](const size_type _Pos) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1563 :         auto& _My_data = _Mypair._Myval2;

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax
$LN4@operator:

; 1564 : #if _CONTAINER_DEBUG_LEVEL > 0
; 1565 :         _STL_VERIFY(

  00028	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002b	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002e	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00031	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00034	c1 f8 02	 sar	 eax, 2
  00037	39 45 08	 cmp	 DWORD PTR __Pos$[ebp], eax
  0003a	73 02		 jae	 SHORT $LN7@operator
  0003c	eb 5c		 jmp	 SHORT $LN2@operator
$LN7@operator:
  0003e	8b f4		 mov	 esi, esp
  00040	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@PFKOHNJC@vector?5subscript?5out?5of?5range@
  00045	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0004a	6a 00		 push	 0
  0004c	68 1e 06 00 00	 push	 1566			; 0000061eH
  00051	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00056	6a 02		 push	 2
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005e	83 c4 18	 add	 esp, 24			; 00000018H
  00061	3b f4		 cmp	 esi, esp
  00063	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00068	83 f8 01	 cmp	 eax, 1
  0006b	75 01		 jne	 SHORT $LN11@operator
  0006d	cc		 int	 3
$LN11@operator:
  0006e	8b f4		 mov	 esi, esp
  00070	6a 00		 push	 0
  00072	68 1e 06 00 00	 push	 1566			; 0000061eH
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0007c	68 00 00 00 00	 push	 OFFSET ??_C@_1JG@ILDNFCDK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
  00081	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@LEKOKFNB@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAs?$AAu?$AAb?$AAs?$AAc?$AAr?$AAi@
  00086	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0008c	83 c4 14	 add	 esp, 20			; 00000014H
  0008f	3b f4		 cmp	 esi, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	33 d2		 xor	 edx, edx
  00098	75 a4		 jne	 SHORT $LN7@operator
$LN2@operator:
  0009a	33 c0		 xor	 eax, eax
  0009c	75 8a		 jne	 SHORT $LN4@operator

; 1566 :             _Pos < static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
; 1567 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 1568 : 
; 1569 :         return _My_data._Myfirst[_Pos];

  0009e	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000a1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000a4	8b 45 08	 mov	 eax, DWORD PTR __Pos$[ebp]
  000a7	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]

; 1570 :     }

  000aa	5e		 pop	 esi
  000ab	83 c4 08	 add	 esp, 8
  000ae	3b ec		 cmp	 ebp, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c2 04 00	 ret	 4
??A?$vector@IV?$allocator@I@std@@@std@@QAEAAII@Z ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -12						; size = 4
$T2 = -8						; size = 4
_this$ = -4						; size = 4
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00030	50		 push	 eax
  00031	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR $T2[ebp], eax
  0003c	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  00041	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  00044	8d 45 f8	 lea	 eax, DWORD PTR $T2[ebp]
  00047	50		 push	 eax
  00048	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  0004b	51		 push	 ecx
  0004c	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00051	83 c4 08	 add	 esp, 8
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?max_size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::size, COMDAT
; _this$ = ecx

; 1547 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1548 :         auto& _My_data = _Mypair._Myval2;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00027	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002a	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0002d	8b 41 08	 mov	 eax, DWORD PTR [ecx+8]
  00030	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
  00033	c1 f8 02	 sar	 eax, 2

; 1550 :     }

  00036	83 c4 08	 add	 esp, 8
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?size@?$vector@IV?$allocator@I@std@@@std@@QBEIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = -16						; size = 4
tv80 = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::end, COMDAT
; _this$ = ecx

; 1484 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1485 :         auto& _My_data = _Mypair._Myval2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1486 :         return iterator(_My_data._Mylast, _STD addressof(_My_data));

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR tv80[ebp], eax
  00039	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0003c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0003f	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR tv80[ebp]
  00045	51		 push	 ecx
  00046	8b 55 f0	 mov	 edx, DWORD PTR tv78[ebp]
  00049	52		 push	 edx
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
  00052	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1487 :     }

  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?end@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
tv78 = -16						; size = 4
tv80 = -12						; size = 4
__My_data$ = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::begin, COMDAT
; _this$ = ecx

; 1474 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0001f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1475 :         auto& _My_data = _Mypair._Myval2;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00027	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1476 :         return iterator(_My_data._Myfirst, _STD addressof(_My_data));

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR tv80[ebp], eax
  00039	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  0003c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003f	89 45 f0	 mov	 DWORD PTR tv78[ebp], eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR tv80[ebp]
  00045	51		 push	 ecx
  00046	8b 55 f0	 mov	 edx, DWORD PTR tv78[ebp]
  00049	52		 push	 edx
  0004a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0004d	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
  00052	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1477 :     }

  00055	83 c4 10	 add	 esp, 16			; 00000010H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c2 04 00	 ret	 4
?begin@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::data, COMDAT
; _this$ = ecx

; 1470 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Ty* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1471 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ; std::_Unfancy_maybe_null<unsigned int>
  00024	83 c4 04	 add	 esp, 4

; 1472 :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::data, COMDAT
; _this$ = ecx

; 1466 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty* data() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1467 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0001e	51		 push	 ecx
  0001f	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ; std::_Unfancy_maybe_null<unsigned int>
  00024	83 c4 04	 add	 esp, 4

; 1468 :     }

  00027	83 c4 04	 add	 esp, 4
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
_TEXT	SEGMENT
__Newlast$2 = -36					; size = 4
__Mylast$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Lastptr$ = -24					; size = 4
__Firstptr$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::erase, COMDAT
; _this$ = ecx

; 1426 :         is_nothrow_move_assignable_v<value_type>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	56		 push	 esi
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001d	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00020	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00023	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00026	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00029	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	50		 push	 eax
  00034	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00037	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003d	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1427 :         const pointer _Firstptr = _First._Ptr;

  0004a	8b 45 14	 mov	 eax, DWORD PTR __First$[ebp+8]
  0004d	89 45 ec	 mov	 DWORD PTR __Firstptr$[ebp], eax

; 1428 :         const pointer _Lastptr  = _Last._Ptr;

  00050	8b 4d 20	 mov	 ecx, DWORD PTR __Last$[ebp+8]
  00053	89 4d e8	 mov	 DWORD PTR __Lastptr$[ebp], ecx

; 1429 :         auto& _My_data          = _Mypair._Myval2;

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	89 55 e4	 mov	 DWORD PTR __My_data$[ebp], edx

; 1430 :         pointer& _Mylast        = _My_data._Mylast;

  0005c	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0005f	83 c0 08	 add	 eax, 8
  00062	89 45 e0	 mov	 DWORD PTR __Mylast$[ebp], eax
$LN4@erase:

; 1431 : 
; 1432 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1433 :         _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) && _Last._Getcont() == _STD addressof(_My_data)

  00065	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00068	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0006d	8b f0		 mov	 esi, eax
  0006f	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00078	83 c4 04	 add	 esp, 4
  0007b	3b f0		 cmp	 esi, eax
  0007d	75 39		 jne	 SHORT $LN7@erase
  0007f	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  00082	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  00087	8b f0		 mov	 esi, eax
  00089	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  0008c	52		 push	 edx
  0008d	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00092	83 c4 04	 add	 esp, 4
  00095	3b f0		 cmp	 esi, eax
  00097	75 1f		 jne	 SHORT $LN7@erase
  00099	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0009c	8b 4d ec	 mov	 ecx, DWORD PTR __Firstptr$[ebp]
  0009f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  000a2	72 14		 jb	 SHORT $LN7@erase
  000a4	8b 55 e8	 mov	 edx, DWORD PTR __Lastptr$[ebp]
  000a7	3b 55 ec	 cmp	 edx, DWORD PTR __Firstptr$[ebp]
  000aa	72 0c		 jb	 SHORT $LN7@erase
  000ac	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000af	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b1	3b 4d e8	 cmp	 ecx, DWORD PTR __Lastptr$[ebp]
  000b4	72 02		 jb	 SHORT $LN7@erase
  000b6	eb 5c		 jmp	 SHORT $LN2@erase
$LN7@erase:
  000b8	8b f4		 mov	 esi, esp
  000ba	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@EAMOGAIE@vector?5erase?5iterator?5outside?5r@
  000bf	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000c4	6a 00		 push	 0
  000c6	68 9b 05 00 00	 push	 1435			; 0000059bH
  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000d0	6a 02		 push	 2
  000d2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000d8	83 c4 18	 add	 esp, 24			; 00000018H
  000db	3b f4		 cmp	 esi, esp
  000dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000e2	83 f8 01	 cmp	 eax, 1
  000e5	75 01		 jne	 SHORT $LN12@erase
  000e7	cc		 int	 3
$LN12@erase:
  000e8	8b f4		 mov	 esi, esp
  000ea	6a 00		 push	 0
  000ec	68 9b 05 00 00	 push	 1435			; 0000059bH
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000f6	68 00 00 00 00	 push	 OFFSET ??_C@_1IK@JDPLIGFN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAu?$AAn?$AAs@
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@BEMPOGMM@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi@
  00100	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00106	83 c4 14	 add	 esp, 20			; 00000014H
  00109	3b f4		 cmp	 esi, esp
  0010b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00110	33 c0		 xor	 eax, eax
  00112	75 a4		 jne	 SHORT $LN7@erase
$LN2@erase:
  00114	33 c9		 xor	 ecx, ecx
  00116	0f 85 49 ff ff
	ff		 jne	 $LN4@erase

; 1434 :                         && _Firstptr >= _My_data._Myfirst && _Lastptr >= _Firstptr && _Mylast >= _Lastptr,
; 1435 :             "vector erase iterator outside range");
; 1436 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1437 : 
; 1438 :         if (_Firstptr != _Lastptr) { // something to do, invalidate iterators

  0011c	8b 55 ec	 mov	 edx, DWORD PTR __Firstptr$[ebp]
  0011f	3b 55 e8	 cmp	 edx, DWORD PTR __Lastptr$[ebp]
  00122	74 45		 je	 SHORT $LN10@erase

; 1439 :             _Orphan_range(_Firstptr, _Mylast);

  00124	8b 45 e0	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00127	8b 08		 mov	 ecx, DWORD PTR [eax]
  00129	51		 push	 ecx
  0012a	8b 55 ec	 mov	 edx, DWORD PTR __Firstptr$[ebp]
  0012d	52		 push	 edx
  0012e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@IV?$allocator@I@std@@@std@@ABEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Orphan_range

; 1440 : 
; 1441 :             const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);

  00136	8b 45 ec	 mov	 eax, DWORD PTR __Firstptr$[ebp]
  00139	50		 push	 eax
  0013a	8b 4d e0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0013d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0013f	52		 push	 edx
  00140	8b 45 e8	 mov	 eax, DWORD PTR __Lastptr$[ebp]
  00143	50		 push	 eax
  00144	e8 00 00 00 00	 call	 ??$_Move_unchecked@PAIPAI@std@@YAPAIPAI00@Z ; std::_Move_unchecked<unsigned int *,unsigned int *>
  00149	83 c4 0c	 add	 esp, 12			; 0000000cH
  0014c	89 45 dc	 mov	 DWORD PTR __Newlast$2[ebp], eax

; 1442 :             _Destroy(_Newlast, _Mylast);

  0014f	8b 4d e0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00152	8b 11		 mov	 edx, DWORD PTR [ecx]
  00154	52		 push	 edx
  00155	8b 45 dc	 mov	 eax, DWORD PTR __Newlast$2[ebp]
  00158	50		 push	 eax
  00159	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0015c	e8 00 00 00 00	 call	 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1443 :             _Mylast = _Newlast;

  00161	8b 4d e0	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00164	8b 55 dc	 mov	 edx, DWORD PTR __Newlast$2[ebp]
  00167	89 11		 mov	 DWORD PTR [ecx], edx
$LN10@erase:

; 1444 :         }
; 1445 : 
; 1446 :         return iterator(_Firstptr, _STD addressof(_My_data));

  00169	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0016c	50		 push	 eax
  0016d	e8 00 00 00 00	 call	 ??$addressof@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@YAPAV?$_Vector_val@U?$_Simple_types@I@std@@@0@AAV10@@Z ; std::addressof<std::_Vector_val<std::_Simple_types<unsigned int> > >
  00172	83 c4 04	 add	 esp, 4
  00175	50		 push	 eax
  00176	8b 4d ec	 mov	 ecx, DWORD PTR __Firstptr$[ebp]
  00179	51		 push	 ecx
  0017a	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  0017d	e8 00 00 00 00	 call	 ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@PAIPBU_Container_base12@1@@Z
  00182	8d 4d 0c	 lea	 ecx, DWORD PTR __First$[ebp]
  00185	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  0018a	8d 4d 18	 lea	 ecx, DWORD PTR __Last$[ebp]
  0018d	e8 00 00 00 00	 call	 ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@std@@QAE@XZ
  00192	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1447 :     }

  00195	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00198	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0019f	59		 pop	 ecx
  001a0	5e		 pop	 esi
  001a1	83 c4 24	 add	 esp, 36			; 00000024H
  001a4	3b ec		 cmp	 ebp, esp
  001a6	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001ab	8b e5		 mov	 esp, ebp
  001ad	5d		 pop	 ebp
  001ae	c2 1c 00	 ret	 28			; 0000001cH
  001b1	cc		 int	 3
  001b2	cc		 int	 3
  001b3	cc		 int	 3
  001b4	cc		 int	 3
  001b5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e0	 mov	 ecx, DWORD PTR [edx-32]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@IV?$allocator@I@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@I@std@@@std@@@2@0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::erase
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_$S42$ = -17						; size = 1
__Alproxy$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00047	50		 push	 eax
  00048	8d 4d ef	 lea	 ecx, DWORD PTR _$S42$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  00050	8d 45 ef	 lea	 eax, DWORD PTR _$S42$[ebp]
  00053	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  00056	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0005d	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00060	51		 push	 ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0006a	83 c4 08	 add	 esp, 8
  0006d	50		 push	 eax
  0006e	8b 45 f4	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00077	83 c4 08	 add	 esp, 8

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0007a	52		 push	 edx
  0007b	8b cd		 mov	 ecx, ebp
  0007d	50		 push	 eax
  0007e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@vector
  00084	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00089	58		 pop	 eax
  0008a	5a		 pop	 edx
  0008b	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0008e	33 cd		 xor	 ecx, ebp
  00090	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00095	83 c4 1c	 add	 esp, 28			; 0000001cH
  00098	3b ec		 cmp	 ebp, esp
  0009a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009f	8b e5		 mov	 esp, ebp
  000a1	5d		 pop	 ebp
  000a2	c3		 ret	 0
  000a3	90		 npad	 1
$LN5@vector:
  000a4	01 00 00 00	 DD	 1
  000a8	00 00 00 00	 DD	 $LN4@vector
$LN4@vector:
  000ac	ef ff ff ff	 DD	 -17			; ffffffefH
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN3@vector
$LN3@vector:
  000b8	24		 DB	 36			; 00000024H
  000b9	53		 DB	 83			; 00000053H
  000ba	34		 DB	 52			; 00000034H
  000bb	32		 DB	 50			; 00000032H
  000bc	00		 DB	 0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv76 = -92						; size = 4
tv78 = -88						; size = 4
$T2 = -83						; size = 1
$T3 = -82						; size = 1
$T4 = -81						; size = 1
__Guard$5 = -76						; size = 4
__Proxy$ = -64						; size = 8
__Rightlast$ = -52					; size = 4
__Rightfirst$ = -48					; size = 4
__Right_data$ = -44					; size = 4
__My_data$ = -40					; size = 4
_$S43$ = -29						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 555  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 50	 sub	 esp, 80			; 00000050H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d a4	 lea	 edi, DWORD PTR [ebp-92]
  00019	b9 14 00 00 00	 mov	 ecx, 20			; 00000014H
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00050	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@ABEABV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00055	50		 push	 eax
  00056	8d 4d af	 lea	 ecx, DWORD PTR $T4[ebp]
  00059	51		 push	 ecx
  0005a	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
  0005f	83 c4 08	 add	 esp, 8
  00062	89 45 a4	 mov	 DWORD PTR tv76[ebp], eax
  00065	8a 55 ae	 mov	 dl, BYTE PTR $T3[ebp]
  00068	88 55 ad	 mov	 BYTE PTR $T2[ebp], dl
  0006b	8b 45 a4	 mov	 eax, DWORD PTR tv76[ebp]
  0006e	50		 push	 eax
  0006f	0f b6 4d ad	 movzx	 ecx, BYTE PTR $T2[ebp]
  00073	51		 push	 ecx
  00074	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  00077	e8 00 00 00 00	 call	 ??$?0V?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> >

; 556  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0007c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0007f	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00084	50		 push	 eax
  00085	8d 4d e3	 lea	 ecx, DWORD PTR _$S43$[ebp]
  00088	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  0008d	8d 55 e3	 lea	 edx, DWORD PTR _$S43$[ebp]
  00090	89 55 e8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 557  :         auto& _My_data            = _Mypair._Myval2;

  00093	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00096	89 45 d8	 mov	 DWORD PTR __My_data$[ebp], eax

; 558  :         const auto& _Right_data   = _Right._Mypair._Myval2;

  00099	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0009c	89 4d d4	 mov	 DWORD PTR __Right_data$[ebp], ecx

; 559  :         const pointer _Rightfirst = _Right_data._Myfirst;

  0009f	8b 55 d4	 mov	 edx, DWORD PTR __Right_data$[ebp]
  000a2	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000a5	89 45 d0	 mov	 DWORD PTR __Rightfirst$[ebp], eax

; 560  :         const pointer _Rightlast  = _Right_data._Mylast;

  000a8	8b 4d d4	 mov	 ecx, DWORD PTR __Right_data$[ebp]
  000ab	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  000ae	89 55 cc	 mov	 DWORD PTR __Rightlast$[ebp], edx

; 561  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  000b1	8b 45 d8	 mov	 eax, DWORD PTR __My_data$[ebp]
  000b4	50		 push	 eax
  000b5	8b 4d e8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000b8	51		 push	 ecx
  000b9	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000bc	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000c1	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 562  :         if (_Rightfirst != _Rightlast) {

  000c8	8b 55 d0	 mov	 edx, DWORD PTR __Rightfirst$[ebp]
  000cb	3b 55 cc	 cmp	 edx, DWORD PTR __Rightlast$[ebp]
  000ce	74 4c		 je	 SHORT $LN2@vector

; 563  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  000d0	8b 45 cc	 mov	 eax, DWORD PTR __Rightlast$[ebp]
  000d3	2b 45 d0	 sub	 eax, DWORD PTR __Rightfirst$[ebp]
  000d6	c1 f8 02	 sar	 eax, 2
  000d9	50		 push	 eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000dd	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@IV?$allocator@I@std@@@std@@AAEXI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Buy_raw

; 564  :             _Tidy_guard<vector> _Guard{this};

  000e2	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000e5	89 4d b4	 mov	 DWORD PTR __Guard$5[ebp], ecx
  000e8	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 565  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  000ec	8b 55 d8	 mov	 edx, DWORD PTR __My_data$[ebp]
  000ef	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f2	50		 push	 eax
  000f3	8b 4d cc	 mov	 ecx, DWORD PTR __Rightlast$[ebp]
  000f6	51		 push	 ecx
  000f7	8b 55 d0	 mov	 edx, DWORD PTR __Rightfirst$[ebp]
  000fa	52		 push	 edx
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000fe	e8 00 00 00 00	 call	 ??$_Ucopy@PAI@?$vector@IV?$allocator@I@std@@@std@@AAEPAIPAI00@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Ucopy<unsigned int *>
  00103	8b 4d d8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00106	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 566  :             _Guard._Target   = nullptr;

  00109	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __Guard$5[ebp], 0

; 567  :         }

  00110	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00114	8d 4d b4	 lea	 ecx, DWORD PTR __Guard$5[ebp]
  00117	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
$LN2@vector:

; 568  : 
; 569  :         _Proxy._Release();

  0011c	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0011f	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 570  :     }

  00124	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0012b	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0012e	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00133	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00136	52		 push	 edx
  00137	8b cd		 mov	 ecx, ebp
  00139	50		 push	 eax
  0013a	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@vector
  00140	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00145	58		 pop	 eax
  00146	5a		 pop	 edx
  00147	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00151	59		 pop	 ecx
  00152	5f		 pop	 edi
  00153	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	83 c4 5c	 add	 esp, 92			; 0000005cH
  00160	3b ec		 cmp	 ebp, esp
  00162	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00167	8b e5		 mov	 esp, ebp
  00169	5d		 pop	 ebp
  0016a	c2 04 00	 ret	 4
  0016d	0f 1f 00	 npad	 3
$LN11@vector:
  00170	03 00 00 00	 DD	 3
  00174	00 00 00 00	 DD	 $LN10@vector
$LN10@vector:
  00178	e3 ff ff ff	 DD	 -29			; ffffffe3H
  0017c	01 00 00 00	 DD	 1
  00180	00 00 00 00	 DD	 $LN6@vector
  00184	c0 ff ff ff	 DD	 -64			; ffffffc0H
  00188	08 00 00 00	 DD	 8
  0018c	00 00 00 00	 DD	 $LN7@vector
  00190	b4 ff ff ff	 DD	 -76			; ffffffb4H
  00194	04 00 00 00	 DD	 4
  00198	00 00 00 00	 DD	 $LN8@vector
$LN8@vector:
  0019c	5f		 DB	 95			; 0000005fH
  0019d	47		 DB	 71			; 00000047H
  0019e	75		 DB	 117			; 00000075H
  0019f	61		 DB	 97			; 00000061H
  001a0	72		 DB	 114			; 00000072H
  001a1	64		 DB	 100			; 00000064H
  001a2	00		 DB	 0
$LN7@vector:
  001a3	5f		 DB	 95			; 0000005fH
  001a4	50		 DB	 80			; 00000050H
  001a5	72		 DB	 114			; 00000072H
  001a6	6f		 DB	 111			; 0000006fH
  001a7	78		 DB	 120			; 00000078H
  001a8	79		 DB	 121			; 00000079H
  001a9	00		 DB	 0
$LN6@vector:
  001aa	24		 DB	 36			; 00000024H
  001ab	53		 DB	 83			; 00000053H
  001ac	34		 DB	 52			; 00000034H
  001ad	33		 DB	 51			; 00000033H
  001ae	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 4d c0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z$1:
  00008	8d 4d b4	 lea	 ecx, DWORD PTR __Guard$5[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@IV?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >::~_Tidy_guard<std::vector<unsigned int,std::allocator<unsigned int> > >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a a8	 mov	 ecx, DWORD PTR [edx-88]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
$T1 = -5						; size = 1
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 508  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  0002e	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00031	51		 push	 ecx
  00032	0f b6 55 fb	 movzx	 edx, BYTE PTR $T1[ebp]
  00036	52		 push	 edx
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  0003a	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@I@std@@$$V@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@I@1@@Z ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1><std::allocator<unsigned int> const &>

; 509  :         _Construct_n_copies_of_ty(_Count, _Val);

  0003f	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00042	50		 push	 eax
  00043	8b 4d 08	 mov	 ecx, DWORD PTR __Count$[ebp]
  00046	51		 push	 ecx
  00047	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??$_Construct_n_copies_of_ty@I@?$vector@IV?$allocator@I@std@@@std@@AAEXIABI@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Construct_n_copies_of_ty<unsigned int>

; 510  :     }

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c4 0c	 add	 esp, 12			; 0000000cH
  00055	3b ec		 cmp	 ebp, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 0c 00	 ret	 12			; 0000000cH
??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z PROC	; std::_Vb_val<std::allocator<bool> >::_Nw, COMDAT

; 2472 :     static _CONSTEXPR20_CONTAINER size_type _Nw(size_type _Count) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2473 :         return (_Count + _VBITS - 1) / _VBITS;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00010	83 c0 1f	 add	 eax, 31			; 0000001fH
  00013	c1 e8 05	 shr	 eax, 5

; 2474 :     }

  00016	3b ec		 cmp	 ebp, esp
  00018	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ENDP	; std::_Vb_val<std::allocator<bool> >::_Nw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ PROC ; std::_Vb_val<std::allocator<bool> >::_Getal, COMDAT
; _this$ = ecx

; 2464 :     _CONSTEXPR20_CONTAINER _Alvbase& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2465 :         return _Myvec._Getal();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	83 c1 04	 add	 ecx, 4
  0001e	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal

; 2466 :     }

  00023	83 c4 04	 add	 esp, 4
  00026	3b ec		 cmp	 ebp, esp
  00028	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c3		 ret	 0
?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -28						; size = 4
_$S39$ = -17						; size = 1
__Alproxy$ = -12					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2456 :     _CONSTEXPR20_CONTAINER ~_Vb_val() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  0000e	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00011	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00014	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00017	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  0001a	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  0001d	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2457 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2458 :         this->_Orphan_all();

  00037	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2459 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alvbase, this->_Getal());

  0003f	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00042	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  00047	50		 push	 eax
  00048	8d 4d ef	 lea	 ecx, DWORD PTR _$S39$[ebp]
  0004b	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  00050	8d 45 ef	 lea	 eax, DWORD PTR _$S39$[ebp]
  00053	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2460 :         _Delete_plain_internal(_Alproxy, _STD exchange(this->_Myproxy, nullptr));

  00056	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  0005d	8d 4d e4	 lea	 ecx, DWORD PTR $T1[ebp]
  00060	51		 push	 ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  0006a	83 c4 08	 add	 esp, 8
  0006d	50		 push	 eax
  0006e	8b 45 f4	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  00071	50		 push	 eax
  00072	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00077	83 c4 08	 add	 esp, 8

; 2461 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2462 :     }

  0007a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	83 c1 04	 add	 ecx, 4
  00080	e8 00 00 00 00	 call	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  00085	52		 push	 edx
  00086	8b cd		 mov	 ecx, ebp
  00088	50		 push	 eax
  00089	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Vb_val
  0008f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00094	58		 pop	 eax
  00095	5a		 pop	 edx
  00096	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00099	33 cd		 xor	 ecx, ebp
  0009b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000a0	83 c4 1c	 add	 esp, 28			; 0000001cH
  000a3	3b ec		 cmp	 ebp, esp
  000a5	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000aa	8b e5		 mov	 esp, ebp
  000ac	5d		 pop	 ebp
  000ad	c3		 ret	 0
  000ae	66 90		 npad	 2
$LN5@Vb_val:
  000b0	01 00 00 00	 DD	 1
  000b4	00 00 00 00	 DD	 $LN4@Vb_val
$LN4@Vb_val:
  000b8	ef ff ff ff	 DD	 -17			; ffffffefH
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN3@Vb_val
$LN3@Vb_val:
  000c4	24		 DB	 36			; 00000024H
  000c5	53		 DB	 83			; 00000053H
  000c6	33		 DB	 51			; 00000033H
  000c7	39		 DB	 57			; 00000039H
  000c8	00		 DB	 0
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv75 = -24						; size = 4
$T2 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2431 :     _CONSTEXPR20_CONTAINER _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00014	c7 45 e8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-24], -858993460 ; ccccccccH
  0001b	c7 45 ec cc cc
	cc cc		 mov	 DWORD PTR [ebp-20], -858993460 ; ccccccccH
  00022	c7 45 f0 cc cc
	cc cc		 mov	 DWORD PTR [ebp-16], -858993460 ; ccccccccH
  00029	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002e	33 c5		 xor	 eax, ebp
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0004a	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0004f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00052	83 c0 04	 add	 eax, 4
  00055	89 45 e8	 mov	 DWORD PTR tv75[ebp], eax
  00058	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0005b	83 c1 04	 add	 ecx, 4
  0005e	51		 push	 ecx
  0005f	8b 4d e8	 mov	 ecx, DWORD PTR tv75[ebp]
  00062	e8 00 00 00 00	 call	 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@ABV01@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
  00067	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0006e	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00071	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00074	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00077	89 4a 14	 mov	 DWORD PTR [edx+20], ecx

; 2432 :         this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));

  0007a	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007d	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  00082	50		 push	 eax
  00083	8d 4d ef	 lea	 ecx, DWORD PTR $T2[ebp]
  00086	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  0008b	50		 push	 eax
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2433 :     }

  00094	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a1	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000a8	59		 pop	 ecx
  000a9	83 c4 18	 add	 esp, 24			; 00000018H
  000ac	3b ec		 cmp	 ebp, esp
  000ae	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b3	8b e5		 mov	 esp, ebp
  000b5	5d		 pop	 ebp
  000b6	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a f0	 mov	 ecx, DWORD PTR [edx-16]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
_TEXT	SEGMENT
tv84 = -44						; size = 4
tv78 = -40						; size = 4
tv86 = -36						; size = 4
tv88 = -32						; size = 4
$T2 = -25						; size = 1
$T3 = -24						; size = 4
$T4 = -17						; size = 1
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
__Al$ = 16						; size = 4
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z PROC ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2427 :         : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 20	 sub	 esp, 32			; 00000020H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 d4	 mov	 DWORD PTR [ebp-44], eax
  0001c	89 45 d8	 mov	 DWORD PTR [ebp-40], eax
  0001f	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  00022	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00025	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00028	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  0002b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0002e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00036	33 c5		 xor	 eax, ebp
  00038	50		 push	 eax
  00039	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00042	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00045	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0004a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0004f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00052	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	83 c0 04	 add	 eax, 4
  0005d	89 45 e0	 mov	 DWORD PTR tv88[ebp], eax
  00060	8b 4d 10	 mov	 ecx, DWORD PTR __Al$[ebp]
  00063	51		 push	 ecx
  00064	8d 4d ef	 lea	 ecx, DWORD PTR $T4[ebp]
  00067	e8 00 00 00 00	 call	 ??$?0_N@?$allocator@I@std@@QAE@ABV?$allocator@_N@1@@Z ; std::allocator<unsigned int>::allocator<unsigned int><bool>
  0006c	89 45 dc	 mov	 DWORD PTR tv86[ebp], eax
  0006f	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  00072	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00075	85 c0		 test	 eax, eax
  00077	74 09		 je	 SHORT $LN3@Vb_val
  00079	c7 45 d8 ff ff
	ff ff		 mov	 DWORD PTR tv78[ebp], -1
  00080	eb 07		 jmp	 SHORT $LN4@Vb_val
$LN3@Vb_val:
  00082	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
$LN4@Vb_val:
  00089	8b 4d d8	 mov	 ecx, DWORD PTR tv78[ebp]
  0008c	89 4d e8	 mov	 DWORD PTR $T3[ebp], ecx
  0008f	8b 55 08	 mov	 edx, DWORD PTR __Count$[ebp]
  00092	52		 push	 edx
  00093	e8 00 00 00 00	 call	 ?_Nw@?$_Vb_val@V?$allocator@_N@std@@@std@@SAII@Z ; std::_Vb_val<std::allocator<bool> >::_Nw
  00098	83 c4 04	 add	 esp, 4
  0009b	89 45 d4	 mov	 DWORD PTR tv84[ebp], eax
  0009e	8b 45 dc	 mov	 eax, DWORD PTR tv86[ebp]
  000a1	50		 push	 eax
  000a2	8d 4d e8	 lea	 ecx, DWORD PTR $T3[ebp]
  000a5	51		 push	 ecx
  000a6	8b 55 d4	 mov	 edx, DWORD PTR tv84[ebp]
  000a9	52		 push	 edx
  000aa	8b 4d e0	 mov	 ecx, DWORD PTR tv88[ebp]
  000ad	e8 00 00 00 00	 call	 ??0?$vector@IV?$allocator@I@std@@@std@@QAE@IABIABV?$allocator@I@1@@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::vector<unsigned int,std::allocator<unsigned int> >
  000b2	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000b9	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000bc	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2428 :         this->_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));

  000c3	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  000cb	50		 push	 eax
  000cc	8d 4d e7	 lea	 ecx, DWORD PTR $T2[ebp]
  000cf	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  000d4	50		 push	 eax
  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >

; 2429 :     }

  000dd	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000e4	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000e7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ea	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f1	59		 pop	 ecx
  000f2	83 c4 2c	 add	 esp, 44			; 0000002cH
  000f5	3b ec		 cmp	 ebp, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z$0:
  00000	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	83 c1 04	 add	 ecx, 4
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 4a dc	 mov	 ecx, DWORD PTR [edx-36]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@IAB_NABV?$allocator@_N@1@@Z ENDP ; std::_Vb_val<std::allocator<bool> >::_Vb_val<std::allocator<bool> >
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction, COMDAT

; 731  :     _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :         return _Al;

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 733  :     }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SA?AV?$allocator@I@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@I@std@@@std@@SAIABV?$allocator@I@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<unsigned int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@I@std@@QAEPAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@I@std@@QAEPAII@Z PROC		; std::allocator<unsigned int>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00018	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0002a	83 c4 04	 add	 esp, 4

; 840  :     }

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?allocate@?$allocator@I@std@@QAEPAII@Z ENDP		; std::allocator<unsigned int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXQAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXQAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	c1 e0 02	 shl	 eax, 2
  0001e	50		 push	 eax
  0001f	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00028	83 c4 08	 add	 esp, 8

; 836  :     }

  0002b	83 c4 04	 add	 esp, 4
  0002e	3b ec		 cmp	 ebp, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	8b e5		 mov	 esp, ebp
  00037	5d		 pop	 ebp
  00038	c2 08 00	 ret	 8
?deallocate@?$allocator@I@std@@QAEXQAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@_N@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@_N@std@@QAE@XZ PROC			; std::allocator<bool>::allocator<bool>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$allocator@_N@std@@QAE@XZ ENDP			; std::allocator<bool>::allocator<bool>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
tv65 = -8						; size = 4
$T1 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 42   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :     // return larger of _Left and _Right
; 44   :     return _Left < _Right ? _Right : _Left;

  0001e	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00021	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00024	8b 10		 mov	 edx, DWORD PTR [eax]
  00026	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00028	73 08		 jae	 SHORT $LN3@max
  0002a	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0002d	89 45 f8	 mov	 DWORD PTR tv65[ebp], eax
  00030	eb 06		 jmp	 SHORT $LN4@max
$LN3@max:
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  00035	89 4d f8	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  00038	8b 55 f8	 mov	 edx, DWORD PTR tv65[ebp]
  0003b	89 55 fc	 mov	 DWORD PTR $T1[ebp], edx
  0003e	8b 45 fc	 mov	 eax, DWORD PTR $T1[ebp]

; 45   : }

  00041	83 c4 08	 add	 esp, 8
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Graphics\Rect.inl
;	COMDAT ??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_position$ = 8						; size = 4
_size$ = 12						; size = 4
??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z PROC		; sf::Rect<int>::Rect<int>, COMDAT
; _this$ = ecx

; 57   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C23CD225_Rect@inl
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 53   : left  (position.x),

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  0001e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00020	89 10		 mov	 DWORD PTR [eax], edx

; 54   : top   (position.y),

  00022	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00025	8b 4d 08	 mov	 ecx, DWORD PTR _position$[ebp]
  00028	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0002b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 55   : width (size.x),

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  00034	8b 11		 mov	 edx, DWORD PTR [ecx]
  00036	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 56   : height(size.y)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003c	8b 4d 0c	 mov	 ecx, DWORD PTR _size$[ebp]
  0003f	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00042	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 58   : 
; 59   : }

  00045	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 08 00	 ret	 8
??0?$Rect@H@sf@@QAE@ABV?$Vector2@H@1@0@Z ENDP		; sf::Rect<int>::Rect<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 44
_this$ = -4						; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  00026	8b f4		 mov	 esi, esp
  00028	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0003f	83 c7 18	 add	 edi, 24			; 00000018H
  00042	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00047	8b f0		 mov	 esi, eax
  00049	f3 a5		 rep movsd

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	85 c9		 test	 ecx, ecx
  00052	74 57		 je	 SHORT $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  00054	8b f4		 mov	 esi, esp
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0006c	83 c4 04	 add	 esp, 4
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00072	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 178  :             _Months =

  00075	8b f4		 mov	 esi, esp
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  00080	3b f4		 cmp	 esi, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00096	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  0009b	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  000a0	83 c4 04	 add	 esp, 4
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 181  :         } else {

  000a9	eb 70		 jmp	 SHORT $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	83 c0 18	 add	 eax, 24			; 00000018H
  000b1	50		 push	 eax
  000b2	6a 00		 push	 0
  000b4	8b f4		 mov	 esi, esp
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  000d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	83 c2 18	 add	 edx, 24			; 00000018H
  000db	52		 push	 edx
  000dc	6a 00		 push	 0
  000de	8b f4		 mov	 esi, esp
  000e0	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000e9	3b f4		 cmp	 esi, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  000ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00102	83 c2 18	 add	 edx, 24			; 00000018H
  00105	52		 push	 edx
  00106	6a 00		 push	 0
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  0010d	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	83 c4 30	 add	 esp, 48			; 00000030H
  00120	3b ec		 cmp	 ebp, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 44
_this$ = -4						; size = 4
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	51		 push	 ecx
  00009	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000c	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00011	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00016	f3 ab		 rep stosd
  00018	59		 pop	 ecx
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  00026	8b f4		 mov	 esi, esp
  00028	8d 45 d0	 lea	 eax, DWORD PTR $T1[ebp]
  0002b	50		 push	 eax
  0002c	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0002f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b 7d fc	 mov	 edi, DWORD PTR _this$[ebp]
  0003f	83 c7 18	 add	 edi, 24			; 00000018H
  00042	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00047	8b f0		 mov	 esi, eax
  00049	f3 a5		 rep movsd

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0004b	b9 01 00 00 00	 mov	 ecx, 1
  00050	85 c9		 test	 ecx, ecx
  00052	74 57		 je	 SHORT $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  00054	8b f4		 mov	 esi, esp
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  00059	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  0005f	3b f4		 cmp	 esi, esp
  00061	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0006c	83 c4 04	 add	 esp, 4
  0006f	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00072	89 42 08	 mov	 DWORD PTR [edx+8], eax

; 178  :             _Months =

  00075	8b f4		 mov	 esi, esp
  00077	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  00080	3b f4		 cmp	 esi, esp
  00082	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00087	50		 push	 eax
  00088	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0008d	83 c4 04	 add	 esp, 4
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00096	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  0009b	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  000a0	83 c4 04	 add	 esp, 4
  000a3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000a6	89 42 10	 mov	 DWORD PTR [edx+16], eax

; 181  :         } else {

  000a9	eb 70		 jmp	 SHORT $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  000ab	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  000ae	83 c0 18	 add	 eax, 24			; 00000018H
  000b1	50		 push	 eax
  000b2	6a 00		 push	 0
  000b4	8b f4		 mov	 esi, esp
  000b6	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000b9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  000bf	3b f4		 cmp	 esi, esp
  000c1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c6	50		 push	 eax
  000c7	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000cc	83 c4 0c	 add	 esp, 12			; 0000000cH
  000cf	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d2	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  000d5	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d8	83 c2 18	 add	 edx, 24			; 00000018H
  000db	52		 push	 edx
  000dc	6a 00		 push	 0
  000de	8b f4		 mov	 esi, esp
  000e0	8b 4d 0c	 mov	 ecx, DWORD PTR __Lobj$[ebp]
  000e3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  000e9	3b f4		 cmp	 esi, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	50		 push	 eax
  000f1	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  000f6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f9	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000fc	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  000ff	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00102	83 c2 18	 add	 edx, 24			; 00000018H
  00105	52		 push	 edx
  00106	6a 00		 push	 0
  00108	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  0010d	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  00112	83 c4 0c	 add	 esp, 12			; 0000000cH
  00115	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00118	89 41 10	 mov	 DWORD PTR [ecx+16], eax
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0011b	5f		 pop	 edi
  0011c	5e		 pop	 esi
  0011d	83 c4 30	 add	 esp, 48			; 00000030H
  00120	3b ec		 cmp	 ebp, esp
  00122	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Ptrnext$1 = -12					; size = 4
__Ptrdest$ = -8						; size = 4
__Count$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00021	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _strlen
  0002f	83 c4 04	 add	 esp, 4
  00032	83 c0 01	 add	 eax, 1
  00035	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00038	8b f4		 mov	 esi, esp
  0003a	68 0e 02 00 00	 push	 526			; 0000020eH
  0003f	68 00 00 00 00	 push	 OFFSET $SG256761
  00044	6a 02		 push	 2
  00046	6a 01		 push	 1
  00048	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004b	51		 push	 ecx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00052	83 c4 14	 add	 esp, 20			; 00000014H
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	89 45 f8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 527  : 
; 528  :     if (!_Ptrdest) {

  0005f	83 7d f8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00063	75 05		 jne	 SHORT $LN5@Maklocstr

; 529  :         _Xbad_alloc();

  00065	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0006a	8b 55 f8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  0006d	89 55 f4	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  00070	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00072	8b 45 fc	 mov	 eax, DWORD PTR __Count$[ebp]
  00075	83 e8 01	 sub	 eax, 1
  00078	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0007e	83 c1 01	 add	 ecx, 1
  00081	89 4d f4	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00084	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00087	83 c2 01	 add	 edx, 1
  0008a	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0008d	83 7d fc 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00091	76 0c		 jbe	 SHORT $LN3@Maklocstr

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00093	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  00096	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00099	8a 11		 mov	 dl, BYTE PTR [ecx]
  0009b	88 10		 mov	 BYTE PTR [eax], dl

; 534  :     }

  0009d	eb d3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 535  : 
; 536  :     return _Ptrdest;

  0009f	8b 45 f8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 537  : }

  000a2	5e		 pop	 esi
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Ptrdest$ = -8						; size = 4
__Count$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	56		 push	 esi
  00007	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000e	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00015	b9 00 00 00 00	 mov	 ecx, OFFSET __4CB88277_xlocnum
  0001a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  0001f	8b f4		 mov	 esi, esp
  00021	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00024	50		 push	 eax
  00025	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0002b	83 c4 04	 add	 esp, 4
  0002e	3b f4		 cmp	 esi, esp
  00030	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00035	83 c0 01	 add	 eax, 1
  00038	89 45 fc	 mov	 DWORD PTR __Count$[ebp], eax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  0003b	8b f4		 mov	 esi, esp
  0003d	6a 5d		 push	 93			; 0000005dH
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00044	6a 02		 push	 2
  00046	6a 02		 push	 2
  00048	8b 4d fc	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004b	51		 push	 ecx
  0004c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00052	83 c4 14	 add	 esp, 20			; 00000014H
  00055	3b f4		 cmp	 esi, esp
  00057	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005c	89 45 f8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 94   : 
; 95   :     if (!_Ptrdest) {

  0005f	83 7d f8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00063	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  00065	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  0006a	8b 55 fc	 mov	 edx, DWORD PTR __Count$[ebp]
  0006d	52		 push	 edx
  0006e	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00071	50		 push	 eax
  00072	8b 4d f8	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00075	51		 push	 ecx
  00076	e8 00 00 00 00	 call	 _wmemcpy
  0007b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :     return _Ptrdest;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 101  : }

  00081	5e		 pop	 esi
  00082	83 c4 08	 add	 esp, 8
  00085	3b ec		 cmp	 ebp, esp
  00087	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__Mbst2$ = -72						; size = 8
__Ptrnext$ = -60					; size = 4
__Ptrdest$ = -56					; size = 4
__Mbst1$ = -48						; size = 8
__Wc$ = -32						; size = 2
__Bytes$ = -24						; size = 4
__Ptr1$ = -20						; size = 4
__Wchars$ = -16						; size = 4
__Count1$ = -12						; size = 4
__Count$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 540  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	56		 push	 esi
  00007	57		 push	 edi
  00008	8d 7d b4	 lea	 edi, DWORD PTR [ebp-76]
  0000b	b9 13 00 00 00	 mov	 ecx, 19			; 00000013H
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001c	33 c5		 xor	 eax, ebp
  0001e	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00021	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00026	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 541  :     // convert C string to wchar_t sequence using _Cvtvec
; 542  :     size_t _Count;
; 543  :     size_t _Count1;
; 544  :     size_t _Wchars;
; 545  :     const char* _Ptr1;
; 546  :     int _Bytes;
; 547  :     wchar_t _Wc;
; 548  :     mbstate_t _Mbst1 = {};

  0002b	33 c0		 xor	 eax, eax
  0002d	89 45 d0	 mov	 DWORD PTR __Mbst1$[ebp], eax
  00030	89 45 d4	 mov	 DWORD PTR __Mbst1$[ebp+4], eax

; 549  : 
; 550  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  00033	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 _strlen
  0003c	83 c4 04	 add	 esp, 4
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 f4	 mov	 DWORD PTR __Count1$[ebp], eax

; 551  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  00045	8b 55 f4	 mov	 edx, DWORD PTR __Count1$[ebp]
  00048	89 55 f8	 mov	 DWORD PTR __Count$[ebp], edx
  0004b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  00052	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00055	89 45 ec	 mov	 DWORD PTR __Ptr1$[ebp], eax
  00058	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  0005a	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005d	2b 4d e8	 sub	 ecx, DWORD PTR __Bytes$[ebp]
  00060	89 4d f8	 mov	 DWORD PTR __Count$[ebp], ecx
  00063	8b 55 ec	 mov	 edx, DWORD PTR __Ptr1$[ebp]
  00066	03 55 e8	 add	 edx, DWORD PTR __Bytes$[ebp]
  00069	89 55 ec	 mov	 DWORD PTR __Ptr1$[ebp], edx
  0006c	8b 45 f0	 mov	 eax, DWORD PTR __Wchars$[ebp]
  0006f	83 c0 01	 add	 eax, 1
  00072	89 45 f0	 mov	 DWORD PTR __Wchars$[ebp], eax
$LN4@Maklocstr:
  00075	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00079	76 29		 jbe	 SHORT $LN3@Maklocstr

; 552  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  0007b	8b 4d 10	 mov	 ecx, DWORD PTR __Cvt$[ebp]
  0007e	51		 push	 ecx
  0007f	8d 55 d0	 lea	 edx, DWORD PTR __Mbst1$[ebp]
  00082	52		 push	 edx
  00083	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00086	50		 push	 eax
  00087	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr1$[ebp]
  0008a	51		 push	 ecx
  0008b	8d 55 e0	 lea	 edx, DWORD PTR __Wc$[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 __Mbrtowc
  00094	83 c4 14	 add	 esp, 20			; 00000014H
  00097	89 45 e8	 mov	 DWORD PTR __Bytes$[ebp], eax
  0009a	83 7d e8 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0009e	7f 02		 jg	 SHORT $LN8@Maklocstr

; 553  :             break;

  000a0	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 554  :         }
; 555  :     }

  000a2	eb b6		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 556  : 
; 557  :     ++_Wchars; // count terminating nul

  000a4	8b 45 f0	 mov	 eax, DWORD PTR __Wchars$[ebp]
  000a7	83 c0 01	 add	 eax, 1
  000aa	89 45 f0	 mov	 DWORD PTR __Wchars$[ebp], eax

; 558  : 
; 559  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  000ad	8b f4		 mov	 esi, esp
  000af	68 2f 02 00 00	 push	 559			; 0000022fH
  000b4	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000b9	6a 02		 push	 2
  000bb	6a 02		 push	 2
  000bd	8b 4d f0	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  000c0	51		 push	 ecx
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  000c7	83 c4 14	 add	 esp, 20			; 00000014H
  000ca	3b f4		 cmp	 esi, esp
  000cc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d1	89 45 c8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 560  : 
; 561  :     if (!_Ptrdest) {

  000d4	83 7d c8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  000d8	75 05		 jne	 SHORT $LN9@Maklocstr

; 562  :         _Xbad_alloc();

  000da	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 563  :     }
; 564  : 
; 565  :     wchar_t* _Ptrnext = _Ptrdest;

  000df	8b 55 c8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  000e2	89 55 c4	 mov	 DWORD PTR __Ptrnext$[ebp], edx

; 566  :     mbstate_t _Mbst2  = {};

  000e5	33 c0		 xor	 eax, eax
  000e7	89 45 b8	 mov	 DWORD PTR __Mbst2$[ebp], eax
  000ea	89 45 bc	 mov	 DWORD PTR __Mbst2$[ebp+4], eax

; 567  : 
; 568  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  000ed	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  000f2	2b 4d e8	 sub	 ecx, DWORD PTR __Bytes$[ebp]
  000f5	89 4d f8	 mov	 DWORD PTR __Count$[ebp], ecx
  000f8	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  000fb	03 55 e8	 add	 edx, DWORD PTR __Bytes$[ebp]
  000fe	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
  00101	8b 45 f0	 mov	 eax, DWORD PTR __Wchars$[ebp]
  00104	83 e8 01	 sub	 eax, 1
  00107	89 45 f0	 mov	 DWORD PTR __Wchars$[ebp], eax
  0010a	8b 4d c4	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  0010d	83 c1 02	 add	 ecx, 2
  00110	89 4d c4	 mov	 DWORD PTR __Ptrnext$[ebp], ecx
$LN7@Maklocstr:
  00113	83 7d f0 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  00117	76 29		 jbe	 SHORT $LN6@Maklocstr

; 569  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00119	8b 55 10	 mov	 edx, DWORD PTR __Cvt$[ebp]
  0011c	52		 push	 edx
  0011d	8d 45 b8	 lea	 eax, DWORD PTR __Mbst2$[ebp]
  00120	50		 push	 eax
  00121	8b 4d f4	 mov	 ecx, DWORD PTR __Count1$[ebp]
  00124	51		 push	 ecx
  00125	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00128	52		 push	 edx
  00129	8b 45 c4	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  0012c	50		 push	 eax
  0012d	e8 00 00 00 00	 call	 __Mbrtowc
  00132	83 c4 14	 add	 esp, 20			; 00000014H
  00135	89 45 e8	 mov	 DWORD PTR __Bytes$[ebp], eax
  00138	83 7d e8 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  0013c	7f 02		 jg	 SHORT $LN10@Maklocstr

; 570  :             break;

  0013e	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 571  :         }
; 572  :     }

  00140	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 573  : 
; 574  :     *_Ptrnext = L'\0';

  00142	33 c9		 xor	 ecx, ecx
  00144	8b 55 c4	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  00147	66 89 0a	 mov	 WORD PTR [edx], cx

; 575  : 
; 576  :     return _Ptrdest;

  0014a	8b 45 c8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN11@Maklocstr:

; 577  : }

  0014d	52		 push	 edx
  0014e	8b cd		 mov	 ecx, ebp
  00150	50		 push	 eax
  00151	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN16@Maklocstr
  00157	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0015c	58		 pop	 eax
  0015d	5a		 pop	 edx
  0015e	5f		 pop	 edi
  0015f	5e		 pop	 esi
  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	33 cd		 xor	 ecx, ebp
  00165	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016a	83 c4 4c	 add	 esp, 76			; 0000004cH
  0016d	3b ec		 cmp	 ebp, esp
  0016f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00174	8b e5		 mov	 esp, ebp
  00176	5d		 pop	 ebp
  00177	c3		 ret	 0
$LN16@Maklocstr:
  00178	03 00 00 00	 DD	 3
  0017c	00 00 00 00	 DD	 $LN15@Maklocstr
$LN15@Maklocstr:
  00180	e0 ff ff ff	 DD	 -32			; ffffffe0H
  00184	02 00 00 00	 DD	 2
  00188	00 00 00 00	 DD	 $LN12@Maklocstr
  0018c	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00190	08 00 00 00	 DD	 8
  00194	00 00 00 00	 DD	 $LN13@Maklocstr
  00198	b8 ff ff ff	 DD	 -72			; ffffffb8H
  0019c	08 00 00 00	 DD	 8
  001a0	00 00 00 00	 DD	 $LN14@Maklocstr
$LN14@Maklocstr:
  001a4	5f		 DB	 95			; 0000005fH
  001a5	4d		 DB	 77			; 0000004dH
  001a6	62		 DB	 98			; 00000062H
  001a7	73		 DB	 115			; 00000073H
  001a8	74		 DB	 116			; 00000074H
  001a9	32		 DB	 50			; 00000032H
  001aa	00		 DB	 0
$LN13@Maklocstr:
  001ab	5f		 DB	 95			; 0000005fH
  001ac	4d		 DB	 77			; 0000004dH
  001ad	62		 DB	 98			; 00000062H
  001ae	73		 DB	 115			; 00000073H
  001af	74		 DB	 116			; 00000074H
  001b0	31		 DB	 49			; 00000031H
  001b1	00		 DB	 0
$LN12@Maklocstr:
  001b2	5f		 DB	 95			; 0000005fH
  001b3	57		 DB	 87			; 00000057H
  001b4	63		 DB	 99			; 00000063H
  001b5	00		 DB	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABI@std@@YAABIABI@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABI@std@@YAABIABI@Z PROC			; std::forward<unsigned int const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$forward@ABI@std@@YAABIABI@Z ENDP			; std::forward<unsigned int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1invalid_argument@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1invalid_argument@std@@UAE@XZ PROC			; std::invalid_argument::~invalid_argument, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1logic_error@std@@UAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1invalid_argument@std@@UAE@XZ ENDP			; std::invalid_argument::~invalid_argument
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4654 :     _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4655 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4656 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4650 :     _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4651 :         return _Mypair._Get_first();

  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4652 :     }

  00020	83 c4 04	 add	 esp, 4
  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -33						; size = 1
__Raw_new$3 = -32					; size = 4
__New_ptr$4 = -28					; size = 4
__Al$5 = -24						; size = 4
__My_data$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4594 :     _CONSTEXPR20_CONTAINER void _Tidy_init() noexcept { // initialize basic_string data members

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 18	 sub	 esp, 24			; 00000018H
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0001c	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  0001f	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00022	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00025	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  00028	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4595 :         auto& _My_data   = _Mypair._Myval2;

  00049	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	89 45 ec	 mov	 DWORD PTR __My_data$[ebp], eax

; 4596 :         _My_data._Mysize = 0;

  0004f	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00052	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {

  00059	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0005e	0f b6 d0	 movzx	 edx, al
  00061	85 d2		 test	 edx, edx
  00063	74 4c		 je	 SHORT $LN2@Tidy_init

; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context

  00065	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  00068	c7 40 18 10 00
	00 00		 mov	 DWORD PTR [eax+24], 16	; 00000010H

; 4601 :             auto& _Al              = _Getal();

  0006f	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00077	89 45 e8	 mov	 DWORD PTR __Al$5[ebp], eax

; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws

  0007a	6a 11		 push	 17			; 00000011H
  0007c	8b 4d e8	 mov	 ecx, DWORD PTR __Al$5[ebp]
  0007f	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  00084	89 45 e4	 mov	 DWORD PTR __New_ptr$4[ebp], eax

; 4603 :             _My_data._Bx._Ptr      = _New_ptr;

  00087	8b 4d ec	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0008a	8b 55 e4	 mov	 edx, DWORD PTR __New_ptr$4[ebp]
  0008d	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);

  00090	8b 45 e4	 mov	 eax, DWORD PTR __New_ptr$4[ebp]
  00093	50		 push	 eax
  00094	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00099	83 c4 04	 add	 esp, 4
  0009c	89 45 e0	 mov	 DWORD PTR __Raw_new$3[ebp], eax

; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());

  0009f	6a 00		 push	 0
  000a1	6a 11		 push	 17			; 00000011H
  000a3	8b 4d e0	 mov	 ecx, DWORD PTR __Raw_new$3[ebp]
  000a6	51		 push	 ecx
  000a7	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  000ac	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4607 :         } else

  000af	eb 2a		 jmp	 SHORT $LN4@Tidy_init
$LN2@Tidy_init:

; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  000b1	8b 55 ec	 mov	 edx, DWORD PTR __My_data$[ebp]
  000b4	c7 42 18 0f 00
	00 00		 mov	 DWORD PTR [edx+24], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000bb	c6 45 df 00	 mov	 BYTE PTR $T2[ebp], 0
  000bf	8d 45 df	 lea	 eax, DWORD PTR $T2[ebp]
  000c2	50		 push	 eax
  000c3	b9 01 00 00 00	 mov	 ecx, 1
  000c8	6b d1 00	 imul	 edx, ecx, 0
  000cb	8b 45 ec	 mov	 eax, DWORD PTR __My_data$[ebp]
  000ce	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000d2	51		 push	 ecx
  000d3	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000d8	83 c4 08	 add	 esp, 8
$LN4@Tidy_init:

; 4613 :         }
; 4614 :     }

  000db	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000de	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000e5	59		 pop	 ecx
  000e6	83 c4 24	 add	 esp, 36			; 00000024H
  000e9	3b ec		 cmp	 ebp, esp
  000eb	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f0	8b e5		 mov	 esp, ebp
  000f2	5d		 pop	 ebp
  000f3	c3		 ret	 0
  000f4	cc		 int	 3
  000f5	cc		 int	 3
  000f6	cc		 int	 3
  000f7	cc		 int	 3
  000f8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e4	 mov	 ecx, DWORD PTR [edx-28]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
tv74 = -12						; size = 4
tv76 = -8						; size = 4
_this$ = -4						; size = 4
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4500 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4501 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00030	89 45 f8	 mov	 DWORD PTR tv76[ebp], eax
  00033	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00036	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00039	89 4d f4	 mov	 DWORD PTR tv74[ebp], ecx
  0003c	8b 55 f8	 mov	 edx, DWORD PTR tv76[ebp]
  0003f	52		 push	 edx
  00040	8b 45 f4	 mov	 eax, DWORD PTR tv74[ebp]
  00043	50		 push	 eax
  00044	8b 4d 08	 mov	 ecx, DWORD PTR __Requested$[ebp]
  00047	51		 push	 ecx
  00048	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  0004d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4502 :     }

  00050	83 c4 0c	 add	 esp, 12			; 0000000cH
  00053	3b ec		 cmp	 ebp, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
__Masked$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4487 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000e	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00011	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00014	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00017	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001f	33 c5		 xor	 eax, ebp
  00021	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00024	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00029	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  0002e	8b 45 08	 mov	 eax, DWORD PTR __Requested$[ebp]
  00031	83 c8 0f	 or	 eax, 15			; 0000000fH
  00034	89 45 f4	 mov	 DWORD PTR __Masked$[ebp], eax

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  00037	8b 4d f4	 mov	 ecx, DWORD PTR __Masked$[ebp]
  0003a	3b 4d 10	 cmp	 ecx, DWORD PTR __Max$[ebp]
  0003d	76 05		 jbe	 SHORT $LN2@Calculate_

; 4490 :             return _Max;

  0003f	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00042	eb 31		 jmp	 SHORT $LN4@Calculate_
$LN2@Calculate_:

; 4491 :         }
; 4492 : 
; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  00044	8b 55 0c	 mov	 edx, DWORD PTR __Old$[ebp]
  00047	d1 ea		 shr	 edx, 1
  00049	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  0004c	2b c2		 sub	 eax, edx
  0004e	39 45 0c	 cmp	 DWORD PTR __Old$[ebp], eax
  00051	76 05		 jbe	 SHORT $LN3@Calculate_

; 4494 :             return _Max;

  00053	8b 45 10	 mov	 eax, DWORD PTR __Max$[ebp]
  00056	eb 1d		 jmp	 SHORT $LN4@Calculate_
$LN3@Calculate_:

; 4495 :         }
; 4496 : 
; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  00058	8b 4d 0c	 mov	 ecx, DWORD PTR __Old$[ebp]
  0005b	d1 e9		 shr	 ecx, 1
  0005d	03 4d 0c	 add	 ecx, DWORD PTR __Old$[ebp]
  00060	89 4d ec	 mov	 DWORD PTR $T1[ebp], ecx
  00063	8d 55 ec	 lea	 edx, DWORD PTR $T1[ebp]
  00066	52		 push	 edx
  00067	8d 45 f4	 lea	 eax, DWORD PTR __Masked$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00070	83 c4 08	 add	 esp, 8
  00073	8b 00		 mov	 eax, DWORD PTR [eax]
$LN4@Calculate_:

; 4498 :     }

  00075	52		 push	 edx
  00076	8b cd		 mov	 ecx, ebp
  00078	50		 push	 eax
  00079	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN7@Calculate_
  0007f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00084	58		 pop	 eax
  00085	5a		 pop	 edx
  00086	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00089	33 cd		 xor	 ecx, ebp
  0008b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00090	83 c4 14	 add	 esp, 20			; 00000014H
  00093	3b ec		 cmp	 ebp, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
  0009e	66 90		 npad	 2
$LN7@Calculate_:
  000a0	01 00 00 00	 DD	 1
  000a4	00 00 00 00	 DD	 $LN6@Calculate_
$LN6@Calculate_:
  000a8	f4 ff ff ff	 DD	 -12			; fffffff4H
  000ac	04 00 00 00	 DD	 4
  000b0	00 00 00 00	 DD	 $LN5@Calculate_
$LN5@Calculate_:
  000b4	5f		 DB	 95			; 0000005fH
  000b5	4d		 DB	 77			; 0000004dH
  000b6	61		 DB	 97			; 00000061H
  000b7	73		 DB	 115			; 00000073H
  000b8	6b		 DB	 107			; 0000006bH
  000b9	65		 DB	 101			; 00000065H
  000ba	64		 DB	 100			; 00000064H
  000bb	00		 DB	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -36						; size = 4
$T2 = -32						; size = 4
$T3 = -28						; size = 4
__Storage_max$ = -24					; size = 4
__Alloc_max$ = -16					; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3943 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 dc	 mov	 DWORD PTR [ebp-36], eax
  0000e	89 45 e0	 mov	 DWORD PTR [ebp-32], eax
  00011	89 45 e4	 mov	 DWORD PTR [ebp-28], eax
  00014	89 45 e8	 mov	 DWORD PTR [ebp-24], eax
  00017	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0001a	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0001d	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00020	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00023	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00033	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00038	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3944 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  0003d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00040	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00045	50		 push	 eax
  00046	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  0004b	83 c4 04	 add	 esp, 4
  0004e	89 45 f0	 mov	 DWORD PTR __Alloc_max$[ebp], eax

; 3945 :         const size_type _Storage_max = // can always store small string

  00051	c7 45 e4 10 00
	00 00		 mov	 DWORD PTR $T3[ebp], 16	; 00000010H
  00058	8d 45 e4	 lea	 eax, DWORD PTR $T3[ebp]
  0005b	50		 push	 eax
  0005c	8d 4d f0	 lea	 ecx, DWORD PTR __Alloc_max$[ebp]
  0005f	51		 push	 ecx
  00060	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00065	83 c4 08	 add	 esp, 8
  00068	8b 10		 mov	 edx, DWORD PTR [eax]
  0006a	89 55 e8	 mov	 DWORD PTR __Storage_max$[ebp], edx

; 3946 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3947 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  0006d	8b 45 e8	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  00070	83 e8 01	 sub	 eax, 1
  00073	89 45 e0	 mov	 DWORD PTR $T2[ebp], eax
  00076	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  0007b	89 45 dc	 mov	 DWORD PTR $T1[ebp], eax
  0007e	8d 4d e0	 lea	 ecx, DWORD PTR $T2[ebp]
  00081	51		 push	 ecx
  00082	8d 55 dc	 lea	 edx, DWORD PTR $T1[ebp]
  00085	52		 push	 edx
  00086	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  0008b	83 c4 08	 add	 esp, 8
  0008e	8b 00		 mov	 eax, DWORD PTR [eax]

; 3948 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3949 :         );
; 3950 :     }

  00090	52		 push	 edx
  00091	8b cd		 mov	 ecx, ebp
  00093	50		 push	 eax
  00094	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@max_size
  0009a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0009f	58		 pop	 eax
  000a0	5a		 pop	 edx
  000a1	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000a4	33 cd		 xor	 ecx, ebp
  000a6	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ab	83 c4 24	 add	 esp, 36			; 00000024H
  000ae	3b ec		 cmp	 ebp, esp
  000b0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
  000b9	0f 1f 00	 npad	 3
$LN5@max_size:
  000bc	01 00 00 00	 DD	 1
  000c0	00 00 00 00	 DD	 $LN4@max_size
$LN4@max_size:
  000c4	f0 ff ff ff	 DD	 -16			; fffffff0H
  000c8	04 00 00 00	 DD	 4
  000cc	00 00 00 00	 DD	 $LN3@max_size
$LN3@max_size:
  000d0	5f		 DB	 95			; 0000005fH
  000d1	41		 DB	 65			; 00000041H
  000d2	6c		 DB	 108			; 0000006cH
  000d3	6c		 DB	 108			; 0000006cH
  000d4	6f		 DB	 111			; 0000006fH
  000d5	63		 DB	 99			; 00000063H
  000d6	5f		 DB	 95			; 0000005fH
  000d7	6d		 DB	 109			; 0000006dH
  000d8	61		 DB	 97			; 00000061H
  000d9	78		 DB	 120			; 00000078H
  000da	00		 DB	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3263 :     _CONSTEXPR20_CONTAINER basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00018	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  0002a	83 c4 04	 add	 esp, 4
  0002d	50		 push	 eax
  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00031	51		 push	 ecx
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00035	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3265 :     }

  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
$T1 = -10						; size = 1
$T2 = -9						; size = 1
__Old_ptr$3 = -8					; size = 4
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00023	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00028	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002b	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0002e	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00031	77 44		 ja	 SHORT $LN2@assign

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  00033	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  0003b	89 45 f8	 mov	 DWORD PTR __Old_ptr$3[ebp], eax

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  0003e	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00041	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00044	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  00047	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0004a	51		 push	 ecx
  0004b	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0004e	52		 push	 edx
  0004f	8b 45 f8	 mov	 eax, DWORD PTR __Old_ptr$3[ebp]
  00052	50		 push	 eax
  00053	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
  00058	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  0005b	c6 45 f7 00	 mov	 BYTE PTR $T2[ebp], 0
  0005f	8d 4d f7	 lea	 ecx, DWORD PTR $T2[ebp]
  00062	51		 push	 ecx
  00063	8b 55 f8	 mov	 edx, DWORD PTR __Old_ptr$3[ebp]
  00066	03 55 0c	 add	 edx, DWORD PTR __Count$[ebp]
  00069	52		 push	 edx
  0006a	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0006f	83 c4 08	 add	 esp, 8

; 3251 :             return *this;

  00072	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00075	eb 15		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3252 :         }
; 3253 : 
; 3254 :         return _Reallocate_for(

  00077	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0007a	50		 push	 eax
  0007b	0f b6 4d f6	 movzx	 ecx, BYTE PTR $T1[ebp]
  0007f	51		 push	 ecx
  00080	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00083	52		 push	 edx
  00084	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00087	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
$LN1@assign:

; 3255 :             _Count,
; 3256 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3257 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  0008c	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008f	3b ec		 cmp	 ebp, esp
  00091	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00096	8b e5		 mov	 esp, ebp
  00098	5d		 pop	 ebp
  00099	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
tv69 = -60						; size = 4
$T2 = -53						; size = 1
__Proxy$ = -48						; size = 8
_$S36$ = -29						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -20						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2517 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 30	 sub	 esp, 48			; 00000030H
  00014	57		 push	 edi
  00015	51		 push	 ecx
  00016	8d 7d c4	 lea	 edi, DWORD PTR [ebp-60]
  00019	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  0001e	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00023	f3 ab		 rep stosd
  00025	59		 pop	 ecx
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00030	50		 push	 eax
  00031	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00034	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003a	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003d	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00042	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00047	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004a	89 45 c4	 mov	 DWORD PTR tv69[ebp], eax
  0004d	0f b6 4d cb	 movzx	 ecx, BYTE PTR $T2[ebp]
  00051	51		 push	 ecx
  00052	8b 4d c4	 mov	 ecx, DWORD PTR tv69[ebp]
  00055	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  0005a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2518 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00061	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00064	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00069	50		 push	 eax
  0006a	8d 4d e3	 lea	 ecx, DWORD PTR _$S36$[ebp]
  0006d	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  00072	8d 55 e3	 lea	 edx, DWORD PTR _$S36$[ebp]
  00075	89 55 e8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 2519 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	50		 push	 eax
  0007c	8b 4d e8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  0007f	51		 push	 ecx
  00080	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00083	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00088	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 2520 :         _Tidy_init();

  0008c	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008f	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2521 :         assign(_Ptr);

  00094	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00097	52		 push	 edx
  00098	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0009b	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2522 :         _Proxy._Release();

  000a0	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000a3	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2523 :     }

  000a8	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  000ac	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000af	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000b4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000bb	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000be	52		 push	 edx
  000bf	8b cd		 mov	 ecx, ebp
  000c1	50		 push	 eax
  000c2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN9@basic_stri
  000c8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000cd	58		 pop	 eax
  000ce	5a		 pop	 edx
  000cf	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000d2	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000d9	59		 pop	 ecx
  000da	5f		 pop	 edi
  000db	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000de	33 cd		 xor	 ecx, ebp
  000e0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000e5	83 c4 3c	 add	 esp, 60			; 0000003cH
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c2 04 00	 ret	 4
  000f5	0f 1f 00	 npad	 3
$LN9@basic_stri:
  000f8	02 00 00 00	 DD	 2
  000fc	00 00 00 00	 DD	 $LN8@basic_stri
$LN8@basic_stri:
  00100	e3 ff ff ff	 DD	 -29			; ffffffe3H
  00104	01 00 00 00	 DD	 1
  00108	00 00 00 00	 DD	 $LN5@basic_stri
  0010c	d0 ff ff ff	 DD	 -48			; ffffffd0H
  00110	08 00 00 00	 DD	 8
  00114	00 00 00 00	 DD	 $LN6@basic_stri
$LN6@basic_stri:
  00118	5f		 DB	 95			; 0000005fH
  00119	50		 DB	 80			; 00000050H
  0011a	72		 DB	 114			; 00000072H
  0011b	6f		 DB	 111			; 0000006fH
  0011c	78		 DB	 120			; 00000078H
  0011d	79		 DB	 121			; 00000079H
  0011e	00		 DB	 0
$LN5@basic_stri:
  0011f	24		 DB	 36			; 00000024H
  00120	53		 DB	 83			; 00000053H
  00121	33		 DB	 51			; 00000033H
  00122	36		 DB	 54			; 00000036H
  00123	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1:
  00008	8d 4d d0	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00021	33 c8		 xor	 ecx, eax
  00023	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00028	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0002b	33 c8		 xor	 ecx, eax
  0002d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00032	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00037	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	83 c1 04	 add	 ecx, 4
  00014	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00019	83 c4 04	 add	 esp, 4
  0001c	3b ec		 cmp	 ebp, esp
  0001e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2348 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	83 c4 04	 add	 esp, 4
  0001b	3b ec		 cmp	 ebp, esp
  0001d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00022	8b e5		 mov	 esp, ebp
  00024	5d		 pop	 ebp
  00025	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2313 :     _CONSTEXPR20_CONTAINER bool _Large_string_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2314 : #ifdef __cpp_lib_constexpr_string
; 2315 :         if (_STD is_constant_evaluated()) {

  00021	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 04		 je	 SHORT $LN2@Large_stri

; 2316 :             return true;

  0002d	b0 01		 mov	 al, 1
  0002f	eb 1c		 jmp	 SHORT $LN3@Large_stri
$LN2@Large_stri:

; 2317 :         }
; 2318 : #endif // __cpp_lib_constexpr_string
; 2319 :         return _BUF_SIZE <= _Myres;

  00031	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00034	83 79 18 10	 cmp	 DWORD PTR [ecx+24], 16	; 00000010H
  00038	72 09		 jb	 SHORT $LN4@Large_stri
  0003a	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00041	eb 07		 jmp	 SHORT $LN5@Large_stri
$LN4@Large_stri:
  00043	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN5@Large_stri:
  0004a	8a 45 f8	 mov	 al, BYTE PTR tv69[ebp]
$LN3@Large_stri:

; 2320 :     }

  0004d	83 c4 08	 add	 esp, 8
  00050	3b ec		 cmp	 ebp, esp
  00052	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -8						; size = 4
_this$ = -4						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2295 :     _CONSTEXPR20_CONTAINER value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2296 :         value_type* _Result = _Bx._Buf;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c0 04	 add	 eax, 4
  00027	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax

; 2297 :         if (_Large_string_engaged()) {

  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00032	0f b6 c8	 movzx	 ecx, al
  00035	85 c9		 test	 ecx, ecx
  00037	74 12		 je	 SHORT $LN2@Myptr

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 f8	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2299 :         }
; 2300 : 
; 2301 :         return _Result;

  0004b	8b 45 f8	 mov	 eax, DWORD PTR __Result$[ebp]

; 2302 :     }

  0004e	83 c4 08	 add	 esp, 8
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2284 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 04	 add	 ecx, 4
  00026	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2285 : 
; 2286 :     // length of internal buffer, [1, 16]:
; 2287 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2288 :     // roundup mask for allocated buffers, [0, 15]:
; 2289 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2290 :                                            : sizeof(value_type) <= 2 ? 7
; 2291 :                                            : sizeof(value_type) <= 4 ? 3
; 2292 :                                            : sizeof(value_type) <= 8 ? 1
; 2293 :                                                                      : 0;
; 2294 : 
; 2295 :     _CONSTEXPR20_CONTAINER value_type* _Myptr() noexcept {
; 2296 :         value_type* _Result = _Bx._Buf;
; 2297 :         if (_Large_string_engaged()) {
; 2298 :             _Result = _Unfancy(_Bx._Ptr);
; 2299 :         }
; 2300 : 
; 2301 :         return _Result;
; 2302 :     }
; 2303 : 
; 2304 :     _CONSTEXPR20_CONTAINER const value_type* _Myptr() const noexcept {
; 2305 :         const value_type* _Result = _Bx._Buf;
; 2306 :         if (_Large_string_engaged()) {
; 2307 :             _Result = _Unfancy(_Bx._Ptr);
; 2308 :         }
; 2309 : 
; 2310 :         return _Result;
; 2311 :     }
; 2312 : 
; 2313 :     _CONSTEXPR20_CONTAINER bool _Large_string_engaged() const noexcept {
; 2314 : #ifdef __cpp_lib_constexpr_string
; 2315 :         if (_STD is_constant_evaluated()) {
; 2316 :             return true;
; 2317 :         }
; 2318 : #endif // __cpp_lib_constexpr_string
; 2319 :         return _BUF_SIZE <= _Myres;
; 2320 :     }
; 2321 : 
; 2322 :     _CONSTEXPR20_CONTAINER void _Check_offset(const size_type _Off) const {
; 2323 :         // checks whether _Off is in the bounds of [0, size()]
; 2324 :         if (_Mysize < _Off) {
; 2325 :             _Xran();
; 2326 :         }
; 2327 :     }
; 2328 : 
; 2329 :     _CONSTEXPR20_CONTAINER void _Check_offset_exclusive(const size_type _Off) const {
; 2330 :         // checks whether _Off is in the bounds of [0, size())
; 2331 :         if (_Mysize <= _Off) {
; 2332 :             _Xran();
; 2333 :         }
; 2334 :     }
; 2335 : 
; 2336 :     [[noreturn]] static void _Xran() {
; 2337 :         _Xout_of_range("invalid string position");
; 2338 :     }
; 2339 : 
; 2340 :     _CONSTEXPR20_CONTAINER size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2341 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2342 :         return (_STD min)(_Size, _Mysize - _Off);
; 2343 :     }
; 2344 : 
; 2345 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers
; 2347 : 
; 2348 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2349 : 
; 2350 :         value_type _Buf[_BUF_SIZE];
; 2351 :         pointer _Ptr;
; 2352 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2353 :     } _Bx;
; 2354 : 
; 2355 :     size_type _Mysize = 0; // current length of string

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  00035	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00038	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], 0

; 2284 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c4 04	 add	 esp, 4
  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	8b e5		 mov	 esp, ebp
  0004e	5d		 pop	 ebp
  0004f	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	83 c8 ff	 or	 eax, -1

; 729  :     }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00018	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	50		 push	 eax
  0001c	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  00021	83 c4 04	 add	 esp, 4
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  0002a	83 c4 04	 add	 esp, 4

; 840  :     }

  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00018	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001b	50		 push	 eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00025	83 c4 08	 add	 esp, 8

; 836  :     }

  00028	83 c4 04	 add	 esp, 4
  0002b	3b ec		 cmp	 ebp, esp
  0002d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2373 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2374 :     _Xlength_error("string too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2375 : }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 477  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 478  :         return static_cast<int_type>(EOF);

  0000d	83 c8 ff	 or	 eax, -1

; 479  :     }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -4						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 469  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 470  :         return _Left == _Right;

  00015	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00018	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001b	8b 10		 mov	 edx, DWORD PTR [eax]
  0001d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0001f	75 09		 jne	 SHORT $LN3@eq_int_typ
  00021	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR tv65[ebp], 1
  00028	eb 07		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  0002a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  00031	8a 45 fc	 mov	 al, BYTE PTR tv65[ebp]

; 471  :     }

  00034	83 c4 04	 add	 esp, 4
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 449  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 450  :         _Left = _Right;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00013	8a 11		 mov	 dl, BYTE PTR [ecx]
  00015	88 10		 mov	 BYTE PTR [eax], dl

; 451  :     }

  00017	3b ec		 cmp	 ebp, esp
  00019	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 439  :         // assign _Count * _Ch to [_First, ...)
; 440  : #ifdef __cpp_lib_is_constant_evaluated
; 441  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 17		 je	 SHORT $LN2@assign

; 442  :             return _Primary_char_traits::assign(_First, _Count, _Ch);

  00019	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAPADQADID@Z ; std::_Char_traits<char,int>::assign
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	eb 15		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 443  :         }
; 444  : #endif // __cpp_lib_is_constant_evaluated
; 445  : 
; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	0f be 55 10	 movsx	 edx, BYTE PTR __Ch$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@assign:

; 447  :     }

  00045	3b ec		 cmp	 ebp, esp
  00047	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
tv66 = -16						; size = 4
tv75 = -9						; size = 1
tv72 = -8						; size = 4
tv69 = -4						; size = 4
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 396  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 397  :         // find length of null-terminated string
; 398  : #if _HAS_CXX17
; 399  : #ifdef __cpp_char8_t
; 400  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 401  : #if _HAS_U8_INTRINSICS
; 402  :             return __builtin_u8strlen(_First);
; 403  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 404  :             return _Primary_char_traits::length(_First);
; 405  : #endif // _HAS_U8_INTRINSICS
; 406  :         } else
; 407  : #endif // __cpp_char8_t
; 408  :         {
; 409  :             return __builtin_strlen(_First);

  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	89 45 fc	 mov	 DWORD PTR tv69[ebp], eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR tv69[ebp]
  0002a	83 c1 01	 add	 ecx, 1
  0002d	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
$LL3@length:
  00030	8b 55 fc	 mov	 edx, DWORD PTR tv69[ebp]
  00033	8a 02		 mov	 al, BYTE PTR [edx]
  00035	88 45 f7	 mov	 BYTE PTR tv75[ebp], al
  00038	83 45 fc 01	 add	 DWORD PTR tv69[ebp], 1
  0003c	80 7d f7 00	 cmp	 BYTE PTR tv75[ebp], 0
  00040	75 ee		 jne	 SHORT $LL3@length
  00042	8b 4d fc	 mov	 ecx, DWORD PTR tv69[ebp]
  00045	2b 4d f8	 sub	 ecx, DWORD PTR tv72[ebp]
  00048	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  0004b	8b 45 f0	 mov	 eax, DWORD PTR tv66[ebp]

; 410  :         }
; 411  : #else // _HAS_CXX17
; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 413  : #endif // _HAS_CXX17
; 414  :     }

  0004e	83 c4 10	 add	 esp, 16			; 00000010H
  00051	3b ec		 cmp	 ebp, esp
  00053	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__Next$1 = -8						; size = 4
__Next$2 = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 167  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00019	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         // assign _Count * _Ch to [_First, ...)
; 169  : #ifdef __cpp_lib_constexpr_string
; 170  :         if (_STD is_constant_evaluated()) {

  0001e	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00023	0f b6 c0	 movzx	 eax, al
  00026	85 c0		 test	 eax, eax
  00028	74 34		 je	 SHORT $LN8@assign

; 171  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  0002a	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0002d	89 4d fc	 mov	 DWORD PTR __Next$2[ebp], ecx
  00030	eb 12		 jmp	 SHORT $LN4@assign
$LN2@assign:
  00032	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00035	83 ea 01	 sub	 edx, 1
  00038	89 55 0c	 mov	 DWORD PTR __Count$[ebp], edx
  0003b	8b 45 fc	 mov	 eax, DWORD PTR __Next$2[ebp]
  0003e	83 c0 01	 add	 eax, 1
  00041	89 45 fc	 mov	 DWORD PTR __Next$2[ebp], eax
$LN4@assign:
  00044	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00048	76 12		 jbe	 SHORT $LN3@assign

; 172  :                 _STD construct_at(_Next, _Ch);

  0004a	8d 4d 10	 lea	 ecx, DWORD PTR __Ch$[ebp]
  0004d	51		 push	 ecx
  0004e	8b 55 fc	 mov	 edx, DWORD PTR __Next$2[ebp]
  00051	52		 push	 edx
  00052	e8 00 00 00 00	 call	 ??$construct_at@DABDX@std@@YAPADQADABD@Z ; std::construct_at<char,char const &,void>
  00057	83 c4 08	 add	 esp, 8

; 173  :             }

  0005a	eb d6		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 174  :         } else

  0005c	eb 2a		 jmp	 SHORT $LN9@assign
$LN8@assign:

; 175  : #endif // __cpp_lib_constexpr_string
; 176  :         {
; 177  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  0005e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00061	89 45 f8	 mov	 DWORD PTR __Next$1[ebp], eax
  00064	eb 12		 jmp	 SHORT $LN7@assign
$LN5@assign:
  00066	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00069	83 e9 01	 sub	 ecx, 1
  0006c	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  0006f	8b 55 f8	 mov	 edx, DWORD PTR __Next$1[ebp]
  00072	83 c2 01	 add	 edx, 1
  00075	89 55 f8	 mov	 DWORD PTR __Next$1[ebp], edx
$LN7@assign:
  00078	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0007c	76 0a		 jbe	 SHORT $LN9@assign

; 178  :                 *_Next = _Ch;

  0007e	8b 45 f8	 mov	 eax, DWORD PTR __Next$1[ebp]
  00081	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  00084	88 08		 mov	 BYTE PTR [eax], cl

; 179  :             }

  00086	eb de		 jmp	 SHORT $LN5@assign
$LN9@assign:

; 180  :         }
; 181  : 
; 182  :         return _First;

  00088	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 183  :     }

  0008b	83 c4 08	 add	 esp, 8
  0008e	3b ec		 cmp	 ebp, esp
  00090	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00095	8b e5		 mov	 esp, ebp
  00097	5d		 pop	 ebp
  00098	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Idx$1 = -16						; size = 4
__Idx$2 = -12						; size = 4
__Src$3 = -8						; size = 4
__Loop_forward$4 = -1					; size = 1
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 80   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 81   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 82   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 83   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 84   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 85   : #ifdef __cpp_lib_is_constant_evaluated
; 86   :         if (_STD is_constant_evaluated()) {

  00022	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00027	0f b6 c0	 movzx	 eax, al
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 b5 00 00
	00		 je	 $LN11@move

; 87   :             // dest: [_First1, _First1 + _Count)
; 88   :             // src: [_First2, _First2 + _Count)
; 89   :             // We need to handle overlapping ranges.
; 90   :             // If _First1 is in the src range, we need a backward loop.
; 91   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 92   : 
; 93   :             if (_First1 == _First2) {

  00032	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00035	3b 4d 0c	 cmp	 ecx, DWORD PTR __First2$[ebp]
  00038	75 08		 jne	 SHORT $LN12@move

; 94   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.

  0003a	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003d	e9 bc 00 00 00	 jmp	 $LN16@move
$LN12@move:

; 95   :             }
; 96   : 
; 97   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 98   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 99   :             bool _Loop_forward = true;

  00042	c6 45 ff 01	 mov	 BYTE PTR __Loop_forward$4[ebp], 1

; 100  : 
; 101  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

  00046	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00049	89 55 f8	 mov	 DWORD PTR __Src$3[ebp], edx
  0004c	eb 09		 jmp	 SHORT $LN4@move
$LN2@move:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR __Src$3[ebp]
  00051	83 c0 01	 add	 eax, 1
  00054	89 45 f8	 mov	 DWORD PTR __Src$3[ebp], eax
$LN4@move:
  00057	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0005a	03 4d 10	 add	 ecx, DWORD PTR __Count$[ebp]
  0005d	39 4d f8	 cmp	 DWORD PTR __Src$3[ebp], ecx
  00060	74 10		 je	 SHORT $LN3@move

; 102  :                 if (_First1 == _Src) {

  00062	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00065	3b 55 f8	 cmp	 edx, DWORD PTR __Src$3[ebp]
  00068	75 06		 jne	 SHORT $LN13@move

; 103  :                     _Loop_forward = false;

  0006a	c6 45 ff 00	 mov	 BYTE PTR __Loop_forward$4[ebp], 0

; 104  :                     break;

  0006e	eb 02		 jmp	 SHORT $LN3@move
$LN13@move:

; 105  :                 }
; 106  :             }

  00070	eb dc		 jmp	 SHORT $LN2@move
$LN3@move:

; 107  : 
; 108  :             if (_Loop_forward) {

  00072	0f b6 45 ff	 movzx	 eax, BYTE PTR __Loop_forward$4[ebp]
  00076	85 c0		 test	 eax, eax
  00078	74 2e		 je	 SHORT $LN14@move

; 109  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  0007a	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Idx$2[ebp], 0
  00081	eb 09		 jmp	 SHORT $LN7@move
$LN5@move:
  00083	8b 4d f4	 mov	 ecx, DWORD PTR __Idx$2[ebp]
  00086	83 c1 01	 add	 ecx, 1
  00089	89 4d f4	 mov	 DWORD PTR __Idx$2[ebp], ecx
$LN7@move:
  0008c	8b 55 f4	 mov	 edx, DWORD PTR __Idx$2[ebp]
  0008f	3b 55 10	 cmp	 edx, DWORD PTR __Count$[ebp]
  00092	73 12		 jae	 SHORT $LN6@move

; 110  :                     _First1[_Idx] = _First2[_Idx];

  00094	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00097	03 45 f4	 add	 eax, DWORD PTR __Idx$2[ebp]
  0009a	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  0009d	03 4d f4	 add	 ecx, DWORD PTR __Idx$2[ebp]
  000a0	8a 11		 mov	 dl, BYTE PTR [ecx]
  000a2	88 10		 mov	 BYTE PTR [eax], dl

; 111  :                 }

  000a4	eb dd		 jmp	 SHORT $LN5@move
$LN6@move:

; 112  :             } else {

  000a6	eb 3a		 jmp	 SHORT $LN15@move
$LN14@move:

; 113  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  000a8	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Idx$1[ebp], 0
  000af	eb 09		 jmp	 SHORT $LN10@move
$LN8@move:
  000b1	8b 45 f0	 mov	 eax, DWORD PTR __Idx$1[ebp]
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 f0	 mov	 DWORD PTR __Idx$1[ebp], eax
$LN10@move:
  000ba	8b 4d f0	 mov	 ecx, DWORD PTR __Idx$1[ebp]
  000bd	3b 4d 10	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000c0	73 20		 jae	 SHORT $LN15@move

; 114  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];

  000c2	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  000c5	83 ea 01	 sub	 edx, 1
  000c8	2b 55 f0	 sub	 edx, DWORD PTR __Idx$1[ebp]
  000cb	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  000ce	83 e8 01	 sub	 eax, 1
  000d1	2b 45 f0	 sub	 eax, DWORD PTR __Idx$1[ebp]
  000d4	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  000d7	8b 75 0c	 mov	 esi, DWORD PTR __First2$[ebp]
  000da	8a 14 16	 mov	 dl, BYTE PTR [esi+edx]
  000dd	88 14 01	 mov	 BYTE PTR [ecx+eax], dl

; 115  :                 }

  000e0	eb cf		 jmp	 SHORT $LN8@move
$LN15@move:

; 116  :             }
; 117  : 
; 118  :             return _First1;

  000e2	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  000e5	eb 17		 jmp	 SHORT $LN16@move
$LN11@move:

; 119  :         }
; 120  : #endif // __cpp_lib_is_constant_evaluated
; 121  : 
; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  000e7	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  000ea	50		 push	 eax
  000eb	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  000ee	51		 push	 ecx
  000ef	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  000f2	52		 push	 edx
  000f3	e8 00 00 00 00	 call	 _memmove
  000f8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 124  : 
; 125  :         return _First1;

  000fb	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
$LN16@move:

; 126  :     }

  000fe	5e		 pop	 esi
  000ff	83 c4 10	 add	 esp, 16			; 00000010H
  00102	3b ec		 cmp	 ebp, esp
  00104	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00109	8b e5		 mov	 esp, ebp
  0010b	5d		 pop	 ebp
  0010c	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
__Idx$1 = -4						; size = 4
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 49   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00010	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 51   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 52   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 53   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 54   : #ifdef __cpp_lib_is_constant_evaluated
; 55   :         if (_STD is_constant_evaluated()) {

  00015	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001a	0f b6 c0	 movzx	 eax, al
  0001d	85 c0		 test	 eax, eax
  0001f	74 31		 je	 SHORT $LN5@copy

; 56   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 57   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  00021	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __Idx$1[ebp], 0
  00028	eb 09		 jmp	 SHORT $LN4@copy
$LN2@copy:
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR __Idx$1[ebp]
  0002d	83 c1 01	 add	 ecx, 1
  00030	89 4d fc	 mov	 DWORD PTR __Idx$1[ebp], ecx
$LN4@copy:
  00033	8b 55 fc	 mov	 edx, DWORD PTR __Idx$1[ebp]
  00036	3b 55 10	 cmp	 edx, DWORD PTR __Count$[ebp]
  00039	73 12		 jae	 SHORT $LN3@copy

; 58   :                 _First1[_Idx] = _First2[_Idx];

  0003b	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0003e	03 45 fc	 add	 eax, DWORD PTR __Idx$1[ebp]
  00041	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00044	03 4d fc	 add	 ecx, DWORD PTR __Idx$1[ebp]
  00047	8a 11		 mov	 dl, BYTE PTR [ecx]
  00049	88 10		 mov	 BYTE PTR [eax], dl

; 59   :             }

  0004b	eb dd		 jmp	 SHORT $LN2@copy
$LN3@copy:

; 60   : 
; 61   :             return _First1;

  0004d	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  00050	eb 17		 jmp	 SHORT $LN6@copy
$LN5@copy:

; 62   :         }
; 63   : #endif // __cpp_lib_is_constant_evaluated
; 64   : 
; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  00052	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00055	50		 push	 eax
  00056	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00059	51		 push	 ecx
  0005a	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 _memcpy
  00063	83 c4 0c	 add	 esp, 12			; 0000000cH

; 66   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 67   : 
; 68   :         return _First1;

  00066	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
$LN6@copy:

; 69   :     }

  00069	83 c4 04	 add	 esp, 4
  0006c	3b ec		 cmp	 ebp, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
tv93 = -16						; size = 4
tv75 = -12						; size = 4
tv77 = -8						; size = 4
$T1 = -4						; size = 4
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000b	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000e	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00011	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00014	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00021	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00026	0f b6 c0	 movzx	 eax, al
  00029	85 c0		 test	 eax, eax
  0002b	74 30		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0002d	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00036	83 c4 04	 add	 esp, 4
  00039	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  0003c	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00045	83 c4 04	 add	 esp, 4
  00048	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
  0004e	50		 push	 eax
  0004f	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  00052	51		 push	 ecx
  00053	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
  00058	83 c4 08	 add	 esp, 8

; 155  :     } else

  0005b	eb 40		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0005d	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  00060	52		 push	 edx
  00061	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00066	83 c4 04	 add	 esp, 4
  00069	50		 push	 eax
  0006a	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  0006f	83 c4 04	 add	 esp, 4
  00072	50		 push	 eax
  00073	6a 08		 push	 8
  00075	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0007a	83 c4 08	 add	 esp, 8
  0007d	89 45 fc	 mov	 DWORD PTR $T1[ebp], eax
  00080	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00089	83 c4 04	 add	 esp, 4
  0008c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008e	89 4d f0	 mov	 DWORD PTR tv93[ebp], ecx
  00091	8b 55 f0	 mov	 edx, DWORD PTR tv93[ebp]
  00094	52		 push	 edx
  00095	8b 4d fc	 mov	 ecx, DWORD PTR $T1[ebp]
  00098	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  0009d	83 c4 10	 add	 esp, 16			; 00000010H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1316 :     _Container_proxy* _Ptr = nullptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1318 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1319 :         _Ptr = nullptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1320 :     }

  00021	83 c4 04	 add	 esp, 4
  00024	3b ec		 cmp	 ebp, esp
  00026	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -16						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ PROC	; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT
; _this$ = ecx

; 1229 :     void _Orphan_me_locked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  00032	8b f4		 mov	 esi, esp
  00034	6a 03		 push	 3
  00036	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1231 :         _Orphan_me_unlocked_v3();

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1232 :     }

  0004e	8b f4		 mov	 esi, esp
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	52		 push	 edx
  00061	8b cd		 mov	 ecx, ebp
  00063	50		 push	 eax
  00064	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Orphan_me_
  0006a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006f	58		 pop	 eax
  00070	5a		 pop	 edx
  00071	5e		 pop	 esi
  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	33 cd		 xor	 ecx, ebp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	83 c4 14	 add	 esp, 20			; 00000014H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
  0008a	66 90		 npad	 2
$LN5@Orphan_me_:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@Orphan_me_
$LN4@Orphan_me_:
  00094	f0 ff ff ff	 DD	 -16			; fffffff0H
  00098	04 00 00 00	 DD	 4
  0009c	00 00 00 00	 DD	 $LN3@Orphan_me_
$LN3@Orphan_me_:
  000a0	5f		 DB	 95			; 0000005fH
  000a1	4c		 DB	 76			; 0000004cH
  000a2	6f		 DB	 111			; 0000006fH
  000a3	63		 DB	 99			; 00000063H
  000a4	6b		 DB	 107			; 0000006bH
  000a5	00		 DB	 0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ENDP	; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Temp$1 = -12						; size = 4
__Pnext$ = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT
; _this$ = ecx

; 1212 :     _CONSTEXPR20_CONTAINER void _Orphan_me_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi
  00007	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000e	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00015	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001c	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00024	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1213 :         if (!_Myproxy) { // already orphaned

  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002f	75 05		 jne	 SHORT $LN10@Orphan_me_

; 1214 :             return;

  00031	e9 ae 00 00 00	 jmp	 $LN13@Orphan_me_
$LN10@Orphan_me_:

; 1215 :         }
; 1216 : 
; 1217 :         // adopted, remove self from list
; 1218 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	8b 11		 mov	 edx, DWORD PTR [ecx]
  0003b	83 c2 04	 add	 edx, 4
  0003e	89 55 f8	 mov	 DWORD PTR __Pnext$[ebp], edx
$LN2@Orphan_me_:

; 1219 :         while (*_Pnext && *_Pnext != this) {

  00041	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00044	83 38 00	 cmp	 DWORD PTR [eax], 0
  00047	74 1d		 je	 SHORT $LN6@Orphan_me_
  00049	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  0004c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004e	3b 55 fc	 cmp	 edx, DWORD PTR _this$[ebp]
  00051	74 13		 je	 SHORT $LN6@Orphan_me_

; 1220 :             const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00053	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d f4	 mov	 DWORD PTR __Temp$1[ebp], ecx

; 1221 :             _Pnext           = &_Temp->_Mynextiter;

  0005b	8b 55 f4	 mov	 edx, DWORD PTR __Temp$1[ebp]
  0005e	83 c2 04	 add	 edx, 4
  00061	89 55 f8	 mov	 DWORD PTR __Pnext$[ebp], edx

; 1222 :         }

  00064	eb db		 jmp	 SHORT $LN2@Orphan_me_
$LN6@Orphan_me_:

; 1223 : 
; 1224 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

  00066	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00069	83 38 00	 cmp	 DWORD PTR [eax], 0
  0006c	74 02		 je	 SHORT $LN9@Orphan_me_
  0006e	eb 5c		 jmp	 SHORT $LN4@Orphan_me_
$LN9@Orphan_me_:
  00070	8b f4		 mov	 esi, esp
  00072	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
  00077	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0007c	6a 00		 push	 0
  0007e	68 c8 04 00 00	 push	 1224			; 000004c8H
  00083	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00088	6a 02		 push	 2
  0008a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00090	83 c4 18	 add	 esp, 24			; 00000018H
  00093	3b f4		 cmp	 esi, esp
  00095	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009a	83 f8 01	 cmp	 eax, 1
  0009d	75 01		 jne	 SHORT $LN14@Orphan_me_
  0009f	cc		 int	 3
$LN14@Orphan_me_:
  000a0	8b f4		 mov	 esi, esp
  000a2	6a 00		 push	 0
  000a4	68 c8 04 00 00	 push	 1224			; 000004c8H
  000a9	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000ae	68 00 00 00 00	 push	 OFFSET ??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
  000b3	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
  000b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000be	83 c4 14	 add	 esp, 20			; 00000014H
  000c1	3b f4		 cmp	 esi, esp
  000c3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c8	33 d2		 xor	 edx, edx
  000ca	75 a4		 jne	 SHORT $LN9@Orphan_me_
$LN4@Orphan_me_:
  000cc	33 c0		 xor	 eax, eax
  000ce	75 96		 jne	 SHORT $LN6@Orphan_me_

; 1225 :         *_Pnext  = _Mynextiter;

  000d0	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000d3	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000d9	89 01		 mov	 DWORD PTR [ecx], eax

; 1226 :         _Myproxy = nullptr;

  000db	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  000de	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN13@Orphan_me_:

; 1227 :     }

  000e4	5e		 pop	 esi
  000e5	83 c4 0c	 add	 esp, 12			; 0000000cH
  000e8	3b ec		 cmp	 ebp, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	8b e5		 mov	 esp, ebp
  000f1	5d		 pop	 ebp
  000f2	c3		 ret	 0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$ = -16						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Parent$ = 8						; size = 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT
; _this$ = ecx

; 1207 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1208 :         _Lockit _Lock(_LOCK_DEBUG);

  00032	8b f4		 mov	 esi, esp
  00034	6a 03		 push	 3
  00036	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1209 :         _Adopt_unlocked(_Parent);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1210 :     }

  00052	8b f4		 mov	 esi, esp
  00054	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	52		 push	 edx
  00065	8b cd		 mov	 ecx, ebp
  00067	50		 push	 eax
  00068	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Adopt_lock
  0006e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00073	58		 pop	 eax
  00074	5a		 pop	 edx
  00075	5e		 pop	 esi
  00076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN5@Adopt_lock:
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN4@Adopt_lock
$LN4@Adopt_lock:
  00098	f0 ff ff ff	 DD	 -16			; fffffff0H
  0009c	04 00 00 00	 DD	 4
  000a0	00 00 00 00	 DD	 $LN3@Adopt_lock
$LN3@Adopt_lock:
  000a4	5f		 DB	 95			; 0000005fH
  000a5	4c		 DB	 76			; 0000004cH
  000a6	6f		 DB	 111			; 0000006fH
  000a7	63		 DB	 99			; 00000063H
  000a8	6b		 DB	 107			; 0000006bH
  000a9	00		 DB	 0
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent_proxy$ = -8					; size = 4
_this$ = -4						; size = 4
__Parent$ = 8						; size = 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT
; _this$ = ecx

; 1190 :     _CONSTEXPR20_CONTAINER void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1191 :         if (!_Parent) {

  00021	83 7d 08 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  00025	75 0a		 jne	 SHORT $LN2@Adopt_unlo

; 1192 :             _Orphan_me_unlocked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1193 :             return;

  0002f	eb 3f		 jmp	 SHORT $LN5@Adopt_unlo
$LN2@Adopt_unlo:

; 1194 :         }
; 1195 : 
; 1196 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00031	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	89 4d f8	 mov	 DWORD PTR __Parent_proxy$[ebp], ecx

; 1197 :         if (_Myproxy != _Parent_proxy) { // change parentage

  00039	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  0003c	8b 02		 mov	 eax, DWORD PTR [edx]
  0003e	3b 45 f8	 cmp	 eax, DWORD PTR __Parent_proxy$[ebp]
  00041	74 2d		 je	 SHORT $LN5@Adopt_unlo

; 1198 :             if (_Myproxy) { // adopted, remove self from list

  00043	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00046	83 39 00	 cmp	 DWORD PTR [ecx], 0
  00049	74 08		 je	 SHORT $LN4@Adopt_unlo

; 1199 :                 _Orphan_me_unlocked_v3();

  0004b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0004e	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN4@Adopt_unlo:

; 1200 :             }
; 1201 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

  00053	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00056	8b 45 f8	 mov	 eax, DWORD PTR __Parent_proxy$[ebp]
  00059	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0005c	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1202 :             _Parent_proxy->_Myfirstiter = this;

  0005f	8b 55 f8	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  00062	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00065	89 42 04	 mov	 DWORD PTR [edx+4], eax

; 1203 :             _Myproxy                    = _Parent_proxy;

  00068	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0006b	8b 55 f8	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  0006e	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@Adopt_unlo:

; 1204 :         }
; 1205 :     }

  00070	83 c4 08	 add	 esp, 8
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 04 00	 ret	 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
__Lock$ = -16						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Right$ = 8						; size = 4
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z PROC	; std::_Iterator_base12::_Assign_locked, COMDAT
; _this$ = ecx

; 1185 :     void _Assign_locked(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1186 :         _Lockit _Lock(_LOCK_DEBUG);

  00032	8b f4		 mov	 esi, esp
  00034	6a 03		 push	 3
  00036	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1187 :         _Assign_unlocked(_Right);

  00046	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00049	50		 push	 eax
  0004a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0004d	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1188 :     }

  00052	8b f4		 mov	 esi, esp
  00054	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00057	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0005d	3b f4		 cmp	 esi, esp
  0005f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00064	52		 push	 edx
  00065	8b cd		 mov	 ecx, ebp
  00067	50		 push	 eax
  00068	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Assign_loc
  0006e	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00073	58		 pop	 eax
  00074	5a		 pop	 edx
  00075	5e		 pop	 esi
  00076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
$LN5@Assign_loc:
  00090	01 00 00 00	 DD	 1
  00094	00 00 00 00	 DD	 $LN4@Assign_loc
$LN4@Assign_loc:
  00098	f0 ff ff ff	 DD	 -16			; fffffff0H
  0009c	04 00 00 00	 DD	 4
  000a0	00 00 00 00	 DD	 $LN3@Assign_loc
$LN3@Assign_loc:
  000a4	5f		 DB	 95			; 0000005fH
  000a5	4c		 DB	 76			; 0000004cH
  000a6	6f		 DB	 111			; 0000006fH
  000a7	63		 DB	 99			; 00000063H
  000a8	6b		 DB	 107			; 0000006bH
  000a9	00		 DB	 0
?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ENDP	; std::_Iterator_base12::_Assign_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z PROC ; std::_Iterator_base12::_Assign_unlocked, COMDAT
; _this$ = ecx

; 1173 :     _CONSTEXPR20_CONTAINER void _Assign_unlocked(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1174 :         if (_Myproxy == _Right._Myproxy) {

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  0001e	8b 10		 mov	 edx, DWORD PTR [eax]
  00020	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00022	75 02		 jne	 SHORT $LN2@Assign_unl

; 1175 :             return;

  00024	eb 22		 jmp	 SHORT $LN5@Assign_unl
$LN2@Assign_unl:

; 1176 :         }
; 1177 : 
; 1178 :         if (_Right._Myproxy) {

  00026	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00029	83 38 00	 cmp	 DWORD PTR [eax], 0
  0002c	74 12		 je	 SHORT $LN3@Assign_unl

; 1179 :             _Adopt_unlocked(_Right._Myproxy->_Mycont);

  0002e	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00031	8b 11		 mov	 edx, DWORD PTR [ecx]
  00033	8b 02		 mov	 eax, DWORD PTR [edx]
  00035	50		 push	 eax
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1180 :         } else { // becoming invalid, disown current parent

  0003e	eb 08		 jmp	 SHORT $LN5@Assign_unl
$LN3@Assign_unl:

; 1181 :             _Orphan_me_unlocked_v3();

  00040	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00043	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN5@Assign_unl:

; 1182 :         }
; 1183 :     }

  00048	83 c4 04	 add	 esp, 4
  0004b	3b ec		 cmp	 ebp, esp
  0004d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c2 04 00	 ret	 4
?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ENDP ; std::_Iterator_base12::_Assign_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -8						; size = 4
_this$ = -4						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 38 00	 cmp	 DWORD PTR [eax], 0
  00027	74 0c		 je	 SHORT $LN3@Getcont
  00029	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002e	8b 02		 mov	 eax, DWORD PTR [edx]
  00030	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00033	eb 07		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Getcont:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv68[ebp]

; 1164 :     }

  0003f	83 c4 08	 add	 esp, 8
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {

  00018	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 0e		 je	 SHORT $LN2@Adopt

; 1145 :             _Adopt_unlocked(_Parent);

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Parent$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1146 :         } else

  00030	eb 0c		 jmp	 SHORT $LN4@Adopt
$LN2@Adopt:

; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);

  00032	8b 55 08	 mov	 edx, DWORD PTR __Parent$[ebp]
  00035	52		 push	 edx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
$LN4@Adopt:

; 1150 :         }
; 1151 :     }

  0003e	83 c4 04	 add	 esp, 4
  00041	3b ec		 cmp	 ebp, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00048	8b e5		 mov	 esp, ebp
  0004a	5d		 pop	 ebp
  0004b	c2 04 00	 ret	 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {

  00018	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN2@Iterator_b

; 1134 :             _Orphan_me_unlocked_v3();

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1135 :         } else

  0002c	eb 08		 jmp	 SHORT $LN4@Iterator_b
$LN2@Iterator_b:

; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
$LN4@Iterator_b:

; 1139 :         }
; 1140 :     }

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {

  00018	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 0e		 je	 SHORT $LN2@operator

; 1118 :             _Assign_unlocked(_Right);

  00024	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00027	51		 push	 ecx
  00028	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002b	e8 00 00 00 00	 call	 ?_Assign_unlocked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_unlocked

; 1119 :         } else

  00030	eb 0c		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);

  00032	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00035	52		 push	 edx
  00036	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00039	e8 00 00 00 00	 call	 ?_Assign_locked@_Iterator_base12@std@@AAEXABU12@@Z ; std::_Iterator_base12::_Assign_locked
$LN3@operator:

; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;

  0003e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1128 :     }

  00041	83 c4 04	 add	 esp, 4
  00044	3b ec		 cmp	 ebp, esp
  00046	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 04 00	 ret	 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1110 :     _CONSTEXPR20_CONTAINER _Iterator_base12(const _Iterator_base12& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1113 : 
; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {
; 1118 :             _Assign_unlocked(_Right);
; 1119 :         } else
; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);
; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;
; 1128 :     }
; 1129 : 
; 1130 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {
; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {
; 1134 :             _Orphan_me_unlocked_v3();
; 1135 :         } else
; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();
; 1139 :         }
; 1140 :     }
; 1141 : 
; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {
; 1145 :             _Adopt_unlocked(_Parent);
; 1146 :         } else
; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);
; 1150 :         }
; 1151 :     }
; 1152 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1153 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1154 :         if (_Parent) { // have a parent, do adoption
; 1155 :             _Myproxy = _Parent->_Myproxy;
; 1156 :         } else { // no future parent, just disown current parent
; 1157 :             _Myproxy = nullptr;
; 1158 :         }
; 1159 :     }
; 1160 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1161 : 
; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {
; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1164 :     }
; 1165 : 
; 1166 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1167 : 
; 1168 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1169 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1111 :         *this = _Right;

  0002b	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0002e	52		 push	 edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 1112 :     }

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 04 00	 ret	 4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1108 :     _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1109 : 
; 1110 :     _CONSTEXPR20_CONTAINER _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1111 :         *this = _Right;
; 1112 :     }
; 1113 : 
; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {
; 1118 :             _Assign_unlocked(_Right);
; 1119 :         } else
; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);
; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;
; 1128 :     }
; 1129 : 
; 1130 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {
; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {
; 1134 :             _Orphan_me_unlocked_v3();
; 1135 :         } else
; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();
; 1139 :         }
; 1140 :     }
; 1141 : 
; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {
; 1145 :             _Adopt_unlocked(_Parent);
; 1146 :         } else
; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);
; 1150 :         }
; 1151 :     }
; 1152 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1153 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1154 :         if (_Parent) { // have a parent, do adoption
; 1155 :             _Myproxy = _Parent->_Myproxy;
; 1156 :         } else { // no future parent, just disown current parent
; 1157 :             _Myproxy = nullptr;
; 1158 :         }
; 1159 :     }
; 1160 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1161 : 
; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {
; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1164 :     }
; 1165 : 
; 1166 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1167 : 
; 1168 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1169 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 1108 :     _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	83 c4 04	 add	 esp, 4
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -16						; size = 4
_this$ = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1095 :     void _Orphan_all_locked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1096 :         _Lockit _Lock(_LOCK_DEBUG);

  00032	8b f4		 mov	 esi, esp
  00034	6a 03		 push	 3
  00036	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00039	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  0003f	3b f4		 cmp	 esi, esp
  00041	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1097 :         _Orphan_all_unlocked_v3();

  00046	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00049	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1098 :     }

  0004e	8b f4		 mov	 esi, esp
  00050	8d 4d f0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	52		 push	 edx
  00061	8b cd		 mov	 ecx, ebp
  00063	50		 push	 eax
  00064	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Orphan_all
  0006a	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0006f	58		 pop	 eax
  00070	5a		 pop	 edx
  00071	5e		 pop	 esi
  00072	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00075	33 cd		 xor	 ecx, ebp
  00077	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0007c	83 c4 14	 add	 esp, 20			; 00000014H
  0007f	3b ec		 cmp	 ebp, esp
  00081	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00086	8b e5		 mov	 esp, ebp
  00088	5d		 pop	 ebp
  00089	c3		 ret	 0
  0008a	66 90		 npad	 2
$LN5@Orphan_all:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN4@Orphan_all
$LN4@Orphan_all:
  00094	f0 ff ff ff	 DD	 -16			; fffffff0H
  00098	04 00 00 00	 DD	 4
  0009c	00 00 00 00	 DD	 $LN3@Orphan_all
$LN3@Orphan_all:
  000a0	5f		 DB	 95			; 0000005fH
  000a1	4c		 DB	 76			; 0000004cH
  000a2	6f		 DB	 111			; 0000006fH
  000a3	63		 DB	 99			; 00000063H
  000a4	6b		 DB	 107			; 0000006bH
  000a5	00		 DB	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -8						; size = 4
_this$ = -4						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 :     if (!_Myproxy) { // no proxy, already done

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 38 00	 cmp	 DWORD PTR [eax], 0
  00027	75 02		 jne	 SHORT $LN5@Orphan_all

; 1239 :         return;

  00029	eb 3b		 jmp	 SHORT $LN6@Orphan_all
$LN5@Orphan_all:

; 1240 :     }
; 1241 : 
; 1242 :     // proxy allocated, drain it
; 1243 :     for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { // TRANSITION, VSO-1269037

  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	83 c2 04	 add	 edx, 4
  00033	89 55 f8	 mov	 DWORD PTR __Pnext$1[ebp], edx
  00036	eb 0d		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  00038	8b 45 f8	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  0003b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0003d	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  00040	8b 41 04	 mov	 eax, DWORD PTR [ecx+4]
  00043	89 02		 mov	 DWORD PTR [edx], eax
$LN4@Orphan_all:
  00045	8b 4d f8	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00048	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0004b	74 0d		 je	 SHORT $LN3@Orphan_all

; 1244 :         _Pnext->_Myproxy = nullptr;

  0004d	8b 55 f8	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  00050	8b 02		 mov	 eax, DWORD PTR [edx]
  00052	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1245 :     }

  00058	eb de		 jmp	 SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 1246 :     _Myproxy->_Myfirstiter = nullptr;

  0005a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005f	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0
$LN6@Orphan_all:

; 1247 : }

  00066	83 c4 08	 add	 esp, 8
  00069	3b ec		 cmp	 ebp, esp
  0006b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00070	8b e5		 mov	 esp, ebp
  00072	5d		 pop	 ebp
  00073	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1250 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1251 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1252 :     if (_STD is_constant_evaluated()) {

  00018	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  0001d	0f b6 c0	 movzx	 eax, al
  00020	85 c0		 test	 eax, eax
  00022	74 0a		 je	 SHORT $LN2@Orphan_all

; 1253 :         _Orphan_all_unlocked_v3();

  00024	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00027	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1254 :     } else

  0002c	eb 08		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 1255 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1256 :     {
; 1257 :         _Orphan_all_locked_v3();

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00031	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN4@Orphan_all:

; 1258 :     }
; 1259 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1260 : }

  00036	83 c4 04	 add	 esp, 4
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1065 : 
; 1066 :     _Container_base12(const _Container_base12&) = delete;
; 1067 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1068 : 
; 1069 :     _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept;
; 1070 :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1071 : 
; 1072 :     template <class _Alloc>
; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {
; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1075 :         _Construct_in_place(*_New_proxy, this);
; 1076 :         _Myproxy            = _New_proxy;
; 1077 :         _New_proxy->_Mycont = this;
; 1078 :     }
; 1079 : 
; 1080 :     template <class _Alloc>
; 1081 :     _CONSTEXPR20_CONTAINER void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1082 :         // pre: no iterators refer to the existing proxy
; 1083 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1084 :         _Construct_in_place(*_New_proxy, this);
; 1085 :         _New_proxy->_Mycont = this;
; 1086 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1087 :     }
; 1088 : 
; 1089 :     _Container_proxy* _Myproxy = nullptr;

  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 c4 04	 add	 esp, 4
  00027	3b ec		 cmp	 ebp, esp
  00029	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  0001e	89 08		 mov	 DWORD PTR [eax], ecx

; 1057 : 
; 1058 :     const _Container_base12* _Mycont       = nullptr;
; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00020	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00023	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c4 04	 add	 esp, 4
  00030	3b ec		 cmp	 ebp, esp
  00032	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 978  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 979  :     // convert size_t to size_t, unchanged
; 980  :     return _Len;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 981  : }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -16					; size = 4
__Min_back_shift$ = -12					; size = 4
__Ptr_container$ = -8					; size = 4
__Ptr_user$ = -4					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 153  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  0000f	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00012	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00015	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  00018	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0001d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 154  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 155  :     _Bytes += _Non_user_size;

  00022	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00025	8b 08		 mov	 ecx, DWORD PTR [eax]
  00027	83 c1 27	 add	 ecx, 39			; 00000027H
  0002a	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  0002d	89 0a		 mov	 DWORD PTR [edx], ecx

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  0002f	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00032	8b 08		 mov	 ecx, DWORD PTR [eax]
  00034	89 4d fc	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  00037	ba 04 00 00 00	 mov	 edx, 4
  0003c	6b c2 ff	 imul	 eax, edx, -1
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR __Ptr_user$[ebp]
  00042	8b 14 01	 mov	 edx, DWORD PTR [ecx+eax]
  00045	89 55 f8	 mov	 DWORD PTR __Ptr_container$[ebp], edx
$LN4@Adjust_man:

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00048	b8 04 00 00 00	 mov	 eax, 4
  0004d	6b c8 fe	 imul	 ecx, eax, -2
  00050	8b 55 fc	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00053	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0005a	75 02		 jne	 SHORT $LN7@Adjust_man
  0005c	eb 5c		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  0005e	8b f4		 mov	 esi, esp
  00060	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00065	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0006a	6a 00		 push	 0
  0006c	68 a2 00 00 00	 push	 162			; 000000a2H
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  00076	6a 02		 push	 2
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0007e	83 c4 18	 add	 esp, 24			; 00000018H
  00081	3b f4		 cmp	 esi, esp
  00083	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00088	83 f8 01	 cmp	 eax, 1
  0008b	75 01		 jne	 SHORT $LN19@Adjust_man
  0008d	cc		 int	 3
$LN19@Adjust_man:
  0008e	8b f4		 mov	 esi, esp
  00090	6a 00		 push	 0
  00092	68 a2 00 00 00	 push	 162			; 000000a2H
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0009c	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  000a1	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000ac	83 c4 14	 add	 esp, 20			; 00000014H
  000af	3b f4		 cmp	 esi, esp
  000b1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b6	33 c9		 xor	 ecx, ecx
  000b8	75 a4		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  000ba	33 d2		 xor	 edx, edx
  000bc	75 8a		 jne	 SHORT $LN4@Adjust_man

; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000be	c7 45 f4 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000c5	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000c8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000ca	2b 4d f8	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  000cd	89 4d f0	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000d0	83 7d f0 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000d4	72 08		 jb	 SHORT $LN13@Adjust_man
  000d6	83 7d f0 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000da	77 02		 ja	 SHORT $LN13@Adjust_man
  000dc	eb 5c		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  000de	8b f4		 mov	 esi, esp
  000e0	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000e5	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000ea	6a 00		 push	 0
  000ec	68 ac 00 00 00	 push	 172			; 000000acH
  000f1	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000f6	6a 02		 push	 2
  000f8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000fe	83 c4 18	 add	 esp, 24			; 00000018H
  00101	3b f4		 cmp	 esi, esp
  00103	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00108	83 f8 01	 cmp	 eax, 1
  0010b	75 01		 jne	 SHORT $LN20@Adjust_man
  0010d	cc		 int	 3
$LN20@Adjust_man:
  0010e	8b f4		 mov	 esi, esp
  00110	6a 00		 push	 0
  00112	68 ac 00 00 00	 push	 172			; 000000acH
  00117	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0011c	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  00121	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00126	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0012c	83 c4 14	 add	 esp, 20			; 00000014H
  0012f	3b f4		 cmp	 esi, esp
  00131	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00136	33 c0		 xor	 eax, eax
  00138	75 a4		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0013a	33 c9		 xor	 ecx, ecx
  0013c	75 92		 jne	 SHORT $LN10@Adjust_man

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  0013e	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00141	8b 45 f8	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  00144	89 02		 mov	 DWORD PTR [edx], eax

; 174  : }

  00146	5e		 pop	 esi
  00147	83 c4 10	 add	 esp, 16			; 00000010H
  0014a	3b ec		 cmp	 ebp, esp
  0014c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00151	8b e5		 mov	 esp, ebp
  00153	5d		 pop	 ebp
  00154	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 84   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 85   :         return ::operator new(_Bytes);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 86   :     }

  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??0?$tuple@$$V@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z PROC			; std::tuple<>::tuple<>, COMDAT
; _this$ = ecx

; 217  :     constexpr tuple(const tuple&) noexcept /* strengthened */ {} // TRANSITION, ABI: should be defaulted

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	83 c4 04	 add	 esp, 4
  0001e	3b ec		 cmp	 ebp, esp
  00020	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00025	8b e5		 mov	 esp, ebp
  00027	5d		 pop	 ebp
  00028	c2 04 00	 ret	 4
??0?$tuple@$$V@std@@QAE@ABV01@@Z ENDP			; std::tuple<>::tuple<>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
$T1 = -12						; size = 12
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	c7 45 f4 cc cc
	cc cc		 mov	 DWORD PTR [ebp-12], -858993460 ; ccccccccH
  0000d	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  00014	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __FF458F76_exception
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 321  :     _THROW(bad_array_new_length{});

  00025	8d 4d f4	 lea	 ecx, DWORD PTR $T1[ebp]
  00028	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0002d	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00032	8d 45 f4	 lea	 eax, DWORD PTR $T1[ebp]
  00035	50		 push	 eax
  00036	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

  00018	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 c4 04	 add	 esp, 4
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  00011	50		 push	 eax
  00012	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00015	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 c4 04	 add	 esp, 4
  00029	3b ec		 cmp	 ebp, esp
  0002b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00016	83 c4 04	 add	 esp, 4
  00019	3b ec		 cmp	 ebp, esp
  0001b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

  00018	6a 01		 push	 1
  0001a	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00026	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00032	83 c4 04	 add	 esp, 4
  00035	3b ec		 cmp	 ebp, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00011	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  00016	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00019	83 e0 01	 and	 eax, 1
  0001c	74 0e		 je	 SHORT $LN2@scalar
  0001e	6a 0c		 push	 12			; 0000000cH
  00020	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	51		 push	 ecx
  00024	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00029	83 c4 08	 add	 esp, 8
$LN2@scalar:
  0002c	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	83 c4 04	 add	 esp, 4
  00032	3b ec		 cmp	 ebp, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00039	8b e5		 mov	 esp, ebp
  0003b	5d		 pop	 ebp
  0003c	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -8						; size = 4
_this$ = -4						; size = 4
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	c7 45 f8 cc cc
	cc cc		 mov	 DWORD PTR [ebp-8], -858993460 ; ccccccccH
  0000d	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  00014	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00028	74 0b		 je	 SHORT $LN3@what
  0002a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00030	89 55 f8	 mov	 DWORD PTR tv69[ebp], edx
  00033	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  00035	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  0003c	8b 45 f8	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  0003f	83 c4 08	 add	 esp, 8
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	83 c1 04	 add	 ecx, 4
  00027	51		 push	 ecx
  00028	e8 00 00 00 00	 call	 ___std_exception_destroy
  0002d	83 c4 04	 add	 esp, 4

; 91   :     }

  00030	83 c4 04	 add	 esp, 4
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00021	33 c9		 xor	 ecx, ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	83 c2 04	 add	 edx, 4
  00029	89 0a		 mov	 DWORD PTR [edx], ecx
  0002b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	83 c0 04	 add	 eax, 4
  00034	50		 push	 eax
  00035	8b 4d 08	 mov	 ecx, DWORD PTR __Other$[ebp]
  00038	83 c1 04	 add	 ecx, 4
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ___std_exception_copy
  00041	83 c4 08	 add	 esp, 8

; 74   :     }

  00044	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00047	83 c4 04	 add	 esp, 4
  0004a	3b ec		 cmp	 ebp, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	8b e5		 mov	 esp, ebp
  00053	5d		 pop	 ebp
  00054	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	c7 45 fc cc cc
	cc cc		 mov	 DWORD PTR [ebp-4], -858993460 ; ccccccccH
  0000b	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0000e	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  00013	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00018	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001b	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00021	33 c9		 xor	 ecx, ecx
  00023	8b 55 fc	 mov	 edx, DWORD PTR _this$[ebp]
  00026	83 c2 04	 add	 edx, 4
  00029	89 0a		 mov	 DWORD PTR [edx], ecx
  0002b	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 67   :         _Data._What = _Message;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00031	8b 4d 08	 mov	 ecx, DWORD PTR __Message$[ebp]
  00034	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 68   :     }

  00037	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0003a	83 c4 04	 add	 esp, 4
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __97D3638F_vcruntime_new@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         (void)_Size;
; 169  :         return _Where;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  00010	3b ec		 cmp	 ebp, esp
  00012	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 556  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __7FE5F402_limits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 557  :         return INT_MAX;

  0000d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 558  :     }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 180  : _NODISCARD constexpr bool is_constant_evaluated() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __47F37C5A_xtr1common
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 181  :     return __builtin_is_constant_evaluated();

  0000d	32 c0		 xor	 al, al

; 182  : }

  0000f	3b ec		 cmp	 ebp, esp
  00011	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __93DC0B45_wchar@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00010	d1 e0		 shl	 eax, 1
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00023	3b ec		 cmp	 ebp, esp
  00025	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT _printf
_TEXT	SEGMENT
tv73 = -20						; size = 4
tv75 = -16						; size = 4
__ArgList$ = -8						; size = 4
__Result$ = -4						; size = 4
__Format$ = 8						; size = 4
_printf	PROC						; COMDAT

; 956  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	56		 push	 esi
  00007	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0000c	89 45 ec	 mov	 DWORD PTR [ebp-20], eax
  0000f	89 45 f0	 mov	 DWORD PTR [ebp-16], eax
  00012	89 45 f4	 mov	 DWORD PTR [ebp-12], eax
  00015	89 45 f8	 mov	 DWORD PTR [ebp-8], eax
  00018	89 45 fc	 mov	 DWORD PTR [ebp-4], eax
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00025	8d 45 0c	 lea	 eax, DWORD PTR __Format$[ebp+4]
  00028	89 45 f8	 mov	 DWORD PTR __ArgList$[ebp], eax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  0002b	8b 4d 08	 mov	 ecx, DWORD PTR __Format$[ebp]
  0002e	89 4d f0	 mov	 DWORD PTR tv75[ebp], ecx
  00031	8b f4		 mov	 esi, esp
  00033	6a 01		 push	 1
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____acrt_iob_func
  0003b	83 c4 04	 add	 esp, 4
  0003e	3b f4		 cmp	 esi, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  00048	8b 55 f8	 mov	 edx, DWORD PTR __ArgList$[ebp]
  0004b	52		 push	 edx
  0004c	6a 00		 push	 0
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv75[ebp]
  00051	50		 push	 eax
  00052	8b 4d ec	 mov	 ecx, DWORD PTR tv73[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 __vfprintf_l
  0005b	83 c4 10	 add	 esp, 16			; 00000010H
  0005e	89 45 fc	 mov	 DWORD PTR __Result$[ebp], eax

; 961  :         __crt_va_end(_ArgList);

  00061	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __ArgList$[ebp], 0

; 962  :         return _Result;

  00068	8b 45 fc	 mov	 eax, DWORD PTR __Result$[ebp]

; 963  :     }

  0006b	5e		 pop	 esi
  0006c	83 c4 14	 add	 esp, 20			; 00000014H
  0006f	3b ec		 cmp	 ebp, esp
  00071	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00076	8b e5		 mov	 esp, ebp
  00078	5d		 pop	 ebp
  00079	c3		 ret	 0
_printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\stdio.h
;	COMDAT __vfprintf_l
_TEXT	SEGMENT
__Stream$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vfprintf_l PROC					; COMDAT

; 644  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	56		 push	 esi
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET __6DFAE8B8_stdio@h
  00009	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  0000e	8b f4		 mov	 esi, esp
  00010	8b 45 14	 mov	 eax, DWORD PTR __ArgList$[ebp]
  00013	50		 push	 eax
  00014	8b 4d 10	 mov	 ecx, DWORD PTR __Locale$[ebp]
  00017	51		 push	 ecx
  00018	8b 55 0c	 mov	 edx, DWORD PTR __Format$[ebp]
  0001b	52		 push	 edx
  0001c	8b 45 08	 mov	 eax, DWORD PTR __Stream$[ebp]
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 ___local_stdio_printf_options
  00025	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00028	51		 push	 ecx
  00029	8b 10		 mov	 edx, DWORD PTR [eax]
  0002b	52		 push	 edx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____stdio_common_vfprintf
  00032	83 c4 18	 add	 esp, 24			; 00000018H
  00035	3b f4		 cmp	 esi, esp
  00037	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 646  :     }

  0003c	5e		 pop	 esi
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
__vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 90   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __A2143F22_corecrt_stdio_config@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  0000d	b8 00 00 00 00	 mov	 eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00012	3b ec		 cmp	 ebp, esp
  00014	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Univers.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __91E4D184_Univers@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	3b ec		 cmp	 ebp, esp
  0000f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
