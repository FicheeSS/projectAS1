; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Debug\ProjetTutore1.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG254796 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xlocale', 00H
___asan_rrz_$SG254796 DD 0f9H
	ORG $+52
$SG230840 DB	'Projet Tutor', 0e9H, ' Groupe 1', 00H
___asan_rrz_$SG230840 DD 0f9H
	ORG $+37
$SG230843 DB	'.\ico.png', 00H
___asan_rrz_$SG230843 DD 0f9H
	ORG $+50
$SG249217 DB	'Unable to open message catalog: ', 00H
___asan_rrz_$SG249217 DD 0f9H
	ORG $+59
$SG249224 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
___asan_rrz_$SG249224 DD 0f9H
	ORG $+86
$SG249225 DB	'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H
___asan_rrz_$SG249225 DD 0f9H
	ORG $+46
$SG249227 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
___asan_rrz_$SG249227 DD 0f9H
	ORG $+86
$SG249228 DB	'0', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'r', 00H
	DB	00H, 00H
___asan_rrz_$SG249228 DD 0f9H
	ORG $+46
$SG258642 DB	'invalid argument', 00H
___asan_rrz_$SG258642 DD 0f9H
	ORG $+43
$SG258643 DB	'%s', 00H
___asan_rrz_$SG258643 DD 0f9H
	ORG $+57
$SG258644 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xmemory', 00H
___asan_rrz_$SG258644 DD 0f9H
	ORG $+52
$SG258645 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
___asan_rrz_$SG258645 DD 0f9H
	ORG $+44
$SG258646 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
___asan_rrz_$SG258646 DD 0f9H
	ORG $+46
$SG258647 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
___asan_rrz_$SG258647 DD 0f9H
CONST	ENDS
ASAN$GL	SEGMENT
_L___asan_global_$SG258647 DD FLAT:$SG258647
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.30
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.31
	DD	00H
_L___asan_global_$SG258646 DD FLAT:$SG258646
	DD	04eH
	DD	080H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
_L___asan_global_$SG258645 DD FLAT:$SG258645
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.26
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.27
	DD	00H
_L___asan_global_$SG258644 DD FLAT:$SG258644
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.24
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.25
	DD	00H
_L___asan_global_$SG258643 DD FLAT:$SG258643
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.22
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.23
	DD	00H
_L___asan_global_$SG258642 DD FLAT:$SG258642
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.20
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.21
	DD	00H
_L___asan_global_$SG249228 DD FLAT:$SG249228
	DD	0eH
	DD	040H
	DD	FLAT:_L___asan_gen_.17
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.18
	DD	00H
_L___asan_global_$SG249227 DD FLAT:$SG249227
	DD	0106H
	DD	0160H
	DD	FLAT:_L___asan_gen_.15
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.16
	DD	00H
_L___asan_global_$SG249225 DD FLAT:$SG249225
	DD	0eH
	DD	040H
	DD	FLAT:_L___asan_gen_.13
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.14
	DD	00H
_L___asan_global_$SG249224 DD FLAT:$SG249224
	DD	0106H
	DD	0160H
	DD	FLAT:_L___asan_gen_.11
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.12
	DD	00H
_L___asan_global_$SG249217 DD FLAT:$SG249217
	DD	021H
	DD	060H
	DD	FLAT:_L___asan_gen_.9
	DD	FLAT:_L___asan_gen_.8
	DD	00H
	DD	FLAT:_L___asan_gen_.10
	DD	00H
_L___asan_global_$SG230843 DD FLAT:$SG230843
	DD	0aH
	DD	040H
	DD	FLAT:_L___asan_gen_.6
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.7
	DD	00H
_L___asan_global_$SG230840 DD FLAT:$SG230840
	DD	017H
	DD	040H
	DD	FLAT:_L___asan_gen_.4
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.5
	DD	00H
_L___asan_global_$SG254796 DD FLAT:$SG254796
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
CONST	SEGMENT
	ORG $+54
_L___asan_gen_.0 DB 'xlocale', 00H
_L___asan_gen_.1 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	020eH
	DD	059H
_L___asan_gen_.3 DB 'ProjetTutore1.cpp', 00H
	ORG $+2
_L___asan_gen_.4 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.5 DD FLAT:_L___asan_gen_.3
	DD	09H
	DD	036H
_L___asan_gen_.6 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.7 DD FLAT:_L___asan_gen_.3
	DD	0cH
	DD	01aH
_L___asan_gen_.8 DB 'w32_regex_traits.hpp', 00H
	ORG $+3
_L___asan_gen_.9 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.10 DD FLAT:_L___asan_gen_.8
	DD	02c1H
	DD	01aH
_L___asan_gen_.11 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.12 DD FLAT:_L___asan_gen_.8
	DD	02f7H
	DD	06H
_L___asan_gen_.13 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.14 DD FLAT:_L___asan_gen_.8
	DD	02f7H
	DD	06H
_L___asan_gen_.15 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.16 DD FLAT:_L___asan_gen_.8
	DD	0314H
	DD	06H
_L___asan_gen_.17 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.18 DD FLAT:_L___asan_gen_.8
	DD	0314H
	DD	06H
_L___asan_gen_.19 DB 'xmemory', 00H
_L___asan_gen_.20 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.21 DD FLAT:_L___asan_gen_.19
	DD	08eH
	DD	04H
_L___asan_gen_.22 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.23 DD FLAT:_L___asan_gen_.19
	DD	08eH
	DD	04H
_L___asan_gen_.24 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.25 DD FLAT:_L___asan_gen_.19
	DD	08eH
	DD	04H
_L___asan_gen_.26 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.27 DD FLAT:_L___asan_gen_.19
	DD	08eH
	DD	04H
_L___asan_gen_.28 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.19
	DD	08eH
	DD	04H
_L___asan_gen_.30 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.31 DD FLAT:_L___asan_gen_.19
	DD	08eH
	DD	04H
CONST	ENDS
msvcjmc	SEGMENT
__4FA62C6D_Univers@h DB 01H
__B3577796_RenderStates@hpp DB 01H
__59466570_predefined C++ types (compiler internal) DB 01H
__97D3638F_vcruntime_new@h DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__47F37C5A_xtr1common DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__A751F051_corecrt_memory@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__32E5F013_string@h DB 01H
__81812A28_cstddef DB 01H
__589FA321_type_traits DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__7FE5F402_limits DB 01H
__DD5FCA34_compare DB 01H
__12269DE6_xutility DB 01H
__60BC708E_cmath DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__C69F69CF_tuple DB 01H
__79D216CD_xmemory DB 01H
__374A57BA_xpolymorphic_allocator@h DB 01H
__0D019051_xstring DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__1B354CA2_system_error DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__C34BF88C_memory DB 01H
__EF0EAF83_xfacet DB 01H
__B2D2BA86_ctype@h DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__B2A9EE53_InputStream@hpp DB 01H
__62DD75E3_NonCopyable@hpp DB 01H
__B7987E10_string DB 01H
__1589CDA2_algorithm DB 01H
__FE33131C_xlocmes DB 01H
__67DA974F_xlocmon DB 01H
__D96D2425_xloctime DB 01H
__FC4CDF9C_Thread@inl DB 01H
__3C1C7D88_ContextSettings@hpp DB 01H
__8D991C03_Drawable@hpp DB 01H
__896EE8A8_Glyph@hpp DB 01H
__69958C8C_xtree DB 01H
__E3A1A8C3_Font@hpp DB 01H
__68B92D9D_xbit_ops@h DB 01H
__0F13B0E8_xhash DB 01H
__BFE0F84B_functional DB 01H
__3A667B81_error_category@hpp DB 01H
__25339F4A_generic_category_message@hpp DB 01H
__A4E336F0_generic_category@hpp DB 01H
__2DD6F2A3_error_condition@hpp DB 01H
__C6D9B9B2_system_category@hpp DB 01H
__1B11AAFA_snprintf@hpp DB 01H
__6767E947_error_handling@hpp DB 01H
__EE1D0242_system_category_message_win32@hpp DB 01H
__F4D1038E_system_category_condition_win32@hpp DB 01H
__1D2FDE06_system_category_impl@hpp DB 01H
__13E3B269_interop_category@hpp DB 01H
__F4A89B3F_error_code@hpp DB 01H
__C655F023_std_category@hpp DB 01H
__51E12D41_error_category_impl@hpp DB 01H
__147DD91B_path_traits@hpp DB 01H
__CE27CDA6_facade_iterator_category@hpp DB 01H
__FCD69F0E_ios_state@hpp DB 01H
__32E57CF6_path@hpp DB 01H
__0269C046_errc@hpp DB 01H
__38C7FDF2_throws@hpp DB 01H
__B76B1A2C_system_error@hpp DB 01H
__8868518C_atomic_count_std_atomic@hpp DB 01H
__BFCE1B3F_intrusive_ref_counter@hpp DB 01H
__203D301F_exception@hpp DB 01H
__6D84B491_file_status@hpp DB 01H
__9E7B425B_directory@hpp DB 01H
__994C2822_operations@hpp DB 01H
__85CA39D3_convenience@hpp DB 01H
__54B77B77_fstream DB 01H
__819F9458_fstream@hpp DB 01H
__807252DF_string_file@hpp DB 01H
__2B558C5C_implementation_help@hpp DB 01H
__53FD89EC_noncopyable@hpp DB 01H
__249AC1FF_as_literal@hpp DB 01H
__CCA81496_classification@hpp DB 01H
__9E8302C5_classification@hpp DB 01H
__291069DD_compare@hpp DB 01H
__6E0894BC_finder@hpp DB 01H
__6005BCF8_finder@hpp DB 01H
__876C1A82_exception@hpp DB 01H
__C6048E53_current_function@hpp DB 01H
__550A1F1C_source_location@hpp DB 01H
__78E6F2C5_throw_exception@hpp DB 01H
__36989B12_demangle@hpp DB 01H
__DBA21239_stl_type_index@hpp DB 01H
__DFD8B503_function_base@hpp DB 01H
__0C0FE920_ratio DB 01H
__2D75401A___msvc_tzdb@hpp DB 01H
__7BF231E7_optional DB 01H
__324884E2_vector DB 01H
__1347750E_utility DB 01H
__20D3AEFC_forward_list DB 01H
__1B08F288_chrono DB 01H
__491EF713_xfilesystem_abi@h DB 01H
__2B6093AE_list DB 01H
__B111E740_filesystem DB 01H
__B26BA995_regex DB 01H
__C78A343B_SoundFileReader@hpp DB 01H
__5D3957BC_SoundFileWriter@hpp DB 01H
__A5341E86_regex_workaround@hpp DB 01H
__84A6C509_regex_traits_defaults@hpp DB 01H
__C72864EE_pattern_except@hpp DB 01H
__8A32E06C_stop_token DB 01H
__1806803A_thread DB 01H
__1EA2E370_mutex DB 01H
__BC8232E2_cpp_regex_traits@hpp DB 01H
__EF9A24B2_c_regex_traits@hpp DB 01H
__79C7FC57_basetsd@h DB 01H
__D545DD43_guiddef@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__D4435474_winerror@h DB 01H
__B3ED30D4_winbase@h DB 01H
__DB057BA3_winuser@h DB 01H
__A118E6DC_stralign@h DB 01H
__43AE03FC_w32_regex_traits@hpp DB 01H
__ED044598_match_flags@hpp DB 01H
__9829EA86_regex_raw_buffer@hpp DB 01H
__BA42420E_basic_regex@hpp DB 01H
__F162022C_set DB 01H
__3C41319C_indexed_bit_flag@hpp DB 01H
__A750400E_basic_regex_creator@hpp DB 01H
__CFA0C522_basic_regex_parser@hpp DB 01H
__23D98615_mem_block_cache@hpp DB 01H
__0A52C9A5_perl_matcher_non_recursive@hpp DB 01H
__C1A77E9F_perl_matcher@hpp DB 01H
__28BBFA9C_RessourcePack@h DB 01H
__0D6BD463_Character@h DB 01H
__372D2D08_initializer_list DB 01H
__E458E21C_xstddef DB 01H
__218DFE2C_Levels@h DB 01H
__9344C8DF_Block@h DB 01H
__7385D044_any DB 01H
__78BC29F0_TerrainConstructor@h DB 01H
__9D99E827_Terrain@h DB 01H
__E4B0DE56_String@hpp DB 01H
__059B899A_ProjetTutore1@cpp DB 01H
__FA839AC8_operator_bool@hpp DB 01H
__0FFFED91_intrusive_ptr@hpp DB 01H
__B38B2551_iterator_facade@hpp DB 01H
__A2FF0B9E_istream DB 01H
__68A60A21_locale DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__038A2AA6_iterator DB 01H
__B30C2184_iosfwd DB 01H
__C23CD225_Rect@inl DB 01H
__03BEDB82_Rect@hpp DB 01H
__F1CBF088_type_index@hpp DB 01H
__68C17CDA_primary_transform@hpp DB 01H
__F54903A0_xatomic@h DB 01H
__1CB4EB11_addressof@hpp DB 01H
__1EB17C13_integral_constant@hpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	_wmemcpy
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::copy
PUBLIC	?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z	; std::_Char_traits<char,int>::move
PUBLIC	?assign@?$_Char_traits@DH@std@@SAPADQADID@Z	; std::_Char_traits<char,int>::assign
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?_Xlen_string@std@@YAXXZ			; std::_Xlen_string
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0locale@std@@QAE@XZ				; std::locale::locale
PUBLIC	??1locale@std@@QAE@XZ				; std::locale::~locale
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0ContextSettings@sf@@QAE@IIIIII_N@Z		; sf::ContextSettings::ContextSettings
PUBLIC	??$max@I@std@@YAABIABI0@Z			; std::max<unsigned int>
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
PUBLIC	??0?$initializer_list@H@std@@QAE@PBH0@Z		; std::initializer_list<int>::initializer_list<int>
PUBLIC	?begin@?$initializer_list@H@std@@QBEPBHXZ	; std::initializer_list<int>::begin
PUBLIC	?end@?$initializer_list@H@std@@QBEPBHXZ		; std::initializer_list<int>::end
PUBLIC	?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::setDefaultFolder
PUBLIC	?__autoclassinit2@RessourcePack@@QAEXI@Z	; RessourcePack::__autoclassinit2
PUBLIC	??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
PUBLIC	?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
PUBLIC	?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
PUBLIC	?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
PUBLIC	?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
PUBLIC	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
PUBLIC	??$distance@PBH@std@@YAHPBH0@Z			; std::distance<int const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z	; std::_Get_unwrapped<int const * const &>
PUBLIC	??$to_address@$$CBH@std@@YAPBHQBH@Z		; std::to_address<int const >
PUBLIC	??$to_address@H@std@@YAPAHQAH@Z			; std::to_address<int>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z	; std::_Copy_memmove<int const *,int *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$construct_at@HABHX@std@@YAPAHQAHABH@Z	; std::construct_at<int,int const &,void>
PUBLIC	??$_Voidify_iter@PAH@std@@YAPAXPAH@Z		; std::_Voidify_iter<int *>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
PUBLIC	??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
PUBLIC	??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
PUBLIC	??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
PUBLIC	??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
PUBLIC	??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
PUBLIC	??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z	; std::construct_at<int,int &,void>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
PUBLIC	?__autoclassinit2@Univers@@QAEXI@Z		; Univers::__autoclassinit2
PUBLIC	_main
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YAII@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
PUBLIC	??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
PUBLIC	??$_Get_size_of_n@$00@std@@YAII@Z		; std::_Get_size_of_n<1>
PUBLIC	??$construct_at@DABDX@std@@YAPADQADABD@Z	; std::construct_at<char,char const &,void>
PUBLIC	??$_Voidify_iter@PAD@std@@YAPAXPAD@Z		; std::_Voidify_iter<char *>
PUBLIC	??$forward@ABD@std@@YAABDABD@Z			; std::forward<char const &>
PUBLIC	??$_To_address@PBH@std@@YA?A_PABQBH@Z		; std::_To_address<int const *>
PUBLIC	??$_To_address@PAH@std@@YA?A_PABQAH@Z		; std::_To_address<int *>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$forward@ABQAD@std@@YAABQADABQAD@Z		; std::forward<char * const &>
PUBLIC	??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &,void>
PUBLIC	??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z	; std::_Voidify_iter<char * *>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long@		; `string'
PUBLIC	??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	?_Init@locale@std@@CAPAV_Locimp@12@_N@Z:PROC	; std::locale::_Init
EXTRN	__imp_??0String@sf@@QAE@PBDABVlocale@std@@@Z:PROC
EXTRN	__imp_??1String@sf@@QAE@XZ:PROC
EXTRN	__imp_??0VideoMode@sf@@QAE@III@Z:PROC
EXTRN	__imp_?setIcon@Window@sf@@QAEXIIPBE@Z:PROC
EXTRN	__imp_?setFramerateLimit@Window@sf@@QAEXI@Z:PROC
EXTRN	__imp_??0Image@sf@@QAE@XZ:PROC
EXTRN	__imp_??1Image@sf@@QAE@XZ:PROC
EXTRN	__imp_?loadFromFile@Image@sf@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:PROC
EXTRN	__imp_?getSize@Image@sf@@QBE?AV?$Vector2@I@2@XZ:PROC
EXTRN	__imp_?getPixelsPtr@Image@sf@@QBEPBEXZ:PROC
EXTRN	__imp_??0RenderWindow@sf@@QAE@VVideoMode@1@ABVString@1@IABUContextSettings@1@@Z:PROC
EXTRN	__imp_??1RenderWindow@sf@@UAE@XZ:PROC
EXTRN	??0RessourcePack@@QAE@XZ:PROC			; RessourcePack::RessourcePack
EXTRN	??1RessourcePack@@QAE@XZ:PROC			; RessourcePack::~RessourcePack
EXTRN	??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z:PROC ; Univers::Univers
EXTRN	?animate@Univers@@QAEXXZ:PROC			; Univers::animate
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___asan_loadN:PROC
EXTRN	___asan_memcpy:PROC
EXTRN	___asan_memset:PROC
EXTRN	___asan_report_load1:PROC
EXTRN	___asan_report_load4:PROC
EXTRN	___asan_report_store1:PROC
EXTRN	___asan_report_store2:PROC
EXTRN	___asan_report_store4:PROC
EXTRN	___asan_set_shadow_00:PROC
EXTRN	___asan_set_shadow_f8:PROC
EXTRN	___asan_storeN:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A
_BSS	SEGMENT
?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 010H DUP (?) ; level1
___asan_rrz_?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 030H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
___asan_rrz_??_C@_0BC@EOODALEL@Unknown?5exception@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
___asan_rrz_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
___asan_rrz_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
___asan_rrz_??_C@_02DKCKIIND@?$CFs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xmemory', 00H	; `string'
___asan_rrz_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long@ DB 'string too long', 00H ; `string'
___asan_rrz_??_C@_0BA@JFNIOLAK@string?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocale', 00H	; `string'
___asan_rrz_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocnum', 00H	; `string'
___asan_rrz_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
___asan_rrz_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
___asan_rrz_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD 0f9H
CONST	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?level1$initializer$@@3P6AXXZA DD FLAT:??__Elevel1@@YAXXZ ; level1$initializer$
CRT$XCU	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	DD	01aH
	DD	040H
	DD	FLAT:_L___asan_gen_.33
	DD	FLAT:_L___asan_gen_.30
	DD	00H
	DD	FLAT:_L___asan_gen_.34
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.34 DD FLAT:_L___asan_gen_.30
	DD	0b4H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.33 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	DD	0dH
	DD	040H
	DD	FLAT:_L___asan_gen_.31
	DD	FLAT:_L___asan_gen_.30
	DD	00H
	DD	FLAT:_L___asan_gen_.32
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.32 DD FLAT:_L___asan_gen_.30
	DD	01b7H
	DD	030H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.31 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.30 DB 'xloctime', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.27
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.27
	DD	06eeH
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.28 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.27 DB 'vector', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.25
	DD	FLAT:_L___asan_gen_.24
	DD	00H
	DD	FLAT:_L___asan_gen_.26
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.26 DD FLAT:_L___asan_gen_.24
	DD	05dH
	DD	05fH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.25 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.24 DB 'xlocnum', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.22
	DD	FLAT:_L___asan_gen_.21
	DD	00H
	DD	FLAT:_L___asan_gen_.23
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.23 DD FLAT:_L___asan_gen_.21
	DD	049H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.22 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.21 DB 'xlocale', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BA@JFNIOLAK@string?5too?5long@ DD FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.19
	DD	FLAT:_L___asan_gen_.18
	DD	00H
	DD	FLAT:_L___asan_gen_.20
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.20 DD FLAT:_L___asan_gen_.18
	DD	0946H
	DD	013H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.19 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.18 DB 'xstring', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.16
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.17
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.17 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.16 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD FLAT:??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	DD	04aH
	DD	080H
	DD	FLAT:_L___asan_gen_.14
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.15
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.15 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.14 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.12
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.13
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.13 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.12 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.10
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.11
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.11 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.10 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_02DKCKIIND@?$CFs@ DD FLAT:??_C@_02DKCKIIND@?$CFs@
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.8
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.9
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.9 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.8 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.6
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.7
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.7 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.6 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.5 DB 'xmemory', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	DD	015H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	08cH
	DD	014H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.3 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BC@EOODALEL@Unknown?5exception@ DD FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	DD	012H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	05fH
	DD	02bH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.1 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.0 DB 'vcruntime_exception.h', 00H
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	030dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z DB '1'
	DB	' 16 4 8 _New_ptr'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$_main$0
	DD	053H
	DD	060H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:_main
	DD	032H
	DD	0612H
voltbl	ENDS
xdata$x	SEGMENT
__ehfuncinfo$_main DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
	DD	00H
	DD	FLAT:__unwindfunclet$_main$1
	DD	01H
	DD	FLAT:__unwindfunclet$_main$2
	DD	00H
	DD	FLAT:__unwindfunclet$_main$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$_main$2
	DD	04H
	DD	FLAT:__unwindfunclet$_main$3
	DD	05H
	DD	FLAT:__unwindfunclet$_main$4
	DD	05H
	DD	FLAT:__unwindfunclet$_main$5
xdata$x	ENDS
CONST	SEGMENT
	ORG $+4
__L__asan_gen_._main DB '10 16 528 6 window 32 48 2 RP 48 40 4 Univ 64 28'
	DB	' 18 compiler temporary 80 28 18 compiler temporary 96 8 18 co'
	DB	'mpiler temporary 112 12 18 compiler temporary 128 24 4 icon 1'
	DB	'44 28 18 compiler temporary 160 8 1 s'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0b3H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__Elevel1@@YAXXZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$??__Elevel1@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__Elevel1@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$14
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??__Elevel1@@YAXXZ DB '45 16 224 18 compiler temporary 32 '
	DB	'36 18 compiler temporary 48 36 18 compiler temporary 64 36 18'
	DB	' compiler temporary 80 36 18 compiler temporary 96 36 18 comp'
	DB	'iler temporary 112 36 18 compiler temporary 128 36 18 compile'
	DB	'r temporary 144 36 18 compiler temporary 160 36 18 compiler t'
	DB	'emporary 176 36 18 compiler temporary 192 36 18 compiler temp'
	DB	'orary 208 36 18 compiler temporary 224 36 18 compiler tempora'
	DB	'ry 240 36 18 compiler temporary 256 1 18 compiler temporary 2'
	DB	'72 1 18 compiler temporary 288 8 18 compiler temporary 304 1 '
	DB	'18 compiler temporary 320 8 18 compiler temporary 336 1 18 co'
	DB	'mpiler temporary 352 8 18 compiler temporary 368 1 18 compile'
	DB	'r temporary 384 8 18 compiler temporary 400 1 18 compiler tem'
	DB	'porary 416 8 18 compiler temporary 432 1 18 compiler temporar'
	DB	'y 448 8 18 compiler temporary 464 1 18 compiler temporary 480'
	DB	' 8 18 compiler temporary 496 1 18 compiler temporary 512 8 18'
	DB	' compiler temporary 528 1 18 compiler temporary 544 8 18 comp'
	DB	'iler temporary 560 1 18 compiler temporary 576 8 18 compiler '
	DB	'temporary 592 1 18 compiler temporary 608 8 18 compiler tempo'
	DB	'rary 624 1 18 compiler temporary 640 8 18 compiler temporary '
	DB	'656 1 18 compiler temporary 672 8 18 compiler temporary 688 1'
	DB	' 18 compiler temporary 704 8 18 compiler temporary 720 8 18 c'
	DB	'ompiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02fH
	DW	0137H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0268H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DB '1'
	DB	' 16 4 6 _Guard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0268H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DB '1'
	DB	' 16 4 6 _Guard'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z DB '1'
	DB	' 16 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ DB '2'
	DB	' 16 1 4 $S10 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01d2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DB '3'
	DB	' 16 1 3 $S8 32 8 6 _Proxy 48 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
__ehfuncinfo$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DB '2 16 1 4'
	DB	' $S13 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	03f7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DB '4 '
	DB	'16 1 18 compiler temporary 32 1 3 $S9 48 8 6 _Proxy 64 4 6 _G'
	DB	'uard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01d2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DB '3'
	DB	' 16 1 3 $S7 32 8 6 _Proxy 48 1 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	022dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z DB '3 16'
	DB	' 8 6 _Mbst1 32 2 3 _Wc 48 8 6 _Mbst2'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0locale@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0253H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z DB '2'
	DB	' 16 4 7 _Masked 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	02c7H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ DB '4'
	DB	' 16 4 10 _Alloc_max 32 4 18 compiler temporary 48 4 18 compil'
	DB	'er temporary 64 4 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0160H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ DB '1'
	DB	' 16 1 4 $S35'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	01eH
	DB	02bH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0153H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1
__ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z DB '2'
	DB	' 16 1 4 $S37 32 8 6 _Proxy'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ DB '1 16 12 18 com'
	DB	'piler temporary'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 693  :     static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 694  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 695  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 696  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN2@deallocate

; 697  :             _Al.deallocate(_Ptr, _Count);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00024	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 698  :         } else

  00029	eb 13		 jmp	 SHORT $LN1@deallocate
$LN2@deallocate:

; 699  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 700  :         {
; 701  :             (void) _Al;
; 702  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	c1 e0 03	 shl	 eax, 3
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003b	83 c4 08	 add	 esp, 8
$LN1@deallocate:

; 703  :         }
; 704  :     }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z PROC		; std::_Voidify_iter<char * *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ENDP		; std::_Voidify_iter<char * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z PROC	; std::construct_at<char *,char * const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ENDP	; std::construct_at<char *,char * const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAD@std@@YAABQADABQAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAD@std@@YAABQADABQAD@Z PROC		; std::forward<char * const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABQAD@std@@YAABQADABQAD@Z ENDP		; std::forward<char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
tv90 = -32						; size = 4
tv88 = -28						; size = 4
__Block_size$ = -24					; size = 4
__Ptr$ = -20						; size = 4
tv128 = -16						; size = 4
__Ptr_container$ = -12					; size = 4
tv138 = -8						; size = 4
tv131 = -2						; size = 1
tv141 = -1						; size = 1
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	83 c0 27	 add	 eax, 39			; 00000027H
  00016	89 45 e8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 137  :     if (_Block_size <= _Bytes) {

  00019	8b 4d e8	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  0001c	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  0001f	77 05		 ja	 SHORT $LN8@Allocate_m

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00021	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00026	8b 55 e8	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f4	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00035	83 7d f4 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00039	74 02		 je	 SHORT $LN7@Allocate_m
  0003b	eb 4a		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  0003d	68 00 00 00 00	 push	 OFFSET $SG258642
  00042	68 00 00 00 00	 push	 OFFSET $SG258643
  00047	6a 00		 push	 0
  00049	68 8e 00 00 00	 push	 142			; 0000008eH
  0004e	68 00 00 00 00	 push	 OFFSET $SG258644
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN12@Allocate_m
  00063	cc		 int	 3
$LN12@Allocate_m:
  00064	6a 00		 push	 0
  00066	68 8e 00 00 00	 push	 142			; 0000008eH
  0006b	68 00 00 00 00	 push	 OFFSET $SG258645
  00070	68 00 00 00 00	 push	 OFFSET $SG258646
  00075	68 00 00 00 00	 push	 OFFSET $SG258647
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	33 c9		 xor	 ecx, ecx
  00085	75 b6		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00087	33 d2		 xor	 edx, edx
  00089	75 aa		 jne	 SHORT $LN4@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0008e	83 c0 27	 add	 eax, 39			; 00000027H
  00091	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00094	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00097	b9 04 00 00 00	 mov	 ecx, 4
  0009c	6b d1 ff	 imul	 edx, ecx, -1
  0009f	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a2	03 c2		 add	 eax, edx
  000a4	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR tv88[ebp]
  000aa	89 4d f8	 mov	 DWORD PTR tv138[ebp], ecx
  000ad	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000b0	c1 ea 03	 shr	 edx, 3
  000b3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b9	88 45 ff	 mov	 BYTE PTR tv141[ebp], al
  000bc	80 7d ff 00	 cmp	 BYTE PTR tv141[ebp], 0
  000c0	74 1a		 je	 SHORT $LN14@Allocate_m
  000c2	8a 4d f8	 mov	 cl, BYTE PTR tv138[ebp]
  000c5	80 e1 07	 and	 cl, 7
  000c8	80 c1 03	 add	 cl, 3
  000cb	3a 4d ff	 cmp	 cl, BYTE PTR tv141[ebp]
  000ce	7c 0c		 jl	 SHORT $LN14@Allocate_m
  000d0	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ___asan_report_store4
  000d9	83 c4 04	 add	 esp, 4
$LN14@Allocate_m:
  000dc	8b 45 e4	 mov	 eax, DWORD PTR tv88[ebp]
  000df	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e4	ba 04 00 00 00	 mov	 edx, 4
  000e9	6b c2 fe	 imul	 eax, edx, -2
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ef	03 c8		 add	 ecx, eax
  000f1	89 4d e0	 mov	 DWORD PTR tv90[ebp], ecx
  000f4	8b 55 e0	 mov	 edx, DWORD PTR tv90[ebp]
  000f7	89 55 f0	 mov	 DWORD PTR tv128[ebp], edx
  000fa	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  000fd	c1 e8 03	 shr	 eax, 3
  00100	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00106	88 4d fe	 mov	 BYTE PTR tv131[ebp], cl
  00109	80 7d fe 00	 cmp	 BYTE PTR tv131[ebp], 0
  0010d	74 1a		 je	 SHORT $LN13@Allocate_m
  0010f	8a 55 f0	 mov	 dl, BYTE PTR tv128[ebp]
  00112	80 e2 07	 and	 dl, 7
  00115	80 c2 03	 add	 dl, 3
  00118	3a 55 fe	 cmp	 dl, BYTE PTR tv131[ebp]
  0011b	7c 0c		 jl	 SHORT $LN13@Allocate_m
  0011d	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ___asan_report_store4
  00126	83 c4 04	 add	 esp, 4
$LN13@Allocate_m:
  00129	8b 4d e0	 mov	 ecx, DWORD PTR tv90[ebp]
  0012c	c7 01 fa fa fa
	fa		 mov	 DWORD PTR [ecx], -84215046 ; fafafafaH

; 148  : #endif // _DEBUG
; 149  :     return _Ptr;

  00132	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 150  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::destroy_at<std::vector<int,std::allocator<int> > >, COMDAT

; 318  : _CONSTEXPR20_DYNALLOC void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 319  : #if _HAS_CXX20
; 320  :     if constexpr (is_array_v<_Ty>) {
; 321  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 322  :     } else
; 323  : #endif // _HAS_CXX20
; 324  :     {
; 325  :         _Location->~_Ty();

  0000d	6a 00		 push	 0
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Location$[ebp]
  00012	e8 00 00 00 00	 call	 ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z

; 326  :     }
; 327  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::destroy_at<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 985  : _CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 986  :     // deallocate a plain pointer using an allocator
; 987  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 988  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 989  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  0002c	6a 01		 push	 1
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 990  :     } else {
; 991  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 992  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 993  :     }
; 994  : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAH@std@@YA?A_PABQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAH@std@@YA?A_PABQAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@H@std@@YAPAHQAH@Z ; std::to_address<int>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAH@std@@YA?A_PABQAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PBH@std@@YA?A_PABQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PBH@std@@YA?A_PABQBH@Z PROC		; std::_To_address<int const *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@$$CBH@std@@YAPBHQBH@Z ; std::to_address<int const >
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PBH@std@@YA?A_PABQBH@Z ENDP		; std::_To_address<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABD@std@@YAABDABD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABD@std@@YAABDABD@Z PROC			; std::forward<char const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABD@std@@YAABDABD@Z ENDP			; std::forward<char const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAD@std@@YAPAXPAD@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAD@std@@YAPAXPAD@Z PROC		; std::_Voidify_iter<char *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAD@std@@YAPAXPAD@Z ENDP		; std::_Voidify_iter<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@DABDX@std@@YAPADQADABD@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@DABDX@std@@YAPADQADABD@Z PROC		; std::construct_at<char,char const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAD@std@@YAPAXPAD@Z ; std::_Voidify_iter<char *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 01		 push	 1
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABD@std@@YAABDABD@Z ; std::forward<char const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 17		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  0005d	7c 0c		 jl	 SHORT $LN4@construct_
  0005f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 ___asan_report_load1
  00068	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006b	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0006e	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00071	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00074	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  00077	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007a	c1 e8 03	 shr	 eax, 3
  0007d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00083	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00086	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008a	74 17		 je	 SHORT $LN3@construct_
  0008c	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  0008f	80 e2 07	 and	 dl, 7
  00092	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  00095	7c 0c		 jl	 SHORT $LN3@construct_
  00097	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0009a	50		 push	 eax
  0009b	e8 00 00 00 00	 call	 ___asan_report_store1
  000a0	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000a6	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000a9	8a 02		 mov	 al, BYTE PTR [edx]
  000ab	88 01		 mov	 BYTE PTR [ecx], al
  000ad	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b0	8b e5		 mov	 esp, ebp
  000b2	5d		 pop	 ebp
  000b3	c3		 ret	 0
??$construct_at@DABDX@std@@YAPADQADABD@Z ENDP		; std::construct_at<char,char const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$00@std@@YAII@Z
_TEXT	SEGMENT
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$00@std@@YAII@Z PROC			; std::_Get_size_of_n<1>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00009	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  0000e	c6 45 ff 00	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 0

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 64   :         if (_Count > _Max_possible) {
; 65   :             _Throw_bad_array_new_length(); // multiply overflow
; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00012	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]

; 70   : }

  00015	8b e5		 mov	 esp, ebp
  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$_Get_size_of_n@$00@std@@YAII@Z ENDP			; std::_Get_size_of_n<1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z
_TEXT	SEGMENT
tv92 = -32						; size = 4
tv75 = -28						; size = 4
tv77 = -24						; size = 4
tv87 = -20						; size = 4
$T1 = -16						; size = 4
tv95 = -12						; size = 4
tv137 = -8						; size = 4
tv130 = -2						; size = 1
tv140 = -1						; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z PROC ; std::_Construct_in_place<char *,char * const &>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 33		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 e8	 mov	 DWORD PTR tv77[ebp], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  0003a	8b 45 e8	 mov	 eax, DWORD PTR tv77[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d e4	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$construct_at@PADABQADX@std@@YAPAPADQAPADABQAD@Z ; std::construct_at<char *,char * const &,void>
  00047	83 c4 08	 add	 esp, 8

; 155  :     } else

  0004a	e9 ac 00 00 00	 jmp	 $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0004f	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ??$addressof@PAD@std@@YAPAPADAAPAD@Z ; std::addressof<char *>
  00058	83 c4 04	 add	 esp, 4
  0005b	50		 push	 eax
  0005c	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAD@std@@YAPAXPAPAD@Z ; std::_Voidify_iter<char * *>
  00061	83 c4 04	 add	 esp, 4
  00064	50		 push	 eax
  00065	6a 04		 push	 4
  00067	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0006c	83 c4 08	 add	 esp, 8
  0006f	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00072	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$forward@ABQAD@std@@YAABQADABQAD@Z ; std::forward<char * const &>
  0007b	83 c4 04	 add	 esp, 4
  0007e	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
  00081	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  00084	89 4d f8	 mov	 DWORD PTR tv137[ebp], ecx
  00087	8b 55 f8	 mov	 edx, DWORD PTR tv137[ebp]
  0008a	c1 ea 03	 shr	 edx, 3
  0008d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00093	88 45 ff	 mov	 BYTE PTR tv140[ebp], al
  00096	80 7d ff 00	 cmp	 BYTE PTR tv140[ebp], 0
  0009a	74 1a		 je	 SHORT $LN6@Construct_
  0009c	8a 4d f8	 mov	 cl, BYTE PTR tv137[ebp]
  0009f	80 e1 07	 and	 cl, 7
  000a2	80 c1 03	 add	 cl, 3
  000a5	3a 4d ff	 cmp	 cl, BYTE PTR tv140[ebp]
  000a8	7c 0c		 jl	 SHORT $LN6@Construct_
  000aa	8b 55 f8	 mov	 edx, DWORD PTR tv137[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 ___asan_report_load4
  000b3	83 c4 04	 add	 esp, 4
$LN6@Construct_:
  000b6	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  000b9	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  000bc	8b 4d e0	 mov	 ecx, DWORD PTR tv92[ebp]
  000bf	89 4d f4	 mov	 DWORD PTR tv95[ebp], ecx
  000c2	8b 55 f4	 mov	 edx, DWORD PTR tv95[ebp]
  000c5	c1 ea 03	 shr	 edx, 3
  000c8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000ce	88 45 fe	 mov	 BYTE PTR tv130[ebp], al
  000d1	80 7d fe 00	 cmp	 BYTE PTR tv130[ebp], 0
  000d5	74 1a		 je	 SHORT $LN5@Construct_
  000d7	8a 4d f4	 mov	 cl, BYTE PTR tv95[ebp]
  000da	80 e1 07	 and	 cl, 7
  000dd	80 c1 03	 add	 cl, 3
  000e0	3a 4d fe	 cmp	 cl, BYTE PTR tv130[ebp]
  000e3	7c 0c		 jl	 SHORT $LN5@Construct_
  000e5	8b 55 f4	 mov	 edx, DWORD PTR tv95[ebp]
  000e8	52		 push	 edx
  000e9	e8 00 00 00 00	 call	 ___asan_report_store4
  000ee	83 c4 04	 add	 esp, 4
$LN5@Construct_:
  000f1	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]
  000f4	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000f7	8b 11		 mov	 edx, DWORD PTR [ecx]
  000f9	89 10		 mov	 DWORD PTR [eax], edx
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c3		 ret	 0
??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ENDP ; std::_Construct_in_place<char *,char * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 918  : _CONSTEXPR20 void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 919  :     if constexpr (allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value) {
; 920  :         _Left = _Right;
; 921  :     }
; 922  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
_TEXT	SEGMENT
__asan_gen_0$ = -144					; size = 4
__asan_gen_1$ = -140					; size = 4
__asan_gen_2$ = -136					; size = 4
__New_ptr$ = -128					; size = 4
tv241 = -86						; size = 1
tv231 = -85						; size = 1
tv221 = -84						; size = 1
tv211 = -83						; size = 1
tv201 = -82						; size = 1
tv191 = -81						; size = 1
_this$ = -80						; size = 4
tv181 = -76						; size = 4
tv238 = -72						; size = 4
tv228 = -68						; size = 4
tv218 = -64						; size = 4
tv208 = -60						; size = 4
__New_capacity$ = -56					; size = 4
tv198 = -52						; size = 4
tv188 = -48						; size = 4
tv69 = -44						; size = 4
tv136 = -40						; size = 4
tv139 = -36						; size = 4
__Old_capacity$ = -32					; size = 4
__Al$ = -28						; size = 4
tv158 = -24						; size = 4
tv179 = -20						; size = 4
tv75 = -16						; size = 4
tv184 = -12						; size = 4
tv166 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__New_size$ = 8						; size = 4
__Fn$ = 12						; size = 1
_<_Args_0>$ = 16					; size = 4
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>, COMDAT
; _this$ = ecx

; 4505 :     _CONSTEXPR20_CONTAINER basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 85 70 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00033	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z
  0003d	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
  00047	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004d	89 45 ec	 mov	 DWORD PTR tv179[ebp], eax
  00050	8b 4d ec	 mov	 ecx, DWORD PTR tv179[ebp]
  00053	c1 e9 03	 shr	 ecx, 3
  00056	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0005c	89 4d b4	 mov	 DWORD PTR tv181[ebp], ecx
  0005f	8b 55 b4	 mov	 edx, DWORD PTR tv181[ebp]
  00062	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00068	83 45 b4 04	 add	 DWORD PTR tv181[ebp], 4
  0006c	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00071	8b 4d b4	 mov	 ecx, DWORD PTR tv181[ebp]
  00074	66 89 01	 mov	 WORD PTR [ecx], ax
  00077	83 45 b4 02	 add	 DWORD PTR tv181[ebp], 2
  0007b	8b 55 b4	 mov	 edx, DWORD PTR tv181[ebp]
  0007e	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00081	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00086	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4506 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 4507 :         // _Fn(_New_ptr, _New_size, _Args...)
; 4508 :         if (_New_size > max_size()) {

  0008b	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00093	39 43 08	 cmp	 DWORD PTR __New_size$[ebx], eax
  00096	76 05		 jbe	 SHORT $LN2@Reallocate

; 4509 :             _Xlen_string(); // result too long

  00098	e8 00 00 00 00	 call	 ?_Xlen_string@std@@YAXXZ ; std::_Xlen_string
$LN2@Reallocate:

; 4510 :         }
; 4511 : 
; 4512 :         const size_type _Old_capacity = _Mypair._Myval2._Myres;

  0009d	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  000a0	83 c0 18	 add	 eax, 24			; 00000018H
  000a3	89 45 d4	 mov	 DWORD PTR tv69[ebp], eax
  000a6	8b 4d d4	 mov	 ecx, DWORD PTR tv69[ebp]
  000a9	89 4d b8	 mov	 DWORD PTR tv238[ebp], ecx
  000ac	8b 55 b8	 mov	 edx, DWORD PTR tv238[ebp]
  000af	c1 ea 03	 shr	 edx, 3
  000b2	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b8	88 45 aa	 mov	 BYTE PTR tv241[ebp], al
  000bb	80 7d aa 00	 cmp	 BYTE PTR tv241[ebp], 0
  000bf	74 1a		 je	 SHORT $LN12@Reallocate
  000c1	8a 4d b8	 mov	 cl, BYTE PTR tv238[ebp]
  000c4	80 e1 07	 and	 cl, 7
  000c7	80 c1 03	 add	 cl, 3
  000ca	3a 4d aa	 cmp	 cl, BYTE PTR tv241[ebp]
  000cd	7c 0c		 jl	 SHORT $LN12@Reallocate
  000cf	8b 55 b8	 mov	 edx, DWORD PTR tv238[ebp]
  000d2	52		 push	 edx
  000d3	e8 00 00 00 00	 call	 ___asan_report_load4
  000d8	83 c4 04	 add	 esp, 4
$LN12@Reallocate:
  000db	8b 45 d4	 mov	 eax, DWORD PTR tv69[ebp]
  000de	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e0	89 4d e0	 mov	 DWORD PTR __Old_capacity$[ebp], ecx

; 4513 :         const size_type _New_capacity = _Calculate_growth(_New_size);

  000e3	8b 53 08	 mov	 edx, DWORD PTR __New_size$[ebx]
  000e6	52		 push	 edx
  000e7	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  000ef	89 45 c8	 mov	 DWORD PTR __New_capacity$[ebp], eax

; 4514 :         auto& _Al                     = _Getal();

  000f2	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  000f5	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000fa	89 45 e4	 mov	 DWORD PTR __Al$[ebp], eax

; 4515 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

  000fd	33 c0		 xor	 eax, eax
  000ff	8b 4d c8	 mov	 ecx, DWORD PTR __New_capacity$[ebp]
  00102	83 c1 01	 add	 ecx, 1
  00105	0f 92 c0	 setb	 al
  00108	f7 d8		 neg	 eax
  0010a	0b c1		 or	 eax, ecx
  0010c	50		 push	 eax
  0010d	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00110	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  00115	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
  00118	8d 55 80	 lea	 edx, DWORD PTR __New_ptr$[ebp]
  0011b	89 55 bc	 mov	 DWORD PTR tv228[ebp], edx
  0011e	8b 45 bc	 mov	 eax, DWORD PTR tv228[ebp]
  00121	c1 e8 03	 shr	 eax, 3
  00124	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012a	88 4d ab	 mov	 BYTE PTR tv231[ebp], cl
  0012d	80 7d ab 00	 cmp	 BYTE PTR tv231[ebp], 0
  00131	74 1a		 je	 SHORT $LN11@Reallocate
  00133	8a 55 bc	 mov	 dl, BYTE PTR tv228[ebp]
  00136	80 e2 07	 and	 dl, 7
  00139	80 c2 03	 add	 dl, 3
  0013c	3a 55 ab	 cmp	 dl, BYTE PTR tv231[ebp]
  0013f	7c 0c		 jl	 SHORT $LN11@Reallocate
  00141	8b 45 bc	 mov	 eax, DWORD PTR tv228[ebp]
  00144	50		 push	 eax
  00145	e8 00 00 00 00	 call	 ___asan_report_store4
  0014a	83 c4 04	 add	 esp, 4
$LN11@Reallocate:
  0014d	8b 4d f0	 mov	 ecx, DWORD PTR tv75[ebp]
  00150	89 4d 80	 mov	 DWORD PTR __New_ptr$[ebp], ecx

; 4516 : 
; 4517 : #ifdef __cpp_lib_constexpr_string
; 4518 :         if (_STD is_constant_evaluated()) { // Begin the lifetimes of the objects before copying to avoid UB

  00153	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00158	0f b6 d0	 movzx	 edx, al
  0015b	85 d2		 test	 edx, edx
  0015d	74 1e		 je	 SHORT $LN3@Reallocate

; 4519 :             _Traits::assign(_Unfancy(_New_ptr), _New_capacity + 1, _Elem());

  0015f	6a 00		 push	 0
  00161	8b 45 c8	 mov	 eax, DWORD PTR __New_capacity$[ebp]
  00164	83 c0 01	 add	 eax, 1
  00167	50		 push	 eax
  00168	8b 4d 80	 mov	 ecx, DWORD PTR __New_ptr$[ebp]
  0016b	51		 push	 ecx
  0016c	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00171	83 c4 04	 add	 esp, 4
  00174	50		 push	 eax
  00175	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  0017a	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@Reallocate:

; 4520 :         }
; 4521 : #endif // __cpp_lib_constexpr_string
; 4522 :         _Mypair._Myval2._Orphan_all();

  0017d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00180	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4523 :         _Mypair._Myval2._Mysize = _New_size;

  00185	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  00188	83 c2 14	 add	 edx, 20			; 00000014H
  0018b	89 55 d8	 mov	 DWORD PTR tv136[ebp], edx
  0018e	8b 45 d8	 mov	 eax, DWORD PTR tv136[ebp]
  00191	89 45 c0	 mov	 DWORD PTR tv218[ebp], eax
  00194	8b 4d c0	 mov	 ecx, DWORD PTR tv218[ebp]
  00197	c1 e9 03	 shr	 ecx, 3
  0019a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001a0	88 55 ac	 mov	 BYTE PTR tv221[ebp], dl
  001a3	80 7d ac 00	 cmp	 BYTE PTR tv221[ebp], 0
  001a7	74 18		 je	 SHORT $LN10@Reallocate
  001a9	8a 45 c0	 mov	 al, BYTE PTR tv218[ebp]
  001ac	24 07		 and	 al, 7
  001ae	04 03		 add	 al, 3
  001b0	3a 45 ac	 cmp	 al, BYTE PTR tv221[ebp]
  001b3	7c 0c		 jl	 SHORT $LN10@Reallocate
  001b5	8b 4d c0	 mov	 ecx, DWORD PTR tv218[ebp]
  001b8	51		 push	 ecx
  001b9	e8 00 00 00 00	 call	 ___asan_report_store4
  001be	83 c4 04	 add	 esp, 4
$LN10@Reallocate:
  001c1	8b 55 d8	 mov	 edx, DWORD PTR tv136[ebp]
  001c4	8b 43 08	 mov	 eax, DWORD PTR __New_size$[ebx]
  001c7	89 02		 mov	 DWORD PTR [edx], eax

; 4524 :         _Mypair._Myval2._Myres  = _New_capacity;

  001c9	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  001cc	83 c1 18	 add	 ecx, 24			; 00000018H
  001cf	89 4d dc	 mov	 DWORD PTR tv139[ebp], ecx
  001d2	8b 55 dc	 mov	 edx, DWORD PTR tv139[ebp]
  001d5	89 55 c4	 mov	 DWORD PTR tv208[ebp], edx
  001d8	8b 45 c4	 mov	 eax, DWORD PTR tv208[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d ad	 mov	 BYTE PTR tv211[ebp], cl
  001e7	80 7d ad 00	 cmp	 BYTE PTR tv211[ebp], 0
  001eb	74 1a		 je	 SHORT $LN9@Reallocate
  001ed	8a 55 c4	 mov	 dl, BYTE PTR tv208[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 ad	 cmp	 dl, BYTE PTR tv211[ebp]
  001f9	7c 0c		 jl	 SHORT $LN9@Reallocate
  001fb	8b 45 c4	 mov	 eax, DWORD PTR tv208[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN9@Reallocate:
  00207	8b 4d dc	 mov	 ecx, DWORD PTR tv139[ebp]
  0020a	8b 55 c8	 mov	 edx, DWORD PTR __New_capacity$[ebp]
  0020d	89 11		 mov	 DWORD PTR [ecx], edx

; 4525 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);

  0020f	8b 43 10	 mov	 eax, DWORD PTR _<_Args_0>$[ebx]
  00212	50		 push	 eax
  00213	8b 4b 08	 mov	 ecx, DWORD PTR __New_size$[ebx]
  00216	51		 push	 ecx
  00217	8b 55 80	 mov	 edx, DWORD PTR __New_ptr$[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00220	83 c4 04	 add	 esp, 4
  00223	50		 push	 eax
  00224	8d 4b 0c	 lea	 ecx, DWORD PTR __Fn$[ebx]
  00227	e8 00 00 00 00	 call	 ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()

; 4526 :         if (_BUF_SIZE <= _Old_capacity) {

  0022c	83 7d e0 10	 cmp	 DWORD PTR __Old_capacity$[ebp], 16 ; 00000010H
  00230	0f 82 91 00 00
	00		 jb	 $LN4@Reallocate

; 4527 :             _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);

  00236	8b 45 e0	 mov	 eax, DWORD PTR __Old_capacity$[ebp]
  00239	83 c0 01	 add	 eax, 1
  0023c	50		 push	 eax
  0023d	8b 4d b0	 mov	 ecx, DWORD PTR _this$[ebp]
  00240	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00243	52		 push	 edx
  00244	8b 4d e4	 mov	 ecx, DWORD PTR __Al$[ebp]
  00247	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate

; 4528 :             _Mypair._Myval2._Bx._Ptr = _New_ptr;

  0024c	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  0024f	83 c0 04	 add	 eax, 4
  00252	89 45 e8	 mov	 DWORD PTR tv158[ebp], eax
  00255	8d 4d 80	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  00258	89 4d cc	 mov	 DWORD PTR tv198[ebp], ecx
  0025b	8b 55 cc	 mov	 edx, DWORD PTR tv198[ebp]
  0025e	c1 ea 03	 shr	 edx, 3
  00261	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00267	88 45 ae	 mov	 BYTE PTR tv201[ebp], al
  0026a	80 7d ae 00	 cmp	 BYTE PTR tv201[ebp], 0
  0026e	74 1a		 je	 SHORT $LN8@Reallocate
  00270	8a 4d cc	 mov	 cl, BYTE PTR tv198[ebp]
  00273	80 e1 07	 and	 cl, 7
  00276	80 c1 03	 add	 cl, 3
  00279	3a 4d ae	 cmp	 cl, BYTE PTR tv201[ebp]
  0027c	7c 0c		 jl	 SHORT $LN8@Reallocate
  0027e	8b 55 cc	 mov	 edx, DWORD PTR tv198[ebp]
  00281	52		 push	 edx
  00282	e8 00 00 00 00	 call	 ___asan_report_load4
  00287	83 c4 04	 add	 esp, 4
$LN8@Reallocate:
  0028a	8b 45 e8	 mov	 eax, DWORD PTR tv158[ebp]
  0028d	89 45 d0	 mov	 DWORD PTR tv188[ebp], eax
  00290	8b 4d d0	 mov	 ecx, DWORD PTR tv188[ebp]
  00293	c1 e9 03	 shr	 ecx, 3
  00296	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0029c	88 55 af	 mov	 BYTE PTR tv191[ebp], dl
  0029f	80 7d af 00	 cmp	 BYTE PTR tv191[ebp], 0
  002a3	74 18		 je	 SHORT $LN7@Reallocate
  002a5	8a 45 d0	 mov	 al, BYTE PTR tv188[ebp]
  002a8	24 07		 and	 al, 7
  002aa	04 03		 add	 al, 3
  002ac	3a 45 af	 cmp	 al, BYTE PTR tv191[ebp]
  002af	7c 0c		 jl	 SHORT $LN7@Reallocate
  002b1	8b 4d d0	 mov	 ecx, DWORD PTR tv188[ebp]
  002b4	51		 push	 ecx
  002b5	e8 00 00 00 00	 call	 ___asan_report_store4
  002ba	83 c4 04	 add	 esp, 4
$LN7@Reallocate:
  002bd	8b 55 e8	 mov	 edx, DWORD PTR tv158[ebp]
  002c0	8b 45 80	 mov	 eax, DWORD PTR __New_ptr$[ebp]
  002c3	89 02		 mov	 DWORD PTR [edx], eax

; 4529 :         } else {

  002c5	eb 13		 jmp	 SHORT $LN5@Reallocate
$LN4@Reallocate:

; 4530 :             _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);

  002c7	8d 4d 80	 lea	 ecx, DWORD PTR __New_ptr$[ebp]
  002ca	51		 push	 ecx
  002cb	8b 55 b0	 mov	 edx, DWORD PTR _this$[ebp]
  002ce	83 c2 04	 add	 edx, 4
  002d1	52		 push	 edx
  002d2	e8 00 00 00 00	 call	 ??$_Construct_in_place@PADABQAD@std@@YAXAAPADABQAD@Z ; std::_Construct_in_place<char *,char * const &>
  002d7	83 c4 08	 add	 esp, 8
$LN5@Reallocate:

; 4531 :         }
; 4532 : 
; 4533 :         return *this;

  002da	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  002dd	89 45 f8	 mov	 DWORD PTR tv166[ebp], eax
  002e0	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  002ea	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  002f0	c1 e9 03	 shr	 ecx, 3
  002f3	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  002f9	89 4d f4	 mov	 DWORD PTR tv184[ebp], ecx
  002fc	6a 07		 push	 7
  002fe	8b 55 f4	 mov	 edx, DWORD PTR tv184[ebp]
  00301	52		 push	 edx
  00302	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00307	83 c4 08	 add	 esp, 8
  0030a	8b 45 f8	 mov	 eax, DWORD PTR tv166[ebp]
$LN6@Reallocate:

; 4534 :     }

  0030d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00310	33 cd		 xor	 ecx, ebp
  00312	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00317	8b e5		 mov	 esp, ebp
  00319	5d		 pop	 ebp
  0031a	8b e3		 mov	 esp, ebx
  0031c	5b		 pop	 ebx
  0031d	c2 0c 00	 ret	 12			; 0000000cH
??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 1
tv89 = -21						; size = 1
tv76 = -20						; size = 4
tv86 = -16						; size = 4
tv74 = -12						; size = 4
tv82 = -8						; size = 4
_this$ = -4						; size = 4
__New_ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator(), COMDAT
; _this$ = ecx

; 3259 :             },

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00023	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
  00031	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00043	89 4d ec	 mov	 DWORD PTR tv76[ebp], ecx
  00046	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00049	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0004f	83 45 ec 04	 add	 DWORD PTR tv76[ebp], 4
  00053	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00058	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  0005b	66 89 01	 mov	 WORD PTR [ecx], ax
  0005e	83 45 ec 02	 add	 DWORD PTR tv76[ebp], 2
  00062	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00065	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0006d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3257 :                 _Traits::copy(_New_ptr, _Ptr, _Count);

  00072	8b 43 0c	 mov	 eax, DWORD PTR __Count$[ebx]
  00075	50		 push	 eax
  00076	8b 4b 10	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  00079	51		 push	 ecx
  0007a	8b 53 08	 mov	 edx, DWORD PTR __New_ptr$[ebx]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::copy
  00083	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());

  00086	8d 45 c0	 lea	 eax, DWORD PTR $T2[ebp]
  00089	89 45 f0	 mov	 DWORD PTR tv86[ebp], eax
  0008c	8b 4d f0	 mov	 ecx, DWORD PTR tv86[ebp]
  0008f	c1 e9 03	 shr	 ecx, 3
  00092	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00098	88 55 eb	 mov	 BYTE PTR tv89[ebp], dl
  0009b	80 7d eb 00	 cmp	 BYTE PTR tv89[ebp], 0
  0009f	74 16		 je	 SHORT $LN3@operator
  000a1	8a 45 f0	 mov	 al, BYTE PTR tv86[ebp]
  000a4	24 07		 and	 al, 7
  000a6	3a 45 eb	 cmp	 al, BYTE PTR tv89[ebp]
  000a9	7c 0c		 jl	 SHORT $LN3@operator
  000ab	8b 4d f0	 mov	 ecx, DWORD PTR tv86[ebp]
  000ae	51		 push	 ecx
  000af	e8 00 00 00 00	 call	 ___asan_report_store1
  000b4	83 c4 04	 add	 esp, 4
$LN3@operator:
  000b7	c6 45 c0 00	 mov	 BYTE PTR $T2[ebp], 0
  000bb	8d 55 c0	 lea	 edx, DWORD PTR $T2[ebp]
  000be	52		 push	 edx
  000bf	8b 43 08	 mov	 eax, DWORD PTR __New_ptr$[ebx]
  000c2	03 43 0c	 add	 eax, DWORD PTR __Count$[ebx]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000cb	83 c4 08	 add	 esp, 8
  000ce	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  000d1	c1 e9 03	 shr	 ecx, 3
  000d4	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 3259 :             },

  000db	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000e2	8d 55 b0	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000e5	c1 ea 03	 shr	 edx, 3
  000e8	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000ee	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  000f1	6a 07		 push	 7
  000f3	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000fc	83 c4 08	 add	 esp, 8
  000ff	8b e5		 mov	 esp, ebp
  00101	5d		 pop	 ebp
  00102	8b e3		 mov	 esp, ebx
  00104	5b		 pop	 ebx
  00105	c2 0c 00	 ret	 12			; 0000000cH
??R<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV23@QBDI@Z@QBE@QADI0@Z ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 307  : _CONSTEXPR20_DYNALLOC void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 308  :     if constexpr (is_array_v<_Ty>) {
; 309  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 310  :     } else {
; 311  :         _Obj.~_Ty();
; 312  :     }
; 313  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 251  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  0002c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4

; 256  :     } else

  00044	eb 29		 jmp	 SHORT $LN5@Deallocate
$LN2@Deallocate:

; 257  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00046	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0004d	72 10		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004f	8d 55 0c	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00052	52		 push	 edx
  00053	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0005c	83 c4 08	 add	 esp, 8
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006c	83 c4 08	 add	 esp, 8
$LN5@Deallocate:

; 265  :     }
; 266  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx

; 1390 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$allocator@D@std@@QAE@XZ ; std::allocator<char>::allocator<char>
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 02	 shl	 eax, 2
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BA@@std@@YAII@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 04	 shl	 eax, 4
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -32					; size = 4
tv71 = -28						; size = 4
tv68 = -24						; size = 4
tv65 = -20						; size = 4
tv74 = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 614  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0002f	74 1a		 je	 SHORT $LN5@exchange
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv94[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  0003d	7c 0c		 jl	 SHORT $LN5@exchange
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN5@exchange:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	89 4d e0	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00053	8b 55 0c	 mov	 edx, DWORD PTR __New_val$[ebp]
  00056	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00062	c1 e9 03	 shr	 ecx, 3
  00065	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006b	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  0006e	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00072	74 18		 je	 SHORT $LN4@exchange
  00074	8a 45 f4	 mov	 al, BYTE PTR tv84[ebp]
  00077	24 07		 and	 al, 7
  00079	04 03		 add	 al, 3
  0007b	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@exchange
  00080	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ___asan_report_load4
  00089	83 c4 04	 add	 esp, 4
$LN4@exchange:
  0008c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0008f	89 55 e4	 mov	 DWORD PTR tv71[ebp], edx
  00092	8b 45 e4	 mov	 eax, DWORD PTR tv71[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00098	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0009b	c1 e9 03	 shr	 ecx, 3
  0009e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a4	88 55 fd	 mov	 BYTE PTR tv77[ebp], dl
  000a7	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000ab	74 18		 je	 SHORT $LN3@exchange
  000ad	8a 45 f0	 mov	 al, BYTE PTR tv74[ebp]
  000b0	24 07		 and	 al, 7
  000b2	04 03		 add	 al, 3
  000b4	3a 45 fd	 cmp	 al, BYTE PTR tv77[ebp]
  000b7	7c 0c		 jl	 SHORT $LN3@exchange
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ___asan_report_store4
  000c2	83 c4 04	 add	 esp, 4
$LN3@exchange:
  000c5	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 0a		 mov	 DWORD PTR [edx], ecx

; 618  :     return _Old_val;

  000cf	8b 45 e0	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 619  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 17		 jne	 SHORT $LN2@Allocate

; 235  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00020	72 0e		 jb	 SHORT $LN2@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0002b	83 c4 04	 add	 esp, 4
  0002e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00030	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00034	74 0e		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00036	8b 55 08	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003f	83 c4 04	 add	 esp, 4
  00042	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00044	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\ProjetTutore1.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -1248					; size = 4
__asan_gen_1$ = -1244					; size = 4
__asan_gen_2$ = -1240					; size = 4
_window$ = -1232					; size = 528
_RP$ = -672						; size = 48
_Univ$ = -592						; size = 40
$T3 = -520						; size = 28
$T4 = -456						; size = 28
$T5 = -392						; size = 8
$T6 = -376						; size = 12
_icon$ = -328						; size = 24
$T7 = -272						; size = 28
_s$8 = -208						; size = 8
tv292 = -162						; size = 1
$T9 = -161						; size = 1
tv220 = -160						; size = 4
tv205 = -156						; size = 4
tv289 = -152						; size = 4
tv206 = -148						; size = 4
tv211 = -144						; size = 4
tv216 = -140						; size = 4
tv247 = -136						; size = 4
tv271 = -132						; size = 4
tv264 = -128						; size = 4
tv254 = -124						; size = 4
tv180 = -120						; size = 4
tv203 = -116						; size = 4
tv210 = -112						; size = 4
tv215 = -108						; size = 4
tv241 = -104						; size = 4
tv235 = -100						; size = 4
tv229 = -96						; size = 4
tv223 = -92						; size = 4
tv201 = -88						; size = 4
tv190 = -84						; size = 4
tv95 = -80						; size = 4
tv173 = -76						; size = 4
$T10 = -72						; size = 4
tv284 = -68						; size = 4
tv65 = -64						; size = 4
$T11 = -60						; size = 4
$T12 = -56						; size = 12
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC

; 8    : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$_main
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 30 fb ff
	ff		 add	 esp, -1232		; fffffb30H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 20 fb ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 24 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_._main
  00053	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET _main
  0005d	8d 85 20 fb ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00063	89 45 8c	 mov	 DWORD PTR tv203[ebp], eax
  00066	8b 4d 8c	 mov	 ecx, DWORD PTR tv203[ebp]
  00069	c1 e9 03	 shr	 ecx, 3
  0006c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00072	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv205[ebp], ecx
  00078	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0007d	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  00083	66 89 10	 mov	 WORD PTR [eax], dx
  00086	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv205[ebp]
  0008c	83 c1 02	 add	 ecx, 2
  0008f	89 8d 6c ff ff
	ff		 mov	 DWORD PTR tv206[ebp], ecx
  00095	6a 42		 push	 66			; 00000042H
  00097	8b 95 6c ff ff
	ff		 mov	 edx, DWORD PTR tv206[ebp]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000a3	83 c4 08	 add	 esp, 8
  000a6	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  000ac	83 c0 42	 add	 eax, 66			; 00000042H
  000af	89 45 90	 mov	 DWORD PTR tv210[ebp], eax
  000b2	8b 4d 90	 mov	 ecx, DWORD PTR tv210[ebp]
  000b5	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  000bb	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv205[ebp]
  000c1	83 c2 48	 add	 edx, 72			; 00000048H
  000c4	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv211[ebp], edx
  000ca	6a 06		 push	 6
  000cc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv211[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000d8	83 c4 08	 add	 esp, 8
  000db	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv211[ebp]
  000e1	83 c1 06	 add	 ecx, 6
  000e4	89 4d 94	 mov	 DWORD PTR tv215[ebp], ecx
  000e7	8b 55 94	 mov	 edx, DWORD PTR tv215[ebp]
  000ea	c7 02 f2 f2 f2
	f2		 mov	 DWORD PTR [edx], -218959118 ; f2f2f2f2H
  000f0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv205[ebp]
  000f6	83 c0 52	 add	 eax, 82			; 00000052H
  000f9	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  000ff	6a 05		 push	 5
  00101	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  00107	51		 push	 ecx
  00108	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0010d	83 c4 08	 add	 esp, 8
  00110	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv216[ebp]
  00116	83 c2 05	 add	 edx, 5
  00119	89 95 60 ff ff
	ff		 mov	 DWORD PTR tv220[ebp], edx
  0011f	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv220[ebp]
  00125	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  0012b	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  00132	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv220[ebp]
  00138	c7 01 00 00 00
	04		 mov	 DWORD PTR [ecx], 67108864 ; 04000000H
  0013e	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  00145	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  0014b	c7 02 f2 f2 f2
	f2		 mov	 DWORD PTR [edx], -218959118 ; f2f2f2f2H
  00151	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  00158	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv220[ebp]
  0015e	c7 00 00 00 00
	04		 mov	 DWORD PTR [eax], 67108864 ; 04000000H
  00164	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  0016b	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv220[ebp]
  00171	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00177	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  0017e	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  00184	c7 02 00 f2 00
	04		 mov	 DWORD PTR [edx], 67170816 ; 0400f200H
  0018a	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  00191	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv220[ebp]
  00197	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  0019d	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  001a4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv220[ebp]
  001aa	c7 01 f8 f8 f8
	f2		 mov	 DWORD PTR [ecx], -218564360 ; f2f8f8f8H
  001b0	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  001b7	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  001bd	c7 02 f2 f2 f2
	f8		 mov	 DWORD PTR [edx], -118295822 ; f8f2f2f2H
  001c3	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  001ca	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR tv220[ebp]
  001d0	c7 00 f8 f8 04
	f2		 mov	 DWORD PTR [eax], -234555144 ; f204f8f8H
  001d6	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  001dd	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv220[ebp]
  001e3	c7 01 f2 f2 f2
	f8		 mov	 DWORD PTR [ecx], -118295822 ; f8f2f2f2H
  001e9	83 85 60 ff ff
	ff 04		 add	 DWORD PTR tv220[ebp], 4
  001f0	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv220[ebp]
  001f6	c7 02 f3 f3 f3
	f3		 mov	 DWORD PTR [edx], -202116109 ; f3f3f3f3H
  001fc	8d 85 b8 fe ff
	ff		 lea	 eax, DWORD PTR _icon$[ebp]
  00202	c1 e8 03	 shr	 eax, 3
  00205	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0020a	89 45 98	 mov	 DWORD PTR tv241[ebp], eax
  0020d	6a 03		 push	 3
  0020f	8b 4d 98	 mov	 ecx, DWORD PTR tv241[ebp]
  00212	51		 push	 ecx
  00213	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00218	83 c4 08	 add	 esp, 8
  0021b	8d 95 60 fd ff
	ff		 lea	 edx, DWORD PTR _RP$[ebp]
  00221	c1 ea 03	 shr	 edx, 3
  00224	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0022a	89 55 9c	 mov	 DWORD PTR tv235[ebp], edx
  0022d	6a 06		 push	 6
  0022f	8b 45 9c	 mov	 eax, DWORD PTR tv235[ebp]
  00232	50		 push	 eax
  00233	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00238	83 c4 08	 add	 esp, 8
  0023b	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _Univ$[ebp]
  00241	c1 e9 03	 shr	 ecx, 3
  00244	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0024a	89 4d a0	 mov	 DWORD PTR tv229[ebp], ecx
  0024d	6a 05		 push	 5
  0024f	8b 55 a0	 mov	 edx, DWORD PTR tv229[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00258	83 c4 08	 add	 esp, 8
  0025b	8d 85 30 fb ff
	ff		 lea	 eax, DWORD PTR _window$[ebp]
  00261	c1 e8 03	 shr	 eax, 3
  00264	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00269	89 45 a4	 mov	 DWORD PTR tv223[ebp], eax
  0026c	6a 42		 push	 66			; 00000042H
  0026e	8b 4d a4	 mov	 ecx, DWORD PTR tv223[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00277	83 c4 08	 add	 esp, 8
  0027a	8d 95 f0 fe ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  00280	c1 ea 03	 shr	 edx, 3
  00283	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00289	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv247[ebp], edx
  0028f	6a 03		 push	 3
  00291	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv247[ebp]
  00297	50		 push	 eax
  00298	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0029d	83 c4 08	 add	 esp, 8
  002a0	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv247[ebp]
  002a6	c6 41 03 04	 mov	 BYTE PTR [ecx+3], 4
  002aa	b9 00 00 00 00	 mov	 ecx, OFFSET __059B899A_ProjetTutore1@cpp
  002af	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 9    :     sf::RenderWindow window(sf::VideoMode(1280, 720), "Projet Tutor Groupe 1");

  002b4	6a 00		 push	 0
  002b6	6a 00		 push	 0
  002b8	6a 01		 push	 1
  002ba	6a 01		 push	 1
  002bc	6a 00		 push	 0
  002be	6a 00		 push	 0
  002c0	6a 00		 push	 0
  002c2	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  002c8	e8 00 00 00 00	 call	 ??0ContextSettings@sf@@QAE@IIIIII_N@Z ; sf::ContextSettings::ContextSettings
  002cd	89 45 b0	 mov	 DWORD PTR tv95[ebp], eax
  002d0	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  002d6	e8 00 00 00 00	 call	 ??0locale@std@@QAE@XZ	; std::locale::locale
  002db	89 45 a8	 mov	 DWORD PTR tv201[ebp], eax
  002de	8b 55 a8	 mov	 edx, DWORD PTR tv201[ebp]
  002e1	89 55 ac	 mov	 DWORD PTR tv190[ebp], edx
  002e4	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  002eb	8b 45 ac	 mov	 eax, DWORD PTR tv190[ebp]
  002ee	50		 push	 eax
  002ef	68 00 00 00 00	 push	 OFFSET $SG230840
  002f4	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  002fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0String@sf@@QAE@PBDABVlocale@std@@@Z
  00300	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  00304	6a 20		 push	 32			; 00000020H
  00306	68 d0 02 00 00	 push	 720			; 000002d0H
  0030b	68 00 05 00 00	 push	 1280			; 00000500H
  00310	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00316	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0VideoMode@sf@@QAE@III@Z
  0031c	6a 0c		 push	 12			; 0000000cH
  0031e	50		 push	 eax
  0031f	8d 4d c8	 lea	 ecx, DWORD PTR $T12[ebp]
  00322	51		 push	 ecx
  00323	e8 00 00 00 00	 call	 ___asan_memcpy
  00328	83 c4 0c	 add	 esp, 12			; 0000000cH
  0032b	8b 55 b0	 mov	 edx, DWORD PTR tv95[ebp]
  0032e	52		 push	 edx
  0032f	6a 07		 push	 7
  00331	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  00337	50		 push	 eax
  00338	83 ec 0c	 sub	 esp, 12			; 0000000cH
  0033b	8b cc		 mov	 ecx, esp
  0033d	8b 55 c8	 mov	 edx, DWORD PTR $T12[ebp]
  00340	89 11		 mov	 DWORD PTR [ecx], edx
  00342	8b 45 cc	 mov	 eax, DWORD PTR $T12[ebp+4]
  00345	89 41 04	 mov	 DWORD PTR [ecx+4], eax
  00348	8b 55 d0	 mov	 edx, DWORD PTR $T12[ebp+8]
  0034b	89 51 08	 mov	 DWORD PTR [ecx+8], edx
  0034e	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR _window$[ebp]
  00354	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0RenderWindow@sf@@QAE@VVideoMode@1@ABVString@1@IABUContextSettings@1@@Z
  0035a	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  0035e	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00364	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1String@sf@@QAE@XZ
  0036a	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  0036e	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00374	e8 00 00 00 00	 call	 ??1locale@std@@QAE@XZ	; std::locale::~locale
  00379	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0037f	c1 e8 03	 shr	 eax, 3
  00382	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00387	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv271[ebp], eax
  0038d	6a 03		 push	 3
  0038f	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv271[ebp]
  00395	51		 push	 ecx
  00396	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0039b	83 c4 08	 add	 esp, 8
  0039e	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR tv271[ebp]
  003a4	c6 42 03 f8	 mov	 BYTE PTR [edx+3], 248	; 000000f8H
  003a8	8d 85 38 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  003ae	c1 e8 03	 shr	 eax, 3
  003b1	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  003b6	89 45 80	 mov	 DWORD PTR tv264[ebp], eax
  003b9	6a 03		 push	 3
  003bb	8b 4d 80	 mov	 ecx, DWORD PTR tv264[ebp]
  003be	51		 push	 ecx
  003bf	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  003c4	83 c4 08	 add	 esp, 8
  003c7	8b 55 80	 mov	 edx, DWORD PTR tv264[ebp]
  003ca	c6 42 03 f8	 mov	 BYTE PTR [edx+3], 248	; 000000f8H
  003ce	8d 85 78 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  003d4	c1 e8 03	 shr	 eax, 3
  003d7	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  003de	8d 8d 88 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  003e4	c1 e9 03	 shr	 ecx, 3
  003e7	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  003ed	89 4d 84	 mov	 DWORD PTR tv254[ebp], ecx
  003f0	6a 01		 push	 1
  003f2	8b 55 84	 mov	 edx, DWORD PTR tv254[ebp]
  003f5	52		 push	 edx
  003f6	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  003fb	83 c4 08	 add	 esp, 8
  003fe	8b 45 84	 mov	 eax, DWORD PTR tv254[ebp]
  00401	c6 40 01 f8	 mov	 BYTE PTR [eax+1], 248	; 000000f8H

; 10   :     window.setFramerateLimit(144);

  00405	68 90 00 00 00	 push	 144			; 00000090H
  0040a	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR _window$[ebp]
  00410	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setFramerateLimit@Window@sf@@QAEXI@Z

; 11   :     sf::Image icon;

  00416	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _icon$[ebp]
  0041c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Image@sf@@QAE@XZ
  00422	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5

; 12   :     if (icon.loadFromFile(".\\ico.png")) { // File/Image/Pixel

  00426	68 00 00 00 00	 push	 OFFSET $SG230843
  0042b	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00431	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00436	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  0043a	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00440	51		 push	 ecx
  00441	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _icon$[ebp]
  00447	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?loadFromFile@Image@sf@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0044d	88 85 5f ff ff
	ff		 mov	 BYTE PTR $T9[ebp], al
  00453	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00457	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  0045d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00462	0f b6 95 5f ff
	ff ff		 movzx	 edx, BYTE PTR $T9[ebp]
  00469	85 d2		 test	 edx, edx
  0046b	74 5a		 je	 SHORT $LN2@main
  0046d	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _s$8[ebp]
  00473	c1 e8 03	 shr	 eax, 3
  00476	c6 80 00 00 00
	30 00		 mov	 BYTE PTR [eax+805306368], 0

; 13   :         sf::Vector2u s = icon.getSize();

  0047d	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _s$8[ebp]
  00483	51		 push	 ecx
  00484	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _icon$[ebp]
  0048a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getSize@Image@sf@@QBE?AV?$Vector2@I@2@XZ

; 14   :         window.setIcon(s.x, s.y, icon.getPixelsPtr());

  00490	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _icon$[ebp]
  00496	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getPixelsPtr@Image@sf@@QBEPBEXZ
  0049c	50		 push	 eax
  0049d	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR _s$8[ebp+4]
  004a3	52		 push	 edx
  004a4	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR _s$8[ebp]
  004aa	50		 push	 eax
  004ab	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR _window$[ebp]
  004b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setIcon@Window@sf@@QAEXIIPBE@Z

; 15   :     }

  004b7	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _s$8[ebp]
  004bd	c1 e9 03	 shr	 ecx, 3
  004c0	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN2@main:

; 16   :     RessourcePack RP;

  004c7	6a 30		 push	 48			; 00000030H
  004c9	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR _RP$[ebp]
  004cf	e8 00 00 00 00	 call	 ?__autoclassinit2@RessourcePack@@QAEXI@Z
  004d4	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR _RP$[ebp]
  004da	e8 00 00 00 00	 call	 ??0RessourcePack@@QAE@XZ ; RessourcePack::RessourcePack
  004df	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7

; 17   :     Univers Univ(&RP,&window);

  004e3	6a 28		 push	 40			; 00000028H
  004e5	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _Univ$[ebp]
  004eb	e8 00 00 00 00	 call	 ?__autoclassinit2@Univers@@QAEXI@Z
  004f0	8d 95 30 fb ff
	ff		 lea	 edx, DWORD PTR _window$[ebp]
  004f6	52		 push	 edx
  004f7	8d 85 60 fd ff
	ff		 lea	 eax, DWORD PTR _RP$[ebp]
  004fd	50		 push	 eax
  004fe	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _Univ$[ebp]
  00504	e8 00 00 00 00	 call	 ??0Univers@@QAE@PAVRessourcePack@@PAVRenderWindow@sf@@@Z ; Univers::Univers

; 18   :     if (argc > 0) {

  00509	83 7b 08 00	 cmp	 DWORD PTR _argc$[ebx], 0
  0050d	7e 7e		 jle	 SHORT $LN3@main

; 19   :         RP.setDefaultFolder(argv[0]);

  0050f	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00512	8b cc		 mov	 ecx, esp
  00514	89 65 c4	 mov	 DWORD PTR $T11[ebp], esp
  00517	89 4d b4	 mov	 DWORD PTR tv173[ebp], ecx
  0051a	ba 04 00 00 00	 mov	 edx, 4
  0051f	6b c2 00	 imul	 eax, edx, 0
  00522	8b 4b 0c	 mov	 ecx, DWORD PTR _argv$[ebx]
  00525	03 c8		 add	 ecx, eax
  00527	89 4d 88	 mov	 DWORD PTR tv180[ebp], ecx
  0052a	8b 55 88	 mov	 edx, DWORD PTR tv180[ebp]
  0052d	89 95 68 ff ff
	ff		 mov	 DWORD PTR tv289[ebp], edx
  00533	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv289[ebp]
  00539	c1 e8 03	 shr	 eax, 3
  0053c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00542	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv292[ebp], cl
  00548	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv292[ebp], 0
  0054f	74 23		 je	 SHORT $LN12@main
  00551	8a 95 68 ff ff
	ff		 mov	 dl, BYTE PTR tv289[ebp]
  00557	80 e2 07	 and	 dl, 7
  0055a	80 c2 03	 add	 dl, 3
  0055d	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv292[ebp]
  00563	7c 0f		 jl	 SHORT $LN12@main
  00565	8b 85 68 ff ff
	ff		 mov	 eax, DWORD PTR tv289[ebp]
  0056b	50		 push	 eax
  0056c	e8 00 00 00 00	 call	 ___asan_report_load4
  00571	83 c4 04	 add	 esp, 4
$LN12@main:
  00574	8b 4d 88	 mov	 ecx, DWORD PTR tv180[ebp]
  00577	8b 11		 mov	 edx, DWORD PTR [ecx]
  00579	52		 push	 edx
  0057a	8b 4d b4	 mov	 ecx, DWORD PTR tv173[ebp]
  0057d	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00582	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR _RP$[ebp]
  00588	e8 00 00 00 00	 call	 ?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; RessourcePack::setDefaultFolder
$LN3@main:

; 20   :     }
; 21   :     Univ.animate();

  0058d	8d 8d b0 fd ff
	ff		 lea	 ecx, DWORD PTR _Univ$[ebp]
  00593	e8 00 00 00 00	 call	 ?animate@Univers@@QAEXXZ ; Univers::animate

; 22   :     
; 23   :     return EXIT_SUCCESS;

  00598	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T10[ebp], 0
  0059f	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  005a3	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR _RP$[ebp]
  005a9	e8 00 00 00 00	 call	 ??1RessourcePack@@QAE@XZ ; RessourcePack::~RessourcePack
  005ae	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  005b2	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _icon$[ebp]
  005b8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1Image@sf@@QAE@XZ
  005be	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  005c5	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR _window$[ebp]
  005cb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1RenderWindow@sf@@UAE@XZ
  005d1	8b 45 b8	 mov	 eax, DWORD PTR $T10[ebp]
  005d4	89 45 c0	 mov	 DWORD PTR tv65[ebp], eax
  005d7	c7 85 20 fb ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  005e1	8d 8d 20 fb ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  005e7	c1 e9 03	 shr	 ecx, 3
  005ea	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  005f0	89 4d bc	 mov	 DWORD PTR tv284[ebp], ecx
  005f3	68 87 00 00 00	 push	 135			; 00000087H
  005f8	8b 55 bc	 mov	 edx, DWORD PTR tv284[ebp]
  005fb	52		 push	 edx
  005fc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00601	83 c4 08	 add	 esp, 8
  00604	8b 45 c0	 mov	 eax, DWORD PTR tv65[ebp]

; 24   : }

  00607	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0060a	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00611	59		 pop	 ecx
  00612	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00615	33 cd		 xor	 ecx, ebp
  00617	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0061c	8b e5		 mov	 esp, ebp
  0061e	5d		 pop	 ebp
  0061f	8b e3		 mov	 esp, ebx
  00621	5b		 pop	 ebx
  00622	c3		 ret	 0
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 8d 78 fe ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1locale@std@@QAE@XZ	; std::locale::~locale
__unwindfunclet$_main$1:
  0000b	8d 8d 38 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00011	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1String@sf@@QAE@XZ
__unwindfunclet$_main$2:
  00017	8d 8d 30 fb ff
	ff		 lea	 ecx, DWORD PTR _window$[ebp]
  0001d	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1RenderWindow@sf@@UAE@XZ
__unwindfunclet$_main$3:
  00023	8d 8d b8 fe ff
	ff		 lea	 ecx, DWORD PTR _icon$[ebp]
  00029	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1Image@sf@@QAE@XZ
__unwindfunclet$_main$4:
  0002f	8d 8d f0 fe ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00035	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$_main$5:
  0003a	8d 8d 60 fd ff
	ff		 lea	 ecx, DWORD PTR _RP$[ebp]
  00040	e9 00 00 00 00	 jmp	 ??1RessourcePack@@QAE@XZ ; RessourcePack::~RessourcePack
  00045	cc		 int	 3
  00046	cc		 int	 3
  00047	cc		 int	 3
  00048	cc		 int	 3
  00049	cc		 int	 3
__ehhandler$_main:
  0004a	90		 npad	 1
  0004b	90		 npad	 1
  0004c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00050	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00053	8b 8a 28 fb ff
	ff		 mov	 ecx, DWORD PTR [edx-1240]
  00059	33 c8		 xor	 ecx, eax
  0005b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00060	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00063	33 c8		 xor	 ecx, eax
  00065	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0006a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  0006f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@Univers@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@Univers@@QAEXI@Z PROC			; Univers::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@Univers@@QAEXI@Z ENDP			; Univers::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??__Flevel1@@YAXXZ
text$yd	SEGMENT
??__Flevel1@@YAXXZ PROC					; `dynamic atexit destructor for 'level1'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  00008	e8 00 00 00 00	 call	 ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Flevel1@@YAXXZ ENDP					; `dynamic atexit destructor for 'level1''
text$yd	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Levels.h
;	COMDAT ??__Elevel1@@YAXXZ
text$di	SEGMENT
__asan_gen_0$ = -2248					; size = 4
__asan_gen_1$ = -2244					; size = 4
__asan_gen_2$ = -2240					; size = 4
$T3 = -2232						; size = 224
$T4 = -1976						; size = 36
$T5 = -1904						; size = 36
$T6 = -1832						; size = 36
$T7 = -1760						; size = 36
$T8 = -1688						; size = 36
$T9 = -1616						; size = 36
$T10 = -1544						; size = 36
$T11 = -1472						; size = 36
$T12 = -1400						; size = 36
$T13 = -1328						; size = 36
$T14 = -1256						; size = 36
$T15 = -1184						; size = 36
$T16 = -1112						; size = 36
$T17 = -1040						; size = 36
$T18 = -968						; size = 1
$T19 = -952						; size = 1
$T20 = -936						; size = 8
$T21 = -920						; size = 1
$T22 = -904						; size = 8
$T23 = -888						; size = 1
$T24 = -872						; size = 8
$T25 = -856						; size = 1
$T26 = -840						; size = 8
$T27 = -824						; size = 1
$T28 = -808						; size = 8
$T29 = -792						; size = 1
$T30 = -776						; size = 8
$T31 = -760						; size = 1
$T32 = -744						; size = 8
$T33 = -728						; size = 1
$T34 = -712						; size = 8
$T35 = -696						; size = 1
$T36 = -680						; size = 8
$T37 = -664						; size = 1
$T38 = -648						; size = 8
$T39 = -632						; size = 1
$T40 = -616						; size = 8
$T41 = -600						; size = 1
$T42 = -584						; size = 8
$T43 = -568						; size = 1
$T44 = -552						; size = 8
$T45 = -536						; size = 1
$T46 = -520						; size = 8
$T47 = -504						; size = 8
tv1007 = -460						; size = 4
tv918 = -456						; size = 4
tv924 = -452						; size = 4
tv930 = -448						; size = 4
tv936 = -444						; size = 4
tv942 = -440						; size = 4
tv948 = -436						; size = 4
tv954 = -432						; size = 4
tv960 = -428						; size = 4
tv966 = -424						; size = 4
tv972 = -420						; size = 4
tv978 = -416						; size = 4
tv984 = -412						; size = 4
tv990 = -408						; size = 4
tv996 = -404						; size = 4
tv1002 = -400						; size = 4
tv919 = -396						; size = 4
tv1185 = -392						; size = 4
tv1172 = -388						; size = 4
tv1159 = -384						; size = 4
tv1146 = -380						; size = 4
tv1133 = -376						; size = 4
tv1120 = -372						; size = 4
tv1107 = -368						; size = 4
tv1094 = -364						; size = 4
tv1081 = -360						; size = 4
tv1068 = -356						; size = 4
tv1055 = -352						; size = 4
tv1042 = -348						; size = 4
tv1029 = -344						; size = 4
tv1016 = -340						; size = 4
tv916 = -336						; size = 4
tv923 = -332						; size = 4
tv928 = -328						; size = 4
tv929 = -324						; size = 4
tv934 = -320						; size = 4
tv935 = -316						; size = 4
tv940 = -312						; size = 4
tv941 = -308						; size = 4
tv946 = -304						; size = 4
tv947 = -300						; size = 4
tv952 = -296						; size = 4
tv953 = -292						; size = 4
tv958 = -288						; size = 4
tv959 = -284						; size = 4
tv964 = -280						; size = 4
tv965 = -276						; size = 4
tv970 = -272						; size = 4
tv971 = -268						; size = 4
tv976 = -264						; size = 4
tv977 = -260						; size = 4
tv982 = -256						; size = 4
tv983 = -252						; size = 4
tv988 = -248						; size = 4
tv989 = -244						; size = 4
tv994 = -240						; size = 4
tv995 = -236						; size = 4
tv1000 = -232						; size = 4
tv1001 = -228						; size = 4
tv1006 = -224						; size = 4
tv84 = -220						; size = 4
tv164 = -216						; size = 4
tv179 = -212						; size = 4
tv226 = -208						; size = 4
tv241 = -204						; size = 4
tv320 = -200						; size = 4
tv335 = -196						; size = 4
tv350 = -192						; size = 4
tv397 = -188						; size = 4
tv412 = -184						; size = 4
tv459 = -180						; size = 4
tv474 = -176						; size = 4
tv553 = -172						; size = 4
tv568 = -168						; size = 4
tv612 = -164						; size = 4
tv1195 = -160						; size = 4
tv1204 = -156						; size = 4
$T48 = -152						; size = 8
$T49 = -144						; size = 8
$T50 = -136						; size = 8
$T51 = -128						; size = 8
$T52 = -120						; size = 8
$T53 = -112						; size = 8
$T54 = -104						; size = 8
$T55 = -96						; size = 8
$T56 = -88						; size = 8
$T57 = -80						; size = 8
$T58 = -72						; size = 8
$T59 = -64						; size = 8
$T60 = -56						; size = 8
$T61 = -48						; size = 8
$T62 = -40						; size = 8
__$EHRec$ = -12						; size = 12
??__Elevel1@@YAXXZ PROC					; `dynamic initializer for 'level1'', COMDAT

; 19   : };

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??__Elevel1@@YAXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 30 f7 ff
	ff		 add	 esp, -2256		; fffff730H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 85 38 f7 ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00046	c7 85 3c f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??__Elevel1@@YAXXZ
  00050	c7 85 40 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??__Elevel1@@YAXXZ ; `dynamic initializer for 'level1''
  0005a	8d 85 38 f7 ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv916[ebp], eax
  00066	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv916[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv918[ebp], ecx
  0007b	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  00080	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR tv918[ebp]
  00086	66 89 10	 mov	 WORD PTR [eax], dx
  00089	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR tv918[ebp]
  0008f	83 c1 02	 add	 ecx, 2
  00092	89 8d 74 fe ff
	ff		 mov	 DWORD PTR tv919[ebp], ecx
  00098	6a 1c		 push	 28			; 0000001cH
  0009a	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR tv919[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000a6	83 c4 08	 add	 esp, 8
  000a9	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv919[ebp]
  000af	83 c0 1c	 add	 eax, 28			; 0000001cH
  000b2	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv923[ebp], eax
  000b8	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv923[ebp]
  000be	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  000c4	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  000ca	83 c2 22	 add	 edx, 34			; 00000022H
  000cd	89 95 3c fe ff
	ff		 mov	 DWORD PTR tv924[ebp], edx
  000d3	6a 04		 push	 4
  000d5	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR tv924[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e1	83 c4 08	 add	 esp, 8
  000e4	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR tv924[ebp]
  000ea	83 c1 04	 add	 ecx, 4
  000ed	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv928[ebp], ecx
  000f3	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv928[ebp]
  000f9	c6 02 04	 mov	 BYTE PTR [edx], 4
  000fc	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR tv924[ebp]
  00102	83 c0 05	 add	 eax, 5
  00105	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv929[ebp], eax
  0010b	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv929[ebp]
  00111	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00117	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0011d	83 c2 2b	 add	 edx, 43			; 0000002bH
  00120	89 95 40 fe ff
	ff		 mov	 DWORD PTR tv930[ebp], edx
  00126	6a 04		 push	 4
  00128	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00134	83 c4 08	 add	 esp, 8
  00137	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv930[ebp]
  0013d	83 c1 04	 add	 ecx, 4
  00140	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv934[ebp], ecx
  00146	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR tv934[ebp]
  0014c	c6 02 04	 mov	 BYTE PTR [edx], 4
  0014f	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  00155	83 c0 05	 add	 eax, 5
  00158	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv935[ebp], eax
  0015e	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv935[ebp]
  00164	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  0016a	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00170	83 c2 34	 add	 edx, 52			; 00000034H
  00173	89 95 44 fe ff
	ff		 mov	 DWORD PTR tv936[ebp], edx
  00179	6a 04		 push	 4
  0017b	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv936[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00187	83 c4 08	 add	 esp, 8
  0018a	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR tv936[ebp]
  00190	83 c1 04	 add	 ecx, 4
  00193	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv940[ebp], ecx
  00199	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv940[ebp]
  0019f	c6 02 04	 mov	 BYTE PTR [edx], 4
  001a2	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv936[ebp]
  001a8	83 c0 05	 add	 eax, 5
  001ab	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv941[ebp], eax
  001b1	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv941[ebp]
  001b7	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  001bd	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  001c3	83 c2 3d	 add	 edx, 61			; 0000003dH
  001c6	89 95 48 fe ff
	ff		 mov	 DWORD PTR tv942[ebp], edx
  001cc	6a 04		 push	 4
  001ce	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001da	83 c4 08	 add	 esp, 8
  001dd	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR tv942[ebp]
  001e3	83 c1 04	 add	 ecx, 4
  001e6	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv946[ebp], ecx
  001ec	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv946[ebp]
  001f2	c6 02 04	 mov	 BYTE PTR [edx], 4
  001f5	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  001fb	83 c0 05	 add	 eax, 5
  001fe	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv947[ebp], eax
  00204	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv947[ebp]
  0020a	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00210	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00216	83 c2 46	 add	 edx, 70			; 00000046H
  00219	89 95 4c fe ff
	ff		 mov	 DWORD PTR tv948[ebp], edx
  0021f	6a 04		 push	 4
  00221	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv948[ebp]
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022d	83 c4 08	 add	 esp, 8
  00230	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR tv948[ebp]
  00236	83 c1 04	 add	 ecx, 4
  00239	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv952[ebp], ecx
  0023f	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv952[ebp]
  00245	c6 02 04	 mov	 BYTE PTR [edx], 4
  00248	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv948[ebp]
  0024e	83 c0 05	 add	 eax, 5
  00251	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv953[ebp], eax
  00257	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv953[ebp]
  0025d	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00263	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00269	83 c2 4f	 add	 edx, 79			; 0000004fH
  0026c	89 95 50 fe ff
	ff		 mov	 DWORD PTR tv954[ebp], edx
  00272	6a 04		 push	 4
  00274	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv954[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00280	83 c4 08	 add	 esp, 8
  00283	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR tv954[ebp]
  00289	83 c1 04	 add	 ecx, 4
  0028c	89 8d e0 fe ff
	ff		 mov	 DWORD PTR tv958[ebp], ecx
  00292	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv958[ebp]
  00298	c6 02 04	 mov	 BYTE PTR [edx], 4
  0029b	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv954[ebp]
  002a1	83 c0 05	 add	 eax, 5
  002a4	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv959[ebp], eax
  002aa	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv959[ebp]
  002b0	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  002b6	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  002bc	83 c2 58	 add	 edx, 88			; 00000058H
  002bf	89 95 54 fe ff
	ff		 mov	 DWORD PTR tv960[ebp], edx
  002c5	6a 04		 push	 4
  002c7	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv960[ebp]
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002d3	83 c4 08	 add	 esp, 8
  002d6	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv960[ebp]
  002dc	83 c1 04	 add	 ecx, 4
  002df	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv964[ebp], ecx
  002e5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv964[ebp]
  002eb	c6 02 04	 mov	 BYTE PTR [edx], 4
  002ee	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv960[ebp]
  002f4	83 c0 05	 add	 eax, 5
  002f7	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv965[ebp], eax
  002fd	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv965[ebp]
  00303	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00309	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0030f	83 c2 61	 add	 edx, 97			; 00000061H
  00312	89 95 58 fe ff
	ff		 mov	 DWORD PTR tv966[ebp], edx
  00318	6a 04		 push	 4
  0031a	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv966[ebp]
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00326	83 c4 08	 add	 esp, 8
  00329	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv966[ebp]
  0032f	83 c1 04	 add	 ecx, 4
  00332	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv970[ebp], ecx
  00338	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv970[ebp]
  0033e	c6 02 04	 mov	 BYTE PTR [edx], 4
  00341	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv966[ebp]
  00347	83 c0 05	 add	 eax, 5
  0034a	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv971[ebp], eax
  00350	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv971[ebp]
  00356	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  0035c	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00362	83 c2 6a	 add	 edx, 106		; 0000006aH
  00365	89 95 5c fe ff
	ff		 mov	 DWORD PTR tv972[ebp], edx
  0036b	6a 04		 push	 4
  0036d	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv972[ebp]
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00379	83 c4 08	 add	 esp, 8
  0037c	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR tv972[ebp]
  00382	83 c1 04	 add	 ecx, 4
  00385	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv976[ebp], ecx
  0038b	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv976[ebp]
  00391	c6 02 04	 mov	 BYTE PTR [edx], 4
  00394	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv972[ebp]
  0039a	83 c0 05	 add	 eax, 5
  0039d	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv977[ebp], eax
  003a3	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR tv977[ebp]
  003a9	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  003af	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  003b5	83 c2 73	 add	 edx, 115		; 00000073H
  003b8	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv978[ebp], edx
  003be	6a 04		 push	 4
  003c0	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003cc	83 c4 08	 add	 esp, 8
  003cf	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR tv978[ebp]
  003d5	83 c1 04	 add	 ecx, 4
  003d8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv982[ebp], ecx
  003de	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv982[ebp]
  003e4	c6 02 04	 mov	 BYTE PTR [edx], 4
  003e7	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  003ed	83 c0 05	 add	 eax, 5
  003f0	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv983[ebp], eax
  003f6	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv983[ebp]
  003fc	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00402	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00408	83 c2 7c	 add	 edx, 124		; 0000007cH
  0040b	89 95 64 fe ff
	ff		 mov	 DWORD PTR tv984[ebp], edx
  00411	6a 04		 push	 4
  00413	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv984[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0041f	83 c4 08	 add	 esp, 8
  00422	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR tv984[ebp]
  00428	83 c1 04	 add	 ecx, 4
  0042b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv988[ebp], ecx
  00431	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR tv988[ebp]
  00437	c6 02 04	 mov	 BYTE PTR [edx], 4
  0043a	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv984[ebp]
  00440	83 c0 05	 add	 eax, 5
  00443	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv989[ebp], eax
  00449	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv989[ebp]
  0044f	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00455	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0045b	81 c2 85 00 00
	00		 add	 edx, 133		; 00000085H
  00461	89 95 68 fe ff
	ff		 mov	 DWORD PTR tv990[ebp], edx
  00467	6a 04		 push	 4
  00469	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  0046f	50		 push	 eax
  00470	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00475	83 c4 08	 add	 esp, 8
  00478	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv990[ebp]
  0047e	83 c1 04	 add	 ecx, 4
  00481	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv994[ebp], ecx
  00487	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv994[ebp]
  0048d	c6 02 04	 mov	 BYTE PTR [edx], 4
  00490	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  00496	83 c0 05	 add	 eax, 5
  00499	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv995[ebp], eax
  0049f	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv995[ebp]
  004a5	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  004ab	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  004b1	81 c2 8e 00 00
	00		 add	 edx, 142		; 0000008eH
  004b7	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv996[ebp], edx
  004bd	6a 04		 push	 4
  004bf	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv996[ebp]
  004c5	50		 push	 eax
  004c6	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  004cb	83 c4 08	 add	 esp, 8
  004ce	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv996[ebp]
  004d4	83 c1 04	 add	 ecx, 4
  004d7	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv1000[ebp], ecx
  004dd	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv1000[ebp]
  004e3	c6 02 04	 mov	 BYTE PTR [edx], 4
  004e6	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv996[ebp]
  004ec	83 c0 05	 add	 eax, 5
  004ef	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv1001[ebp], eax
  004f5	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv1001[ebp]
  004fb	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00501	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00507	81 c2 97 00 00
	00		 add	 edx, 151		; 00000097H
  0050d	89 95 70 fe ff
	ff		 mov	 DWORD PTR tv1002[ebp], edx
  00513	6a 04		 push	 4
  00515	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv1002[ebp]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00521	83 c4 08	 add	 esp, 8
  00524	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv1002[ebp]
  0052a	83 c1 04	 add	 ecx, 4
  0052d	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv1006[ebp], ecx
  00533	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv1006[ebp]
  00539	c6 02 04	 mov	 BYTE PTR [edx], 4
  0053c	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv1002[ebp]
  00542	83 c0 05	 add	 eax, 5
  00545	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv1007[ebp], eax
  0054b	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00551	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00557	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0055e	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  00564	c7 02 01 f2 01
	f2		 mov	 DWORD PTR [edx], -234753535 ; f201f201H
  0056a	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00571	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00577	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  0057d	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00584	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  0058a	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  00590	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00597	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  0059d	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  005a3	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005aa	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  005b0	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  005b6	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005bd	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  005c3	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  005c9	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005d0	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  005d6	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  005dc	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005e3	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  005e9	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  005ef	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005f6	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  005fc	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  00602	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00609	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  0060f	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  00615	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0061c	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00622	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  00628	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0062f	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00635	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  0063b	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00642	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  00648	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  0064e	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00655	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  0065b	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  00661	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00668	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  0066e	c7 01 00 f2 00
	f3		 mov	 DWORD PTR [ecx], -218041856 ; f300f200H
  00674	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0067b	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  00680	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00686	66 89 10	 mov	 WORD PTR [eax], dx
  00689	83 85 34 fe ff
	ff 02		 add	 DWORD PTR tv1007[ebp], 2
  00690	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00696	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00699	b9 00 00 00 00	 mov	 ecx, OFFSET __218DFE2C_Levels@h
  0069e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4    : inline std::vector<std::vector<int>> level1 = {

  006a3	6a 10		 push	 16			; 00000010H
  006a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  006aa	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
  006af	8d 8d 38 fc ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  006b5	e8 00 00 00 00	 call	 ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
  006ba	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv612[ebp], eax
  006c0	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  006c6	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  006cb	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  006d1	c7 85 48 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  006db	c7 85 4c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], 0
  006e5	c7 85 50 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+8], 0
  006ef	c7 85 54 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+12], 0
  006f9	c7 85 58 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0
  00703	c7 85 5c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 0
  0070d	c7 85 60 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+24], 0
  00717	c7 85 64 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+28], 0
  00721	c7 85 68 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+32], 0
  0072b	8d 95 48 f8 ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00731	83 c2 24	 add	 edx, 36			; 00000024H
  00734	52		 push	 edx
  00735	8d 85 48 f8 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0073b	50		 push	 eax
  0073c	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00742	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00747	6a 08		 push	 8
  00749	50		 push	 eax
  0074a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T48[ebp]
  00750	51		 push	 ecx
  00751	e8 00 00 00 00	 call	 ___asan_memcpy
  00756	83 c4 0c	 add	 esp, 12			; 0000000cH
  00759	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  0075f	52		 push	 edx
  00760	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T48[ebp+4]
  00766	50		 push	 eax
  00767	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T48[ebp]
  0076d	51		 push	 ecx
  0076e	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00774	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00779	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00780	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00786	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0078b	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv164[ebp], eax
  00791	c7 85 90 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  0079b	c7 85 94 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], 0
  007a5	c7 85 98 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+8], 0
  007af	c7 85 9c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+12], 0
  007b9	c7 85 a0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  007c3	c7 85 a4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 0
  007cd	c7 85 a8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+24], 0
  007d7	c7 85 ac f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+28], 0
  007e1	c7 85 b0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+32], 0
  007eb	8d 95 90 f8 ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  007f1	83 c2 24	 add	 edx, 36			; 00000024H
  007f4	52		 push	 edx
  007f5	8d 85 90 f8 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  007fb	50		 push	 eax
  007fc	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00802	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00807	6a 08		 push	 8
  00809	50		 push	 eax
  0080a	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp]
  00810	51		 push	 ecx
  00811	e8 00 00 00 00	 call	 ___asan_memcpy
  00816	83 c4 0c	 add	 esp, 12			; 0000000cH
  00819	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv164[ebp]
  0081f	52		 push	 edx
  00820	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T49[ebp+4]
  00826	50		 push	 eax
  00827	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T49[ebp]
  0082d	51		 push	 ecx
  0082e	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+16]
  00834	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00839	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0083d	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00843	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00848	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  0084e	c7 85 d8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  00858	c7 85 dc f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], 0
  00862	c7 85 e0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+8], 0
  0086c	c7 85 e4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+12], 0
  00876	c7 85 e8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  00880	c7 85 ec f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 0
  0088a	c7 85 f0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+24], 0
  00894	c7 85 f4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+28], 0
  0089e	c7 85 f8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+32], 0
  008a8	8d 95 d8 f8 ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  008ae	83 c2 24	 add	 edx, 36			; 00000024H
  008b1	52		 push	 edx
  008b2	8d 85 d8 f8 ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  008b8	50		 push	 eax
  008b9	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  008bf	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  008c4	6a 08		 push	 8
  008c6	50		 push	 eax
  008c7	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  008cd	51		 push	 ecx
  008ce	e8 00 00 00 00	 call	 ___asan_memcpy
  008d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  008d6	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv179[ebp]
  008dc	52		 push	 edx
  008dd	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T50[ebp+4]
  008e3	50		 push	 eax
  008e4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T50[ebp]
  008ea	51		 push	 ecx
  008eb	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+32]
  008f1	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  008f6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  008fa	8d 8d a8 fc ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00900	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00905	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  0090b	c7 85 20 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], 0
  00915	c7 85 24 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], 0
  0091f	c7 85 28 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+8], 0
  00929	c7 85 2c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+12], 0
  00933	c7 85 30 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  0093d	c7 85 34 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 0
  00947	c7 85 38 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+24], 0
  00951	c7 85 3c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+28], 0
  0095b	c7 85 40 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+32], 0
  00965	8d 95 20 f9 ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0096b	83 c2 24	 add	 edx, 36			; 00000024H
  0096e	52		 push	 edx
  0096f	8d 85 20 f9 ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00975	50		 push	 eax
  00976	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0097c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00981	6a 08		 push	 8
  00983	50		 push	 eax
  00984	8d 4d 80	 lea	 ecx, DWORD PTR $T51[ebp]
  00987	51		 push	 ecx
  00988	e8 00 00 00 00	 call	 ___asan_memcpy
  0098d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00990	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  00996	52		 push	 edx
  00997	8b 45 84	 mov	 eax, DWORD PTR $T51[ebp+4]
  0099a	50		 push	 eax
  0099b	8b 4d 80	 mov	 ecx, DWORD PTR $T51[ebp]
  0099e	51		 push	 ecx
  0099f	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+48]
  009a5	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  009aa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  009ae	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  009b4	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  009b9	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  009bf	c7 85 68 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], 0
  009c9	c7 85 6c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], 0
  009d3	c7 85 70 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+8], 0
  009dd	c7 85 74 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+12], 0
  009e7	c7 85 78 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  009f1	c7 85 7c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 0
  009fb	c7 85 80 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+24], 0
  00a05	c7 85 84 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+28], 0
  00a0f	c7 85 88 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+32], 0
  00a19	8d 95 68 f9 ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00a1f	83 c2 24	 add	 edx, 36			; 00000024H
  00a22	52		 push	 edx
  00a23	8d 85 68 f9 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00a29	50		 push	 eax
  00a2a	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00a30	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00a35	6a 08		 push	 8
  00a37	50		 push	 eax
  00a38	8d 4d 88	 lea	 ecx, DWORD PTR $T52[ebp]
  00a3b	51		 push	 ecx
  00a3c	e8 00 00 00 00	 call	 ___asan_memcpy
  00a41	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a44	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  00a4a	52		 push	 edx
  00a4b	8b 45 8c	 mov	 eax, DWORD PTR $T52[ebp+4]
  00a4e	50		 push	 eax
  00a4f	8b 4d 88	 mov	 ecx, DWORD PTR $T52[ebp]
  00a52	51		 push	 ecx
  00a53	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+64]
  00a59	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00a5e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00a62	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00a68	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00a6d	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv320[ebp], eax
  00a73	c7 85 b0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], 0
  00a7d	c7 85 b4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+4], 0
  00a87	c7 85 b8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+8], 0
  00a91	c7 85 bc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+12], 0
  00a9b	c7 85 c0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  00aa5	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 0
  00aaf	c7 85 c8 f9 ff
	ff 03 00 00 00	 mov	 DWORD PTR $T9[ebp+24], 3
  00ab9	c7 85 cc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+28], 0
  00ac3	c7 85 d0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+32], 0
  00acd	8d 95 b0 f9 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  00ad3	83 c2 24	 add	 edx, 36			; 00000024H
  00ad6	52		 push	 edx
  00ad7	8d 85 b0 f9 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00add	50		 push	 eax
  00ade	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  00ae4	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00ae9	6a 08		 push	 8
  00aeb	50		 push	 eax
  00aec	8d 4d 90	 lea	 ecx, DWORD PTR $T53[ebp]
  00aef	51		 push	 ecx
  00af0	e8 00 00 00 00	 call	 ___asan_memcpy
  00af5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00af8	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv320[ebp]
  00afe	52		 push	 edx
  00aff	8b 45 94	 mov	 eax, DWORD PTR $T53[ebp+4]
  00b02	50		 push	 eax
  00b03	8b 4d 90	 mov	 ecx, DWORD PTR $T53[ebp]
  00b06	51		 push	 ecx
  00b07	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+80]
  00b0d	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00b12	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00b16	8d 8d 08 fd ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  00b1c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00b21	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv335[ebp], eax
  00b27	c7 85 f8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp], 0
  00b31	c7 85 fc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+4], 0
  00b3b	c7 85 00 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+8], 0
  00b45	c7 85 04 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+12], 0
  00b4f	c7 85 08 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+16], 0
  00b59	c7 85 0c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+20], 0
  00b63	c7 85 10 fa ff
	ff 05 00 00 00	 mov	 DWORD PTR $T10[ebp+24], 5
  00b6d	c7 85 14 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+28], 0
  00b77	c7 85 18 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+32], 0
  00b81	8d 95 f8 f9 ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  00b87	83 c2 24	 add	 edx, 36			; 00000024H
  00b8a	52		 push	 edx
  00b8b	8d 85 f8 f9 ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00b91	50		 push	 eax
  00b92	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  00b98	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00b9d	6a 08		 push	 8
  00b9f	50		 push	 eax
  00ba0	8d 4d 98	 lea	 ecx, DWORD PTR $T54[ebp]
  00ba3	51		 push	 ecx
  00ba4	e8 00 00 00 00	 call	 ___asan_memcpy
  00ba9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bac	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv335[ebp]
  00bb2	52		 push	 edx
  00bb3	8b 45 9c	 mov	 eax, DWORD PTR $T54[ebp+4]
  00bb6	50		 push	 eax
  00bb7	8b 4d 98	 mov	 ecx, DWORD PTR $T54[ebp]
  00bba	51		 push	 ecx
  00bbb	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+96]
  00bc1	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00bc6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00bca	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00bd0	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00bd5	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv350[ebp], eax
  00bdb	c7 85 40 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp], 0
  00be5	c7 85 44 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+4], 0
  00bef	c7 85 48 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+8], 0
  00bf9	c7 85 4c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+12], 0
  00c03	c7 85 50 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  00c0d	c7 85 54 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 0
  00c17	c7 85 58 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T11[ebp+24], 3
  00c21	c7 85 5c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+28], 0
  00c2b	c7 85 60 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+32], 0
  00c35	8d 95 40 fa ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  00c3b	83 c2 24	 add	 edx, 36			; 00000024H
  00c3e	52		 push	 edx
  00c3f	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00c45	50		 push	 eax
  00c46	8d 8d 38 fd ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  00c4c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00c51	6a 08		 push	 8
  00c53	50		 push	 eax
  00c54	8d 4d a0	 lea	 ecx, DWORD PTR $T55[ebp]
  00c57	51		 push	 ecx
  00c58	e8 00 00 00 00	 call	 ___asan_memcpy
  00c5d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c60	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv350[ebp]
  00c66	52		 push	 edx
  00c67	8b 45 a4	 mov	 eax, DWORD PTR $T55[ebp+4]
  00c6a	50		 push	 eax
  00c6b	8b 4d a0	 mov	 ecx, DWORD PTR $T55[ebp]
  00c6e	51		 push	 ecx
  00c6f	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+112]
  00c75	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00c7a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00c7e	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  00c84	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00c89	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
  00c8f	c7 85 88 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp], 2
  00c99	c7 85 8c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+4], 0
  00ca3	c7 85 90 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+8], 0
  00cad	c7 85 94 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+12], 2
  00cb7	c7 85 98 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+16], 0
  00cc1	c7 85 9c fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+20], 2
  00ccb	c7 85 a0 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+24], 2
  00cd5	c7 85 a4 fa ff
	ff 06 00 00 00	 mov	 DWORD PTR $T12[ebp+28], 6
  00cdf	c7 85 a8 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+32], 2
  00ce9	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00cef	83 c2 24	 add	 edx, 36			; 00000024H
  00cf2	52		 push	 edx
  00cf3	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  00cf9	50		 push	 eax
  00cfa	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  00d00	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00d05	6a 08		 push	 8
  00d07	50		 push	 eax
  00d08	8d 4d a8	 lea	 ecx, DWORD PTR $T56[ebp]
  00d0b	51		 push	 ecx
  00d0c	e8 00 00 00 00	 call	 ___asan_memcpy
  00d11	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d14	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv397[ebp]
  00d1a	52		 push	 edx
  00d1b	8b 45 ac	 mov	 eax, DWORD PTR $T56[ebp+4]
  00d1e	50		 push	 eax
  00d1f	8b 4d a8	 mov	 ecx, DWORD PTR $T56[ebp]
  00d22	51		 push	 ecx
  00d23	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+128]
  00d29	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00d2e	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00d32	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR $T37[ebp]
  00d38	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00d3d	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv412[ebp], eax
  00d43	c7 85 d0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp], 0
  00d4d	c7 85 d4 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+4], 2
  00d57	c7 85 d8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+8], 0
  00d61	c7 85 dc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+12], 0
  00d6b	c7 85 e0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+16], 0
  00d75	c7 85 e4 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp+20], 3
  00d7f	c7 85 e8 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp+24], 3
  00d89	c7 85 ec fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+28], 2
  00d93	c7 85 f0 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+32], 2
  00d9d	8d 95 d0 fa ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  00da3	83 c2 24	 add	 edx, 36			; 00000024H
  00da6	52		 push	 edx
  00da7	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00dad	50		 push	 eax
  00dae	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  00db4	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00db9	6a 08		 push	 8
  00dbb	50		 push	 eax
  00dbc	8d 4d b0	 lea	 ecx, DWORD PTR $T57[ebp]
  00dbf	51		 push	 ecx
  00dc0	e8 00 00 00 00	 call	 ___asan_memcpy
  00dc5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dc8	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv412[ebp]
  00dce	52		 push	 edx
  00dcf	8b 45 b4	 mov	 eax, DWORD PTR $T57[ebp+4]
  00dd2	50		 push	 eax
  00dd3	8b 4d b0	 mov	 ecx, DWORD PTR $T57[ebp]
  00dd6	51		 push	 ecx
  00dd7	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+144]
  00ddd	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00de2	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00de6	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  00dec	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00df1	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  00df7	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp], 0
  00e01	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+4], 0
  00e0b	c7 85 20 fb ff
	ff 05 00 00 00	 mov	 DWORD PTR $T14[ebp+8], 5
  00e15	c7 85 24 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+12], 0
  00e1f	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0
  00e29	c7 85 2c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 0
  00e33	c7 85 30 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T14[ebp+24], 4
  00e3d	c7 85 34 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T14[ebp+28], 3
  00e47	c7 85 38 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+32], 0
  00e51	8d 95 18 fb ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  00e57	83 c2 24	 add	 edx, 36			; 00000024H
  00e5a	52		 push	 edx
  00e5b	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00e61	50		 push	 eax
  00e62	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR $T40[ebp]
  00e68	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00e6d	6a 08		 push	 8
  00e6f	50		 push	 eax
  00e70	8d 4d b8	 lea	 ecx, DWORD PTR $T58[ebp]
  00e73	51		 push	 ecx
  00e74	e8 00 00 00 00	 call	 ___asan_memcpy
  00e79	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e7c	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv459[ebp]
  00e82	52		 push	 edx
  00e83	8b 45 bc	 mov	 eax, DWORD PTR $T58[ebp+4]
  00e86	50		 push	 eax
  00e87	8b 4d b8	 mov	 ecx, DWORD PTR $T58[ebp]
  00e8a	51		 push	 ecx
  00e8b	8d 8d e8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+160]
  00e91	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00e96	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00e9a	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00ea0	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00ea5	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv474[ebp], eax
  00eab	c7 85 60 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp], 0
  00eb5	c7 85 64 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+4], 0
  00ebf	c7 85 68 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T15[ebp+8], 3
  00ec9	c7 85 6c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp+12], 2
  00ed3	c7 85 70 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR $T15[ebp+16], -1
  00edd	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 0
  00ee7	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+24], 0
  00ef1	c7 85 7c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp+28], 2
  00efb	c7 85 80 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+32], 0
  00f05	8d 95 60 fb ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00f0b	83 c2 24	 add	 edx, 36			; 00000024H
  00f0e	52		 push	 edx
  00f0f	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00f15	50		 push	 eax
  00f16	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00f1c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00f21	6a 08		 push	 8
  00f23	50		 push	 eax
  00f24	8d 4d c0	 lea	 ecx, DWORD PTR $T59[ebp]
  00f27	51		 push	 ecx
  00f28	e8 00 00 00 00	 call	 ___asan_memcpy
  00f2d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f30	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv474[ebp]
  00f36	52		 push	 edx
  00f37	8b 45 c4	 mov	 eax, DWORD PTR $T59[ebp+4]
  00f3a	50		 push	 eax
  00f3b	8b 4d c0	 mov	 ecx, DWORD PTR $T59[ebp]
  00f3e	51		 push	 ecx
  00f3f	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+176]
  00f45	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00f4a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00f4e	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00f54	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00f59	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv553[ebp], eax
  00f5f	c7 85 a8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp], 0
  00f69	c7 85 ac fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+4], 0
  00f73	c7 85 b0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T16[ebp+8], 2
  00f7d	c7 85 b4 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp+12], 4
  00f87	c7 85 b8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 3
  00f91	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 0
  00f9b	c7 85 c0 fb ff
	ff 64 00 00 00	 mov	 DWORD PTR $T16[ebp+24], 100 ; 00000064H
  00fa5	c7 85 c4 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp+28], 4
  00faf	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+32], 0
  00fb9	8d 95 a8 fb ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  00fbf	83 c2 24	 add	 edx, 36			; 00000024H
  00fc2	52		 push	 edx
  00fc3	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00fc9	50		 push	 eax
  00fca	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00fd0	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00fd5	6a 08		 push	 8
  00fd7	50		 push	 eax
  00fd8	8d 4d c8	 lea	 ecx, DWORD PTR $T60[ebp]
  00fdb	51		 push	 ecx
  00fdc	e8 00 00 00 00	 call	 ___asan_memcpy
  00fe1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe4	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv553[ebp]
  00fea	52		 push	 edx
  00feb	8b 45 cc	 mov	 eax, DWORD PTR $T60[ebp+4]
  00fee	50		 push	 eax
  00fef	8b 4d c8	 mov	 ecx, DWORD PTR $T60[ebp]
  00ff2	51		 push	 ecx
  00ff3	8d 8d 08 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+192]
  00ff9	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00ffe	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  01002	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  01008	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0100d	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv568[ebp], eax
  01013	c7 85 f0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp], 2
  0101d	c7 85 f4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+4], 2
  01027	c7 85 f8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+8], 3
  01031	c7 85 fc fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+12], 3
  0103b	c7 85 00 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 2
  01045	c7 85 04 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 3
  0104f	c7 85 08 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+24], 3
  01059	c7 85 0c fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+28], 2
  01063	c7 85 10 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR $T17[ebp+32], 4
  0106d	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T17[ebp]
  01073	83 c2 24	 add	 edx, 36			; 00000024H
  01076	52		 push	 edx
  01077	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0107d	50		 push	 eax
  0107e	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  01084	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  01089	6a 08		 push	 8
  0108b	50		 push	 eax
  0108c	8d 4d d0	 lea	 ecx, DWORD PTR $T61[ebp]
  0108f	51		 push	 ecx
  01090	e8 00 00 00 00	 call	 ___asan_memcpy
  01095	83 c4 0c	 add	 esp, 12			; 0000000cH
  01098	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv568[ebp]
  0109e	52		 push	 edx
  0109f	8b 45 d4	 mov	 eax, DWORD PTR $T61[ebp+4]
  010a2	50		 push	 eax
  010a3	8b 4d d0	 mov	 ecx, DWORD PTR $T61[ebp]
  010a6	51		 push	 ecx
  010a7	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+208]
  010ad	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  010b2	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  010b9	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  010bf	81 c2 e0 00 00
	00		 add	 edx, 224		; 000000e0H
  010c5	52		 push	 edx
  010c6	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  010cc	50		 push	 eax
  010cd	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  010d3	e8 00 00 00 00	 call	 ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
  010d8	6a 08		 push	 8
  010da	50		 push	 eax
  010db	8d 4d d8	 lea	 ecx, DWORD PTR $T62[ebp]
  010de	51		 push	 ecx
  010df	e8 00 00 00 00	 call	 ___asan_memcpy
  010e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  010e7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv612[ebp]
  010ed	52		 push	 edx
  010ee	8b 45 dc	 mov	 eax, DWORD PTR $T62[ebp+4]
  010f1	50		 push	 eax
  010f2	8b 4d d8	 mov	 ecx, DWORD PTR $T62[ebp]
  010f5	51		 push	 ecx
  010f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  010fb	e8 00 00 00 00	 call	 ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  01100	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01107	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0110c	6a 0e		 push	 14			; 0000000eH
  0110e	6a 10		 push	 16			; 00000010H
  01110	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  01116	52		 push	 edx
  01117	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0111c	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  01122	c1 e8 03	 shr	 eax, 3
  01125	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0112c	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  01132	c1 e9 03	 shr	 ecx, 3
  01135	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0113b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1195[ebp], ecx
  01141	6a 1c		 push	 28			; 0000001cH
  01143	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv1195[ebp]
  01149	52		 push	 edx
  0114a	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0114f	83 c4 08	 add	 esp, 8
  01152	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  01158	c1 e8 03	 shr	 eax, 3
  0115b	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01162	8d 8d 48 f8 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  01168	c1 e9 03	 shr	 ecx, 3
  0116b	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  01171	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv1185[ebp], ecx
  01177	6a 04		 push	 4
  01179	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR tv1185[ebp]
  0117f	52		 push	 edx
  01180	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01185	83 c4 08	 add	 esp, 8
  01188	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR tv1185[ebp]
  0118e	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01192	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  01198	c1 e9 03	 shr	 ecx, 3
  0119b	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  011a2	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR $T21[ebp]
  011a8	c1 ea 03	 shr	 edx, 3
  011ab	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  011b2	8d 85 90 f8 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  011b8	c1 e8 03	 shr	 eax, 3
  011bb	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  011c0	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv1172[ebp], eax
  011c6	6a 04		 push	 4
  011c8	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR tv1172[ebp]
  011ce	51		 push	 ecx
  011cf	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  011d4	83 c4 08	 add	 esp, 8
  011d7	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR tv1172[ebp]
  011dd	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  011e1	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  011e7	c1 e8 03	 shr	 eax, 3
  011ea	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  011f1	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  011f7	c1 e9 03	 shr	 ecx, 3
  011fa	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01201	8d 95 d8 f8 ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  01207	c1 ea 03	 shr	 edx, 3
  0120a	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  01210	89 95 80 fe ff
	ff		 mov	 DWORD PTR tv1159[ebp], edx
  01216	6a 04		 push	 4
  01218	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR tv1159[ebp]
  0121e	50		 push	 eax
  0121f	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01224	83 c4 08	 add	 esp, 8
  01227	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR tv1159[ebp]
  0122d	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  01231	8d 95 98 fc ff
	ff		 lea	 edx, DWORD PTR $T24[ebp]
  01237	c1 ea 03	 shr	 edx, 3
  0123a	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01241	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  01247	c1 e8 03	 shr	 eax, 3
  0124a	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01251	8d 8d 20 f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  01257	c1 e9 03	 shr	 ecx, 3
  0125a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  01260	89 8d 84 fe ff
	ff		 mov	 DWORD PTR tv1146[ebp], ecx
  01266	6a 04		 push	 4
  01268	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv1146[ebp]
  0126e	52		 push	 edx
  0126f	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01274	83 c4 08	 add	 esp, 8
  01277	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv1146[ebp]
  0127d	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01281	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  01287	c1 e9 03	 shr	 ecx, 3
  0128a	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01291	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR $T27[ebp]
  01297	c1 ea 03	 shr	 edx, 3
  0129a	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  012a1	8d 85 68 f9 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  012a7	c1 e8 03	 shr	 eax, 3
  012aa	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  012af	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv1133[ebp], eax
  012b5	6a 04		 push	 4
  012b7	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv1133[ebp]
  012bd	51		 push	 ecx
  012be	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  012c3	83 c4 08	 add	 esp, 8
  012c6	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv1133[ebp]
  012cc	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  012d0	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  012d6	c1 e8 03	 shr	 eax, 3
  012d9	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  012e0	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  012e6	c1 e9 03	 shr	 ecx, 3
  012e9	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  012f0	8d 95 b0 f9 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  012f6	c1 ea 03	 shr	 edx, 3
  012f9	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  012ff	89 95 8c fe ff
	ff		 mov	 DWORD PTR tv1120[ebp], edx
  01305	6a 04		 push	 4
  01307	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv1120[ebp]
  0130d	50		 push	 eax
  0130e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01313	83 c4 08	 add	 esp, 8
  01316	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR tv1120[ebp]
  0131c	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  01320	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR $T30[ebp]
  01326	c1 ea 03	 shr	 edx, 3
  01329	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01330	8d 85 08 fd ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  01336	c1 e8 03	 shr	 eax, 3
  01339	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01340	8d 8d f8 f9 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  01346	c1 e9 03	 shr	 ecx, 3
  01349	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0134f	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv1107[ebp], ecx
  01355	6a 04		 push	 4
  01357	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR tv1107[ebp]
  0135d	52		 push	 edx
  0135e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01363	83 c4 08	 add	 esp, 8
  01366	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv1107[ebp]
  0136c	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01370	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  01376	c1 e9 03	 shr	 ecx, 3
  01379	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01380	8d 95 28 fd ff
	ff		 lea	 edx, DWORD PTR $T33[ebp]
  01386	c1 ea 03	 shr	 edx, 3
  01389	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01390	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  01396	c1 e8 03	 shr	 eax, 3
  01399	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0139e	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv1094[ebp], eax
  013a4	6a 04		 push	 4
  013a6	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv1094[ebp]
  013ac	51		 push	 ecx
  013ad	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  013b2	83 c4 08	 add	 esp, 8
  013b5	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv1094[ebp]
  013bb	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  013bf	8d 85 38 fd ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  013c5	c1 e8 03	 shr	 eax, 3
  013c8	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  013cf	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  013d5	c1 e9 03	 shr	 ecx, 3
  013d8	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  013df	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  013e5	c1 ea 03	 shr	 edx, 3
  013e8	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  013ee	89 95 98 fe ff
	ff		 mov	 DWORD PTR tv1081[ebp], edx
  013f4	6a 04		 push	 4
  013f6	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv1081[ebp]
  013fc	50		 push	 eax
  013fd	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01402	83 c4 08	 add	 esp, 8
  01405	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv1081[ebp]
  0140b	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  0140f	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR $T36[ebp]
  01415	c1 ea 03	 shr	 edx, 3
  01418	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0141f	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR $T37[ebp]
  01425	c1 e8 03	 shr	 eax, 3
  01428	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0142f	8d 8d d0 fa ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  01435	c1 e9 03	 shr	 ecx, 3
  01438	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0143e	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv1068[ebp], ecx
  01444	6a 04		 push	 4
  01446	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv1068[ebp]
  0144c	52		 push	 edx
  0144d	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01452	83 c4 08	 add	 esp, 8
  01455	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv1068[ebp]
  0145b	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  0145f	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  01465	c1 e9 03	 shr	 ecx, 3
  01468	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  0146f	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR $T39[ebp]
  01475	c1 ea 03	 shr	 edx, 3
  01478	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0147f	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  01485	c1 e8 03	 shr	 eax, 3
  01488	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0148d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv1055[ebp], eax
  01493	6a 04		 push	 4
  01495	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1055[ebp]
  0149b	51		 push	 ecx
  0149c	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  014a1	83 c4 08	 add	 esp, 8
  014a4	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR tv1055[ebp]
  014aa	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  014ae	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR $T40[ebp]
  014b4	c1 e8 03	 shr	 eax, 3
  014b7	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  014be	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  014c4	c1 e9 03	 shr	 ecx, 3
  014c7	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  014ce	8d 95 60 fb ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  014d4	c1 ea 03	 shr	 edx, 3
  014d7	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  014dd	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv1042[ebp], edx
  014e3	6a 04		 push	 4
  014e5	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv1042[ebp]
  014eb	50		 push	 eax
  014ec	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  014f1	83 c4 08	 add	 esp, 8
  014f4	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv1042[ebp]
  014fa	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  014fe	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR $T42[ebp]
  01504	c1 ea 03	 shr	 edx, 3
  01507	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0150e	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  01514	c1 e8 03	 shr	 eax, 3
  01517	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0151e	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  01524	c1 e9 03	 shr	 ecx, 3
  01527	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0152d	89 8d a8 fe ff
	ff		 mov	 DWORD PTR tv1029[ebp], ecx
  01533	6a 04		 push	 4
  01535	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR tv1029[ebp]
  0153b	52		 push	 edx
  0153c	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01541	83 c4 08	 add	 esp, 8
  01544	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv1029[ebp]
  0154a	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  0154e	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  01554	c1 e9 03	 shr	 ecx, 3
  01557	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  0155e	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR $T45[ebp]
  01564	c1 ea 03	 shr	 edx, 3
  01567	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0156e	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01574	c1 e8 03	 shr	 eax, 3
  01577	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0157c	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv1016[ebp], eax
  01582	6a 04		 push	 4
  01584	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv1016[ebp]
  0158a	51		 push	 ecx
  0158b	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01590	83 c4 08	 add	 esp, 8
  01593	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv1016[ebp]
  01599	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  0159d	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR $T46[ebp]
  015a3	c1 e8 03	 shr	 eax, 3
  015a6	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  015ad	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  015b3	c1 e9 03	 shr	 ecx, 3
  015b6	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  015bd	68 00 00 00 00	 push	 OFFSET ??__Flevel1@@YAXXZ ; `dynamic atexit destructor for 'level1''
  015c2	e8 00 00 00 00	 call	 _atexit
  015c7	83 c4 04	 add	 esp, 4
  015ca	c7 85 38 f7 ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  015d4	8d 95 38 f7 ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  015da	c1 ea 03	 shr	 edx, 3
  015dd	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  015e3	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1204[ebp], edx
  015e9	68 df 00 00 00	 push	 223			; 000000dfH
  015ee	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv1204[ebp]
  015f4	50		 push	 eax
  015f5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  015fa	83 c4 08	 add	 esp, 8
  015fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01600	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01607	59		 pop	 ecx
  01608	8b e5		 mov	 esp, ebp
  0160a	5d		 pop	 ebp
  0160b	8b e3		 mov	 esp, ebx
  0160d	5b		 pop	 ebx
  0160e	c3		 ret	 0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Elevel1@@YAXXZ$0:
  00000	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$1:
  0000b	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+16]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$2:
  00016	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+32]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$3:
  00021	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+48]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$4:
  0002c	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+64]
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$5:
  00037	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+80]
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$6:
  00042	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+96]
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$7:
  0004d	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+112]
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$8:
  00058	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+128]
  0005e	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$9:
  00063	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+144]
  00069	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$10:
  0006e	8d 8d e8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+160]
  00074	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$11:
  00079	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+176]
  0007f	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$12:
  00084	8d 8d 08 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+192]
  0008a	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$14:
  0008f	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00094	6a 0e		 push	 14			; 0000000eH
  00096	6a 10		 push	 16			; 00000010H
  00098	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000a4	c3		 ret	 0
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
__ehhandler$??__Elevel1@@YAXXZ:
  000aa	90		 npad	 1
  000ab	90		 npad	 1
  000ac	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000b0	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000b3	8b 8a 28 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2264]
  000b9	33 c8		 xor	 ecx, eax
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Elevel1@@YAXXZ
  000c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Elevel1@@YAXXZ ENDP					; `dynamic initializer for 'level1''
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >, COMDAT

; 719  :     static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 720  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 721  :         _STD destroy_at(_Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
  00016	83 c4 04	 add	 esp, 4

; 722  : #else // __cpp_lib_constexpr_dynamic_alloc
; 723  :         _Ptr->~_Uty();
; 724  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 725  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {

  0002c	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	83 c0 10	 add	 eax, 16			; 00000010H
  00034	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003a	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0003d	74 1b		 je	 SHORT $LN5@Destroy_ra

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
  00055	83 c4 08	 add	 esp, 8

; 951  :         }

  00058	eb d4		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 952  :     }
; 953  : }

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z PROC		; std::construct_at<int,int &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ENDP		; std::construct_at<int,int &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ; std::construct_at<int,int &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z PROC		; std::_Get_unwrapped<int * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ENDP		; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z PROC ; std::forward<std::allocator<int> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ENDP ; std::forward<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv78 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z PROC ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 10		 push	 16			; 00000010H
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR tv78[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00040	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 145  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ENDP ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv85 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	eb 35		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00040	83 c4 04	 add	 esp, 4
  00043	50		 push	 eax
  00044	6a 10		 push	 16			; 00000010H
  00046	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 fc	 mov	 DWORD PTR tv85[ebp], eax
  00060	8b 55 fc	 mov	 edx, DWORD PTR tv85[ebp]
  00063	52		 push	 edx
  00064	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00067	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z PROC ; std::_Unfancy<std::vector<int,std::allocator<int> > >, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 10	 add	 eax, 16			; 00000010H
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
__Backout$ = -112					; size = 12
tv86 = -64						; size = 4
__UFirst$ = -60						; size = 4
tv84 = -56						; size = 4
__ULast$ = -52						; size = 4
$T3 = -48						; size = 4
tv89 = -44						; size = 4
tv71 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00043	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0004a	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  00051	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00054	89 45 c8	 mov	 DWORD PTR tv84[ebp], eax
  00057	8b 4d c8	 mov	 ecx, DWORD PTR tv84[ebp]
  0005a	c1 e9 03	 shr	 ecx, 3
  0005d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00063	89 4d c0	 mov	 DWORD PTR tv86[ebp], ecx
  00066	8b 55 c0	 mov	 edx, DWORD PTR tv86[ebp]
  00069	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0006f	83 45 c0 04	 add	 DWORD PTR tv86[ebp], 4
  00073	8b 45 c0	 mov	 eax, DWORD PTR tv86[ebp]
  00076	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00081	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00086	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 c4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00095	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0009e	83 c4 04	 add	 esp, 4
  000a1	89 45 cc	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())
; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1664 :             _Dest += _ULast - _UFirst;
; 1665 :             return _Dest;
; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000a4	6a 0c		 push	 12			; 0000000cH
  000a6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000a9	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
  000ae	8b 43 14	 mov	 eax, DWORD PTR __Al$[ebx]
  000b1	50		 push	 eax
  000b2	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000b5	51		 push	 ecx
  000b6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b9	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  000c5	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000c7	8b 55 c4	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000ca	83 c2 10	 add	 edx, 16			; 00000010H
  000cd	89 55 c4	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  000d0	8b 45 c4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d3	3b 45 cc	 cmp	 eax, DWORD PTR __ULast$[ebp]
  000d6	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000d8	8b 4d c4	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000db	51		 push	 ecx
  000dc	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000df	e8 00 00 00 00	 call	 ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>

; 1672 :     }

  000e4	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000e6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000e9	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
  000ee	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  000f1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f8	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000fb	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00100	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp]
  00103	89 55 d8	 mov	 DWORD PTR tv71[ebp], edx
  00106	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0010d	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00110	c1 e8 03	 shr	 eax, 3
  00113	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00118	89 45 d4	 mov	 DWORD PTR tv89[ebp], eax
  0011b	6a 08		 push	 8
  0011d	8b 4d d4	 mov	 ecx, DWORD PTR tv89[ebp]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00126	83 c4 08	 add	 esp, 8
  00129	8b 45 d8	 mov	 eax, DWORD PTR tv71[ebp]

; 1675 : }

  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	8b e3		 mov	 esp, ebx
  00146	5b		 pop	 ebx
  00147	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0:
  00000	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z PROC ; std::distance<std::vector<int,std::allocator<int> > const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 04	 sar	 eax, 4

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ENDP ; std::distance<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Guard$3 = -136					; size = 4
tv172 = -92						; size = 1
tv162 = -91						; size = 1
tv152 = -90						; size = 1
tv142 = -89						; size = 1
tv94 = -88						; size = 4
_this$ = -84						; size = 4
tv169 = -80						; size = 4
tv159 = -76						; size = 4
tv149 = -72						; size = 4
tv139 = -68						; size = 4
__Count$ = -64						; size = 4
tv78 = -60						; size = 4
__My_data$4 = -56					; size = 4
tv75 = -52						; size = 4
tv92 = -48						; size = 4
tv77 = -44						; size = 4
tv135 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  00056	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
  00060	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  00069	8b 4d d0	 mov	 ecx, DWORD PTR tv92[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d a8	 mov	 DWORD PTR tv94[ebp], ecx
  00078	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  0007b	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00081	83 45 a8 04	 add	 DWORD PTR tv94[ebp], 4
  00085	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0008a	8b 4d a8	 mov	 ecx, DWORD PTR tv94[ebp]
  0008d	66 89 01	 mov	 WORD PTR [ecx], ax
  00090	83 45 a8 02	 add	 DWORD PTR tv94[ebp], 2
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  00097	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0009f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  000a4	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000a7	50		 push	 eax
  000a8	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 c0	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  000c0	83 7d c0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000c4	0f 84 69 01 00
	00		 je	 $LN1@Range_cons
  000ca	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 527  :             _Buy_nonzero(_Count);

  000da	8b 45 c0	 mov	 eax, DWORD PTR __Count$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  000e6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ec	89 4d b0	 mov	 DWORD PTR tv169[ebp], ecx
  000ef	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 a4	 mov	 BYTE PTR tv172[ebp], al
  000fe	80 7d a4 00	 cmp	 BYTE PTR tv172[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@Range_cons
  00104	8a 4d b0	 mov	 cl, BYTE PTR tv169[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d a4	 cmp	 cl, BYTE PTR tv172[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@Range_cons
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN8@Range_cons:
  0011e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Guard$3[ebp], eax
  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0012e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	89 4d c8	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00134	8b 55 c8	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00137	83 c2 04	 add	 edx, 4
  0013a	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00140	89 45 b4	 mov	 DWORD PTR tv159[ebp], eax
  00143	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	c1 e9 03	 shr	 ecx, 3
  00149	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0014f	88 55 a5	 mov	 BYTE PTR tv162[ebp], dl
  00152	80 7d a5 00	 cmp	 BYTE PTR tv162[ebp], 0
  00156	74 18		 je	 SHORT $LN7@Range_cons
  00158	8a 45 b4	 mov	 al, BYTE PTR tv159[ebp]
  0015b	24 07		 and	 al, 7
  0015d	04 03		 add	 al, 3
  0015f	3a 45 a5	 cmp	 al, BYTE PTR tv162[ebp]
  00162	7c 0c		 jl	 SHORT $LN7@Range_cons
  00164	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ___asan_report_load4
  0016d	83 c4 04	 add	 esp, 4
$LN7@Range_cons:
  00170	8b 55 c4	 mov	 edx, DWORD PTR tv78[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	50		 push	 eax
  00176	8b 4b 0c	 mov	 ecx, DWORD PTR __Last$[ebx]
  00179	51		 push	 ecx
  0017a	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  0017d	52		 push	 edx
  0017e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
  00186	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00189	8b 45 c8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	89 45 cc	 mov	 DWORD PTR tv75[ebp], eax
  00192	8b 4d cc	 mov	 ecx, DWORD PTR tv75[ebp]
  00195	89 4d b8	 mov	 DWORD PTR tv149[ebp], ecx
  00198	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  0019b	c1 ea 03	 shr	 edx, 3
  0019e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001a4	88 45 a6	 mov	 BYTE PTR tv152[ebp], al
  001a7	80 7d a6 00	 cmp	 BYTE PTR tv152[ebp], 0
  001ab	74 1a		 je	 SHORT $LN6@Range_cons
  001ad	8a 4d b8	 mov	 cl, BYTE PTR tv149[ebp]
  001b0	80 e1 07	 and	 cl, 7
  001b3	80 c1 03	 add	 cl, 3
  001b6	3a 4d a6	 cmp	 cl, BYTE PTR tv152[ebp]
  001b9	7c 0c		 jl	 SHORT $LN6@Range_cons
  001bb	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 ___asan_report_store4
  001c4	83 c4 04	 add	 esp, 4
$LN6@Range_cons:
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv75[ebp]
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  001cd	89 08		 mov	 DWORD PTR [eax], ecx

; 531  :             _Guard._Target   = nullptr;

  001cf	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  001d5	89 55 bc	 mov	 DWORD PTR tv139[ebp], edx
  001d8	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d a7	 mov	 BYTE PTR tv142[ebp], cl
  001e7	80 7d a7 00	 cmp	 BYTE PTR tv142[ebp], 0
  001eb	74 1a		 je	 SHORT $LN5@Range_cons
  001ed	8a 55 bc	 mov	 dl, BYTE PTR tv139[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 a7	 cmp	 dl, BYTE PTR tv142[ebp]
  001f9	7c 0c		 jl	 SHORT $LN5@Range_cons
  001fb	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN5@Range_cons:
  00207	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  00211	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00218	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0021e	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN1@Range_cons:

; 533  :     }

  00233	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0023d	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00243	c1 ea 03	 shr	 edx, 3
  00246	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0024c	89 55 d8	 mov	 DWORD PTR tv135[ebp], edx
  0024f	6a 07		 push	 7
  00251	8b 45 d8	 mov	 eax, DWORD PTR tv135[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025a	83 c4 08	 add	 esp, 8
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	59		 pop	 ecx
  00268	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	8b e3		 mov	 esp, ebx
  00277	5b		 pop	 ebx
  00278	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : _CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 999  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1000 :     using _Ty = typename _Alloc::value_type;
; 1001 :     _Ptr->~_Ty();
; 1002 :     _Deallocate_plain(_Al, _Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0001a	83 c4 08	 add	 esp, 8

; 1003 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z PROC		; std::_Voidify_iter<int *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ENDP		; std::_Voidify_iter<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HABHX@std@@YAPAHQAHABH@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HABHX@std@@YAPAHQAHABH@Z PROC		; std::construct_at<int,int const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@HABHX@std@@YAPAHQAHABH@Z ENDP		; std::construct_at<int,int const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@HABHX@std@@YAPAHQAHABH@Z ; std::construct_at<int,int const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z PROC	; std::_Copy_memmove<int const *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ENDP	; std::_Copy_memmove<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@H@std@@YAPAHQAH@Z PROC			; std::to_address<int>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@H@std@@YAPAHQAH@Z ENDP			; std::to_address<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@$$CBH@std@@YAPBHQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@$$CBH@std@@YAPBHQBH@Z PROC		; std::to_address<int const >, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@$$CBH@std@@YAPBHQBH@Z ENDP		; std::to_address<int const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z PROC		; std::_Get_unwrapped<int const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ENDP		; std::_Get_unwrapped<int const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int const *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ; std::_Copy_memmove<int const *,int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int const *,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
tv67 = -20						; size = 4
tv65 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 66   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 67   :     // return smaller of _Left and _Right
; 68   :     return _Right < _Left ? _Right : _Left;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@min
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@min
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@min:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv70[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv76[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@min
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv73[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv76[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@min
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@min:
  00086	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	73 08		 jae	 SHORT $LN3@min
  00092	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00098	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009d	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  000a3	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000a6	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 69   : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBH@std@@YAHPBH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBH@std@@YAHPBH0@Z PROC			; std::distance<int const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 02	 sar	 eax, 2

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$distance@PBH@std@@YAHPBH0@Z ENDP			; std::distance<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z PROC ; std::_Voidify_iter<std::_Container_proxy *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ENDP ; std::_Voidify_iter<std::_Container_proxy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv78 = -16						; size = 4
tv74 = -12						; size = 4
tv82 = -8						; size = 4
tv85 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 08		 push	 8
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv85[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00052	74 1a		 je	 SHORT $LN3@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv82[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv85[ebp]
  00060	7c 0c		 jl	 SHORT $LN3@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN3@construct_:
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
  00076	8b 45 f0	 mov	 eax, DWORD PTR tv78[ebp]
  00079	50		 push	 eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0007d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 145  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Guard$3 = -136					; size = 4
tv172 = -92						; size = 1
tv162 = -91						; size = 1
tv152 = -90						; size = 1
tv142 = -89						; size = 1
tv94 = -88						; size = 4
_this$ = -84						; size = 4
tv169 = -80						; size = 4
tv159 = -76						; size = 4
tv149 = -72						; size = 4
tv139 = -68						; size = 4
__Count$ = -64						; size = 4
tv78 = -60						; size = 4
__My_data$4 = -56					; size = 4
tv75 = -52						; size = 4
tv92 = -48						; size = 4
tv77 = -44						; size = 4
tv135 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  00056	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
  00060	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  00069	8b 4d d0	 mov	 ecx, DWORD PTR tv92[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d a8	 mov	 DWORD PTR tv94[ebp], ecx
  00078	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  0007b	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00081	83 45 a8 04	 add	 DWORD PTR tv94[ebp], 4
  00085	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0008a	8b 4d a8	 mov	 ecx, DWORD PTR tv94[ebp]
  0008d	66 89 01	 mov	 WORD PTR [ecx], ax
  00090	83 45 a8 02	 add	 DWORD PTR tv94[ebp], 2
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  00097	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0009f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  000a4	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000a7	50		 push	 eax
  000a8	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$distance@PBH@std@@YAHPBH0@Z ; std::distance<int const *>
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 c0	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  000c0	83 7d c0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000c4	0f 84 69 01 00
	00		 je	 $LN1@Range_cons
  000ca	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 527  :             _Buy_nonzero(_Count);

  000da	8b 45 c0	 mov	 eax, DWORD PTR __Count$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  000e6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ec	89 4d b0	 mov	 DWORD PTR tv169[ebp], ecx
  000ef	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 a4	 mov	 BYTE PTR tv172[ebp], al
  000fe	80 7d a4 00	 cmp	 BYTE PTR tv172[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@Range_cons
  00104	8a 4d b0	 mov	 cl, BYTE PTR tv169[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d a4	 cmp	 cl, BYTE PTR tv172[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@Range_cons
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN8@Range_cons:
  0011e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Guard$3[ebp], eax
  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0012e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	89 4d c8	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00134	8b 55 c8	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00137	83 c2 04	 add	 edx, 4
  0013a	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00140	89 45 b4	 mov	 DWORD PTR tv159[ebp], eax
  00143	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	c1 e9 03	 shr	 ecx, 3
  00149	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0014f	88 55 a5	 mov	 BYTE PTR tv162[ebp], dl
  00152	80 7d a5 00	 cmp	 BYTE PTR tv162[ebp], 0
  00156	74 18		 je	 SHORT $LN7@Range_cons
  00158	8a 45 b4	 mov	 al, BYTE PTR tv159[ebp]
  0015b	24 07		 and	 al, 7
  0015d	04 03		 add	 al, 3
  0015f	3a 45 a5	 cmp	 al, BYTE PTR tv162[ebp]
  00162	7c 0c		 jl	 SHORT $LN7@Range_cons
  00164	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ___asan_report_load4
  0016d	83 c4 04	 add	 esp, 4
$LN7@Range_cons:
  00170	8b 55 c4	 mov	 edx, DWORD PTR tv78[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	50		 push	 eax
  00176	8b 4b 0c	 mov	 ecx, DWORD PTR __Last$[ebx]
  00179	51		 push	 ecx
  0017a	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  0017d	52		 push	 edx
  0017e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
  00186	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00189	8b 45 c8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	89 45 cc	 mov	 DWORD PTR tv75[ebp], eax
  00192	8b 4d cc	 mov	 ecx, DWORD PTR tv75[ebp]
  00195	89 4d b8	 mov	 DWORD PTR tv149[ebp], ecx
  00198	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  0019b	c1 ea 03	 shr	 edx, 3
  0019e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001a4	88 45 a6	 mov	 BYTE PTR tv152[ebp], al
  001a7	80 7d a6 00	 cmp	 BYTE PTR tv152[ebp], 0
  001ab	74 1a		 je	 SHORT $LN6@Range_cons
  001ad	8a 4d b8	 mov	 cl, BYTE PTR tv149[ebp]
  001b0	80 e1 07	 and	 cl, 7
  001b3	80 c1 03	 add	 cl, 3
  001b6	3a 4d a6	 cmp	 cl, BYTE PTR tv152[ebp]
  001b9	7c 0c		 jl	 SHORT $LN6@Range_cons
  001bb	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 ___asan_report_store4
  001c4	83 c4 04	 add	 esp, 4
$LN6@Range_cons:
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv75[ebp]
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  001cd	89 08		 mov	 DWORD PTR [eax], ecx

; 531  :             _Guard._Target   = nullptr;

  001cf	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  001d5	89 55 bc	 mov	 DWORD PTR tv139[ebp], edx
  001d8	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d a7	 mov	 BYTE PTR tv142[ebp], cl
  001e7	80 7d a7 00	 cmp	 BYTE PTR tv142[ebp], 0
  001eb	74 1a		 je	 SHORT $LN5@Range_cons
  001ed	8a 55 bc	 mov	 dl, BYTE PTR tv139[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 a7	 cmp	 dl, BYTE PTR tv142[ebp]
  001f9	7c 0c		 jl	 SHORT $LN5@Range_cons
  001fb	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN5@Range_cons:
  00207	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  00211	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00218	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0021e	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN1@Range_cons:

; 533  :     }

  00233	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0023d	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00243	c1 ea 03	 shr	 edx, 3
  00246	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0024c	89 55 d8	 mov	 DWORD PTR tv135[ebp], edx
  0024f	6a 07		 push	 7
  00251	8b 45 d8	 mov	 eax, DWORD PTR tv135[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025a	83 c4 08	 add	 esp, 8
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	59		 pop	 ecx
  00268	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	8b e3		 mov	 esp, ebx
  00277	5b		 pop	 ebx
  00278	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv79 = -16						; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
tv85 = -1						; size = 1
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1353 :     _CONSTEXPR20_CONTAINER ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1354 :         if (_Ptr) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv79[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv82[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv85[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv82[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv85[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 15		 je	 SHORT $LN3@Container_

; 1355 :             _Delete_plain_internal(_Al, _Ptr);

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	52		 push	 edx
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00068	83 c4 08	 add	 esp, 8
$LN3@Container_:

; 1356 :         }
; 1357 :     }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
$T2 = -112						; size = 4
tv199 = -69						; size = 1
tv189 = -68						; size = 1
tv179 = -67						; size = 1
tv169 = -66						; size = 1
tv159 = -65						; size = 1
_this$ = -64						; size = 4
tv146 = -60						; size = 4
tv196 = -56						; size = 4
tv186 = -52						; size = 4
tv176 = -48						; size = 4
tv166 = -44						; size = 4
tv156 = -40						; size = 4
tv69 = -36						; size = 4
tv92 = -32						; size = 4
tv144 = -28						; size = 4
tv134 = -24						; size = 4
tv75 = -20						; size = 4
tv83 = -16						; size = 4
tv139 = -12						; size = 4
tv152 = -8						; size = 4
tv131 = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1339 :     _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
  0002d	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00034	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e4	 mov	 DWORD PTR tv144[ebp], eax
  0003a	8b 4d e4	 mov	 ecx, DWORD PTR tv144[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d c4	 mov	 DWORD PTR tv146[ebp], ecx
  00049	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  0004c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00052	83 45 c4 04	 add	 DWORD PTR tv146[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d c4	 mov	 ecx, DWORD PTR tv146[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 c4 02	 add	 DWORD PTR tv146[ebp], 2
  00065	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00070	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00075	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0007d	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 c0 04	 add	 eax, 4
  00083	89 45 dc	 mov	 DWORD PTR tv69[ebp], eax
  00086	8b 4d dc	 mov	 ecx, DWORD PTR tv69[ebp]
  00089	89 4d c8	 mov	 DWORD PTR tv196[ebp], ecx
  0008c	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  0008f	c1 ea 03	 shr	 edx, 3
  00092	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00098	88 45 bb	 mov	 BYTE PTR tv199[ebp], al
  0009b	80 7d bb 00	 cmp	 BYTE PTR tv199[ebp], 0
  0009f	74 1a		 je	 SHORT $LN7@Container_
  000a1	8a 4d c8	 mov	 cl, BYTE PTR tv196[ebp]
  000a4	80 e1 07	 and	 cl, 7
  000a7	80 c1 03	 add	 cl, 3
  000aa	3a 4d bb	 cmp	 cl, BYTE PTR tv199[ebp]
  000ad	7c 0c		 jl	 SHORT $LN7@Container_
  000af	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ___asan_report_store4
  000b8	83 c4 04	 add	 esp, 4
$LN7@Container_:
  000bb	8b 45 dc	 mov	 eax, DWORD PTR tv69[ebp]
  000be	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c1	89 08		 mov	 DWORD PTR [eax], ecx

; 1340 :         // create a new _Container_proxy pointing at _Mycont
; 1341 :         _Ptr = _Unfancy(_Al_.allocate(1));

  000c3	6a 01		 push	 1
  000c5	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  000d3	83 c4 04	 add	 esp, 4
  000d6	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  000d9	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000dc	89 55 e8	 mov	 DWORD PTR tv134[ebp], edx
  000df	8b 45 e8	 mov	 eax, DWORD PTR tv134[ebp]
  000e2	89 45 cc	 mov	 DWORD PTR tv186[ebp], eax
  000e5	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  000e8	c1 e9 03	 shr	 ecx, 3
  000eb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f1	88 55 bc	 mov	 BYTE PTR tv189[ebp], dl
  000f4	80 7d bc 00	 cmp	 BYTE PTR tv189[ebp], 0
  000f8	74 18		 je	 SHORT $LN6@Container_
  000fa	8a 45 cc	 mov	 al, BYTE PTR tv186[ebp]
  000fd	24 07		 and	 al, 7
  000ff	04 03		 add	 al, 3
  00101	3a 45 bc	 cmp	 al, BYTE PTR tv189[ebp]
  00104	7c 0c		 jl	 SHORT $LN6@Container_
  00106	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 ___asan_report_store4
  0010f	83 c4 04	 add	 esp, 4
$LN6@Container_:
  00112	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00115	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00118	89 02		 mov	 DWORD PTR [edx], eax

; 1342 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  0011a	8b 4b 0c	 mov	 ecx, DWORD PTR __Mycont$[ebx]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00123	83 c4 04	 add	 esp, 4
  00126	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  00129	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  0012c	89 55 d0	 mov	 DWORD PTR tv176[ebp], edx
  0012f	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00132	c1 e8 03	 shr	 eax, 3
  00135	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0013b	88 4d bd	 mov	 BYTE PTR tv179[ebp], cl
  0013e	80 7d bd 00	 cmp	 BYTE PTR tv179[ebp], 0
  00142	74 1a		 je	 SHORT $LN5@Container_
  00144	8a 55 d0	 mov	 dl, BYTE PTR tv176[ebp]
  00147	80 e2 07	 and	 dl, 7
  0014a	80 c2 03	 add	 dl, 3
  0014d	3a 55 bd	 cmp	 dl, BYTE PTR tv179[ebp]
  00150	7c 0c		 jl	 SHORT $LN5@Container_
  00152	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ___asan_report_store4
  0015b	83 c4 04	 add	 esp, 4
$LN5@Container_:
  0015e	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00161	89 4d 90	 mov	 DWORD PTR $T2[ebp], ecx
  00164	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00167	52		 push	 edx
  00168	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00173	83 c4 08	 add	 esp, 8
  00176	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00179	c1 ea 03	 shr	 edx, 3
  0017c	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 1343 :         _Mycont._Myproxy = _Ptr;

  00183	8b 43 0c	 mov	 eax, DWORD PTR __Mycont$[ebx]
  00186	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  00189	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0018f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00192	89 55 d4	 mov	 DWORD PTR tv166[ebp], edx
  00195	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  00198	c1 e8 03	 shr	 eax, 3
  0019b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001a1	88 4d be	 mov	 BYTE PTR tv169[ebp], cl
  001a4	80 7d be 00	 cmp	 BYTE PTR tv169[ebp], 0
  001a8	74 1a		 je	 SHORT $LN4@Container_
  001aa	8a 55 d4	 mov	 dl, BYTE PTR tv166[ebp]
  001ad	80 e2 07	 and	 dl, 7
  001b0	80 c2 03	 add	 dl, 3
  001b3	3a 55 be	 cmp	 dl, BYTE PTR tv169[ebp]
  001b6	7c 0c		 jl	 SHORT $LN4@Container_
  001b8	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ___asan_report_load4
  001c1	83 c4 04	 add	 esp, 4
$LN4@Container_:
  001c4	8b 4d e0	 mov	 ecx, DWORD PTR tv92[ebp]
  001c7	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
  001ca	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001cd	c1 ea 03	 shr	 edx, 3
  001d0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001d6	88 45 bf	 mov	 BYTE PTR tv159[ebp], al
  001d9	80 7d bf 00	 cmp	 BYTE PTR tv159[ebp], 0
  001dd	74 1a		 je	 SHORT $LN3@Container_
  001df	8a 4d d8	 mov	 cl, BYTE PTR tv156[ebp]
  001e2	80 e1 07	 and	 cl, 7
  001e5	80 c1 03	 add	 cl, 3
  001e8	3a 4d bf	 cmp	 cl, BYTE PTR tv159[ebp]
  001eb	7c 0c		 jl	 SHORT $LN3@Container_
  001ed	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001f0	52		 push	 edx
  001f1	e8 00 00 00 00	 call	 ___asan_report_store4
  001f6	83 c4 04	 add	 esp, 4
$LN3@Container_:
  001f9	8b 45 e0	 mov	 eax, DWORD PTR tv92[ebp]
  001fc	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00201	89 10		 mov	 DWORD PTR [eax], edx

; 1344 :     }

  00203	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00206	89 45 fc	 mov	 DWORD PTR tv131[ebp], eax
  00209	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00210	8d 4d 80	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00213	c1 e9 03	 shr	 ecx, 3
  00216	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0021c	89 4d f8	 mov	 DWORD PTR tv152[ebp], ecx
  0021f	6a 07		 push	 7
  00221	8b 55 f8	 mov	 edx, DWORD PTR tv152[ebp]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022a	83 c4 08	 add	 esp, 8
  0022d	8b 45 fc	 mov	 eax, DWORD PTR tv131[ebp]
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	8b e3		 mov	 esp, ebx
  00235	5b		 pop	 ebx
  00236	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 03	 shl	 eax, 3
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@end
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@end
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@end:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 44   :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@begin
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@begin
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@begin:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@initialize
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@initialize
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@initialize:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@initialize
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@initialize
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@initialize:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 04	 sar	 edx, 4
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 04	 shl	 eax, 4
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S10$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S10$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S10$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
_$S8$ = -152						; size = 1
__Proxy$ = -136						; size = 8
$T3 = -120						; size = 1
$T4 = -76						; size = 1
$T5 = -75						; size = 1
$T6 = -74						; size = 1
$T7 = -73						; size = 1
tv153 = -72						; size = 4
_this$ = -68						; size = 4
tv151 = -64						; size = 4
tv70 = -60						; size = 4
__Alproxy$ = -56					; size = 4
tv135 = -52						; size = 4
tv133 = -48						; size = 4
tv162 = -44						; size = 4
tv150 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  00056	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  00060	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv151[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv151[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b8	 mov	 DWORD PTR tv153[ebp], ecx
  00078	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00085	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b8 02	 add	 DWORD PTR tv153[ebp], 2
  000a1	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	c1 e9 03	 shr	 ecx, 3
  000ad	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	89 55 c4	 mov	 DWORD PTR tv70[ebp], edx
  000c4	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  000c7	50		 push	 eax
  000c8	0f b6 4d b6	 movzx	 ecx, BYTE PTR $T6[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  000d0	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  000dd	50		 push	 eax
  000de	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$[ebp]
  000e4	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  000e9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _$S8$[ebp]
  000ef	89 55 c8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000f9	51		 push	 ecx
  000fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0010c	6a 01		 push	 1
  0010e	6a 00		 push	 0
  00110	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_memset
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	6a 01		 push	 1
  0011e	8d 45 b7	 lea	 eax, DWORD PTR $T7[ebp]
  00121	50		 push	 eax
  00122	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ___asan_memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	6a 01		 push	 1
  00130	8d 55 b4	 lea	 edx, DWORD PTR $T4[ebp]
  00133	52		 push	 edx
  00134	8d 45 b5	 lea	 eax, DWORD PTR $T5[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ___asan_memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  00143	e8 00 00 00 00	 call	 ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
  00148	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  0014b	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  0014e	e8 00 00 00 00	 call	 ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
  00153	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  00156	0f b6 4d b5	 movzx	 ecx, BYTE PTR $T5[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00162	50		 push	 eax
  00163	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
  0016b	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	c1 e9 03	 shr	 ecx, 3
  00171	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 551  :         _Proxy._Release();

  00178	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00190	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00195	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	89 55 d8	 mov	 DWORD PTR tv150[ebp], edx
  0019b	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  001ab	c1 e8 03	 shr	 eax, 3
  001ae	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001b3	89 45 d4	 mov	 DWORD PTR tv162[ebp], eax
  001b6	6a 0b		 push	 11			; 0000000bH
  001b8	8b 4d d4	 mov	 ecx, DWORD PTR tv162[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 45 d8	 mov	 eax, DWORD PTR tv150[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	8b e3		 mov	 esp, ebx
  001e1	5b		 pop	 ebx
  001e2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YAII@Z ; std::_Get_size_of_n<16>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 04	 shl	 eax, 4
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@RessourcePack@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@RessourcePack@@QAEXI@Z PROC		; RessourcePack::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@RessourcePack@@QAEXI@Z ENDP		; RessourcePack::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\RessourcePack.h
;	COMDAT ?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_fold$ = 8						; size = 28
?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; RessourcePack::setDefaultFolder, COMDAT
; _this$ = ecx

; 49   : 	inline void setDefaultFolder(std::string fold) { defaultFolder = fold; };

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00017	33 c5		 xor	 eax, ebp
  00019	50		 push	 eax
  0001a	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001d	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00023	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0002d	b9 00 00 00 00	 mov	 ecx, OFFSET __28BBFA9C_RessourcePack@h
  00032	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00037	8d 45 08	 lea	 eax, DWORD PTR _fold$[ebp]
  0003a	50		 push	 eax
  0003b	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0003e	83 c1 14	 add	 ecx, 20			; 00000014H
  00041	e8 00 00 00 00	 call	 ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00046	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0004d	8d 4d 08	 lea	 ecx, DWORD PTR _fold$[ebp]
  00050	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00055	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00058	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005f	59		 pop	 ecx
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c2 1c 00	 ret	 28			; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
  00000	8d 4d 08	 lea	 ecx, DWORD PTR _fold$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
  00025	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?setDefaultFolder@RessourcePack@@QAEXV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; RessourcePack::setDefaultFolder
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?end@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@end
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@end
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@end:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 44   :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?end@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?begin@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@begin
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@begin
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@begin:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?begin@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@H@std@@QAE@PBH0@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@H@std@@QAE@PBH0@Z PROC		; std::initializer_list<int>::initializer_list<int>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@initialize
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@initialize
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@initialize:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@initialize
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@initialize
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@initialize:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$initializer_list@H@std@@QAE@PBH0@Z ENDP		; std::initializer_list<int>::initializer_list<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 02	 shl	 eax, 2
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S13$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S13$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S13$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -240					; size = 4
__asan_gen_1$ = -236					; size = 4
__asan_gen_2$ = -232					; size = 4
$T3 = -224						; size = 1
_$S9$ = -208						; size = 1
__Proxy$ = -192						; size = 8
__Guard$4 = -176					; size = 4
tv242 = -136						; size = 1
tv232 = -135						; size = 1
tv222 = -134						; size = 1
tv212 = -133						; size = 1
tv202 = -132						; size = 1
tv192 = -131						; size = 1
$T5 = -130						; size = 1
$T6 = -129						; size = 1
tv167 = -128						; size = 4
_this$ = -124						; size = 4
tv239 = -120						; size = 4
tv229 = -116						; size = 4
tv219 = -112						; size = 4
tv209 = -108						; size = 4
__Rightlast$ = -104					; size = 4
__Rightfirst$ = -100					; size = 4
__My_data$ = -96					; size = 4
tv199 = -92						; size = 4
tv189 = -88						; size = 4
tv86 = -84						; size = 4
__Right_data$ = -80					; size = 4
tv87 = -76						; size = 4
tv138 = -72						; size = 4
tv135 = -68						; size = 4
tv165 = -64						; size = 4
tv76 = -60						; size = 4
tv78 = -56						; size = 4
__Alproxy$ = -52					; size = 4
tv137 = -48						; size = 4
tv185 = -44						; size = 4
tv152 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 555  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 10 ff ff
	ff		 add	 esp, -240		; ffffff10H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 10 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00056	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00060	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv165[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv165[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d 80	 mov	 DWORD PTR tv167[ebp], ecx
  00078	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00085	8b 45 80	 mov	 eax, DWORD PTR tv167[ebp]
  00088	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  0008e	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00092	8b 4d 80	 mov	 ecx, DWORD PTR tv167[ebp]
  00095	c7 01 f8 f3 f3
	f3		 mov	 DWORD PTR [ecx], -202116104 ; f3f3f3f8H
  0009b	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  0009f	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  000a2	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  000a5	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S9$[ebp]
  000ab	c1 e8 03	 shr	 eax, 3
  000ae	c6 80 00 00 00
	30 01		 mov	 BYTE PTR [eax+805306368], 1
  000b5	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000ca	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000cf	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	89 55 c8	 mov	 DWORD PTR tv78[ebp], edx
  000d5	8b 4b 08	 mov	 ecx, DWORD PTR __Right$[ebx]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
  000ea	83 c4 08	 add	 esp, 8
  000ed	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000f0	6a 01		 push	 1
  000f2	8d 8d 7f ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000f8	51		 push	 ecx
  000f9	8d 95 7e ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ___asan_memcpy
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  0010b	50		 push	 eax
  0010c	0f b6 8d 7e ff
	ff ff		 movzx	 ecx, BYTE PTR $T5[ebp]
  00113	51		 push	 ecx
  00114	8b 4d c8	 mov	 ecx, DWORD PTR tv78[ebp]
  00117	e8 00 00 00 00	 call	 ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
  0011c	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00122	c1 ea 03	 shr	 edx, 3
  00125	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 556  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0012c	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00134	50		 push	 eax
  00135	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _$S9$[ebp]
  0013b	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  00140	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S9$[ebp]
  00146	89 45 cc	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 557  :         auto& _My_data            = _Mypair._Myval2;

  00149	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	89 4d a0	 mov	 DWORD PTR __My_data$[ebp], ecx

; 558  :         const auto& _Right_data   = _Right._Mypair._Myval2;

  0014f	8b 53 08	 mov	 edx, DWORD PTR __Right$[ebx]
  00152	89 55 b0	 mov	 DWORD PTR __Right_data$[ebp], edx

; 559  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00155	8b 45 b0	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00158	83 c0 04	 add	 eax, 4
  0015b	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
  0015e	8b 4d ac	 mov	 ecx, DWORD PTR tv86[ebp]
  00161	89 4d 88	 mov	 DWORD PTR tv239[ebp], ecx
  00164	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00167	c1 ea 03	 shr	 edx, 3
  0016a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00170	88 85 78 ff ff
	ff		 mov	 BYTE PTR tv242[ebp], al
  00176	80 bd 78 ff ff
	ff 00		 cmp	 BYTE PTR tv242[ebp], 0
  0017d	74 1d		 je	 SHORT $LN11@vector
  0017f	8a 4d 88	 mov	 cl, BYTE PTR tv239[ebp]
  00182	80 e1 07	 and	 cl, 7
  00185	80 c1 03	 add	 cl, 3
  00188	3a 8d 78 ff ff
	ff		 cmp	 cl, BYTE PTR tv242[ebp]
  0018e	7c 0c		 jl	 SHORT $LN11@vector
  00190	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ___asan_report_load4
  00199	83 c4 04	 add	 esp, 4
$LN11@vector:
  0019c	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	89 4d 9c	 mov	 DWORD PTR __Rightfirst$[ebp], ecx

; 560  :         const pointer _Rightlast  = _Right_data._Mylast;

  001a4	8b 55 b0	 mov	 edx, DWORD PTR __Right_data$[ebp]
  001a7	83 c2 08	 add	 edx, 8
  001aa	89 55 b4	 mov	 DWORD PTR tv87[ebp], edx
  001ad	8b 45 b4	 mov	 eax, DWORD PTR tv87[ebp]
  001b0	89 45 8c	 mov	 DWORD PTR tv229[ebp], eax
  001b3	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001b6	c1 e9 03	 shr	 ecx, 3
  001b9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001bf	88 95 79 ff ff
	ff		 mov	 BYTE PTR tv232[ebp], dl
  001c5	80 bd 79 ff ff
	ff 00		 cmp	 BYTE PTR tv232[ebp], 0
  001cc	74 1b		 je	 SHORT $LN10@vector
  001ce	8a 45 8c	 mov	 al, BYTE PTR tv229[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 85 79 ff ff
	ff		 cmp	 al, BYTE PTR tv232[ebp]
  001db	7c 0c		 jl	 SHORT $LN10@vector
  001dd	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ___asan_report_load4
  001e6	83 c4 04	 add	 esp, 4
$LN10@vector:
  001e9	8b 55 b4	 mov	 edx, DWORD PTR tv87[ebp]
  001ec	8b 02		 mov	 eax, DWORD PTR [edx]
  001ee	89 45 98	 mov	 DWORD PTR __Rightlast$[ebp], eax

; 561  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  001f1	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  001f4	51		 push	 ecx
  001f5	8b 55 cc	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  001f8	52		 push	 edx
  001f9	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  001ff	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00204	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 562  :         if (_Rightfirst != _Rightlast) {

  0020b	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  0020e	3b 45 98	 cmp	 eax, DWORD PTR __Rightlast$[ebp]
  00211	0f 84 85 01 00
	00		 je	 $LN2@vector
  00217	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  0021d	c1 e9 03	 shr	 ecx, 3
  00220	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4

; 563  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00227	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  0022a	2b 55 9c	 sub	 edx, DWORD PTR __Rightfirst$[ebp]
  0022d	c1 fa 02	 sar	 edx, 2
  00230	52		 push	 edx
  00231	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 564  :             _Tidy_guard<vector> _Guard{this};

  00239	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0023f	89 45 90	 mov	 DWORD PTR tv219[ebp], eax
  00242	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  00245	c1 e9 03	 shr	 ecx, 3
  00248	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0024e	88 95 7a ff ff
	ff		 mov	 BYTE PTR tv222[ebp], dl
  00254	80 bd 7a ff ff
	ff 00		 cmp	 BYTE PTR tv222[ebp], 0
  0025b	74 1b		 je	 SHORT $LN9@vector
  0025d	8a 45 90	 mov	 al, BYTE PTR tv219[ebp]
  00260	24 07		 and	 al, 7
  00262	04 03		 add	 al, 3
  00264	3a 85 7a ff ff
	ff		 cmp	 al, BYTE PTR tv222[ebp]
  0026a	7c 0c		 jl	 SHORT $LN9@vector
  0026c	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ___asan_report_store4
  00275	83 c4 04	 add	 esp, 4
$LN9@vector:
  00278	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  0027b	89 95 50 ff ff
	ff		 mov	 DWORD PTR __Guard$4[ebp], edx
  00281	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 565  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00285	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00288	83 c0 04	 add	 eax, 4
  0028b	89 45 b8	 mov	 DWORD PTR tv138[ebp], eax
  0028e	8b 4d b8	 mov	 ecx, DWORD PTR tv138[ebp]
  00291	89 4d 94	 mov	 DWORD PTR tv209[ebp], ecx
  00294	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  00297	c1 ea 03	 shr	 edx, 3
  0029a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  002a0	88 85 7b ff ff
	ff		 mov	 BYTE PTR tv212[ebp], al
  002a6	80 bd 7b ff ff
	ff 00		 cmp	 BYTE PTR tv212[ebp], 0
  002ad	74 1d		 je	 SHORT $LN8@vector
  002af	8a 4d 94	 mov	 cl, BYTE PTR tv209[ebp]
  002b2	80 e1 07	 and	 cl, 7
  002b5	80 c1 03	 add	 cl, 3
  002b8	3a 8d 7b ff ff
	ff		 cmp	 cl, BYTE PTR tv212[ebp]
  002be	7c 0c		 jl	 SHORT $LN8@vector
  002c0	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 ___asan_report_load4
  002c9	83 c4 04	 add	 esp, 4
$LN8@vector:
  002cc	8b 45 b8	 mov	 eax, DWORD PTR tv138[ebp]
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	51		 push	 ecx
  002d2	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  002d5	52		 push	 edx
  002d6	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  002d9	50		 push	 eax
  002da	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  002dd	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  002e2	89 45 d0	 mov	 DWORD PTR tv137[ebp], eax
  002e5	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  002e8	83 c1 08	 add	 ecx, 8
  002eb	89 4d bc	 mov	 DWORD PTR tv135[ebp], ecx
  002ee	8b 55 bc	 mov	 edx, DWORD PTR tv135[ebp]
  002f1	89 55 a4	 mov	 DWORD PTR tv199[ebp], edx
  002f4	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  002f7	c1 e8 03	 shr	 eax, 3
  002fa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00300	88 8d 7c ff ff
	ff		 mov	 BYTE PTR tv202[ebp], cl
  00306	80 bd 7c ff ff
	ff 00		 cmp	 BYTE PTR tv202[ebp], 0
  0030d	74 1d		 je	 SHORT $LN7@vector
  0030f	8a 55 a4	 mov	 dl, BYTE PTR tv199[ebp]
  00312	80 e2 07	 and	 dl, 7
  00315	80 c2 03	 add	 dl, 3
  00318	3a 95 7c ff ff
	ff		 cmp	 dl, BYTE PTR tv202[ebp]
  0031e	7c 0c		 jl	 SHORT $LN7@vector
  00320	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 ___asan_report_store4
  00329	83 c4 04	 add	 esp, 4
$LN7@vector:
  0032c	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp]
  0032f	8b 55 d0	 mov	 edx, DWORD PTR tv137[ebp]
  00332	89 11		 mov	 DWORD PTR [ecx], edx

; 566  :             _Guard._Target   = nullptr;

  00334	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0033a	89 45 a8	 mov	 DWORD PTR tv189[ebp], eax
  0033d	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  00340	c1 e9 03	 shr	 ecx, 3
  00343	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00349	88 95 7d ff ff
	ff		 mov	 BYTE PTR tv192[ebp], dl
  0034f	80 bd 7d ff ff
	ff 00		 cmp	 BYTE PTR tv192[ebp], 0
  00356	74 1b		 je	 SHORT $LN6@vector
  00358	8a 45 a8	 mov	 al, BYTE PTR tv189[ebp]
  0035b	24 07		 and	 al, 7
  0035d	04 03		 add	 al, 3
  0035f	3a 85 7d ff ff
	ff		 cmp	 al, BYTE PTR tv192[ebp]
  00365	7c 0c		 jl	 SHORT $LN6@vector
  00367	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  0036a	51		 push	 ecx
  0036b	e8 00 00 00 00	 call	 ___asan_report_store4
  00370	83 c4 04	 add	 esp, 4
$LN6@vector:
  00373	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$4[ebp], 0

; 567  :         }

  0037d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00381	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00387	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  0038c	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$4[ebp]
  00392	c1 ea 03	 shr	 edx, 3
  00395	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN2@vector:

; 568  : 
; 569  :         _Proxy._Release();

  0039c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003a2	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 570  :     }

  003a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ae	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003b4	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  003b9	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  003bc	89 45 d8	 mov	 DWORD PTR tv152[ebp], eax
  003bf	c7 85 10 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  003c9	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  003cf	c1 e9 03	 shr	 ecx, 3
  003d2	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  003d8	89 4d d4	 mov	 DWORD PTR tv185[ebp], ecx
  003db	6a 0d		 push	 13			; 0000000dH
  003dd	8b 55 d4	 mov	 edx, DWORD PTR tv185[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003e6	83 c4 08	 add	 esp, 8
  003e9	8b 45 d8	 mov	 eax, DWORD PTR tv152[ebp]
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f6	59		 pop	 ecx
  003f7	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fa	33 cd		 xor	 ecx, ebp
  003fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00401	8b e5		 mov	 esp, ebp
  00403	5d		 pop	 ebp
  00404	8b e3		 mov	 esp, ebx
  00406	5b		 pop	 ebx
  00407	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1:
  0000b	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
_$S7$ = -152						; size = 1
__Proxy$ = -136						; size = 8
$T3 = -120						; size = 1
$T4 = -76						; size = 1
$T5 = -75						; size = 1
$T6 = -74						; size = 1
$T7 = -73						; size = 1
tv153 = -72						; size = 4
_this$ = -68						; size = 4
tv151 = -64						; size = 4
tv70 = -60						; size = 4
__Alproxy$ = -56					; size = 4
tv135 = -52						; size = 4
tv133 = -48						; size = 4
tv162 = -44						; size = 4
tv150 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  00056	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00060	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv151[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv151[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b8	 mov	 DWORD PTR tv153[ebp], ecx
  00078	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00085	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b8 02	 add	 DWORD PTR tv153[ebp], 2
  000a1	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	c1 e9 03	 shr	 ecx, 3
  000ad	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	89 55 c4	 mov	 DWORD PTR tv70[ebp], edx
  000c4	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  000c7	50		 push	 eax
  000c8	0f b6 4d b6	 movzx	 ecx, BYTE PTR $T6[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  000d0	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _$S7$[ebp]
  000e4	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  000e9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _$S7$[ebp]
  000ef	89 55 c8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000f9	51		 push	 ecx
  000fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0010c	6a 01		 push	 1
  0010e	6a 00		 push	 0
  00110	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_memset
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	6a 01		 push	 1
  0011e	8d 45 b7	 lea	 eax, DWORD PTR $T7[ebp]
  00121	50		 push	 eax
  00122	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ___asan_memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	6a 01		 push	 1
  00130	8d 55 b4	 lea	 edx, DWORD PTR $T4[ebp]
  00133	52		 push	 edx
  00134	8d 45 b5	 lea	 eax, DWORD PTR $T5[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ___asan_memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  00143	e8 00 00 00 00	 call	 ?end@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::end
  00148	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  0014b	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  0014e	e8 00 00 00 00	 call	 ?begin@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::begin
  00153	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  00156	0f b6 4d b5	 movzx	 ecx, BYTE PTR $T5[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00162	50		 push	 eax
  00163	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
  0016b	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	c1 e9 03	 shr	 ecx, 3
  00171	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 551  :         _Proxy._Release();

  00178	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00190	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00195	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	89 55 d8	 mov	 DWORD PTR tv150[ebp], edx
  0019b	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  001ab	c1 e8 03	 shr	 eax, 3
  001ae	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001b3	89 45 d4	 mov	 DWORD PTR tv162[ebp], eax
  001b6	6a 0b		 push	 11			; 0000000bH
  001b8	8b 4d d4	 mov	 ecx, DWORD PTR tv162[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 45 d8	 mov	 eax, DWORD PTR tv150[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	8b e3		 mov	 esp, ebx
  001e1	5b		 pop	 ebx
  001e2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction, COMDAT

; 731  :     _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :         return _Al;

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 733  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$max@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
tv67 = -20						; size = 4
tv65 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$max@I@std@@YAABIABI0@Z PROC				; std::max<unsigned int>, COMDAT

; 42   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :     // return larger of _Left and _Right
; 44   :     return _Left < _Right ? _Right : _Left;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@max
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@max
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@max:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv70[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv76[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@max
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv73[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv76[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@max
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@max:
  00086	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00089	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	73 08		 jae	 SHORT $LN3@max
  00092	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00098	eb 06		 jmp	 SHORT $LN4@max
$LN3@max:
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009d	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@max:
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  000a3	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000a6	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 45   : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$max@I@std@@YAABIABI0@Z ENDP				; std::max<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Window\ContextSettings.hpp
;	COMDAT ??0ContextSettings@sf@@QAE@IIIIII_N@Z
_TEXT	SEGMENT
tv70 = -68						; size = 4
tv69 = -64						; size = 4
tv68 = -60						; size = 4
tv67 = -56						; size = 4
tv66 = -52						; size = 4
tv65 = -48						; size = 4
tv64 = -44						; size = 4
tv86 = -40						; size = 4
tv128 = -36						; size = 4
tv138 = -32						; size = 4
tv148 = -28						; size = 4
tv158 = -24						; size = 4
tv168 = -20						; size = 4
tv178 = -16						; size = 4
_this$ = -12						; size = 4
tv89 = -7						; size = 1
tv131 = -6						; size = 1
tv141 = -5						; size = 1
tv151 = -4						; size = 1
tv161 = -3						; size = 1
tv171 = -2						; size = 1
tv181 = -1						; size = 1
_depth$ = 8						; size = 4
_stencil$ = 12						; size = 4
_antialiasing$ = 16					; size = 4
_major$ = 20						; size = 4
_minor$ = 24						; size = 4
_attributes$ = 28					; size = 4
_sRgb$ = 32						; size = 1
??0ContextSettings@sf@@QAE@IIIIII_N@Z PROC		; sf::ContextSettings::ContextSettings, COMDAT
; _this$ = ecx

; 70   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __3C1C7D88_ContextSettings@hpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 63   :     depthBits        (depth),

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f0	 mov	 DWORD PTR tv178[ebp], ecx
  0001f	8b 55 f0	 mov	 edx, DWORD PTR tv178[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv181[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv181[ebp], 0
  00032	74 1a		 je	 SHORT $LN9@ContextSet
  00034	8a 4d f0	 mov	 cl, BYTE PTR tv178[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv181[ebp]
  00040	7c 0c		 jl	 SHORT $LN9@ContextSet
  00042	8b 55 f0	 mov	 edx, DWORD PTR tv178[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN9@ContextSet:
  0004e	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _depth$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 64   :     stencilBits      (stencil),

  00056	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 d0	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 d0	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 ec	 mov	 DWORD PTR tv168[ebp], eax
  00065	8b 4d ec	 mov	 ecx, DWORD PTR tv168[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv171[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv171[ebp], 0
  00078	74 18		 je	 SHORT $LN8@ContextSet
  0007a	8a 45 ec	 mov	 al, BYTE PTR tv168[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv171[ebp]
  00084	7c 0c		 jl	 SHORT $LN8@ContextSet
  00086	8b 4d ec	 mov	 ecx, DWORD PTR tv168[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN8@ContextSet:
  00092	8b 55 d0	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR _stencil$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax

; 65   :     antialiasingLevel(antialiasing),

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d cc	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 cc	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 e8	 mov	 DWORD PTR tv158[ebp], edx
  000a9	8b 45 e8	 mov	 eax, DWORD PTR tv158[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv161[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv161[ebp], 0
  000bc	74 1a		 je	 SHORT $LN7@ContextSet
  000be	8a 55 e8	 mov	 dl, BYTE PTR tv158[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv161[ebp]
  000ca	7c 0c		 jl	 SHORT $LN7@ContextSet
  000cc	8b 45 e8	 mov	 eax, DWORD PTR tv158[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN7@ContextSet:
  000d8	8b 4d cc	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 10	 mov	 edx, DWORD PTR _antialiasing$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx

; 66   :     majorVersion     (major),

  000e0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e6	89 45 c8	 mov	 DWORD PTR tv67[ebp], eax
  000e9	8b 4d c8	 mov	 ecx, DWORD PTR tv67[ebp]
  000ec	89 4d e4	 mov	 DWORD PTR tv148[ebp], ecx
  000ef	8b 55 e4	 mov	 edx, DWORD PTR tv148[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 fc	 mov	 BYTE PTR tv151[ebp], al
  000fe	80 7d fc 00	 cmp	 BYTE PTR tv151[ebp], 0
  00102	74 1a		 je	 SHORT $LN6@ContextSet
  00104	8a 4d e4	 mov	 cl, BYTE PTR tv148[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d fc	 cmp	 cl, BYTE PTR tv151[ebp]
  00110	7c 0c		 jl	 SHORT $LN6@ContextSet
  00112	8b 55 e4	 mov	 edx, DWORD PTR tv148[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN6@ContextSet:
  0011e	8b 45 c8	 mov	 eax, DWORD PTR tv67[ebp]
  00121	8b 4d 14	 mov	 ecx, DWORD PTR _major$[ebp]
  00124	89 08		 mov	 DWORD PTR [eax], ecx

; 67   :     minorVersion     (minor),

  00126	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00129	83 c2 10	 add	 edx, 16			; 00000010H
  0012c	89 55 c4	 mov	 DWORD PTR tv68[ebp], edx
  0012f	8b 45 c4	 mov	 eax, DWORD PTR tv68[ebp]
  00132	89 45 e0	 mov	 DWORD PTR tv138[ebp], eax
  00135	8b 4d e0	 mov	 ecx, DWORD PTR tv138[ebp]
  00138	c1 e9 03	 shr	 ecx, 3
  0013b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00141	88 55 fb	 mov	 BYTE PTR tv141[ebp], dl
  00144	80 7d fb 00	 cmp	 BYTE PTR tv141[ebp], 0
  00148	74 18		 je	 SHORT $LN5@ContextSet
  0014a	8a 45 e0	 mov	 al, BYTE PTR tv138[ebp]
  0014d	24 07		 and	 al, 7
  0014f	04 03		 add	 al, 3
  00151	3a 45 fb	 cmp	 al, BYTE PTR tv141[ebp]
  00154	7c 0c		 jl	 SHORT $LN5@ContextSet
  00156	8b 4d e0	 mov	 ecx, DWORD PTR tv138[ebp]
  00159	51		 push	 ecx
  0015a	e8 00 00 00 00	 call	 ___asan_report_store4
  0015f	83 c4 04	 add	 esp, 4
$LN5@ContextSet:
  00162	8b 55 c4	 mov	 edx, DWORD PTR tv68[ebp]
  00165	8b 45 18	 mov	 eax, DWORD PTR _minor$[ebp]
  00168	89 02		 mov	 DWORD PTR [edx], eax

; 68   :     attributeFlags   (attributes),

  0016a	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0016d	83 c1 14	 add	 ecx, 20			; 00000014H
  00170	89 4d c0	 mov	 DWORD PTR tv69[ebp], ecx
  00173	8b 55 c0	 mov	 edx, DWORD PTR tv69[ebp]
  00176	89 55 dc	 mov	 DWORD PTR tv128[ebp], edx
  00179	8b 45 dc	 mov	 eax, DWORD PTR tv128[ebp]
  0017c	c1 e8 03	 shr	 eax, 3
  0017f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00185	88 4d fa	 mov	 BYTE PTR tv131[ebp], cl
  00188	80 7d fa 00	 cmp	 BYTE PTR tv131[ebp], 0
  0018c	74 1a		 je	 SHORT $LN4@ContextSet
  0018e	8a 55 dc	 mov	 dl, BYTE PTR tv128[ebp]
  00191	80 e2 07	 and	 dl, 7
  00194	80 c2 03	 add	 dl, 3
  00197	3a 55 fa	 cmp	 dl, BYTE PTR tv131[ebp]
  0019a	7c 0c		 jl	 SHORT $LN4@ContextSet
  0019c	8b 45 dc	 mov	 eax, DWORD PTR tv128[ebp]
  0019f	50		 push	 eax
  001a0	e8 00 00 00 00	 call	 ___asan_report_store4
  001a5	83 c4 04	 add	 esp, 4
$LN4@ContextSet:
  001a8	8b 4d c0	 mov	 ecx, DWORD PTR tv69[ebp]
  001ab	8b 55 1c	 mov	 edx, DWORD PTR _attributes$[ebp]
  001ae	89 11		 mov	 DWORD PTR [ecx], edx

; 69   :     sRgbCapable      (sRgb)

  001b0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001b3	83 c0 18	 add	 eax, 24			; 00000018H
  001b6	89 45 bc	 mov	 DWORD PTR tv70[ebp], eax
  001b9	8b 4d bc	 mov	 ecx, DWORD PTR tv70[ebp]
  001bc	89 4d d8	 mov	 DWORD PTR tv86[ebp], ecx
  001bf	8b 55 d8	 mov	 edx, DWORD PTR tv86[ebp]
  001c2	c1 ea 03	 shr	 edx, 3
  001c5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001cb	88 45 f9	 mov	 BYTE PTR tv89[ebp], al
  001ce	80 7d f9 00	 cmp	 BYTE PTR tv89[ebp], 0
  001d2	74 17		 je	 SHORT $LN3@ContextSet
  001d4	8a 4d d8	 mov	 cl, BYTE PTR tv86[ebp]
  001d7	80 e1 07	 and	 cl, 7
  001da	3a 4d f9	 cmp	 cl, BYTE PTR tv89[ebp]
  001dd	7c 0c		 jl	 SHORT $LN3@ContextSet
  001df	8b 55 d8	 mov	 edx, DWORD PTR tv86[ebp]
  001e2	52		 push	 edx
  001e3	e8 00 00 00 00	 call	 ___asan_report_store1
  001e8	83 c4 04	 add	 esp, 4
$LN3@ContextSet:
  001eb	8b 45 bc	 mov	 eax, DWORD PTR tv70[ebp]
  001ee	8a 4d 20	 mov	 cl, BYTE PTR _sRgb$[ebp]
  001f1	88 08		 mov	 BYTE PTR [eax], cl

; 71   :     }

  001f3	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001f6	8b e5		 mov	 esp, ebp
  001f8	5d		 pop	 ebp
  001f9	c2 1c 00	 ret	 28			; 0000001cH
??0ContextSettings@sf@@QAE@IIIIII_N@Z ENDP		; sf::ContextSettings::ContextSettings
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv85 = -32						; size = 4
tv82 = -28						; size = 4
__Ptrdest$ = -24					; size = 4
tv88 = -20						; size = 4
tv130 = -16						; size = 4
__Ptrnext$1 = -12					; size = 4
__Count$ = -8						; size = 4
tv91 = -2						; size = 1
tv133 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00022	68 0e 02 00 00	 push	 526			; 0000020eH
  00027	68 00 00 00 00	 push	 OFFSET $SG254796
  0002c	6a 02		 push	 2
  0002e	6a 01		 push	 1
  00030	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	89 45 e8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 527  : 
; 528  :     if (!_Ptrdest) {

  00040	83 7d e8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00044	75 05		 jne	 SHORT $LN5@Maklocstr

; 529  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0004b	8b 55 e8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  00051	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00053	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	83 e8 01	 sub	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f4	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00068	83 c2 01	 add	 edx, 1
  0006b	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0006e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00072	76 7f		 jbe	 SHORT $LN3@Maklocstr

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00074	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00077	89 45 e4	 mov	 DWORD PTR tv82[ebp], eax
  0007a	8b 4d e4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv130[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 ff	 mov	 BYTE PTR tv133[ebp], al
  0008f	80 7d ff 00	 cmp	 BYTE PTR tv133[ebp], 0
  00093	74 17		 je	 SHORT $LN8@Maklocstr
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv130[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	3a 4d ff	 cmp	 cl, BYTE PTR tv133[ebp]
  0009e	7c 0c		 jl	 SHORT $LN8@Maklocstr
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load1
  000a9	83 c4 04	 add	 esp, 4
$LN8@Maklocstr:
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000af	89 45 e0	 mov	 DWORD PTR tv85[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR tv85[ebp]
  000b5	89 4d ec	 mov	 DWORD PTR tv88[ebp], ecx
  000b8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000bb	c1 ea 03	 shr	 edx, 3
  000be	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c4	88 45 fe	 mov	 BYTE PTR tv91[ebp], al
  000c7	80 7d fe 00	 cmp	 BYTE PTR tv91[ebp], 0
  000cb	74 17		 je	 SHORT $LN7@Maklocstr
  000cd	8a 4d ec	 mov	 cl, BYTE PTR tv88[ebp]
  000d0	80 e1 07	 and	 cl, 7
  000d3	3a 4d fe	 cmp	 cl, BYTE PTR tv91[ebp]
  000d6	7c 0c		 jl	 SHORT $LN7@Maklocstr
  000d8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ___asan_report_store1
  000e1	83 c4 04	 add	 esp, 4
$LN7@Maklocstr:
  000e4	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ea	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ec	88 10		 mov	 BYTE PTR [eax], dl

; 534  :     }

  000ee	e9 60 ff ff ff	 jmp	 $LN2@Maklocstr
$LN3@Maklocstr:

; 535  : 
; 536  :     return _Ptrdest;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 537  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__Ptrdest$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __4CB88277_xlocnum
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0001a	83 c4 04	 add	 esp, 4
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00023	6a 5d		 push	 93			; 0000005dH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0002a	6a 02		 push	 2
  0002c	6a 02		 push	 2
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 94   : 
; 95   :     if (!_Ptrdest) {

  0003e	83 7d fc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00042	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  00044	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00049	8b 55 f8	 mov	 edx, DWORD PTR __Count$[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _wmemcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :     return _Ptrdest;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 101  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Mbst1$ = -136						; size = 8
__Wc$ = -120						; size = 2
__Mbst2$ = -104						; size = 8
tv156 = -57						; size = 1
tv146 = -56						; size = 4
__Wchars$ = -52						; size = 4
__Bytes$ = -48						; size = 4
__Count$ = -44						; size = 4
__Ptrnext$ = -40					; size = 4
__Ptr1$ = -36						; size = 4
tv153 = -32						; size = 4
__Ptrdest$ = -28					; size = 4
__Count1$ = -24						; size = 4
tv144 = -20						; size = 4
tv141 = -16						; size = 4
tv149 = -12						; size = 4
tv140 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 540  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
  0003a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00044	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR tv144[ebp], eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c8	 mov	 DWORD PTR tv146[ebp], ecx
  0005c	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0005f	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00065	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00069	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  0006c	c7 00 02 f2 00
	f3		 mov	 DWORD PTR [eax], -218041854 ; f300f202H
  00072	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00076	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  0007b	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0007e	66 89 0a	 mov	 WORD PTR [edx], cx
  00081	83 45 c8 02	 add	 DWORD PTR tv146[ebp], 2
  00085	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  00088	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 541  :     // convert C string to wchar_t sequence using _Cvtvec
; 542  :     size_t _Count;
; 543  :     size_t _Count1;
; 544  :     size_t _Wchars;
; 545  :     const char* _Ptr1;
; 546  :     int _Bytes;
; 547  :     wchar_t _Wc;
; 548  :     mbstate_t _Mbst1 = {};

  00095	6a 08		 push	 8
  00097	6a 00		 push	 0
  00099	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ___asan_memset
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 549  : 
; 550  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  000a8	8b 53 08	 mov	 edx, DWORD PTR __Ptr$[ebx]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _strlen
  000b1	83 c4 04	 add	 esp, 4
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 e8	 mov	 DWORD PTR __Count1$[ebp], eax

; 551  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  000ba	8b 45 e8	 mov	 eax, DWORD PTR __Count1$[ebp]
  000bd	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  000c0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  000c7	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000ca	89 4d dc	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  000cd	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  000cf	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  000d2	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  000d5	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  000d8	8b 45 dc	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  000db	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  000de	89 45 dc	 mov	 DWORD PTR __Ptr1$[ebp], eax
  000e1	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
$LN4@Maklocstr:
  000ea	83 7d d4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000ee	76 2c		 jbe	 SHORT $LN3@Maklocstr

; 552  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  000f0	8b 53 10	 mov	 edx, DWORD PTR __Cvt$[ebx]
  000f3	52		 push	 edx
  000f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __Mbst1$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 dc	 mov	 edx, DWORD PTR __Ptr1$[ebp]
  00102	52		 push	 edx
  00103	8d 45 88	 lea	 eax, DWORD PTR __Wc$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __Mbrtowc
  0010c	83 c4 14	 add	 esp, 20			; 00000014H
  0010f	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00112	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00116	7f 02		 jg	 SHORT $LN8@Maklocstr

; 553  :             break;

  00118	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 554  :         }
; 555  :     }

  0011a	eb b3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 556  : 
; 557  :     ++_Wchars; // count terminating nul

  0011c	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx

; 558  : 
; 559  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00125	68 2f 02 00 00	 push	 559			; 0000022fH
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0012f	6a 02		 push	 2
  00131	6a 02		 push	 2
  00133	8b 55 cc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  00136	52		 push	 edx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0013d	83 c4 14	 add	 esp, 20			; 00000014H
  00140	89 45 e4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 560  : 
; 561  :     if (!_Ptrdest) {

  00143	83 7d e4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00147	75 05		 jne	 SHORT $LN9@Maklocstr

; 562  :         _Xbad_alloc();

  00149	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 563  :     }
; 564  : 
; 565  :     wchar_t* _Ptrnext = _Ptrdest;

  0014e	8b 45 e4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00151	89 45 d8	 mov	 DWORD PTR __Ptrnext$[ebp], eax

; 566  :     mbstate_t _Mbst2  = {};

  00154	6a 08		 push	 8
  00156	6a 00		 push	 0
  00158	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ___asan_memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 
; 568  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00164	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  00166	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  00169	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  0016c	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  0016f	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00172	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00175	89 43 08	 mov	 DWORD PTR __Ptr$[ebx], eax
  00178	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0017b	83 e9 01	 sub	 ecx, 1
  0017e	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
  00181	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  00184	83 c2 02	 add	 edx, 2
  00187	89 55 d8	 mov	 DWORD PTR __Ptrnext$[ebp], edx
$LN7@Maklocstr:
  0018a	83 7d cc 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0018e	76 29		 jbe	 SHORT $LN6@Maklocstr

; 569  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00190	8b 43 10	 mov	 eax, DWORD PTR __Cvt$[ebx]
  00193	50		 push	 eax
  00194	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 e8	 mov	 edx, DWORD PTR __Count1$[ebp]
  0019b	52		 push	 edx
  0019c	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  0019f	50		 push	 eax
  001a0	8b 4d d8	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 __Mbrtowc
  001a9	83 c4 14	 add	 esp, 20			; 00000014H
  001ac	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  001af	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  001b3	7f 02		 jg	 SHORT $LN10@Maklocstr

; 570  :             break;

  001b5	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 571  :         }
; 572  :     }

  001b7	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 573  : 
; 574  :     *_Ptrnext = L'\0';

  001b9	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  001bc	89 55 f0	 mov	 DWORD PTR tv141[ebp], edx
  001bf	8b 45 f0	 mov	 eax, DWORD PTR tv141[ebp]
  001c2	89 45 e0	 mov	 DWORD PTR tv153[ebp], eax
  001c5	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001c8	c1 e9 03	 shr	 ecx, 3
  001cb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001d1	88 55 c7	 mov	 BYTE PTR tv156[ebp], dl
  001d4	80 7d c7 00	 cmp	 BYTE PTR tv156[ebp], 0
  001d8	74 18		 je	 SHORT $LN12@Maklocstr
  001da	8a 45 e0	 mov	 al, BYTE PTR tv153[ebp]
  001dd	24 07		 and	 al, 7
  001df	04 01		 add	 al, 1
  001e1	3a 45 c7	 cmp	 al, BYTE PTR tv156[ebp]
  001e4	7c 0c		 jl	 SHORT $LN12@Maklocstr
  001e6	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 ___asan_report_store2
  001ef	83 c4 04	 add	 esp, 4
$LN12@Maklocstr:
  001f2	33 d2		 xor	 edx, edx
  001f4	8b 45 d8	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  001f7	66 89 10	 mov	 WORD PTR [eax], dx

; 575  : 
; 576  :     return _Ptrdest;

  001fa	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  001fd	89 4d f8	 mov	 DWORD PTR tv140[ebp], ecx
  00200	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0020a	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00210	c1 ea 03	 shr	 edx, 3
  00213	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00219	89 55 f4	 mov	 DWORD PTR tv149[ebp], edx
  0021c	6a 0b		 push	 11			; 0000000bH
  0021e	8b 45 f4	 mov	 eax, DWORD PTR tv149[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00227	83 c4 08	 add	 esp, 8
  0022a	8b 45 f8	 mov	 eax, DWORD PTR tv140[ebp]
$LN11@Maklocstr:

; 577  : }

  0022d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00230	33 cd		 xor	 ecx, ebp
  00232	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	8b e3		 mov	 esp, ebx
  0023c	5b		 pop	 ebx
  0023d	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??1locale@std@@QAE@XZ
_TEXT	SEGMENT
tv86 = -76						; size = 4
tv85 = -72						; size = 4
tv128 = -68						; size = 4
tv74 = -64						; size = 4
tv80 = -60						; size = 4
tv71 = -56						; size = 4
tv73 = -52						; size = 4
tv69 = -48						; size = 4
tv64 = -44						; size = 4
tv133 = -40						; size = 4
tv143 = -36						; size = 4
tv153 = -32						; size = 4
tv163 = -28						; size = 4
_this$ = -24						; size = 4
tv173 = -20						; size = 4
tv183 = -16						; size = 4
$T1 = -12						; size = 4
tv136 = -6						; size = 1
tv146 = -5						; size = 1
tv156 = -4						; size = 1
tv166 = -3						; size = 1
tv176 = -2						; size = 1
tv186 = -1						; size = 1
??1locale@std@@QAE@XZ PROC				; std::locale::~locale, COMDAT
; _this$ = ecx

; 350  :     ~locale() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 351  :         if (_Ptr) {

  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f0	 mov	 DWORD PTR tv183[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR tv183[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv186[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv186[ebp], 0
  00035	74 1a		 je	 SHORT $LN11@locale
  00037	8a 4d f0	 mov	 cl, BYTE PTR tv183[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv186[ebp]
  00043	7c 0c		 jl	 SHORT $LN11@locale
  00045	8b 55 f0	 mov	 edx, DWORD PTR tv183[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN11@locale:
  00051	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	0f 84 6d 01 00
	00		 je	 $LN3@locale

; 352  :             delete _Ptr->_Decref();

  0005d	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00060	83 c1 04	 add	 ecx, 4
  00063	89 4d d0	 mov	 DWORD PTR tv69[ebp], ecx
  00066	8b 55 d0	 mov	 edx, DWORD PTR tv69[ebp]
  00069	89 55 ec	 mov	 DWORD PTR tv173[ebp], edx
  0006c	8b 45 ec	 mov	 eax, DWORD PTR tv173[ebp]
  0006f	c1 e8 03	 shr	 eax, 3
  00072	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00078	88 4d fe	 mov	 BYTE PTR tv176[ebp], cl
  0007b	80 7d fe 00	 cmp	 BYTE PTR tv176[ebp], 0
  0007f	74 1a		 je	 SHORT $LN10@locale
  00081	8a 55 ec	 mov	 dl, BYTE PTR tv173[ebp]
  00084	80 e2 07	 and	 dl, 7
  00087	80 c2 03	 add	 dl, 3
  0008a	3a 55 fe	 cmp	 dl, BYTE PTR tv176[ebp]
  0008d	7c 0c		 jl	 SHORT $LN10@locale
  0008f	8b 45 ec	 mov	 eax, DWORD PTR tv173[ebp]
  00092	50		 push	 eax
  00093	e8 00 00 00 00	 call	 ___asan_report_load4
  00098	83 c4 04	 add	 esp, 4
$LN10@locale:
  0009b	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  0009e	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a0	89 55 c8	 mov	 DWORD PTR tv71[ebp], edx
  000a3	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000a6	83 c0 04	 add	 eax, 4
  000a9	89 45 cc	 mov	 DWORD PTR tv73[ebp], eax
  000ac	8b 4d cc	 mov	 ecx, DWORD PTR tv73[ebp]
  000af	89 4d e4	 mov	 DWORD PTR tv163[ebp], ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR tv163[ebp]
  000b5	c1 ea 03	 shr	 edx, 3
  000b8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000be	88 45 fd	 mov	 BYTE PTR tv166[ebp], al
  000c1	80 7d fd 00	 cmp	 BYTE PTR tv166[ebp], 0
  000c5	74 1a		 je	 SHORT $LN9@locale
  000c7	8a 4d e4	 mov	 cl, BYTE PTR tv163[ebp]
  000ca	80 e1 07	 and	 cl, 7
  000cd	80 c1 03	 add	 cl, 3
  000d0	3a 4d fd	 cmp	 cl, BYTE PTR tv166[ebp]
  000d3	7c 0c		 jl	 SHORT $LN9@locale
  000d5	8b 55 e4	 mov	 edx, DWORD PTR tv163[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ___asan_report_load4
  000de	83 c4 04	 add	 esp, 4
$LN9@locale:
  000e1	8b 45 cc	 mov	 eax, DWORD PTR tv73[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	89 4d c0	 mov	 DWORD PTR tv74[ebp], ecx
  000e9	8b 55 c8	 mov	 edx, DWORD PTR tv71[ebp]
  000ec	89 55 e0	 mov	 DWORD PTR tv153[ebp], edx
  000ef	8b 45 e0	 mov	 eax, DWORD PTR tv153[ebp]
  000f2	c1 e8 03	 shr	 eax, 3
  000f5	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000fb	88 4d fc	 mov	 BYTE PTR tv156[ebp], cl
  000fe	80 7d fc 00	 cmp	 BYTE PTR tv156[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@locale
  00104	8a 55 e0	 mov	 dl, BYTE PTR tv153[ebp]
  00107	80 e2 07	 and	 dl, 7
  0010a	80 c2 03	 add	 dl, 3
  0010d	3a 55 fc	 cmp	 dl, BYTE PTR tv156[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@locale
  00112	8b 45 e0	 mov	 eax, DWORD PTR tv153[ebp]
  00115	50		 push	 eax
  00116	e8 00 00 00 00	 call	 ___asan_report_load4
  0011b	83 c4 04	 add	 esp, 4
$LN8@locale:
  0011e	8b 4d c8	 mov	 ecx, DWORD PTR tv71[ebp]
  00121	8b 11		 mov	 edx, DWORD PTR [ecx]
  00123	8b 4d c0	 mov	 ecx, DWORD PTR tv74[ebp]
  00126	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00129	ff d0		 call	 eax
  0012b	89 45 f4	 mov	 DWORD PTR $T1[ebp], eax
  0012e	83 7d f4 00	 cmp	 DWORD PTR $T1[ebp], 0
  00132	0f 84 8b 00 00
	00		 je	 $LN4@locale
  00138	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  0013b	89 4d bc	 mov	 DWORD PTR tv128[ebp], ecx
  0013e	8b 55 bc	 mov	 edx, DWORD PTR tv128[ebp]
  00141	89 55 dc	 mov	 DWORD PTR tv143[ebp], edx
  00144	8b 45 dc	 mov	 eax, DWORD PTR tv143[ebp]
  00147	c1 e8 03	 shr	 eax, 3
  0014a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00150	88 4d fb	 mov	 BYTE PTR tv146[ebp], cl
  00153	80 7d fb 00	 cmp	 BYTE PTR tv146[ebp], 0
  00157	74 1a		 je	 SHORT $LN7@locale
  00159	8a 55 dc	 mov	 dl, BYTE PTR tv143[ebp]
  0015c	80 e2 07	 and	 dl, 7
  0015f	80 c2 03	 add	 dl, 3
  00162	3a 55 fb	 cmp	 dl, BYTE PTR tv146[ebp]
  00165	7c 0c		 jl	 SHORT $LN7@locale
  00167	8b 45 dc	 mov	 eax, DWORD PTR tv143[ebp]
  0016a	50		 push	 eax
  0016b	e8 00 00 00 00	 call	 ___asan_report_load4
  00170	83 c4 04	 add	 esp, 4
$LN7@locale:
  00173	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  00176	8b 11		 mov	 edx, DWORD PTR [ecx]
  00178	89 55 c4	 mov	 DWORD PTR tv80[ebp], edx
  0017b	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0017e	89 45 d8	 mov	 DWORD PTR tv133[ebp], eax
  00181	8b 4d d8	 mov	 ecx, DWORD PTR tv133[ebp]
  00184	c1 e9 03	 shr	 ecx, 3
  00187	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0018d	88 55 fa	 mov	 BYTE PTR tv136[ebp], dl
  00190	80 7d fa 00	 cmp	 BYTE PTR tv136[ebp], 0
  00194	74 18		 je	 SHORT $LN6@locale
  00196	8a 45 d8	 mov	 al, BYTE PTR tv133[ebp]
  00199	24 07		 and	 al, 7
  0019b	04 03		 add	 al, 3
  0019d	3a 45 fa	 cmp	 al, BYTE PTR tv136[ebp]
  001a0	7c 0c		 jl	 SHORT $LN6@locale
  001a2	8b 4d d8	 mov	 ecx, DWORD PTR tv133[ebp]
  001a5	51		 push	 ecx
  001a6	e8 00 00 00 00	 call	 ___asan_report_load4
  001ab	83 c4 04	 add	 esp, 4
$LN6@locale:
  001ae	8b 55 c4	 mov	 edx, DWORD PTR tv80[ebp]
  001b1	8b 02		 mov	 eax, DWORD PTR [edx]
  001b3	89 45 b8	 mov	 DWORD PTR tv85[ebp], eax
  001b6	6a 01		 push	 1
  001b8	8b 4d f4	 mov	 ecx, DWORD PTR $T1[ebp]
  001bb	ff 55 b8	 call	 DWORD PTR tv85[ebp]
  001be	89 45 b4	 mov	 DWORD PTR tv86[ebp], eax
  001c1	eb 07		 jmp	 SHORT $LN3@locale
$LN4@locale:
  001c3	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR tv86[ebp], 0
$LN3@locale:

; 353  :         }
; 354  :     }

  001ca	8b e5		 mov	 esp, ebp
  001cc	5d		 pop	 ebp
  001cd	c3		 ret	 0
??1locale@std@@QAE@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??0locale@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -32						; size = 4
_this$ = -28						; size = 4
tv68 = -24						; size = 4
tv77 = -20						; size = 4
tv80 = -13						; size = 1
__$EHRec$ = -12						; size = 12
??0locale@std@@QAE@XZ PROC				; std::locale::locale, COMDAT
; _this$ = ecx

; 271  :     locale() noexcept : _Ptr(_Init(true)) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0locale@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 14	 sub	 esp, 20			; 00000014H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00032	6a 01		 push	 1
  00034	e8 00 00 00 00	 call	 ?_Init@locale@std@@CAPAV_Locimp@12@_N@Z ; std::locale::_Init
  00039	83 c4 04	 add	 esp, 4
  0003c	89 45 e0	 mov	 DWORD PTR tv72[ebp], eax
  0003f	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00042	83 c0 04	 add	 eax, 4
  00045	89 45 e8	 mov	 DWORD PTR tv68[ebp], eax
  00048	8b 4d e8	 mov	 ecx, DWORD PTR tv68[ebp]
  0004b	89 4d ec	 mov	 DWORD PTR tv77[ebp], ecx
  0004e	8b 55 ec	 mov	 edx, DWORD PTR tv77[ebp]
  00051	c1 ea 03	 shr	 edx, 3
  00054	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0005a	88 45 f3	 mov	 BYTE PTR tv80[ebp], al
  0005d	80 7d f3 00	 cmp	 BYTE PTR tv80[ebp], 0
  00061	74 1a		 je	 SHORT $LN3@locale
  00063	8a 4d ec	 mov	 cl, BYTE PTR tv77[ebp]
  00066	80 e1 07	 and	 cl, 7
  00069	80 c1 03	 add	 cl, 3
  0006c	3a 4d f3	 cmp	 cl, BYTE PTR tv80[ebp]
  0006f	7c 0c		 jl	 SHORT $LN3@locale
  00071	8b 55 ec	 mov	 edx, DWORD PTR tv77[ebp]
  00074	52		 push	 edx
  00075	e8 00 00 00 00	 call	 ___asan_report_store4
  0007a	83 c4 04	 add	 esp, 4
$LN3@locale:
  0007d	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  00080	8b 4d e0	 mov	 ecx, DWORD PTR tv72[ebp]
  00083	89 08		 mov	 DWORD PTR [eax], ecx
  00085	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00088	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0008b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00092	59		 pop	 ecx
  00093	8b e5		 mov	 esp, ebp
  00095	5d		 pop	 ebp
  00096	c3		 ret	 0
  00097	cc		 int	 3
  00098	cc		 int	 3
  00099	cc		 int	 3
  0009a	cc		 int	 3
  0009b	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0locale@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0locale@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0locale@std@@QAE@XZ ENDP				; std::locale::locale
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4654 :     _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4655 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4656 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 4650 :     _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4651 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 4652 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -184					; size = 4
__asan_gen_1$ = -180					; size = 4
__asan_gen_2$ = -176					; size = 4
$T3 = -168						; size = 1
tv259 = -124						; size = 1
tv249 = -123						; size = 1
tv239 = -122						; size = 1
tv229 = -121						; size = 1
tv219 = -120						; size = 1
tv209 = -119						; size = 1
tv199 = -118						; size = 1
tv189 = -117						; size = 1
_this$ = -116						; size = 4
tv173 = -112						; size = 4
tv256 = -108						; size = 4
tv246 = -104						; size = 4
tv236 = -100						; size = 4
tv226 = -96						; size = 4
tv216 = -92						; size = 4
tv206 = -88						; size = 4
tv196 = -84						; size = 4
tv186 = -80						; size = 4
tv80 = -76						; size = 4
tv91 = -72						; size = 4
tv133 = -68						; size = 4
tv136 = -64						; size = 4
tv139 = -60						; size = 4
tv142 = -56						; size = 4
tv145 = -52						; size = 4
tv171 = -48						; size = 4
__Ptr$4 = -44						; size = 4
__Al$5 = -40						; size = 4
tv182 = -36						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 4616 :     _CONSTEXPR20_CONTAINER void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d 8c	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 85 48 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00053	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
  0005d	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00063	89 45 d0	 mov	 DWORD PTR tv171[ebp], eax
  00066	8b 4d d0	 mov	 ecx, DWORD PTR tv171[ebp]
  00069	c1 e9 03	 shr	 ecx, 3
  0006c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00072	89 4d 90	 mov	 DWORD PTR tv173[ebp], ecx
  00075	8b 55 90	 mov	 edx, DWORD PTR tv173[ebp]
  00078	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  0007e	83 45 90 04	 add	 DWORD PTR tv173[ebp], 4
  00082	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00087	8b 4d 90	 mov	 ecx, DWORD PTR tv173[ebp]
  0008a	66 89 01	 mov	 WORD PTR [ecx], ax
  0008d	83 45 90 02	 add	 DWORD PTR tv173[ebp], 2
  00091	8b 55 90	 mov	 edx, DWORD PTR tv173[ebp]
  00094	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0009c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4617 :         _Mypair._Myval2._Orphan_all();

  000a1	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000a4	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 4618 :         if (_Mypair._Myval2._Large_string_engaged()) {

  000a9	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  000b1	0f b6 c0	 movzx	 eax, al
  000b4	85 c0		 test	 eax, eax
  000b6	0f 84 b3 00 00
	00		 je	 $LN2@Tidy_deall

; 4619 :             const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;

  000bc	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	83 c1 04	 add	 ecx, 4
  000c2	89 4d b4	 mov	 DWORD PTR tv80[ebp], ecx
  000c5	8b 55 b4	 mov	 edx, DWORD PTR tv80[ebp]
  000c8	89 55 94	 mov	 DWORD PTR tv256[ebp], edx
  000cb	8b 45 94	 mov	 eax, DWORD PTR tv256[ebp]
  000ce	c1 e8 03	 shr	 eax, 3
  000d1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000d7	88 4d 84	 mov	 BYTE PTR tv259[ebp], cl
  000da	80 7d 84 00	 cmp	 BYTE PTR tv259[ebp], 0
  000de	74 1a		 je	 SHORT $LN13@Tidy_deall
  000e0	8a 55 94	 mov	 dl, BYTE PTR tv256[ebp]
  000e3	80 e2 07	 and	 dl, 7
  000e6	80 c2 03	 add	 dl, 3
  000e9	3a 55 84	 cmp	 dl, BYTE PTR tv259[ebp]
  000ec	7c 0c		 jl	 SHORT $LN13@Tidy_deall
  000ee	8b 45 94	 mov	 eax, DWORD PTR tv256[ebp]
  000f1	50		 push	 eax
  000f2	e8 00 00 00 00	 call	 ___asan_report_load4
  000f7	83 c4 04	 add	 esp, 4
$LN13@Tidy_deall:
  000fa	8b 4d b4	 mov	 ecx, DWORD PTR tv80[ebp]
  000fd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ff	89 55 d4	 mov	 DWORD PTR __Ptr$4[ebp], edx

; 4620 :             auto& _Al          = _Getal();

  00102	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00105	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0010a	89 45 d8	 mov	 DWORD PTR __Al$5[ebp], eax

; 4621 :             _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);

  0010d	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  00110	83 c0 04	 add	 eax, 4
  00113	50		 push	 eax
  00114	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00119	83 c4 04	 add	 esp, 4

; 4622 :             _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);

  0011c	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0011f	83 c1 18	 add	 ecx, 24			; 00000018H
  00122	89 4d b8	 mov	 DWORD PTR tv91[ebp], ecx
  00125	8b 55 b8	 mov	 edx, DWORD PTR tv91[ebp]
  00128	89 55 98	 mov	 DWORD PTR tv246[ebp], edx
  0012b	8b 45 98	 mov	 eax, DWORD PTR tv246[ebp]
  0012e	c1 e8 03	 shr	 eax, 3
  00131	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00137	88 4d 85	 mov	 BYTE PTR tv249[ebp], cl
  0013a	80 7d 85 00	 cmp	 BYTE PTR tv249[ebp], 0
  0013e	74 1a		 je	 SHORT $LN12@Tidy_deall
  00140	8a 55 98	 mov	 dl, BYTE PTR tv246[ebp]
  00143	80 e2 07	 and	 dl, 7
  00146	80 c2 03	 add	 dl, 3
  00149	3a 55 85	 cmp	 dl, BYTE PTR tv249[ebp]
  0014c	7c 0c		 jl	 SHORT $LN12@Tidy_deall
  0014e	8b 45 98	 mov	 eax, DWORD PTR tv246[ebp]
  00151	50		 push	 eax
  00152	e8 00 00 00 00	 call	 ___asan_report_load4
  00157	83 c4 04	 add	 esp, 4
$LN12@Tidy_deall:
  0015a	8b 4d b8	 mov	 ecx, DWORD PTR tv91[ebp]
  0015d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0015f	83 c2 01	 add	 edx, 1
  00162	52		 push	 edx
  00163	8b 45 d4	 mov	 eax, DWORD PTR __Ptr$4[ebp]
  00166	50		 push	 eax
  00167	8b 4d d8	 mov	 ecx, DWORD PTR __Al$5[ebp]
  0016a	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 4623 :         }
; 4624 : 
; 4625 : #ifdef __cpp_lib_constexpr_string
; 4626 :         if (_STD is_constant_evaluated()) {

  0016f	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00174	0f b6 c8	 movzx	 ecx, al
  00177	85 c9		 test	 ecx, ecx
  00179	0f 84 d8 00 00
	00		 je	 $LN3@Tidy_deall

; 4627 :             _Mypair._Myval2._Bx._Ptr = nullptr;

  0017f	8b 55 8c	 mov	 edx, DWORD PTR _this$[ebp]
  00182	83 c2 04	 add	 edx, 4
  00185	89 55 bc	 mov	 DWORD PTR tv133[ebp], edx
  00188	8b 45 bc	 mov	 eax, DWORD PTR tv133[ebp]
  0018b	89 45 9c	 mov	 DWORD PTR tv236[ebp], eax
  0018e	8b 4d 9c	 mov	 ecx, DWORD PTR tv236[ebp]
  00191	c1 e9 03	 shr	 ecx, 3
  00194	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0019a	88 55 86	 mov	 BYTE PTR tv239[ebp], dl
  0019d	80 7d 86 00	 cmp	 BYTE PTR tv239[ebp], 0
  001a1	74 18		 je	 SHORT $LN11@Tidy_deall
  001a3	8a 45 9c	 mov	 al, BYTE PTR tv236[ebp]
  001a6	24 07		 and	 al, 7
  001a8	04 03		 add	 al, 3
  001aa	3a 45 86	 cmp	 al, BYTE PTR tv239[ebp]
  001ad	7c 0c		 jl	 SHORT $LN11@Tidy_deall
  001af	8b 4d 9c	 mov	 ecx, DWORD PTR tv236[ebp]
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 ___asan_report_store4
  001b8	83 c4 04	 add	 esp, 4
$LN11@Tidy_deall:
  001bb	8b 55 bc	 mov	 edx, DWORD PTR tv133[ebp]
  001be	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 4628 :             _Mypair._Myval2._Mysize  = 0;

  001c4	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  001c7	83 c0 14	 add	 eax, 20			; 00000014H
  001ca	89 45 c0	 mov	 DWORD PTR tv136[ebp], eax
  001cd	8b 4d c0	 mov	 ecx, DWORD PTR tv136[ebp]
  001d0	89 4d a0	 mov	 DWORD PTR tv226[ebp], ecx
  001d3	8b 55 a0	 mov	 edx, DWORD PTR tv226[ebp]
  001d6	c1 ea 03	 shr	 edx, 3
  001d9	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001df	88 45 87	 mov	 BYTE PTR tv229[ebp], al
  001e2	80 7d 87 00	 cmp	 BYTE PTR tv229[ebp], 0
  001e6	74 1a		 je	 SHORT $LN10@Tidy_deall
  001e8	8a 4d a0	 mov	 cl, BYTE PTR tv226[ebp]
  001eb	80 e1 07	 and	 cl, 7
  001ee	80 c1 03	 add	 cl, 3
  001f1	3a 4d 87	 cmp	 cl, BYTE PTR tv229[ebp]
  001f4	7c 0c		 jl	 SHORT $LN10@Tidy_deall
  001f6	8b 55 a0	 mov	 edx, DWORD PTR tv226[ebp]
  001f9	52		 push	 edx
  001fa	e8 00 00 00 00	 call	 ___asan_report_store4
  001ff	83 c4 04	 add	 esp, 4
$LN10@Tidy_deall:
  00202	8b 45 c0	 mov	 eax, DWORD PTR tv136[ebp]
  00205	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 4629 :             _Mypair._Myval2._Myres   = 0;

  0020b	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  0020e	83 c1 18	 add	 ecx, 24			; 00000018H
  00211	89 4d c4	 mov	 DWORD PTR tv139[ebp], ecx
  00214	8b 55 c4	 mov	 edx, DWORD PTR tv139[ebp]
  00217	89 55 a4	 mov	 DWORD PTR tv216[ebp], edx
  0021a	8b 45 a4	 mov	 eax, DWORD PTR tv216[ebp]
  0021d	c1 e8 03	 shr	 eax, 3
  00220	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00226	88 4d 88	 mov	 BYTE PTR tv219[ebp], cl
  00229	80 7d 88 00	 cmp	 BYTE PTR tv219[ebp], 0
  0022d	74 1a		 je	 SHORT $LN9@Tidy_deall
  0022f	8a 55 a4	 mov	 dl, BYTE PTR tv216[ebp]
  00232	80 e2 07	 and	 dl, 7
  00235	80 c2 03	 add	 dl, 3
  00238	3a 55 88	 cmp	 dl, BYTE PTR tv219[ebp]
  0023b	7c 0c		 jl	 SHORT $LN9@Tidy_deall
  0023d	8b 45 a4	 mov	 eax, DWORD PTR tv216[ebp]
  00240	50		 push	 eax
  00241	e8 00 00 00 00	 call	 ___asan_report_store4
  00246	83 c4 04	 add	 esp, 4
$LN9@Tidy_deall:
  00249	8b 4d c4	 mov	 ecx, DWORD PTR tv139[ebp]
  0024c	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 4630 :         } else

  00252	e9 09 01 00 00	 jmp	 $LN5@Tidy_deall
$LN3@Tidy_deall:
  00257	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0025d	c1 ea 03	 shr	 edx, 3
  00260	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 4631 : #endif // __cpp_lib_constexpr_string
; 4632 :         {
; 4633 :             _Mypair._Myval2._Mysize = 0;

  00267	8b 45 8c	 mov	 eax, DWORD PTR _this$[ebp]
  0026a	83 c0 14	 add	 eax, 20			; 00000014H
  0026d	89 45 c8	 mov	 DWORD PTR tv142[ebp], eax
  00270	8b 4d c8	 mov	 ecx, DWORD PTR tv142[ebp]
  00273	89 4d a8	 mov	 DWORD PTR tv206[ebp], ecx
  00276	8b 55 a8	 mov	 edx, DWORD PTR tv206[ebp]
  00279	c1 ea 03	 shr	 edx, 3
  0027c	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00282	88 45 89	 mov	 BYTE PTR tv209[ebp], al
  00285	80 7d 89 00	 cmp	 BYTE PTR tv209[ebp], 0
  00289	74 1a		 je	 SHORT $LN8@Tidy_deall
  0028b	8a 4d a8	 mov	 cl, BYTE PTR tv206[ebp]
  0028e	80 e1 07	 and	 cl, 7
  00291	80 c1 03	 add	 cl, 3
  00294	3a 4d 89	 cmp	 cl, BYTE PTR tv209[ebp]
  00297	7c 0c		 jl	 SHORT $LN8@Tidy_deall
  00299	8b 55 a8	 mov	 edx, DWORD PTR tv206[ebp]
  0029c	52		 push	 edx
  0029d	e8 00 00 00 00	 call	 ___asan_report_store4
  002a2	83 c4 04	 add	 esp, 4
$LN8@Tidy_deall:
  002a5	8b 45 c8	 mov	 eax, DWORD PTR tv142[ebp]
  002a8	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 4634 :             _Mypair._Myval2._Myres  = _BUF_SIZE - 1;

  002ae	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  002b1	83 c1 18	 add	 ecx, 24			; 00000018H
  002b4	89 4d cc	 mov	 DWORD PTR tv145[ebp], ecx
  002b7	8b 55 cc	 mov	 edx, DWORD PTR tv145[ebp]
  002ba	89 55 ac	 mov	 DWORD PTR tv196[ebp], edx
  002bd	8b 45 ac	 mov	 eax, DWORD PTR tv196[ebp]
  002c0	c1 e8 03	 shr	 eax, 3
  002c3	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002c9	88 4d 8a	 mov	 BYTE PTR tv199[ebp], cl
  002cc	80 7d 8a 00	 cmp	 BYTE PTR tv199[ebp], 0
  002d0	74 1a		 je	 SHORT $LN7@Tidy_deall
  002d2	8a 55 ac	 mov	 dl, BYTE PTR tv196[ebp]
  002d5	80 e2 07	 and	 dl, 7
  002d8	80 c2 03	 add	 dl, 3
  002db	3a 55 8a	 cmp	 dl, BYTE PTR tv199[ebp]
  002de	7c 0c		 jl	 SHORT $LN7@Tidy_deall
  002e0	8b 45 ac	 mov	 eax, DWORD PTR tv196[ebp]
  002e3	50		 push	 eax
  002e4	e8 00 00 00 00	 call	 ___asan_report_store4
  002e9	83 c4 04	 add	 esp, 4
$LN7@Tidy_deall:
  002ec	8b 4d cc	 mov	 ecx, DWORD PTR tv145[ebp]
  002ef	c7 01 0f 00 00
	00		 mov	 DWORD PTR [ecx], 15	; 0000000fH

; 4635 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4636 :             _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());

  002f5	8d 95 58 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  002fb	89 55 b0	 mov	 DWORD PTR tv186[ebp], edx
  002fe	8b 45 b0	 mov	 eax, DWORD PTR tv186[ebp]
  00301	c1 e8 03	 shr	 eax, 3
  00304	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0030a	88 4d 8b	 mov	 BYTE PTR tv189[ebp], cl
  0030d	80 7d 8b 00	 cmp	 BYTE PTR tv189[ebp], 0
  00311	74 17		 je	 SHORT $LN6@Tidy_deall
  00313	8a 55 b0	 mov	 dl, BYTE PTR tv186[ebp]
  00316	80 e2 07	 and	 dl, 7
  00319	3a 55 8b	 cmp	 dl, BYTE PTR tv189[ebp]
  0031c	7c 0c		 jl	 SHORT $LN6@Tidy_deall
  0031e	8b 45 b0	 mov	 eax, DWORD PTR tv186[ebp]
  00321	50		 push	 eax
  00322	e8 00 00 00 00	 call	 ___asan_report_store1
  00327	83 c4 04	 add	 esp, 4
$LN6@Tidy_deall:
  0032a	c6 85 58 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  00331	8d 8d 58 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00337	51		 push	 ecx
  00338	ba 01 00 00 00	 mov	 edx, 1
  0033d	6b c2 00	 imul	 eax, edx, 0
  00340	8b 4d 8c	 mov	 ecx, DWORD PTR _this$[ebp]
  00343	8d 54 01 04	 lea	 edx, DWORD PTR [ecx+eax+4]
  00347	52		 push	 edx
  00348	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  0034d	83 c4 08	 add	 esp, 8
  00350	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00356	c1 e8 03	 shr	 eax, 3
  00359	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
$LN5@Tidy_deall:

; 4637 :         }
; 4638 :     }

  00360	c7 85 48 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0036a	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00370	c1 e9 03	 shr	 ecx, 3
  00373	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00379	89 4d dc	 mov	 DWORD PTR tv182[ebp], ecx
  0037c	6a 07		 push	 7
  0037e	8b 55 dc	 mov	 edx, DWORD PTR tv182[ebp]
  00381	52		 push	 edx
  00382	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00387	83 c4 08	 add	 esp, 8
  0038a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0038d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00394	59		 pop	 ecx
  00395	8b e5		 mov	 esp, ebp
  00397	5d		 pop	 ebp
  00398	8b e3		 mov	 esp, ebx
  0039a	5b		 pop	 ebx
  0039b	c3		 ret	 0
  0039c	cc		 int	 3
  0039d	cc		 int	 3
  0039e	cc		 int	 3
  0039f	cc		 int	 3
  003a0	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
$T3 = -152						; size = 1
tv194 = -105						; size = 1
tv184 = -104						; size = 1
tv174 = -103						; size = 1
tv164 = -102						; size = 1
tv154 = -101						; size = 1
tv138 = -100						; size = 4
__My_data$ = -96					; size = 4
tv191 = -92						; size = 4
tv181 = -88						; size = 4
tv171 = -84						; size = 4
tv161 = -80						; size = 4
tv151 = -76						; size = 4
tv66 = -72						; size = 4
tv70 = -68						; size = 4
_this$ = -64						; size = 4
tv80 = -60						; size = 4
__New_ptr$4 = -56					; size = 4
tv83 = -52						; size = 4
tv136 = -48						; size = 4
__Al$5 = -44						; size = 4
__Raw_new$6 = -40					; size = 4
tv147 = -36						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT
; _this$ = ecx

; 4594 :     _CONSTEXPR20_CONTAINER void _Tidy_init() noexcept { // initialize basic_string data members

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  00053	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
  0005d	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00063	89 45 d0	 mov	 DWORD PTR tv136[ebp], eax
  00066	8b 4d d0	 mov	 ecx, DWORD PTR tv136[ebp]
  00069	c1 e9 03	 shr	 ecx, 3
  0006c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00072	89 4d 9c	 mov	 DWORD PTR tv138[ebp], ecx
  00075	8b 55 9c	 mov	 edx, DWORD PTR tv138[ebp]
  00078	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  0007e	83 45 9c 04	 add	 DWORD PTR tv138[ebp], 4
  00082	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00087	8b 4d 9c	 mov	 ecx, DWORD PTR tv138[ebp]
  0008a	66 89 01	 mov	 WORD PTR [ecx], ax
  0008d	83 45 9c 02	 add	 DWORD PTR tv138[ebp], 2
  00091	8b 55 9c	 mov	 edx, DWORD PTR tv138[ebp]
  00094	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00097	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0009c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4595 :         auto& _My_data   = _Mypair._Myval2;

  000a1	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  000a4	89 45 a0	 mov	 DWORD PTR __My_data$[ebp], eax

; 4596 :         _My_data._Mysize = 0;

  000a7	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000aa	83 c1 14	 add	 ecx, 20			; 00000014H
  000ad	89 4d b8	 mov	 DWORD PTR tv66[ebp], ecx
  000b0	8b 55 b8	 mov	 edx, DWORD PTR tv66[ebp]
  000b3	89 55 a4	 mov	 DWORD PTR tv191[ebp], edx
  000b6	8b 45 a4	 mov	 eax, DWORD PTR tv191[ebp]
  000b9	c1 e8 03	 shr	 eax, 3
  000bc	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000c2	88 4d 97	 mov	 BYTE PTR tv194[ebp], cl
  000c5	80 7d 97 00	 cmp	 BYTE PTR tv194[ebp], 0
  000c9	74 1a		 je	 SHORT $LN9@Tidy_init
  000cb	8a 55 a4	 mov	 dl, BYTE PTR tv191[ebp]
  000ce	80 e2 07	 and	 dl, 7
  000d1	80 c2 03	 add	 dl, 3
  000d4	3a 55 97	 cmp	 dl, BYTE PTR tv194[ebp]
  000d7	7c 0c		 jl	 SHORT $LN9@Tidy_init
  000d9	8b 45 a4	 mov	 eax, DWORD PTR tv191[ebp]
  000dc	50		 push	 eax
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN9@Tidy_init:
  000e5	8b 4d b8	 mov	 ecx, DWORD PTR tv66[ebp]
  000e8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 4597 : 
; 4598 : #ifdef __cpp_lib_constexpr_string
; 4599 :         if (_STD is_constant_evaluated()) {

  000ee	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000f3	0f b6 d0	 movzx	 edx, al
  000f6	85 d2		 test	 edx, edx
  000f8	0f 84 c9 00 00
	00		 je	 $LN2@Tidy_init

; 4600 :             _My_data._Myres        = _BUF_SIZE; // SSO disabled in constexpr context

  000fe	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00101	83 c0 18	 add	 eax, 24			; 00000018H
  00104	89 45 bc	 mov	 DWORD PTR tv70[ebp], eax
  00107	8b 4d bc	 mov	 ecx, DWORD PTR tv70[ebp]
  0010a	89 4d a8	 mov	 DWORD PTR tv181[ebp], ecx
  0010d	8b 55 a8	 mov	 edx, DWORD PTR tv181[ebp]
  00110	c1 ea 03	 shr	 edx, 3
  00113	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00119	88 45 98	 mov	 BYTE PTR tv184[ebp], al
  0011c	80 7d 98 00	 cmp	 BYTE PTR tv184[ebp], 0
  00120	74 1a		 je	 SHORT $LN8@Tidy_init
  00122	8a 4d a8	 mov	 cl, BYTE PTR tv181[ebp]
  00125	80 e1 07	 and	 cl, 7
  00128	80 c1 03	 add	 cl, 3
  0012b	3a 4d 98	 cmp	 cl, BYTE PTR tv184[ebp]
  0012e	7c 0c		 jl	 SHORT $LN8@Tidy_init
  00130	8b 55 a8	 mov	 edx, DWORD PTR tv181[ebp]
  00133	52		 push	 edx
  00134	e8 00 00 00 00	 call	 ___asan_report_store4
  00139	83 c4 04	 add	 esp, 4
$LN8@Tidy_init:
  0013c	8b 45 bc	 mov	 eax, DWORD PTR tv70[ebp]
  0013f	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H

; 4601 :             auto& _Al              = _Getal();

  00145	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00148	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0014d	89 45 d4	 mov	 DWORD PTR __Al$5[ebp], eax

; 4602 :             const pointer _New_ptr = _Al.allocate(_BUF_SIZE + 1); // throws

  00150	6a 11		 push	 17			; 00000011H
  00152	8b 4d d4	 mov	 ecx, DWORD PTR __Al$5[ebp]
  00155	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QAEPADI@Z ; std::allocator<char>::allocate
  0015a	89 45 c8	 mov	 DWORD PTR __New_ptr$4[ebp], eax

; 4603 :             _My_data._Bx._Ptr      = _New_ptr;

  0015d	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00160	83 c1 04	 add	 ecx, 4
  00163	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  00166	8b 55 c4	 mov	 edx, DWORD PTR tv80[ebp]
  00169	89 55 ac	 mov	 DWORD PTR tv171[ebp], edx
  0016c	8b 45 ac	 mov	 eax, DWORD PTR tv171[ebp]
  0016f	c1 e8 03	 shr	 eax, 3
  00172	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00178	88 4d 99	 mov	 BYTE PTR tv174[ebp], cl
  0017b	80 7d 99 00	 cmp	 BYTE PTR tv174[ebp], 0
  0017f	74 1a		 je	 SHORT $LN7@Tidy_init
  00181	8a 55 ac	 mov	 dl, BYTE PTR tv171[ebp]
  00184	80 e2 07	 and	 dl, 7
  00187	80 c2 03	 add	 dl, 3
  0018a	3a 55 99	 cmp	 dl, BYTE PTR tv174[ebp]
  0018d	7c 0c		 jl	 SHORT $LN7@Tidy_init
  0018f	8b 45 ac	 mov	 eax, DWORD PTR tv171[ebp]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ___asan_report_store4
  00198	83 c4 04	 add	 esp, 4
$LN7@Tidy_init:
  0019b	8b 4d c4	 mov	 ecx, DWORD PTR tv80[ebp]
  0019e	8b 55 c8	 mov	 edx, DWORD PTR __New_ptr$4[ebp]
  001a1	89 11		 mov	 DWORD PTR [ecx], edx

; 4604 : 
; 4605 :             _Elem* const _Raw_new = _Unfancy(_New_ptr);

  001a3	8b 45 c8	 mov	 eax, DWORD PTR __New_ptr$4[ebp]
  001a6	50		 push	 eax
  001a7	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  001ac	83 c4 04	 add	 esp, 4
  001af	89 45 d8	 mov	 DWORD PTR __Raw_new$6[ebp], eax

; 4606 :             _Traits::assign(_Raw_new, _BUF_SIZE + 1, _Elem());

  001b2	6a 00		 push	 0
  001b4	6a 11		 push	 17			; 00000011H
  001b6	8b 4d d8	 mov	 ecx, DWORD PTR __Raw_new$6[ebp]
  001b9	51		 push	 ecx
  001ba	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ; std::_Narrow_char_traits<char,int>::assign
  001bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4607 :         } else

  001c2	e9 c2 00 00 00	 jmp	 $LN4@Tidy_init
$LN2@Tidy_init:
  001c7	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  001cd	c1 ea 03	 shr	 edx, 3
  001d0	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 4608 : #endif // __cpp_lib_constexpr_string
; 4609 :         {
; 4610 :             _My_data._Myres = _BUF_SIZE - 1;

  001d7	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  001da	83 c0 18	 add	 eax, 24			; 00000018H
  001dd	89 45 cc	 mov	 DWORD PTR tv83[ebp], eax
  001e0	8b 4d cc	 mov	 ecx, DWORD PTR tv83[ebp]
  001e3	89 4d b0	 mov	 DWORD PTR tv161[ebp], ecx
  001e6	8b 55 b0	 mov	 edx, DWORD PTR tv161[ebp]
  001e9	c1 ea 03	 shr	 edx, 3
  001ec	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001f2	88 45 9a	 mov	 BYTE PTR tv164[ebp], al
  001f5	80 7d 9a 00	 cmp	 BYTE PTR tv164[ebp], 0
  001f9	74 1a		 je	 SHORT $LN6@Tidy_init
  001fb	8a 4d b0	 mov	 cl, BYTE PTR tv161[ebp]
  001fe	80 e1 07	 and	 cl, 7
  00201	80 c1 03	 add	 cl, 3
  00204	3a 4d 9a	 cmp	 cl, BYTE PTR tv164[ebp]
  00207	7c 0c		 jl	 SHORT $LN6@Tidy_init
  00209	8b 55 b0	 mov	 edx, DWORD PTR tv161[ebp]
  0020c	52		 push	 edx
  0020d	e8 00 00 00 00	 call	 ___asan_report_store4
  00212	83 c4 04	 add	 esp, 4
$LN6@Tidy_init:
  00215	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  00218	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH

; 4611 :             // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 4612 :             _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  0021e	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00224	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  00227	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  0022a	c1 ea 03	 shr	 edx, 3
  0022d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00233	88 45 9b	 mov	 BYTE PTR tv154[ebp], al
  00236	80 7d 9b 00	 cmp	 BYTE PTR tv154[ebp], 0
  0023a	74 17		 je	 SHORT $LN5@Tidy_init
  0023c	8a 4d b4	 mov	 cl, BYTE PTR tv151[ebp]
  0023f	80 e1 07	 and	 cl, 7
  00242	3a 4d 9b	 cmp	 cl, BYTE PTR tv154[ebp]
  00245	7c 0c		 jl	 SHORT $LN5@Tidy_init
  00247	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  0024a	52		 push	 edx
  0024b	e8 00 00 00 00	 call	 ___asan_report_store1
  00250	83 c4 04	 add	 esp, 4
$LN5@Tidy_init:
  00253	c6 85 68 ff ff
	ff 00		 mov	 BYTE PTR $T3[ebp], 0
  0025a	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00260	50		 push	 eax
  00261	b9 01 00 00 00	 mov	 ecx, 1
  00266	6b d1 00	 imul	 edx, ecx, 0
  00269	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0026c	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  00270	51		 push	 ecx
  00271	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00276	83 c4 08	 add	 esp, 8
  00279	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0027f	c1 ea 03	 shr	 edx, 3
  00282	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN4@Tidy_init:

; 4613 :         }
; 4614 :     }

  00289	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00293	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00299	c1 e8 03	 shr	 eax, 3
  0029c	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  002a1	89 45 dc	 mov	 DWORD PTR tv147[ebp], eax
  002a4	6a 07		 push	 7
  002a6	8b 4d dc	 mov	 ecx, DWORD PTR tv147[ebp]
  002a9	51		 push	 ecx
  002aa	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002af	83 c4 08	 add	 esp, 8
  002b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  002b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002bc	59		 pop	 ecx
  002bd	8b e5		 mov	 esp, ebp
  002bf	5d		 pop	 ebp
  002c0	8b e3		 mov	 esp, ebx
  002c2	5b		 pop	 ebx
  002c3	c3		 ret	 0
  002c4	cc		 int	 3
  002c5	cc		 int	 3
  002c6	cc		 int	 3
  002c7	cc		 int	 3
  002c8	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z
_TEXT	SEGMENT
tv74 = -24						; size = 4
tv76 = -20						; size = 4
tv70 = -16						; size = 4
_this$ = -12						; size = 4
tv80 = -8						; size = 4
tv83 = -1						; size = 1
__Requested$ = 8					; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 4500 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Requested) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4501 :         return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());

  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  0001b	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  0001e	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00021	83 c0 18	 add	 eax, 24			; 00000018H
  00024	89 45 f0	 mov	 DWORD PTR tv70[ebp], eax
  00027	8b 4d f0	 mov	 ecx, DWORD PTR tv70[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv80[ebp], ecx
  0002d	8b 55 f8	 mov	 edx, DWORD PTR tv80[ebp]
  00030	c1 ea 03	 shr	 edx, 3
  00033	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00039	88 45 ff	 mov	 BYTE PTR tv83[ebp], al
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv83[ebp], 0
  00040	74 1a		 je	 SHORT $LN3@Calculate_
  00042	8a 4d f8	 mov	 cl, BYTE PTR tv80[ebp]
  00045	80 e1 07	 and	 cl, 7
  00048	80 c1 03	 add	 cl, 3
  0004b	3a 4d ff	 cmp	 cl, BYTE PTR tv83[ebp]
  0004e	7c 0c		 jl	 SHORT $LN3@Calculate_
  00050	8b 55 f8	 mov	 edx, DWORD PTR tv80[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ___asan_report_load4
  00059	83 c4 04	 add	 esp, 4
$LN3@Calculate_:
  0005c	8b 45 f0	 mov	 eax, DWORD PTR tv70[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d e8	 mov	 DWORD PTR tv74[ebp], ecx
  00064	8b 55 ec	 mov	 edx, DWORD PTR tv76[ebp]
  00067	52		 push	 edx
  00068	8b 45 e8	 mov	 eax, DWORD PTR tv74[ebp]
  0006b	50		 push	 eax
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR __Requested$[ebp]
  0006f	51		 push	 ecx
  00070	e8 00 00 00 00	 call	 ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00075	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4502 :     }

  00078	8b e5		 mov	 esp, ebp
  0007a	5d		 pop	 ebp
  0007b	c2 04 00	 ret	 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
_TEXT	SEGMENT
__asan_gen_0$ = -144					; size = 4
__asan_gen_1$ = -140					; size = 4
__asan_gen_2$ = -136					; size = 4
__Masked$ = -128					; size = 4
$T2 = -112						; size = 4
tv175 = -68						; size = 1
tv165 = -67						; size = 1
tv155 = -66						; size = 1
tv145 = -65						; size = 1
tv88 = -64						; size = 4
tv172 = -60						; size = 4
tv162 = -56						; size = 4
tv152 = -52						; size = 4
tv142 = -48						; size = 4
tv69 = -44						; size = 4
tv86 = -40						; size = 4
tv64 = -36						; size = 4
tv94 = -32						; size = 4
tv75 = -28						; size = 4
tv132 = -24						; size = 4
tv76 = -20						; size = 4
tv71 = -16						; size = 4
tv138 = -12						; size = 4
tv77 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Requested$ = 8					; size = 4
__Old$ = 12						; size = 4
__Max$ = 16						; size = 4
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 4487 :         const size_type _Requested, const size_type _Old, const size_type _Max) noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 70 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z
  0003a	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
  00044	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 d8	 mov	 DWORD PTR tv86[ebp], eax
  0004d	8b 4d d8	 mov	 ecx, DWORD PTR tv86[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c0	 mov	 DWORD PTR tv88[ebp], ecx
  0005c	8b 55 c0	 mov	 edx, DWORD PTR tv88[ebp]
  0005f	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00065	83 45 c0 04	 add	 DWORD PTR tv88[ebp], 4
  00069	8b 45 c0	 mov	 eax, DWORD PTR tv88[ebp]
  0006c	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00072	83 45 c0 04	 add	 DWORD PTR tv88[ebp], 4
  00076	8b 4d c0	 mov	 ecx, DWORD PTR tv88[ebp]
  00079	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00081	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4488 :         const size_type _Masked = _Requested | _ALLOC_MASK;

  00086	8b 53 08	 mov	 edx, DWORD PTR __Requested$[ebx]
  00089	83 ca 0f	 or	 edx, 15			; 0000000fH
  0008c	89 55 dc	 mov	 DWORD PTR tv64[ebp], edx
  0008f	8d 45 80	 lea	 eax, DWORD PTR __Masked$[ebp]
  00092	89 45 c4	 mov	 DWORD PTR tv172[ebp], eax
  00095	8b 4d c4	 mov	 ecx, DWORD PTR tv172[ebp]
  00098	c1 e9 03	 shr	 ecx, 3
  0009b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a1	88 55 bc	 mov	 BYTE PTR tv175[ebp], dl
  000a4	80 7d bc 00	 cmp	 BYTE PTR tv175[ebp], 0
  000a8	74 18		 je	 SHORT $LN8@Calculate_
  000aa	8a 45 c4	 mov	 al, BYTE PTR tv172[ebp]
  000ad	24 07		 and	 al, 7
  000af	04 03		 add	 al, 3
  000b1	3a 45 bc	 cmp	 al, BYTE PTR tv175[ebp]
  000b4	7c 0c		 jl	 SHORT $LN8@Calculate_
  000b6	8b 4d c4	 mov	 ecx, DWORD PTR tv172[ebp]
  000b9	51		 push	 ecx
  000ba	e8 00 00 00 00	 call	 ___asan_report_store4
  000bf	83 c4 04	 add	 esp, 4
$LN8@Calculate_:
  000c2	8b 55 dc	 mov	 edx, DWORD PTR tv64[ebp]
  000c5	89 55 80	 mov	 DWORD PTR __Masked$[ebp], edx

; 4489 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

  000c8	8d 45 80	 lea	 eax, DWORD PTR __Masked$[ebp]
  000cb	89 45 c8	 mov	 DWORD PTR tv162[ebp], eax
  000ce	8b 4d c8	 mov	 ecx, DWORD PTR tv162[ebp]
  000d1	c1 e9 03	 shr	 ecx, 3
  000d4	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000da	88 55 bd	 mov	 BYTE PTR tv165[ebp], dl
  000dd	80 7d bd 00	 cmp	 BYTE PTR tv165[ebp], 0
  000e1	74 18		 je	 SHORT $LN7@Calculate_
  000e3	8a 45 c8	 mov	 al, BYTE PTR tv162[ebp]
  000e6	24 07		 and	 al, 7
  000e8	04 03		 add	 al, 3
  000ea	3a 45 bd	 cmp	 al, BYTE PTR tv165[ebp]
  000ed	7c 0c		 jl	 SHORT $LN7@Calculate_
  000ef	8b 4d c8	 mov	 ecx, DWORD PTR tv162[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_report_load4
  000f8	83 c4 04	 add	 esp, 4
$LN7@Calculate_:
  000fb	8b 55 80	 mov	 edx, DWORD PTR __Masked$[ebp]
  000fe	3b 53 10	 cmp	 edx, DWORD PTR __Max$[ebx]
  00101	76 38		 jbe	 SHORT $LN2@Calculate_

; 4490 :             return _Max;

  00103	8b 43 10	 mov	 eax, DWORD PTR __Max$[ebx]
  00106	89 45 e4	 mov	 DWORD PTR tv75[ebp], eax
  00109	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00113	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d e0	 mov	 DWORD PTR tv94[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 e0	 mov	 edx, DWORD PTR tv94[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 45 e4	 mov	 eax, DWORD PTR tv75[ebp]
  00136	e9 18 01 00 00	 jmp	 $LN4@Calculate_
$LN2@Calculate_:

; 4491 :         }
; 4492 : 
; 4493 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

  0013b	8b 43 0c	 mov	 eax, DWORD PTR __Old$[ebx]
  0013e	d1 e8		 shr	 eax, 1
  00140	8b 4b 10	 mov	 ecx, DWORD PTR __Max$[ebx]
  00143	2b c8		 sub	 ecx, eax
  00145	39 4b 0c	 cmp	 DWORD PTR __Old$[ebx], ecx
  00148	76 37		 jbe	 SHORT $LN3@Calculate_

; 4494 :             return _Max;

  0014a	8b 53 10	 mov	 edx, DWORD PTR __Max$[ebx]
  0014d	89 55 ec	 mov	 DWORD PTR tv76[ebp], edx
  00150	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015a	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00160	c1 e8 03	 shr	 eax, 3
  00163	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00168	89 45 e8	 mov	 DWORD PTR tv132[ebp], eax
  0016b	6a 09		 push	 9
  0016d	8b 4d e8	 mov	 ecx, DWORD PTR tv132[ebp]
  00170	51		 push	 ecx
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 ec	 mov	 eax, DWORD PTR tv76[ebp]
  0017c	e9 d2 00 00 00	 jmp	 $LN4@Calculate_
$LN3@Calculate_:
  00181	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00184	c1 ea 03	 shr	 edx, 3
  00187	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 4495 :         }
; 4496 : 
; 4497 :         return (_STD max)(_Masked, _Old + _Old / 2);

  0018e	8b 43 0c	 mov	 eax, DWORD PTR __Old$[ebx]
  00191	d1 e8		 shr	 eax, 1
  00193	8b 4b 0c	 mov	 ecx, DWORD PTR __Old$[ebx]
  00196	03 c8		 add	 ecx, eax
  00198	89 4d f0	 mov	 DWORD PTR tv71[ebp], ecx
  0019b	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  0019e	89 55 cc	 mov	 DWORD PTR tv152[ebp], edx
  001a1	8b 45 cc	 mov	 eax, DWORD PTR tv152[ebp]
  001a4	c1 e8 03	 shr	 eax, 3
  001a7	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001ad	88 4d be	 mov	 BYTE PTR tv155[ebp], cl
  001b0	80 7d be 00	 cmp	 BYTE PTR tv155[ebp], 0
  001b4	74 1a		 je	 SHORT $LN6@Calculate_
  001b6	8a 55 cc	 mov	 dl, BYTE PTR tv152[ebp]
  001b9	80 e2 07	 and	 dl, 7
  001bc	80 c2 03	 add	 dl, 3
  001bf	3a 55 be	 cmp	 dl, BYTE PTR tv155[ebp]
  001c2	7c 0c		 jl	 SHORT $LN6@Calculate_
  001c4	8b 45 cc	 mov	 eax, DWORD PTR tv152[ebp]
  001c7	50		 push	 eax
  001c8	e8 00 00 00 00	 call	 ___asan_report_store4
  001cd	83 c4 04	 add	 esp, 4
$LN6@Calculate_:
  001d0	8b 4d f0	 mov	 ecx, DWORD PTR tv71[ebp]
  001d3	89 4d 90	 mov	 DWORD PTR $T2[ebp], ecx
  001d6	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  001d9	52		 push	 edx
  001da	8d 45 80	 lea	 eax, DWORD PTR __Masked$[ebp]
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  001e3	83 c4 08	 add	 esp, 8
  001e6	89 45 d4	 mov	 DWORD PTR tv69[ebp], eax
  001e9	8b 4d d4	 mov	 ecx, DWORD PTR tv69[ebp]
  001ec	89 4d d0	 mov	 DWORD PTR tv142[ebp], ecx
  001ef	8b 55 d0	 mov	 edx, DWORD PTR tv142[ebp]
  001f2	c1 ea 03	 shr	 edx, 3
  001f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001fb	88 45 bf	 mov	 BYTE PTR tv145[ebp], al
  001fe	80 7d bf 00	 cmp	 BYTE PTR tv145[ebp], 0
  00202	74 1a		 je	 SHORT $LN5@Calculate_
  00204	8a 4d d0	 mov	 cl, BYTE PTR tv142[ebp]
  00207	80 e1 07	 and	 cl, 7
  0020a	80 c1 03	 add	 cl, 3
  0020d	3a 4d bf	 cmp	 cl, BYTE PTR tv145[ebp]
  00210	7c 0c		 jl	 SHORT $LN5@Calculate_
  00212	8b 55 d0	 mov	 edx, DWORD PTR tv142[ebp]
  00215	52		 push	 edx
  00216	e8 00 00 00 00	 call	 ___asan_report_load4
  0021b	83 c4 04	 add	 esp, 4
$LN5@Calculate_:
  0021e	8b 45 d4	 mov	 eax, DWORD PTR tv69[ebp]
  00221	8b 08		 mov	 ecx, DWORD PTR [eax]
  00223	89 4d f8	 mov	 DWORD PTR tv77[ebp], ecx
  00226	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00230	8d 95 70 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00236	c1 ea 03	 shr	 edx, 3
  00239	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0023f	89 55 f4	 mov	 DWORD PTR tv138[ebp], edx
  00242	6a 09		 push	 9
  00244	8b 45 f4	 mov	 eax, DWORD PTR tv138[ebp]
  00247	50		 push	 eax
  00248	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0024d	83 c4 08	 add	 esp, 8
  00250	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]
$LN4@Calculate_:

; 4498 :     }

  00253	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00256	33 cd		 xor	 ecx, ebp
  00258	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0025d	8b e5		 mov	 esp, ebp
  0025f	5d		 pop	 ebp
  00260	8b e3		 mov	 esp, ebx
  00262	5b		 pop	 ebx
  00263	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAIIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -184					; size = 4
__asan_gen_1$ = -180					; size = 4
__asan_gen_2$ = -176					; size = 4
__Alloc_max$ = -168					; size = 4
$T2 = -152						; size = 4
$T3 = -136						; size = 4
$T4 = -120						; size = 4
tv196 = -78						; size = 1
tv186 = -77						; size = 1
tv176 = -76						; size = 1
tv166 = -75						; size = 1
tv156 = -74						; size = 1
tv146 = -73						; size = 1
tv92 = -72						; size = 4
tv193 = -68						; size = 4
tv183 = -64						; size = 4
tv173 = -60						; size = 4
tv163 = -56						; size = 4
tv153 = -52						; size = 4
tv143 = -48						; size = 4
tv68 = -44						; size = 4
tv71 = -40						; size = 4
tv90 = -36						; size = 4
_this$ = -32						; size = 4
tv64 = -28						; size = 4
__Storage_max$ = -24					; size = 4
tv72 = -20						; size = 4
tv74 = -16						; size = 4
tv139 = -12						; size = 4
tv77 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 3943 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 85 48 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00033	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
  0003d	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
  00047	8d 85 48 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004d	89 45 dc	 mov	 DWORD PTR tv90[ebp], eax
  00050	8b 4d dc	 mov	 ecx, DWORD PTR tv90[ebp]
  00053	c1 e9 03	 shr	 ecx, 3
  00056	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0005c	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  0005f	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00062	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00068	83 45 b8 04	 add	 DWORD PTR tv92[ebp], 4
  0006c	8b 45 b8	 mov	 eax, DWORD PTR tv92[ebp]
  0006f	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  00075	83 45 b8 04	 add	 DWORD PTR tv92[ebp], 4
  00079	8b 4d b8	 mov	 ecx, DWORD PTR tv92[ebp]
  0007c	c7 01 f8 f3 f3
	f3		 mov	 DWORD PTR [ecx], -202116104 ; f3f3f3f8H
  00082	83 45 b8 04	 add	 DWORD PTR tv92[ebp], 4
  00086	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00089	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0008c	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  00092	c1 e8 03	 shr	 eax, 3
  00095	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  0009c	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000a2	c1 e9 03	 shr	 ecx, 3
  000a5	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4
  000ac	8d 55 88	 lea	 edx, DWORD PTR $T4[ebp]
  000af	c1 ea 03	 shr	 edx, 3
  000b2	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  000b9	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  000be	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3944 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());

  000c3	8b 4d e0	 mov	 ecx, DWORD PTR _this$[ebp]
  000c6	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000cb	50		 push	 eax
  000cc	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
  000d1	83 c4 04	 add	 esp, 4
  000d4	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  000d7	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  000dd	89 45 bc	 mov	 DWORD PTR tv193[ebp], eax
  000e0	8b 4d bc	 mov	 ecx, DWORD PTR tv193[ebp]
  000e3	c1 e9 03	 shr	 ecx, 3
  000e6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ec	88 55 b2	 mov	 BYTE PTR tv196[ebp], dl
  000ef	80 7d b2 00	 cmp	 BYTE PTR tv196[ebp], 0
  000f3	74 18		 je	 SHORT $LN8@max_size
  000f5	8a 45 bc	 mov	 al, BYTE PTR tv193[ebp]
  000f8	24 07		 and	 al, 7
  000fa	04 03		 add	 al, 3
  000fc	3a 45 b2	 cmp	 al, BYTE PTR tv196[ebp]
  000ff	7c 0c		 jl	 SHORT $LN8@max_size
  00101	8b 4d bc	 mov	 ecx, DWORD PTR tv193[ebp]
  00104	51		 push	 ecx
  00105	e8 00 00 00 00	 call	 ___asan_report_store4
  0010a	83 c4 04	 add	 esp, 4
$LN8@max_size:
  0010d	8b 55 e4	 mov	 edx, DWORD PTR tv64[ebp]
  00110	89 95 58 ff ff
	ff		 mov	 DWORD PTR __Alloc_max$[ebp], edx

; 3945 :         const size_type _Storage_max = // can always store small string

  00116	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0011c	89 45 c0	 mov	 DWORD PTR tv183[ebp], eax
  0011f	8b 4d c0	 mov	 ecx, DWORD PTR tv183[ebp]
  00122	c1 e9 03	 shr	 ecx, 3
  00125	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0012b	88 55 b3	 mov	 BYTE PTR tv186[ebp], dl
  0012e	80 7d b3 00	 cmp	 BYTE PTR tv186[ebp], 0
  00132	74 18		 je	 SHORT $LN7@max_size
  00134	8a 45 c0	 mov	 al, BYTE PTR tv183[ebp]
  00137	24 07		 and	 al, 7
  00139	04 03		 add	 al, 3
  0013b	3a 45 b3	 cmp	 al, BYTE PTR tv186[ebp]
  0013e	7c 0c		 jl	 SHORT $LN7@max_size
  00140	8b 4d c0	 mov	 ecx, DWORD PTR tv183[ebp]
  00143	51		 push	 ecx
  00144	e8 00 00 00 00	 call	 ___asan_report_store4
  00149	83 c4 04	 add	 esp, 4
$LN7@max_size:
  0014c	c7 85 68 ff ff
	ff 10 00 00 00	 mov	 DWORD PTR $T2[ebp], 16	; 00000010H
  00156	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0015c	52		 push	 edx
  0015d	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __Alloc_max$[ebp]
  00163	50		 push	 eax
  00164	e8 00 00 00 00	 call	 ??$max@I@std@@YAABIABI0@Z ; std::max<unsigned int>
  00169	83 c4 08	 add	 esp, 8
  0016c	89 45 d4	 mov	 DWORD PTR tv68[ebp], eax
  0016f	8b 4d d4	 mov	 ecx, DWORD PTR tv68[ebp]
  00172	89 4d c4	 mov	 DWORD PTR tv173[ebp], ecx
  00175	8b 55 c4	 mov	 edx, DWORD PTR tv173[ebp]
  00178	c1 ea 03	 shr	 edx, 3
  0017b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00181	88 45 b4	 mov	 BYTE PTR tv176[ebp], al
  00184	80 7d b4 00	 cmp	 BYTE PTR tv176[ebp], 0
  00188	74 1a		 je	 SHORT $LN6@max_size
  0018a	8a 4d c4	 mov	 cl, BYTE PTR tv173[ebp]
  0018d	80 e1 07	 and	 cl, 7
  00190	80 c1 03	 add	 cl, 3
  00193	3a 4d b4	 cmp	 cl, BYTE PTR tv176[ebp]
  00196	7c 0c		 jl	 SHORT $LN6@max_size
  00198	8b 55 c4	 mov	 edx, DWORD PTR tv173[ebp]
  0019b	52		 push	 edx
  0019c	e8 00 00 00 00	 call	 ___asan_report_load4
  001a1	83 c4 04	 add	 esp, 4
$LN6@max_size:
  001a4	8b 45 d4	 mov	 eax, DWORD PTR tv68[ebp]
  001a7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a9	89 4d e8	 mov	 DWORD PTR __Storage_max$[ebp], ecx
  001ac	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  001b2	c1 ea 03	 shr	 edx, 3
  001b5	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 3946 :             (_STD max)(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3947 :         return (_STD min)(static_cast<size_type>((numeric_limits<difference_type>::max)()),

  001bc	8b 45 e8	 mov	 eax, DWORD PTR __Storage_max$[ebp]
  001bf	83 e8 01	 sub	 eax, 1
  001c2	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  001c5	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  001cb	89 4d c8	 mov	 DWORD PTR tv163[ebp], ecx
  001ce	8b 55 c8	 mov	 edx, DWORD PTR tv163[ebp]
  001d1	c1 ea 03	 shr	 edx, 3
  001d4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001da	88 45 b5	 mov	 BYTE PTR tv166[ebp], al
  001dd	80 7d b5 00	 cmp	 BYTE PTR tv166[ebp], 0
  001e1	74 1a		 je	 SHORT $LN5@max_size
  001e3	8a 4d c8	 mov	 cl, BYTE PTR tv163[ebp]
  001e6	80 e1 07	 and	 cl, 7
  001e9	80 c1 03	 add	 cl, 3
  001ec	3a 4d b5	 cmp	 cl, BYTE PTR tv166[ebp]
  001ef	7c 0c		 jl	 SHORT $LN5@max_size
  001f1	8b 55 c8	 mov	 edx, DWORD PTR tv163[ebp]
  001f4	52		 push	 edx
  001f5	e8 00 00 00 00	 call	 ___asan_report_store4
  001fa	83 c4 04	 add	 esp, 4
$LN5@max_size:
  001fd	8b 45 ec	 mov	 eax, DWORD PTR tv72[ebp]
  00200	89 85 78 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00206	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  0020b	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  0020e	8d 4d 88	 lea	 ecx, DWORD PTR $T4[ebp]
  00211	89 4d cc	 mov	 DWORD PTR tv153[ebp], ecx
  00214	8b 55 cc	 mov	 edx, DWORD PTR tv153[ebp]
  00217	c1 ea 03	 shr	 edx, 3
  0021a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00220	88 45 b6	 mov	 BYTE PTR tv156[ebp], al
  00223	80 7d b6 00	 cmp	 BYTE PTR tv156[ebp], 0
  00227	74 1a		 je	 SHORT $LN4@max_size
  00229	8a 4d cc	 mov	 cl, BYTE PTR tv153[ebp]
  0022c	80 e1 07	 and	 cl, 7
  0022f	80 c1 03	 add	 cl, 3
  00232	3a 4d b6	 cmp	 cl, BYTE PTR tv156[ebp]
  00235	7c 0c		 jl	 SHORT $LN4@max_size
  00237	8b 55 cc	 mov	 edx, DWORD PTR tv153[ebp]
  0023a	52		 push	 edx
  0023b	e8 00 00 00 00	 call	 ___asan_report_store4
  00240	83 c4 04	 add	 esp, 4
$LN4@max_size:
  00243	8b 45 f0	 mov	 eax, DWORD PTR tv74[ebp]
  00246	89 45 88	 mov	 DWORD PTR $T4[ebp], eax
  00249	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0024f	51		 push	 ecx
  00250	8d 55 88	 lea	 edx, DWORD PTR $T4[ebp]
  00253	52		 push	 edx
  00254	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00259	83 c4 08	 add	 esp, 8
  0025c	89 45 d8	 mov	 DWORD PTR tv71[ebp], eax
  0025f	8b 45 d8	 mov	 eax, DWORD PTR tv71[ebp]
  00262	89 45 d0	 mov	 DWORD PTR tv143[ebp], eax
  00265	8b 4d d0	 mov	 ecx, DWORD PTR tv143[ebp]
  00268	c1 e9 03	 shr	 ecx, 3
  0026b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00271	88 55 b7	 mov	 BYTE PTR tv146[ebp], dl
  00274	80 7d b7 00	 cmp	 BYTE PTR tv146[ebp], 0
  00278	74 18		 je	 SHORT $LN3@max_size
  0027a	8a 45 d0	 mov	 al, BYTE PTR tv143[ebp]
  0027d	24 07		 and	 al, 7
  0027f	04 03		 add	 al, 3
  00281	3a 45 b7	 cmp	 al, BYTE PTR tv146[ebp]
  00284	7c 0c		 jl	 SHORT $LN3@max_size
  00286	8b 4d d0	 mov	 ecx, DWORD PTR tv143[ebp]
  00289	51		 push	 ecx
  0028a	e8 00 00 00 00	 call	 ___asan_report_load4
  0028f	83 c4 04	 add	 esp, 4
$LN3@max_size:
  00292	8b 55 d8	 mov	 edx, DWORD PTR tv71[ebp]
  00295	8b 02		 mov	 eax, DWORD PTR [edx]
  00297	89 45 f8	 mov	 DWORD PTR tv77[ebp], eax
  0029a	c7 85 48 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  002a4	8d 8d 48 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  002aa	c1 e9 03	 shr	 ecx, 3
  002ad	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  002b3	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  002b6	6a 0d		 push	 13			; 0000000dH
  002b8	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  002bb	52		 push	 edx
  002bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002c1	83 c4 08	 add	 esp, 8
  002c4	8b 45 f8	 mov	 eax, DWORD PTR tv77[ebp]

; 3948 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3949 :         );
; 3950 :     }

  002c7	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  002ca	33 cd		 xor	 ecx, ebp
  002cc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  002d1	8b e5		 mov	 esp, ebp
  002d3	5d		 pop	 ebp
  002d4	8b e3		 mov	 esp, ebx
  002d6	5b		 pop	 ebx
  002d7	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3263 :     _CONSTEXPR20_CONTAINER basic_string& assign(_In_z_ const _Elem* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3264 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  00023	83 c4 04	 add	 esp, 4
  00026	50		 push	 eax
  00027	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002a	51		 push	 ecx
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002e	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3265 :     }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
_TEXT	SEGMENT
__asan_gen_0$ = -112					; size = 4
__asan_gen_1$ = -108					; size = 4
__asan_gen_2$ = -104					; size = 4
$T2 = -96						; size = 1
tv172 = -56						; size = 1
tv162 = -55						; size = 1
tv152 = -54						; size = 1
$T3 = -53						; size = 1
tv130 = -52						; size = 4
_this$ = -48						; size = 4
tv169 = -44						; size = 4
tv159 = -40						; size = 4
tv149 = -36						; size = 4
tv66 = -32						; size = 4
tv74 = -28						; size = 4
__Old_ptr$4 = -24					; size = 4
tv128 = -20						; size = 4
tv139 = -16						; size = 4
tv88 = -12						; size = 4
tv145 = -8						; size = 4
tv89 = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 3244 :         _In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 90 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 94 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z
  0002d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00034	8d 45 90	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 ec	 mov	 DWORD PTR tv128[ebp], eax
  0003a	8b 4d ec	 mov	 ecx, DWORD PTR tv128[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d cc	 mov	 DWORD PTR tv130[ebp], ecx
  00049	8b 55 cc	 mov	 edx, DWORD PTR tv130[ebp]
  0004c	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00052	83 45 cc 04	 add	 DWORD PTR tv130[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d cc	 mov	 ecx, DWORD PTR tv130[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 cc 02	 add	 DWORD PTR tv130[ebp], 2
  00065	8b 55 cc	 mov	 edx, DWORD PTR tv130[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00070	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3245 :         // assign [_Ptr, _Ptr + _Count)
; 3246 :         if (_Count <= _Mypair._Myval2._Myres) {

  00075	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  00078	83 c0 18	 add	 eax, 24			; 00000018H
  0007b	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0007e	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  00081	89 4d d4	 mov	 DWORD PTR tv169[ebp], ecx
  00084	8b 55 d4	 mov	 edx, DWORD PTR tv169[ebp]
  00087	c1 ea 03	 shr	 edx, 3
  0008a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00090	88 45 c8	 mov	 BYTE PTR tv172[ebp], al
  00093	80 7d c8 00	 cmp	 BYTE PTR tv172[ebp], 0
  00097	74 1a		 je	 SHORT $LN6@assign
  00099	8a 4d d4	 mov	 cl, BYTE PTR tv169[ebp]
  0009c	80 e1 07	 and	 cl, 7
  0009f	80 c1 03	 add	 cl, 3
  000a2	3a 4d c8	 cmp	 cl, BYTE PTR tv172[ebp]
  000a5	7c 0c		 jl	 SHORT $LN6@assign
  000a7	8b 55 d4	 mov	 edx, DWORD PTR tv169[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ___asan_report_load4
  000b0	83 c4 04	 add	 esp, 4
$LN6@assign:
  000b3	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000b6	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  000b9	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000bb	0f 87 f7 00 00
	00		 ja	 $LN2@assign
  000c1	8d 55 a0	 lea	 edx, DWORD PTR $T2[ebp]
  000c4	c1 ea 03	 shr	 edx, 3
  000c7	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 3247 :             _Elem* const _Old_ptr   = _Mypair._Myval2._Myptr();

  000ce	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d1	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  000d6	89 45 e8	 mov	 DWORD PTR __Old_ptr$4[ebp], eax

; 3248 :             _Mypair._Myval2._Mysize = _Count;

  000d9	8b 45 d0	 mov	 eax, DWORD PTR _this$[ebp]
  000dc	83 c0 14	 add	 eax, 20			; 00000014H
  000df	89 45 e4	 mov	 DWORD PTR tv74[ebp], eax
  000e2	8b 4d e4	 mov	 ecx, DWORD PTR tv74[ebp]
  000e5	89 4d d8	 mov	 DWORD PTR tv159[ebp], ecx
  000e8	8b 55 d8	 mov	 edx, DWORD PTR tv159[ebp]
  000eb	c1 ea 03	 shr	 edx, 3
  000ee	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f4	88 45 c9	 mov	 BYTE PTR tv162[ebp], al
  000f7	80 7d c9 00	 cmp	 BYTE PTR tv162[ebp], 0
  000fb	74 1a		 je	 SHORT $LN5@assign
  000fd	8a 4d d8	 mov	 cl, BYTE PTR tv159[ebp]
  00100	80 e1 07	 and	 cl, 7
  00103	80 c1 03	 add	 cl, 3
  00106	3a 4d c9	 cmp	 cl, BYTE PTR tv162[ebp]
  00109	7c 0c		 jl	 SHORT $LN5@assign
  0010b	8b 55 d8	 mov	 edx, DWORD PTR tv159[ebp]
  0010e	52		 push	 edx
  0010f	e8 00 00 00 00	 call	 ___asan_report_store4
  00114	83 c4 04	 add	 esp, 4
$LN5@assign:
  00117	8b 45 e4	 mov	 eax, DWORD PTR tv74[ebp]
  0011a	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  0011d	89 08		 mov	 DWORD PTR [eax], ecx

; 3249 :             _Traits::move(_Old_ptr, _Ptr, _Count);

  0011f	8b 53 0c	 mov	 edx, DWORD PTR __Count$[ebx]
  00122	52		 push	 edx
  00123	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00126	50		 push	 eax
  00127	8b 4d e8	 mov	 ecx, DWORD PTR __Old_ptr$4[ebp]
  0012a	51		 push	 ecx
  0012b	e8 00 00 00 00	 call	 ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ; std::_Char_traits<char,int>::move
  00130	83 c4 0c	 add	 esp, 12			; 0000000cH

; 3250 :             _Traits::assign(_Old_ptr[_Count], _Elem());

  00133	8d 55 a0	 lea	 edx, DWORD PTR $T2[ebp]
  00136	89 55 dc	 mov	 DWORD PTR tv149[ebp], edx
  00139	8b 45 dc	 mov	 eax, DWORD PTR tv149[ebp]
  0013c	c1 e8 03	 shr	 eax, 3
  0013f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00145	88 4d ca	 mov	 BYTE PTR tv152[ebp], cl
  00148	80 7d ca 00	 cmp	 BYTE PTR tv152[ebp], 0
  0014c	74 17		 je	 SHORT $LN4@assign
  0014e	8a 55 dc	 mov	 dl, BYTE PTR tv149[ebp]
  00151	80 e2 07	 and	 dl, 7
  00154	3a 55 ca	 cmp	 dl, BYTE PTR tv152[ebp]
  00157	7c 0c		 jl	 SHORT $LN4@assign
  00159	8b 45 dc	 mov	 eax, DWORD PTR tv149[ebp]
  0015c	50		 push	 eax
  0015d	e8 00 00 00 00	 call	 ___asan_report_store1
  00162	83 c4 04	 add	 esp, 4
$LN4@assign:
  00165	c6 45 a0 00	 mov	 BYTE PTR $T2[ebp], 0
  00169	8d 4d a0	 lea	 ecx, DWORD PTR $T2[ebp]
  0016c	51		 push	 ecx
  0016d	8b 55 e8	 mov	 edx, DWORD PTR __Old_ptr$4[ebp]
  00170	03 53 0c	 add	 edx, DWORD PTR __Count$[ebx]
  00173	52		 push	 edx
  00174	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  00179	83 c4 08	 add	 esp, 8
  0017c	8d 45 a0	 lea	 eax, DWORD PTR $T2[ebp]
  0017f	c1 e8 03	 shr	 eax, 3
  00182	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 3251 :             return *this;

  00189	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	89 4d f4	 mov	 DWORD PTR tv88[ebp], ecx
  0018f	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00196	8d 55 90	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00199	c1 ea 03	 shr	 edx, 3
  0019c	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  001a2	89 55 f0	 mov	 DWORD PTR tv139[ebp], edx
  001a5	6a 07		 push	 7
  001a7	8b 45 f0	 mov	 eax, DWORD PTR tv139[ebp]
  001aa	50		 push	 eax
  001ab	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001b0	83 c4 08	 add	 esp, 8
  001b3	8b 45 f4	 mov	 eax, DWORD PTR tv88[ebp]
  001b6	eb 3f		 jmp	 SHORT $LN1@assign
$LN2@assign:

; 3252 :         }
; 3253 : 
; 3254 :         return _Reallocate_for(

  001b8	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  001bb	51		 push	 ecx
  001bc	0f b6 55 cb	 movzx	 edx, BYTE PTR $T3[ebp]
  001c0	52		 push	 edx
  001c1	8b 43 0c	 mov	 eax, DWORD PTR __Count$[ebx]
  001c4	50		 push	 eax
  001c5	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  001c8	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_1>@?1??assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV34@QBDI@Z@PBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV01@IV<lambda_1>@?1??assign@01@QAEAAV01@QBDI@Z@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<`std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign'::`2'::<lambda_1>,char const *>
  001cd	89 45 fc	 mov	 DWORD PTR tv89[ebp], eax
  001d0	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001d7	8d 4d 90	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  001da	c1 e9 03	 shr	 ecx, 3
  001dd	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  001e3	89 4d f8	 mov	 DWORD PTR tv145[ebp], ecx
  001e6	6a 07		 push	 7
  001e8	8b 55 f8	 mov	 edx, DWORD PTR tv145[ebp]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001f1	83 c4 08	 add	 esp, 8
  001f4	8b 45 fc	 mov	 eax, DWORD PTR tv89[ebp]
$LN1@assign:

; 3255 :             _Count,
; 3256 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 3257 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 3258 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 3259 :             },
; 3260 :             _Ptr);
; 3261 :     }

  001f7	8b e5		 mov	 esp, ebp
  001f9	5d		 pop	 ebp
  001fa	8b e3		 mov	 esp, ebx
  001fc	5b		 pop	 ebx
  001fd	c2 08 00	 ret	 8
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 1
tv77 = -20						; size = 4
_this$ = -16						; size = 4
tv75 = -12						; size = 4
tv86 = -8						; size = 4
tv74 = -4						; size = 4
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 3076 :     _CONSTEXPR20_CONTAINER basic_string& operator=(const basic_string& _Right) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00023	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
  0002a	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
  00031	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00043	89 4d ec	 mov	 DWORD PTR tv77[ebp], ecx
  00046	8b 55 ec	 mov	 edx, DWORD PTR tv77[ebp]
  00049	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  0004f	83 45 ec 04	 add	 DWORD PTR tv77[ebp], 4
  00053	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00058	8b 4d ec	 mov	 ecx, DWORD PTR tv77[ebp]
  0005b	66 89 01	 mov	 WORD PTR [ecx], ax
  0005e	83 45 ec 02	 add	 DWORD PTR tv77[ebp], 2
  00062	8b 55 ec	 mov	 edx, DWORD PTR tv77[ebp]
  00065	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0006d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3077 :         if (this != _STD addressof(_Right)) {

  00072	8b 43 08	 mov	 eax, DWORD PTR __Right$[ebx]
  00075	50		 push	 eax
  00076	e8 00 00 00 00	 call	 ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
  0007b	83 c4 04	 add	 esp, 4
  0007e	39 45 f0	 cmp	 DWORD PTR _this$[ebp], eax
  00081	74 3b		 je	 SHORT $LN2@operator
  00083	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00086	c1 e9 03	 shr	 ecx, 3
  00089	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1

; 3078 :             _Copy_assign(_Right, _Choose_pocca<_Alty>{});

  00090	6a 01		 push	 1
  00092	6a 00		 push	 0
  00094	8d 55 c0	 lea	 edx, DWORD PTR $T2[ebp]
  00097	52		 push	 edx
  00098	e8 00 00 00 00	 call	 ___asan_memset
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	0f b6 45 c0	 movzx	 eax, BYTE PTR $T2[ebp]
  000a4	50		 push	 eax
  000a5	8b 4b 08	 mov	 ecx, DWORD PTR __Right$[ebx]
  000a8	51		 push	 ecx
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
  000b1	8d 55 c0	 lea	 edx, DWORD PTR $T2[ebp]
  000b4	c1 ea 03	 shr	 edx, 3
  000b7	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN2@operator:

; 3079 :         }
; 3080 : 
; 3081 :         return *this;

  000be	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000c1	89 45 fc	 mov	 DWORD PTR tv74[ebp], eax
  000c4	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000cb	8d 4d b0	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000ce	c1 e9 03	 shr	 ecx, 3
  000d1	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  000d7	89 4d f8	 mov	 DWORD PTR tv86[ebp], ecx
  000da	6a 07		 push	 7
  000dc	8b 55 f8	 mov	 edx, DWORD PTR tv86[ebp]
  000df	52		 push	 edx
  000e0	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e5	83 c4 08	 add	 esp, 8
  000e8	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]

; 3082 :     }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	8b e3		 mov	 esp, ebx
  000f0	5b		 pop	 ebx
  000f1	c2 04 00	 ret	 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z
_TEXT	SEGMENT
tv86 = -32						; size = 4
tv88 = -28						; size = 4
tv71 = -24						; size = 4
tv73 = -20						; size = 4
_this$ = -16						; size = 4
tv78 = -12						; size = 4
tv91 = -8						; size = 4
tv94 = -1						; size = 1
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign, COMDAT
; _this$ = ecx

; 3033 :     _CONSTEXPR20_CONTAINER void _Copy_assign(const basic_string& _Right, false_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3034 :         _Pocca(_Getal(), _Right._Getal());

  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABEABV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0001b	89 45 ec	 mov	 DWORD PTR tv73[ebp], eax
  0001e	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00026	89 45 e8	 mov	 DWORD PTR tv71[ebp], eax
  00029	8b 45 ec	 mov	 eax, DWORD PTR tv73[ebp]
  0002c	50		 push	 eax
  0002d	8b 4d e8	 mov	 ecx, DWORD PTR tv71[ebp]
  00030	51		 push	 ecx
  00031	e8 00 00 00 00	 call	 ??$_Pocca@V?$allocator@D@std@@@std@@YAXAAV?$allocator@D@0@ABV10@@Z ; std::_Pocca<std::allocator<char> >
  00036	83 c4 08	 add	 esp, 8

; 3035 :         assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);

  00039	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  0003c	83 c2 14	 add	 edx, 20			; 00000014H
  0003f	89 55 f4	 mov	 DWORD PTR tv78[ebp], edx
  00042	8b 45 f4	 mov	 eax, DWORD PTR tv78[ebp]
  00045	89 45 f8	 mov	 DWORD PTR tv91[ebp], eax
  00048	8b 4d f8	 mov	 ecx, DWORD PTR tv91[ebp]
  0004b	c1 e9 03	 shr	 ecx, 3
  0004e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00054	88 55 ff	 mov	 BYTE PTR tv94[ebp], dl
  00057	80 7d ff 00	 cmp	 BYTE PTR tv94[ebp], 0
  0005b	74 18		 je	 SHORT $LN3@Copy_assig
  0005d	8a 45 f8	 mov	 al, BYTE PTR tv91[ebp]
  00060	24 07		 and	 al, 7
  00062	04 03		 add	 al, 3
  00064	3a 45 ff	 cmp	 al, BYTE PTR tv94[ebp]
  00067	7c 0c		 jl	 SHORT $LN3@Copy_assig
  00069	8b 4d f8	 mov	 ecx, DWORD PTR tv91[ebp]
  0006c	51		 push	 ecx
  0006d	e8 00 00 00 00	 call	 ___asan_report_load4
  00072	83 c4 04	 add	 esp, 4
$LN3@Copy_assig:
  00075	8b 55 f4	 mov	 edx, DWORD PTR tv78[ebp]
  00078	8b 02		 mov	 eax, DWORD PTR [edx]
  0007a	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  0007d	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00080	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
  00085	89 45 e0	 mov	 DWORD PTR tv86[ebp], eax
  00088	8b 4d e4	 mov	 ecx, DWORD PTR tv88[ebp]
  0008b	51		 push	 ecx
  0008c	8b 55 e0	 mov	 edx, DWORD PTR tv86[ebp]
  0008f	52		 push	 edx
  00090	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00093	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 3036 :     }

  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c2 08 00	 ret	 8
?_Copy_assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXABV12@U?$integral_constant@_N$0A@@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy_assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S35$ = -88						; size = 1
tv146 = -46						; size = 1
tv136 = -45						; size = 1
tv94 = -44						; size = 4
_this$ = -40						; size = 4
tv143 = -36						; size = 4
tv133 = -32						; size = 4
tv76 = -28						; size = 4
tv83 = -24						; size = 4
tv92 = -20						; size = 4
__To_delete$ = -16					; size = 4
__Alproxy$ = -12					; size = 4
tv129 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3002 :     _CONSTEXPR20_CONTAINER ~basic_string() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 ec	 mov	 DWORD PTR tv92[ebp], eax
  00044	8b 4d ec	 mov	 ecx, DWORD PTR tv92[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d d4	 mov	 DWORD PTR tv94[ebp], ecx
  00053	8b 55 d4	 mov	 edx, DWORD PTR tv94[ebp]
  00056	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0005c	83 45 d4 04	 add	 DWORD PTR tv94[ebp], 4
  00060	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00065	8b 4d d4	 mov	 ecx, DWORD PTR tv94[ebp]
  00068	66 89 01	 mov	 WORD PTR [ecx], ax
  0006b	83 45 d4 02	 add	 DWORD PTR tv94[ebp], 2
  0006f	8b 55 d4	 mov	 edx, DWORD PTR tv94[ebp]
  00072	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00075	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0007a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3003 :         _Tidy_deallocate();

  0007f	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00082	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3004 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3005 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00087	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  0008f	50		 push	 eax
  00090	8d 4d a8	 lea	 ecx, DWORD PTR _$S35$[ebp]
  00093	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  00098	8d 45 a8	 lea	 eax, DWORD PTR _$S35$[ebp]
  0009b	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 3006 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  0009e	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000a1	89 4d e4	 mov	 DWORD PTR tv76[ebp], ecx
  000a4	8b 55 e4	 mov	 edx, DWORD PTR tv76[ebp]
  000a7	89 55 dc	 mov	 DWORD PTR tv143[ebp], edx
  000aa	8b 45 dc	 mov	 eax, DWORD PTR tv143[ebp]
  000ad	c1 e8 03	 shr	 eax, 3
  000b0	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b6	88 4d d2	 mov	 BYTE PTR tv146[ebp], cl
  000b9	80 7d d2 00	 cmp	 BYTE PTR tv146[ebp], 0
  000bd	74 1a		 je	 SHORT $LN4@basic_stri
  000bf	8a 55 dc	 mov	 dl, BYTE PTR tv143[ebp]
  000c2	80 e2 07	 and	 dl, 7
  000c5	80 c2 03	 add	 dl, 3
  000c8	3a 55 d2	 cmp	 dl, BYTE PTR tv146[ebp]
  000cb	7c 0c		 jl	 SHORT $LN4@basic_stri
  000cd	8b 45 dc	 mov	 eax, DWORD PTR tv143[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ___asan_report_load4
  000d6	83 c4 04	 add	 esp, 4
$LN4@basic_stri:
  000d9	8b 4d e4	 mov	 ecx, DWORD PTR tv76[ebp]
  000dc	8b 11		 mov	 edx, DWORD PTR [ecx]
  000de	89 55 f0	 mov	 DWORD PTR __To_delete$[ebp], edx

; 3007 :         _Mypair._Myval2._Myproxy = nullptr;

  000e1	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  000e4	89 45 e8	 mov	 DWORD PTR tv83[ebp], eax
  000e7	8b 4d e8	 mov	 ecx, DWORD PTR tv83[ebp]
  000ea	89 4d e0	 mov	 DWORD PTR tv133[ebp], ecx
  000ed	8b 55 e0	 mov	 edx, DWORD PTR tv133[ebp]
  000f0	c1 ea 03	 shr	 edx, 3
  000f3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f9	88 45 d3	 mov	 BYTE PTR tv136[ebp], al
  000fc	80 7d d3 00	 cmp	 BYTE PTR tv136[ebp], 0
  00100	74 1a		 je	 SHORT $LN3@basic_stri
  00102	8a 4d e0	 mov	 cl, BYTE PTR tv133[ebp]
  00105	80 e1 07	 and	 cl, 7
  00108	80 c1 03	 add	 cl, 3
  0010b	3a 4d d3	 cmp	 cl, BYTE PTR tv136[ebp]
  0010e	7c 0c		 jl	 SHORT $LN3@basic_stri
  00110	8b 55 e0	 mov	 edx, DWORD PTR tv133[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_report_store4
  00119	83 c4 04	 add	 esp, 4
$LN3@basic_stri:
  0011c	8b 45 e8	 mov	 eax, DWORD PTR tv83[ebp]
  0011f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 3008 :         _Delete_plain_internal(_Alproxy, _To_delete);

  00125	8b 4d f0	 mov	 ecx, DWORD PTR __To_delete$[ebp]
  00128	51		 push	 ecx
  00129	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  0012c	52		 push	 edx
  0012d	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00132	83 c4 08	 add	 esp, 8

; 3009 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3010 :     }

  00135	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  00138	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0013d	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00144	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00147	c1 e8 03	 shr	 eax, 3
  0014a	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0014f	89 45 f8	 mov	 DWORD PTR tv129[ebp], eax
  00152	6a 07		 push	 7
  00154	8b 4d f8	 mov	 ecx, DWORD PTR tv129[ebp]
  00157	51		 push	 ecx
  00158	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0015d	83 c4 08	 add	 esp, 8
  00160	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00163	33 cd		 xor	 ecx, ebp
  00165	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0016a	8b e5		 mov	 esp, ebp
  0016c	5d		 pop	 ebp
  0016d	8b e3		 mov	 esp, ebx
  0016f	5b		 pop	 ebx
  00170	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
_TEXT	SEGMENT
__asan_gen_0$ = -144					; size = 4
__asan_gen_1$ = -140					; size = 4
__asan_gen_2$ = -136					; size = 4
_$S37$ = -128						; size = 1
__Proxy$ = -112						; size = 8
$T3 = -65						; size = 1
tv132 = -64						; size = 4
_this$ = -60						; size = 4
tv66 = -56						; size = 4
tv69 = -52						; size = 4
__Alproxy$ = -48					; size = 4
tv135 = -44						; size = 4
tv77 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2517 :     _CONSTEXPR20_CONTAINER basic_string(_In_z_ const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d c4	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 70 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 74 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  00056	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00060	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c8	 mov	 DWORD PTR tv66[ebp], eax
  00069	8b 4d c8	 mov	 ecx, DWORD PTR tv66[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d c0	 mov	 DWORD PTR tv132[ebp], ecx
  00078	8b 55 c0	 mov	 edx, DWORD PTR tv132[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 c0 04	 add	 DWORD PTR tv132[ebp], 4
  00085	8b 45 c0	 mov	 eax, DWORD PTR tv132[ebp]
  00088	c7 00 00 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116352 ; f3f3f300H
  0008e	83 45 c0 04	 add	 DWORD PTR tv132[ebp], 4
  00092	8b 4d c0	 mov	 ecx, DWORD PTR tv132[ebp]
  00095	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00098	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0009d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000a2	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  000a5	89 55 cc	 mov	 DWORD PTR tv69[ebp], edx
  000a8	0f b6 45 bf	 movzx	 eax, BYTE PTR $T3[ebp]
  000ac	50		 push	 eax
  000ad	8b 4d cc	 mov	 ecx, DWORD PTR tv69[ebp]
  000b0	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
  000b5	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 2518 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000bc	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000bf	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  000c4	50		 push	 eax
  000c5	8d 4d 80	 lea	 ecx, DWORD PTR _$S37$[ebp]
  000c8	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  000cd	8d 4d 80	 lea	 ecx, DWORD PTR _$S37$[ebp]
  000d0	89 4d d0	 mov	 DWORD PTR __Alproxy$[ebp], ecx

; 2519 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000d3	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  000d6	52		 push	 edx
  000d7	8b 45 d0	 mov	 eax, DWORD PTR __Alproxy$[ebp]
  000da	50		 push	 eax
  000db	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000de	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000e3	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 2520 :         _Tidy_init();

  000e7	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000ea	e8 00 00 00 00	 call	 ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init

; 2521 :         assign(_Ptr);

  000ef	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000f2	51		 push	 ecx
  000f3	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@QBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2522 :         _Proxy._Release();

  000fb	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000fe	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 2523 :     }

  00103	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00107	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0010a	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0010f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00116	8b 55 c4	 mov	 edx, DWORD PTR _this$[ebp]
  00119	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
  0011c	c7 85 70 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00126	8d 85 70 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0012c	c1 e8 03	 shr	 eax, 3
  0012f	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00134	89 45 d4	 mov	 DWORD PTR tv135[ebp], eax
  00137	6a 09		 push	 9
  00139	8b 4d d4	 mov	 ecx, DWORD PTR tv135[ebp]
  0013c	51		 push	 ecx
  0013d	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00142	83 c4 08	 add	 esp, 8
  00145	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  00148	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0014b	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00152	59		 pop	 ecx
  00153	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00156	33 cd		 xor	 ecx, ebp
  00158	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015d	8b e5		 mov	 esp, ebp
  0015f	5d		 pop	 ebp
  00160	8b e3		 mov	 esp, ebx
  00162	5b		 pop	 ebx
  00163	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$0:
  00000	8b 4d c4	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
__unwindfunclet$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z$1:
  00008	8d 4d 90	 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
  00014	cc		 int	 3
__ehhandler$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z:
  00015	90		 npad	 1
  00016	90		 npad	 1
  00017	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001b	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001e	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0002e	33 c8		 xor	 ecx, eax
  00030	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00035	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z
  0003a	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@QBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	83 c1 04	 add	 ecx, 4
  0000d	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  00012	8b e5		 mov	 esp, ebp
  00014	5d		 pop	 ebp
  00015	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2348 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b e5		 mov	 esp, ebp
  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Bxty
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Bxty
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Bxty:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
tv69 = -16						; size = 4
tv67 = -12						; size = 4
tv74 = -8						; size = 4
tv77 = -1						; size = 1
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2313 :     _CONSTEXPR20_CONTAINER bool _Large_string_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2314 : #ifdef __cpp_lib_constexpr_string
; 2315 :         if (_STD is_constant_evaluated()) {

  00013	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00018	0f b6 c0	 movzx	 eax, al
  0001b	85 c0		 test	 eax, eax
  0001d	74 04		 je	 SHORT $LN2@Large_stri

; 2316 :             return true;

  0001f	b0 01		 mov	 al, 1
  00021	eb 59		 jmp	 SHORT $LN3@Large_stri
$LN2@Large_stri:

; 2317 :         }
; 2318 : #endif // __cpp_lib_constexpr_string
; 2319 :         return _BUF_SIZE <= _Myres;

  00023	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	83 c1 18	 add	 ecx, 24			; 00000018H
  00029	89 4d f4	 mov	 DWORD PTR tv67[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv67[ebp]
  0002f	89 55 f8	 mov	 DWORD PTR tv74[ebp], edx
  00032	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
  00035	c1 e8 03	 shr	 eax, 3
  00038	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003e	88 4d ff	 mov	 BYTE PTR tv77[ebp], cl
  00041	80 7d ff 00	 cmp	 BYTE PTR tv77[ebp], 0
  00045	74 1a		 je	 SHORT $LN6@Large_stri
  00047	8a 55 f8	 mov	 dl, BYTE PTR tv74[ebp]
  0004a	80 e2 07	 and	 dl, 7
  0004d	80 c2 03	 add	 dl, 3
  00050	3a 55 ff	 cmp	 dl, BYTE PTR tv77[ebp]
  00053	7c 0c		 jl	 SHORT $LN6@Large_stri
  00055	8b 45 f8	 mov	 eax, DWORD PTR tv74[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ___asan_report_load4
  0005e	83 c4 04	 add	 esp, 4
$LN6@Large_stri:
  00061	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  00064	83 39 10	 cmp	 DWORD PTR [ecx], 16	; 00000010H
  00067	72 09		 jb	 SHORT $LN4@Large_stri
  00069	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv69[ebp], 1
  00070	eb 07		 jmp	 SHORT $LN5@Large_stri
$LN4@Large_stri:
  00072	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], 0
$LN5@Large_stri:
  00079	8a 45 f0	 mov	 al, BYTE PTR tv69[ebp]
$LN3@Large_stri:

; 2320 :     }

  0007c	8b e5		 mov	 esp, ebp
  0007e	5d		 pop	 ebp
  0007f	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
tv72 = -16						; size = 4
tv77 = -12						; size = 4
_this$ = -8						; size = 4
tv80 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2304 :     _CONSTEXPR20_CONTAINER const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2305 :         const value_type* _Result = _Bx._Buf;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 2306 :         if (_Large_string_engaged()) {

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00024	0f b6 c8	 movzx	 ecx, al
  00027	85 c9		 test	 ecx, ecx
  00029	74 4d		 je	 SHORT $LN2@Myptr

; 2307 :             _Result = _Unfancy(_Bx._Ptr);

  0002b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	83 c2 04	 add	 edx, 4
  00031	89 55 f0	 mov	 DWORD PTR tv72[ebp], edx
  00034	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  00037	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00046	88 55 ff	 mov	 BYTE PTR tv80[ebp], dl
  00049	80 7d ff 00	 cmp	 BYTE PTR tv80[ebp], 0
  0004d	74 18		 je	 SHORT $LN4@Myptr
  0004f	8a 45 f4	 mov	 al, BYTE PTR tv77[ebp]
  00052	24 07		 and	 al, 7
  00054	04 03		 add	 al, 3
  00056	3a 45 ff	 cmp	 al, BYTE PTR tv80[ebp]
  00059	7c 0c		 jl	 SHORT $LN4@Myptr
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ___asan_report_load4
  00064	83 c4 04	 add	 esp, 4
$LN4@Myptr:
  00067	8b 55 f0	 mov	 edx, DWORD PTR tv72[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2308 :         }
; 2309 : 
; 2310 :         return _Result;

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 2311 :     }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
tv72 = -16						; size = 4
tv77 = -12						; size = 4
_this$ = -8						; size = 4
tv80 = -1						; size = 1
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2295 :     _CONSTEXPR20_CONTAINER value_type* _Myptr() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2296 :         value_type* _Result = _Bx._Buf;

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 2297 :         if (_Large_string_engaged()) {

  0001c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  00024	0f b6 c8	 movzx	 ecx, al
  00027	85 c9		 test	 ecx, ecx
  00029	74 4d		 je	 SHORT $LN2@Myptr

; 2298 :             _Result = _Unfancy(_Bx._Ptr);

  0002b	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0002e	83 c2 04	 add	 edx, 4
  00031	89 55 f0	 mov	 DWORD PTR tv72[ebp], edx
  00034	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  00037	89 45 f4	 mov	 DWORD PTR tv77[ebp], eax
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00046	88 55 ff	 mov	 BYTE PTR tv80[ebp], dl
  00049	80 7d ff 00	 cmp	 BYTE PTR tv80[ebp], 0
  0004d	74 18		 je	 SHORT $LN4@Myptr
  0004f	8a 45 f4	 mov	 al, BYTE PTR tv77[ebp]
  00052	24 07		 and	 al, 7
  00054	04 03		 add	 al, 3
  00056	3a 45 ff	 cmp	 al, BYTE PTR tv80[ebp]
  00059	7c 0c		 jl	 SHORT $LN4@Myptr
  0005b	8b 4d f4	 mov	 ecx, DWORD PTR tv77[ebp]
  0005e	51		 push	 ecx
  0005f	e8 00 00 00 00	 call	 ___asan_report_load4
  00064	83 c4 04	 add	 esp, 4
$LN4@Myptr:
  00067	8b 55 f0	 mov	 edx, DWORD PTR tv72[ebp]
  0006a	8b 02		 mov	 eax, DWORD PTR [edx]
  0006c	50		 push	 eax
  0006d	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  00072	83 c4 04	 add	 esp, 4
  00075	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2299 :         }
; 2300 : 
; 2301 :         return _Result;

  00078	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 2302 :     }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv75 = -24						; size = 4
tv74 = -20						; size = 4
tv80 = -16						; size = 4
tv90 = -12						; size = 4
_this$ = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 2284 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	83 c1 04	 add	 ecx, 4
  00021	e8 00 00 00 00	 call	 ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty

; 2285 : 
; 2286 :     // length of internal buffer, [1, 16]:
; 2287 :     static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);
; 2288 :     // roundup mask for allocated buffers, [0, 15]:
; 2289 :     static constexpr size_type _ALLOC_MASK = sizeof(value_type) <= 1 ? 15
; 2290 :                                            : sizeof(value_type) <= 2 ? 7
; 2291 :                                            : sizeof(value_type) <= 4 ? 3
; 2292 :                                            : sizeof(value_type) <= 8 ? 1
; 2293 :                                                                      : 0;
; 2294 : 
; 2295 :     _CONSTEXPR20_CONTAINER value_type* _Myptr() noexcept {
; 2296 :         value_type* _Result = _Bx._Buf;
; 2297 :         if (_Large_string_engaged()) {
; 2298 :             _Result = _Unfancy(_Bx._Ptr);
; 2299 :         }
; 2300 : 
; 2301 :         return _Result;
; 2302 :     }
; 2303 : 
; 2304 :     _CONSTEXPR20_CONTAINER const value_type* _Myptr() const noexcept {
; 2305 :         const value_type* _Result = _Bx._Buf;
; 2306 :         if (_Large_string_engaged()) {
; 2307 :             _Result = _Unfancy(_Bx._Ptr);
; 2308 :         }
; 2309 : 
; 2310 :         return _Result;
; 2311 :     }
; 2312 : 
; 2313 :     _CONSTEXPR20_CONTAINER bool _Large_string_engaged() const noexcept {
; 2314 : #ifdef __cpp_lib_constexpr_string
; 2315 :         if (_STD is_constant_evaluated()) {
; 2316 :             return true;
; 2317 :         }
; 2318 : #endif // __cpp_lib_constexpr_string
; 2319 :         return _BUF_SIZE <= _Myres;
; 2320 :     }
; 2321 : 
; 2322 :     _CONSTEXPR20_CONTAINER void _Check_offset(const size_type _Off) const {
; 2323 :         // checks whether _Off is in the bounds of [0, size()]
; 2324 :         if (_Mysize < _Off) {
; 2325 :             _Xran();
; 2326 :         }
; 2327 :     }
; 2328 : 
; 2329 :     _CONSTEXPR20_CONTAINER void _Check_offset_exclusive(const size_type _Off) const {
; 2330 :         // checks whether _Off is in the bounds of [0, size())
; 2331 :         if (_Mysize <= _Off) {
; 2332 :             _Xran();
; 2333 :         }
; 2334 :     }
; 2335 : 
; 2336 :     [[noreturn]] static void _Xran() {
; 2337 :         _Xout_of_range("invalid string position");
; 2338 :     }
; 2339 : 
; 2340 :     _CONSTEXPR20_CONTAINER size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept {
; 2341 :         // trims _Size to the longest it can be assuming a string at/after _Off
; 2342 :         return (_STD min)(_Size, _Mysize - _Off);
; 2343 :     }
; 2344 : 
; 2345 :     union _Bxty { // storage for small buffer or pointer to larger one
; 2346 :         _CONSTEXPR20_CONTAINER _Bxty() noexcept : _Ptr() {} // user-provided, for fancy pointers
; 2347 : 
; 2348 :         _CONSTEXPR20_CONTAINER ~_Bxty() noexcept {} // user-provided, for fancy pointers
; 2349 : 
; 2350 :         value_type _Buf[_BUF_SIZE];
; 2351 :         pointer _Ptr;
; 2352 :         char _Alias[_BUF_SIZE]; // TRANSITION, ABI: _Alias is preserved for binary compatibility (especially /clr)
; 2353 :     } _Bx;
; 2354 : 
; 2355 :     size_type _Mysize = 0; // current length of string

  00026	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00029	83 c0 14	 add	 eax, 20			; 00000014H
  0002c	89 45 ec	 mov	 DWORD PTR tv74[ebp], eax
  0002f	8b 4d ec	 mov	 ecx, DWORD PTR tv74[ebp]
  00032	89 4d f4	 mov	 DWORD PTR tv90[ebp], ecx
  00035	8b 55 f4	 mov	 edx, DWORD PTR tv90[ebp]
  00038	c1 ea 03	 shr	 edx, 3
  0003b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00041	88 45 ff	 mov	 BYTE PTR tv93[ebp], al
  00044	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00048	74 1a		 je	 SHORT $LN4@String_val
  0004a	8a 4d f4	 mov	 cl, BYTE PTR tv90[ebp]
  0004d	80 e1 07	 and	 cl, 7
  00050	80 c1 03	 add	 cl, 3
  00053	3a 4d ff	 cmp	 cl, BYTE PTR tv93[ebp]
  00056	7c 0c		 jl	 SHORT $LN4@String_val
  00058	8b 55 f4	 mov	 edx, DWORD PTR tv90[ebp]
  0005b	52		 push	 edx
  0005c	e8 00 00 00 00	 call	 ___asan_report_store4
  00061	83 c4 04	 add	 esp, 4
$LN4@String_val:
  00064	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  00067	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 2356 :     size_type _Myres  = 0; // current storage reserved for string

  0006d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	83 c1 18	 add	 ecx, 24			; 00000018H
  00073	89 4d e8	 mov	 DWORD PTR tv75[ebp], ecx
  00076	8b 55 e8	 mov	 edx, DWORD PTR tv75[ebp]
  00079	89 55 f0	 mov	 DWORD PTR tv80[ebp], edx
  0007c	8b 45 f0	 mov	 eax, DWORD PTR tv80[ebp]
  0007f	c1 e8 03	 shr	 eax, 3
  00082	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00088	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  0008b	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008f	74 1a		 je	 SHORT $LN3@String_val
  00091	8a 55 f0	 mov	 dl, BYTE PTR tv80[ebp]
  00094	80 e2 07	 and	 dl, 7
  00097	80 c2 03	 add	 dl, 3
  0009a	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009d	7c 0c		 jl	 SHORT $LN3@String_val
  0009f	8b 45 f0	 mov	 eax, DWORD PTR tv80[ebp]
  000a2	50		 push	 eax
  000a3	e8 00 00 00 00	 call	 ___asan_report_store4
  000a8	83 c4 04	 add	 esp, 4
$LN3@String_val:
  000ab	8b 4d e8	 mov	 ecx, DWORD PTR tv75[ebp]
  000ae	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 2284 :     _CONSTEXPR20_CONTAINER _String_val() noexcept : _Bx() {}

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b7	8b e5		 mov	 esp, ebp
  000b9	5d		 pop	 ebp
  000ba	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	83 c8 ff	 or	 eax, -1

; 729  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$00@std@@YAII@Z ; std::_Get_size_of_n<1>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0001e	83 c4 08	 add	 esp, 8

; 836  :     }

  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?_Xlen_string@std@@YAXXZ
_TEXT	SEGMENT
?_Xlen_string@std@@YAXXZ PROC				; std::_Xlen_string, COMDAT

; 2373 : [[noreturn]] inline void _Xlen_string() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2374 :     _Xlength_error("string too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlen_strin:

; 2375 : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlen_string@std@@YAXXZ ENDP				; std::_Xlen_string
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
tv68 = -20						; size = 4
tv65 = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 449  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 450  :         _Left = _Right;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00013	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  0002f	74 17		 je	 SHORT $LN4@assign
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  0003a	7c 0c		 jl	 SHORT $LN4@assign
  0003c	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  0003f	52		 push	 edx
  00040	e8 00 00 00 00	 call	 ___asan_report_load1
  00045	83 c4 04	 add	 esp, 4
$LN4@assign:
  00048	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0004b	89 45 ec	 mov	 DWORD PTR tv68[ebp], eax
  0004e	8b 4d ec	 mov	 ecx, DWORD PTR tv68[ebp]
  00051	89 4d f4	 mov	 DWORD PTR tv71[ebp], ecx
  00054	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00057	c1 ea 03	 shr	 edx, 3
  0005a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00060	88 45 fe	 mov	 BYTE PTR tv74[ebp], al
  00063	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00067	74 17		 je	 SHORT $LN3@assign
  00069	8a 4d f4	 mov	 cl, BYTE PTR tv71[ebp]
  0006c	80 e1 07	 and	 cl, 7
  0006f	3a 4d fe	 cmp	 cl, BYTE PTR tv74[ebp]
  00072	7c 0c		 jl	 SHORT $LN3@assign
  00074	8b 55 f4	 mov	 edx, DWORD PTR tv71[ebp]
  00077	52		 push	 edx
  00078	e8 00 00 00 00	 call	 ___asan_report_store1
  0007d	83 c4 04	 add	 esp, 4
$LN3@assign:
  00080	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00083	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00086	8a 11		 mov	 dl, BYTE PTR [ecx]
  00088	88 10		 mov	 BYTE PTR [eax], dl

; 451  :     }

  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 438  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 439  :         // assign _Count * _Ch to [_First, ...)
; 440  : #ifdef __cpp_lib_is_constant_evaluated
; 441  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 17		 je	 SHORT $LN2@assign

; 442  :             return _Primary_char_traits::assign(_First, _Count, _Ch);

  00019	0f b6 4d 10	 movzx	 ecx, BYTE PTR __Ch$[ebp]
  0001d	51		 push	 ecx
  0001e	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00021	52		 push	 edx
  00022	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00025	50		 push	 eax
  00026	e8 00 00 00 00	 call	 ?assign@?$_Char_traits@DH@std@@SAPADQADID@Z ; std::_Char_traits<char,int>::assign
  0002b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0002e	eb 15		 jmp	 SHORT $LN3@assign
$LN2@assign:

; 443  :         }
; 444  : #endif // __cpp_lib_is_constant_evaluated
; 445  : 
; 446  :         return static_cast<_Elem*>(_CSTD memset(_First, _Ch, _Count));

  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	0f be 55 10	 movsx	 edx, BYTE PTR __Ch$[ebp]
  00038	52		 push	 edx
  00039	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  0003c	50		 push	 eax
  0003d	e8 00 00 00 00	 call	 _memset
  00042	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN3@assign:

; 447  :     }

  00045	5d		 pop	 ebp
  00046	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
tv66 = -16						; size = 4
tv72 = -12						; size = 4
tv69 = -8						; size = 4
tv75 = -1						; size = 1
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 396  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 397  :         // find length of null-terminated string
; 398  : #if _HAS_CXX17
; 399  : #ifdef __cpp_char8_t
; 400  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 401  : #if _HAS_U8_INTRINSICS
; 402  :             return __builtin_u8strlen(_First);
; 403  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 404  :             return _Primary_char_traits::length(_First);
; 405  : #endif // _HAS_U8_INTRINSICS
; 406  :         } else
; 407  : #endif // __cpp_char8_t
; 408  :         {
; 409  :             return __builtin_strlen(_First);

  00010	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00013	89 45 f8	 mov	 DWORD PTR tv69[ebp], eax
  00016	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00019	83 c1 01	 add	 ecx, 1
  0001c	89 4d f4	 mov	 DWORD PTR tv72[ebp], ecx
$LL3@length:
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv69[ebp]
  00022	8a 02		 mov	 al, BYTE PTR [edx]
  00024	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00027	83 45 f8 01	 add	 DWORD PTR tv69[ebp], 1
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  0002f	75 ee		 jne	 SHORT $LL3@length
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv69[ebp]
  00034	2b 4d f4	 sub	 ecx, DWORD PTR tv72[ebp]
  00037	89 4d f0	 mov	 DWORD PTR tv66[ebp], ecx
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv66[ebp]

; 410  :         }
; 411  : #else // _HAS_CXX17
; 412  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));
; 413  : #endif // _HAS_CXX17
; 414  :     }

  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?assign@?$_Char_traits@DH@std@@SAPADQADID@Z
_TEXT	SEGMENT
tv76 = -20						; size = 4
tv79 = -16						; size = 4
__Next$1 = -12						; size = 4
__Next$2 = -8						; size = 4
tv82 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$_Char_traits@DH@std@@SAPADQADID@Z PROC	; std::_Char_traits<char,int>::assign, COMDAT

; 167  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, const _Elem _Ch) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         // assign _Count * _Ch to [_First, ...)
; 169  : #ifdef __cpp_lib_constexpr_string
; 170  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 34		 je	 SHORT $LN8@assign

; 171  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0001f	89 4d f4	 mov	 DWORD PTR __Next$1[ebp], ecx
  00022	eb 12		 jmp	 SHORT $LN4@assign
$LN2@assign:
  00024	8b 55 0c	 mov	 edx, DWORD PTR __Count$[ebp]
  00027	83 ea 01	 sub	 edx, 1
  0002a	89 55 0c	 mov	 DWORD PTR __Count$[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR __Next$1[ebp]
  00030	83 c0 01	 add	 eax, 1
  00033	89 45 f4	 mov	 DWORD PTR __Next$1[ebp], eax
$LN4@assign:
  00036	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0003a	76 12		 jbe	 SHORT $LN3@assign

; 172  :                 _STD construct_at(_Next, _Ch);

  0003c	8d 4d 10	 lea	 ecx, DWORD PTR __Ch$[ebp]
  0003f	51		 push	 ecx
  00040	8b 55 f4	 mov	 edx, DWORD PTR __Next$1[ebp]
  00043	52		 push	 edx
  00044	e8 00 00 00 00	 call	 ??$construct_at@DABDX@std@@YAPADQADABD@Z ; std::construct_at<char,char const &,void>
  00049	83 c4 08	 add	 esp, 8

; 173  :             }

  0004c	eb d6		 jmp	 SHORT $LN2@assign
$LN3@assign:

; 174  :         } else

  0004e	eb 62		 jmp	 SHORT $LN9@assign
$LN8@assign:

; 175  : #endif // __cpp_lib_constexpr_string
; 176  :         {
; 177  :             for (_Elem* _Next = _First; _Count > 0; --_Count, ++_Next) {

  00050	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00053	89 45 f8	 mov	 DWORD PTR __Next$2[ebp], eax
  00056	eb 12		 jmp	 SHORT $LN7@assign
$LN5@assign:
  00058	8b 4d 0c	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	83 e9 01	 sub	 ecx, 1
  0005e	89 4d 0c	 mov	 DWORD PTR __Count$[ebp], ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR __Next$2[ebp]
  00064	83 c2 01	 add	 edx, 1
  00067	89 55 f8	 mov	 DWORD PTR __Next$2[ebp], edx
$LN7@assign:
  0006a	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  0006e	76 42		 jbe	 SHORT $LN9@assign

; 178  :                 *_Next = _Ch;

  00070	8b 45 f8	 mov	 eax, DWORD PTR __Next$2[ebp]
  00073	89 45 ec	 mov	 DWORD PTR tv76[ebp], eax
  00076	8b 4d ec	 mov	 ecx, DWORD PTR tv76[ebp]
  00079	89 4d f0	 mov	 DWORD PTR tv79[ebp], ecx
  0007c	8b 55 f0	 mov	 edx, DWORD PTR tv79[ebp]
  0007f	c1 ea 03	 shr	 edx, 3
  00082	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00088	88 45 ff	 mov	 BYTE PTR tv82[ebp], al
  0008b	80 7d ff 00	 cmp	 BYTE PTR tv82[ebp], 0
  0008f	74 17		 je	 SHORT $LN11@assign
  00091	8a 4d f0	 mov	 cl, BYTE PTR tv79[ebp]
  00094	80 e1 07	 and	 cl, 7
  00097	3a 4d ff	 cmp	 cl, BYTE PTR tv82[ebp]
  0009a	7c 0c		 jl	 SHORT $LN11@assign
  0009c	8b 55 f0	 mov	 edx, DWORD PTR tv79[ebp]
  0009f	52		 push	 edx
  000a0	e8 00 00 00 00	 call	 ___asan_report_store1
  000a5	83 c4 04	 add	 esp, 4
$LN11@assign:
  000a8	8b 45 f8	 mov	 eax, DWORD PTR __Next$2[ebp]
  000ab	8a 4d 10	 mov	 cl, BYTE PTR __Ch$[ebp]
  000ae	88 08		 mov	 BYTE PTR [eax], cl

; 179  :             }

  000b0	eb a6		 jmp	 SHORT $LN5@assign
$LN9@assign:

; 180  :         }
; 181  : 
; 182  :         return _First;

  000b2	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]

; 183  :     }

  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
?assign@?$_Char_traits@DH@std@@SAPADQADID@Z ENDP	; std::_Char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
tv89 = -52						; size = 4
tv85 = -48						; size = 4
tv79 = -44						; size = 4
tv77 = -40						; size = 4
tv134 = -36						; size = 4
tv144 = -32						; size = 4
tv154 = -28						; size = 4
tv164 = -24						; size = 4
__Src$1 = -20						; size = 4
__Idx$2 = -16						; size = 4
__Idx$3 = -12						; size = 4
tv137 = -5						; size = 1
tv147 = -4						; size = 1
tv157 = -3						; size = 1
tv167 = -2						; size = 1
__Loop_forward$4 = -1					; size = 1
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::move, COMDAT

; 80   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 81   :         // copy [_First2, _First2 + _Count) to [_First1, ...), allowing overlap
; 82   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 83   :         __builtin_memmove(_First1, _First2, _Count * sizeof(_Elem));
; 84   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 85   : #ifdef __cpp_lib_is_constant_evaluated
; 86   :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 ab 01 00
	00		 je	 $LN11@move

; 87   :             // dest: [_First1, _First1 + _Count)
; 88   :             // src: [_First2, _First2 + _Count)
; 89   :             // We need to handle overlapping ranges.
; 90   :             // If _First1 is in the src range, we need a backward loop.
; 91   :             // Otherwise, the forward loop works (even if the back of dest overlaps the front of src).
; 92   : 
; 93   :             if (_First1 == _First2) {

  00020	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00023	3b 4d 0c	 cmp	 ecx, DWORD PTR __First2$[ebp]
  00026	75 08		 jne	 SHORT $LN12@move

; 94   :                 return _First1; // Self-assignment; either loop would work, but returning immediately is faster.

  00028	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  0002b	e9 b2 01 00 00	 jmp	 $LN16@move
$LN12@move:

; 95   :             }
; 96   : 
; 97   :             // Usually, we would compare pointers with less-than, even though they could belong to different arrays.
; 98   :             // However, we're not allowed to do that during constant evaluation, so we need a linear scan for equality.
; 99   :             bool _Loop_forward = true;

  00030	c6 45 ff 01	 mov	 BYTE PTR __Loop_forward$4[ebp], 1

; 100  : 
; 101  :             for (const _Elem* _Src = _First2; _Src != _First2 + _Count; ++_Src) {

  00034	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  00037	89 55 ec	 mov	 DWORD PTR __Src$1[ebp], edx
  0003a	eb 09		 jmp	 SHORT $LN4@move
$LN2@move:
  0003c	8b 45 ec	 mov	 eax, DWORD PTR __Src$1[ebp]
  0003f	83 c0 01	 add	 eax, 1
  00042	89 45 ec	 mov	 DWORD PTR __Src$1[ebp], eax
$LN4@move:
  00045	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  00048	03 4d 10	 add	 ecx, DWORD PTR __Count$[ebp]
  0004b	39 4d ec	 cmp	 DWORD PTR __Src$1[ebp], ecx
  0004e	74 10		 je	 SHORT $LN3@move

; 102  :                 if (_First1 == _Src) {

  00050	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  00053	3b 55 ec	 cmp	 edx, DWORD PTR __Src$1[ebp]
  00056	75 06		 jne	 SHORT $LN13@move

; 103  :                     _Loop_forward = false;

  00058	c6 45 ff 00	 mov	 BYTE PTR __Loop_forward$4[ebp], 0

; 104  :                     break;

  0005c	eb 02		 jmp	 SHORT $LN3@move
$LN13@move:

; 105  :                 }
; 106  :             }

  0005e	eb dc		 jmp	 SHORT $LN2@move
$LN3@move:

; 107  : 
; 108  :             if (_Loop_forward) {

  00060	0f b6 45 ff	 movzx	 eax, BYTE PTR __Loop_forward$4[ebp]
  00064	85 c0		 test	 eax, eax
  00066	0f 84 a8 00 00
	00		 je	 $LN14@move

; 109  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  0006c	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR __Idx$3[ebp], 0
  00073	eb 09		 jmp	 SHORT $LN7@move
$LN5@move:
  00075	8b 4d f4	 mov	 ecx, DWORD PTR __Idx$3[ebp]
  00078	83 c1 01	 add	 ecx, 1
  0007b	89 4d f4	 mov	 DWORD PTR __Idx$3[ebp], ecx
$LN7@move:
  0007e	8b 55 f4	 mov	 edx, DWORD PTR __Idx$3[ebp]
  00081	3b 55 10	 cmp	 edx, DWORD PTR __Count$[ebp]
  00084	0f 83 85 00 00
	00		 jae	 $LN6@move

; 110  :                     _First1[_Idx] = _First2[_Idx];

  0008a	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  0008d	03 45 f4	 add	 eax, DWORD PTR __Idx$3[ebp]
  00090	89 45 d4	 mov	 DWORD PTR tv79[ebp], eax
  00093	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  00096	03 4d f4	 add	 ecx, DWORD PTR __Idx$3[ebp]
  00099	89 4d d8	 mov	 DWORD PTR tv77[ebp], ecx
  0009c	8b 55 d4	 mov	 edx, DWORD PTR tv79[ebp]
  0009f	89 55 e8	 mov	 DWORD PTR tv164[ebp], edx
  000a2	8b 45 e8	 mov	 eax, DWORD PTR tv164[ebp]
  000a5	c1 e8 03	 shr	 eax, 3
  000a8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000ae	88 4d fe	 mov	 BYTE PTR tv167[ebp], cl
  000b1	80 7d fe 00	 cmp	 BYTE PTR tv167[ebp], 0
  000b5	74 17		 je	 SHORT $LN20@move
  000b7	8a 55 e8	 mov	 dl, BYTE PTR tv164[ebp]
  000ba	80 e2 07	 and	 dl, 7
  000bd	3a 55 fe	 cmp	 dl, BYTE PTR tv167[ebp]
  000c0	7c 0c		 jl	 SHORT $LN20@move
  000c2	8b 45 e8	 mov	 eax, DWORD PTR tv164[ebp]
  000c5	50		 push	 eax
  000c6	e8 00 00 00 00	 call	 ___asan_report_load1
  000cb	83 c4 04	 add	 esp, 4
$LN20@move:
  000ce	8b 4d d8	 mov	 ecx, DWORD PTR tv77[ebp]
  000d1	89 4d e4	 mov	 DWORD PTR tv154[ebp], ecx
  000d4	8b 55 e4	 mov	 edx, DWORD PTR tv154[ebp]
  000d7	c1 ea 03	 shr	 edx, 3
  000da	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000e0	88 45 fd	 mov	 BYTE PTR tv157[ebp], al
  000e3	80 7d fd 00	 cmp	 BYTE PTR tv157[ebp], 0
  000e7	74 17		 je	 SHORT $LN19@move
  000e9	8a 4d e4	 mov	 cl, BYTE PTR tv154[ebp]
  000ec	80 e1 07	 and	 cl, 7
  000ef	3a 4d fd	 cmp	 cl, BYTE PTR tv157[ebp]
  000f2	7c 0c		 jl	 SHORT $LN19@move
  000f4	8b 55 e4	 mov	 edx, DWORD PTR tv154[ebp]
  000f7	52		 push	 edx
  000f8	e8 00 00 00 00	 call	 ___asan_report_store1
  000fd	83 c4 04	 add	 esp, 4
$LN19@move:
  00100	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  00103	8b 4d d4	 mov	 ecx, DWORD PTR tv79[ebp]
  00106	8a 11		 mov	 dl, BYTE PTR [ecx]
  00108	88 10		 mov	 BYTE PTR [eax], dl

; 111  :                 }

  0010a	e9 66 ff ff ff	 jmp	 $LN5@move
$LN6@move:

; 112  :             } else {

  0010f	e9 b2 00 00 00	 jmp	 $LN15@move
$LN14@move:

; 113  :                 for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  00114	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR __Idx$2[ebp], 0
  0011b	eb 09		 jmp	 SHORT $LN10@move
$LN8@move:
  0011d	8b 45 f0	 mov	 eax, DWORD PTR __Idx$2[ebp]
  00120	83 c0 01	 add	 eax, 1
  00123	89 45 f0	 mov	 DWORD PTR __Idx$2[ebp], eax
$LN10@move:
  00126	8b 4d f0	 mov	 ecx, DWORD PTR __Idx$2[ebp]
  00129	3b 4d 10	 cmp	 ecx, DWORD PTR __Count$[ebp]
  0012c	0f 83 94 00 00
	00		 jae	 $LN15@move

; 114  :                     _First1[_Count - 1 - _Idx] = _First2[_Count - 1 - _Idx];

  00132	8b 55 10	 mov	 edx, DWORD PTR __Count$[ebp]
  00135	83 ea 01	 sub	 edx, 1
  00138	2b 55 f0	 sub	 edx, DWORD PTR __Idx$2[ebp]
  0013b	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  0013e	03 c2		 add	 eax, edx
  00140	89 45 cc	 mov	 DWORD PTR tv89[ebp], eax
  00143	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  00146	83 e9 01	 sub	 ecx, 1
  00149	2b 4d f0	 sub	 ecx, DWORD PTR __Idx$2[ebp]
  0014c	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  0014f	03 d1		 add	 edx, ecx
  00151	89 55 d0	 mov	 DWORD PTR tv85[ebp], edx
  00154	8b 45 cc	 mov	 eax, DWORD PTR tv89[ebp]
  00157	89 45 e0	 mov	 DWORD PTR tv144[ebp], eax
  0015a	8b 4d e0	 mov	 ecx, DWORD PTR tv144[ebp]
  0015d	c1 e9 03	 shr	 ecx, 3
  00160	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00166	88 55 fc	 mov	 BYTE PTR tv147[ebp], dl
  00169	80 7d fc 00	 cmp	 BYTE PTR tv147[ebp], 0
  0016d	74 16		 je	 SHORT $LN18@move
  0016f	8a 45 e0	 mov	 al, BYTE PTR tv144[ebp]
  00172	24 07		 and	 al, 7
  00174	3a 45 fc	 cmp	 al, BYTE PTR tv147[ebp]
  00177	7c 0c		 jl	 SHORT $LN18@move
  00179	8b 4d e0	 mov	 ecx, DWORD PTR tv144[ebp]
  0017c	51		 push	 ecx
  0017d	e8 00 00 00 00	 call	 ___asan_report_load1
  00182	83 c4 04	 add	 esp, 4
$LN18@move:
  00185	8b 55 d0	 mov	 edx, DWORD PTR tv85[ebp]
  00188	89 55 dc	 mov	 DWORD PTR tv134[ebp], edx
  0018b	8b 45 dc	 mov	 eax, DWORD PTR tv134[ebp]
  0018e	c1 e8 03	 shr	 eax, 3
  00191	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00197	88 4d fb	 mov	 BYTE PTR tv137[ebp], cl
  0019a	80 7d fb 00	 cmp	 BYTE PTR tv137[ebp], 0
  0019e	74 17		 je	 SHORT $LN17@move
  001a0	8a 55 dc	 mov	 dl, BYTE PTR tv134[ebp]
  001a3	80 e2 07	 and	 dl, 7
  001a6	3a 55 fb	 cmp	 dl, BYTE PTR tv137[ebp]
  001a9	7c 0c		 jl	 SHORT $LN17@move
  001ab	8b 45 dc	 mov	 eax, DWORD PTR tv134[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ___asan_report_store1
  001b4	83 c4 04	 add	 esp, 4
$LN17@move:
  001b7	8b 4d d0	 mov	 ecx, DWORD PTR tv85[ebp]
  001ba	8b 55 cc	 mov	 edx, DWORD PTR tv89[ebp]
  001bd	8a 02		 mov	 al, BYTE PTR [edx]
  001bf	88 01		 mov	 BYTE PTR [ecx], al

; 115  :                 }

  001c1	e9 57 ff ff ff	 jmp	 $LN8@move
$LN15@move:

; 116  :             }
; 117  : 
; 118  :             return _First1;

  001c6	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  001c9	eb 17		 jmp	 SHORT $LN16@move
$LN11@move:

; 119  :         }
; 120  : #endif // __cpp_lib_is_constant_evaluated
; 121  : 
; 122  :         _CSTD memmove(_First1, _First2, _Count * sizeof(_Elem));

  001cb	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  001ce	51		 push	 ecx
  001cf	8b 55 0c	 mov	 edx, DWORD PTR __First2$[ebp]
  001d2	52		 push	 edx
  001d3	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  001d6	50		 push	 eax
  001d7	e8 00 00 00 00	 call	 _memmove
  001dc	83 c4 0c	 add	 esp, 12			; 0000000cH

; 123  : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 124  : 
; 125  :         return _First1;

  001df	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
$LN16@move:

; 126  :     }

  001e2	8b e5		 mov	 esp, ebp
  001e4	5d		 pop	 ebp
  001e5	c3		 ret	 0
?move@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::move
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstring
;	COMDAT ?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z
_TEXT	SEGMENT
tv72 = -24						; size = 4
tv70 = -20						; size = 4
tv81 = -16						; size = 4
tv91 = -12						; size = 4
__Idx$1 = -8						; size = 4
tv84 = -2						; size = 1
tv94 = -1						; size = 1
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z PROC	; std::_Char_traits<char,int>::copy, COMDAT

; 49   :         _In_reads_(_Count) const _Elem* const _First2, const size_t _Count) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __0D019051_xstring
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 50   :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 51   : #if _HAS_MEMCPY_MEMMOVE_INTRINSICS
; 52   :         __builtin_memcpy(_First1, _First2, _Count * sizeof(_Elem));
; 53   : #else // ^^^ _HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^ / vvv !_HAS_MEMCPY_MEMMOVE_INTRINSICS vvv
; 54   : #ifdef __cpp_lib_is_constant_evaluated
; 55   :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	0f 84 a8 00 00
	00		 je	 $LN5@copy

; 56   :             // pre: [_First1, _First1 + _Count) and [_First2, _First2 + _Count) do not overlap; see LWG-3085
; 57   :             for (size_t _Idx = 0; _Idx < _Count; ++_Idx) {

  00020	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR __Idx$1[ebp], 0
  00027	eb 09		 jmp	 SHORT $LN4@copy
$LN2@copy:
  00029	8b 4d f8	 mov	 ecx, DWORD PTR __Idx$1[ebp]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	89 4d f8	 mov	 DWORD PTR __Idx$1[ebp], ecx
$LN4@copy:
  00032	8b 55 f8	 mov	 edx, DWORD PTR __Idx$1[ebp]
  00035	3b 55 10	 cmp	 edx, DWORD PTR __Count$[ebp]
  00038	0f 83 85 00 00
	00		 jae	 $LN3@copy

; 58   :                 _First1[_Idx] = _First2[_Idx];

  0003e	8b 45 0c	 mov	 eax, DWORD PTR __First2$[ebp]
  00041	03 45 f8	 add	 eax, DWORD PTR __Idx$1[ebp]
  00044	89 45 e8	 mov	 DWORD PTR tv72[ebp], eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __First1$[ebp]
  0004a	03 4d f8	 add	 ecx, DWORD PTR __Idx$1[ebp]
  0004d	89 4d ec	 mov	 DWORD PTR tv70[ebp], ecx
  00050	8b 55 e8	 mov	 edx, DWORD PTR tv72[ebp]
  00053	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00056	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00059	c1 e8 03	 shr	 eax, 3
  0005c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00062	88 4d ff	 mov	 BYTE PTR tv94[ebp], cl
  00065	80 7d ff 00	 cmp	 BYTE PTR tv94[ebp], 0
  00069	74 17		 je	 SHORT $LN8@copy
  0006b	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0006e	80 e2 07	 and	 dl, 7
  00071	3a 55 ff	 cmp	 dl, BYTE PTR tv94[ebp]
  00074	7c 0c		 jl	 SHORT $LN8@copy
  00076	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ___asan_report_load1
  0007f	83 c4 04	 add	 esp, 4
$LN8@copy:
  00082	8b 4d ec	 mov	 ecx, DWORD PTR tv70[ebp]
  00085	89 4d f0	 mov	 DWORD PTR tv81[ebp], ecx
  00088	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  0008b	c1 ea 03	 shr	 edx, 3
  0008e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00094	88 45 fe	 mov	 BYTE PTR tv84[ebp], al
  00097	80 7d fe 00	 cmp	 BYTE PTR tv84[ebp], 0
  0009b	74 17		 je	 SHORT $LN7@copy
  0009d	8a 4d f0	 mov	 cl, BYTE PTR tv81[ebp]
  000a0	80 e1 07	 and	 cl, 7
  000a3	3a 4d fe	 cmp	 cl, BYTE PTR tv84[ebp]
  000a6	7c 0c		 jl	 SHORT $LN7@copy
  000a8	8b 55 f0	 mov	 edx, DWORD PTR tv81[ebp]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 ___asan_report_store1
  000b1	83 c4 04	 add	 esp, 4
$LN7@copy:
  000b4	8b 45 ec	 mov	 eax, DWORD PTR tv70[ebp]
  000b7	8b 4d e8	 mov	 ecx, DWORD PTR tv72[ebp]
  000ba	8a 11		 mov	 dl, BYTE PTR [ecx]
  000bc	88 10		 mov	 BYTE PTR [eax], dl

; 59   :             }

  000be	e9 66 ff ff ff	 jmp	 $LN2@copy
$LN3@copy:

; 60   : 
; 61   :             return _First1;

  000c3	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
  000c6	eb 17		 jmp	 SHORT $LN6@copy
$LN5@copy:

; 62   :         }
; 63   : #endif // __cpp_lib_is_constant_evaluated
; 64   : 
; 65   :         _CSTD memcpy(_First1, _First2, _Count * sizeof(_Elem));

  000c8	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  000cb	50		 push	 eax
  000cc	8b 4d 0c	 mov	 ecx, DWORD PTR __First2$[ebp]
  000cf	51		 push	 ecx
  000d0	8b 55 08	 mov	 edx, DWORD PTR __First1$[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 _memcpy
  000d9	83 c4 0c	 add	 esp, 12			; 0000000cH

; 66   : #endif // ^^^ !_HAS_MEMCPY_MEMMOVE_INTRINSICS ^^^
; 67   : 
; 68   :         return _First1;

  000dc	8b 45 08	 mov	 eax, DWORD PTR __First1$[ebp]
$LN6@copy:

; 69   :     }

  000df	8b e5		 mov	 esp, ebp
  000e1	5d		 pop	 ebp
  000e2	c3		 ret	 0
?copy@?$_Char_traits@DH@std@@SAPADQADQBDI@Z ENDP	; std::_Char_traits<char,int>::copy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv93 = -24						; size = 4
tv75 = -20						; size = 4
tv77 = -16						; size = 4
tv89 = -12						; size = 4
tv128 = -8						; size = 4
tv131 = -1						; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 30		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
  00047	83 c4 08	 add	 esp, 8

; 155  :     } else

  0004a	eb 7b		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0004c	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	6a 08		 push	 8
  00064	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00078	83 c4 04	 add	 esp, 4
  0007b	89 45 f4	 mov	 DWORD PTR tv89[ebp], eax
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR tv89[ebp]
  00081	89 4d f8	 mov	 DWORD PTR tv128[ebp], ecx
  00084	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00087	c1 ea 03	 shr	 edx, 3
  0008a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00090	88 45 ff	 mov	 BYTE PTR tv131[ebp], al
  00093	80 7d ff 00	 cmp	 BYTE PTR tv131[ebp], 0
  00097	74 1a		 je	 SHORT $LN5@Construct_
  00099	8a 4d f8	 mov	 cl, BYTE PTR tv128[ebp]
  0009c	80 e1 07	 and	 cl, 7
  0009f	80 c1 03	 add	 cl, 3
  000a2	3a 4d ff	 cmp	 cl, BYTE PTR tv131[ebp]
  000a5	7c 0c		 jl	 SHORT $LN5@Construct_
  000a7	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ___asan_report_load4
  000b0	83 c4 04	 add	 esp, 4
$LN5@Construct_:
  000b3	8b 45 f4	 mov	 eax, DWORD PTR tv89[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	89 4d e8	 mov	 DWORD PTR tv93[ebp], ecx
  000bb	8b 55 e8	 mov	 edx, DWORD PTR tv93[ebp]
  000be	52		 push	 edx
  000bf	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c2	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1316 :     _Container_proxy* _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Basic_cont
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Basic_cont
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Basic_cont:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1318 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1319 :         _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Release
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Release
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Release:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1320 :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1095 :     void _Orphan_all_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1096 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1097 :         _Orphan_all_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1098 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv89 = -100						; size = 4
tv86 = -96						; size = 4
tv83 = -92						; size = 4
tv78 = -88						; size = 4
tv72 = -84						; size = 4
tv71 = -80						; size = 4
tv70 = -76						; size = 4
tv68 = -72						; size = 4
tv66 = -68						; size = 4
tv64 = -64						; size = 4
tv130 = -60						; size = 4
tv140 = -56						; size = 4
_this$ = -52						; size = 4
tv150 = -48						; size = 4
tv160 = -44						; size = 4
tv170 = -40						; size = 4
tv180 = -36						; size = 4
tv190 = -32						; size = 4
tv200 = -28						; size = 4
tv210 = -24						; size = 4
tv220 = -20						; size = 4
__Pnext$1 = -16						; size = 4
tv133 = -10						; size = 1
tv143 = -9						; size = 1
tv153 = -8						; size = 1
tv163 = -7						; size = 1
tv173 = -6						; size = 1
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 :     if (!_Myproxy) { // no proxy, already done

  00013	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv220[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_all
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv220[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_all
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_all:
  0004e	8b 45 c0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN5@Orphan_all

; 1239 :         return;

  00056	e9 58 02 00 00	 jmp	 $LN6@Orphan_all
$LN5@Orphan_all:

; 1240 :     }
; 1241 : 
; 1242 :     // proxy allocated, drain it
; 1243 :     for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { // TRANSITION, VSO-1269037

  0005b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e8	 mov	 DWORD PTR tv210[ebp], edx
  00067	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv213[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  0007a	74 1a		 je	 SHORT $LN15@Orphan_all
  0007c	8a 55 e8	 mov	 dl, BYTE PTR tv210[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv213[ebp]
  00088	7c 0c		 jl	 SHORT $LN15@Orphan_all
  0008a	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN15@Orphan_all:
  00096	8b 4d bc	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$1[ebp], edx
  000a1	e9 c0 00 00 00	 jmp	 $LN4@Orphan_all
$LN2@Orphan_all:
  000a6	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000a9	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  000ac	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  000af	89 4d e4	 mov	 DWORD PTR tv200[ebp], ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000b5	c1 ea 03	 shr	 edx, 3
  000b8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000be	88 45 fd	 mov	 BYTE PTR tv203[ebp], al
  000c1	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  000c5	74 1a		 je	 SHORT $LN14@Orphan_all
  000c7	8a 4d e4	 mov	 cl, BYTE PTR tv200[ebp]
  000ca	80 e1 07	 and	 cl, 7
  000cd	80 c1 03	 add	 cl, 3
  000d0	3a 4d fd	 cmp	 cl, BYTE PTR tv203[ebp]
  000d3	7c 0c		 jl	 SHORT $LN14@Orphan_all
  000d5	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ___asan_report_load4
  000de	83 c4 04	 add	 esp, 4
$LN14@Orphan_all:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	83 c1 04	 add	 ecx, 4
  000e9	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  000ec	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  000ef	89 55 e0	 mov	 DWORD PTR tv190[ebp], edx
  000f2	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  000f5	c1 e8 03	 shr	 eax, 3
  000f8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000fe	88 4d fc	 mov	 BYTE PTR tv193[ebp], cl
  00101	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  00105	74 1a		 je	 SHORT $LN13@Orphan_all
  00107	8a 55 e0	 mov	 dl, BYTE PTR tv190[ebp]
  0010a	80 e2 07	 and	 dl, 7
  0010d	80 c2 03	 add	 dl, 3
  00110	3a 55 fc	 cmp	 dl, BYTE PTR tv193[ebp]
  00113	7c 0c		 jl	 SHORT $LN13@Orphan_all
  00115	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ___asan_report_load4
  0011e	83 c4 04	 add	 esp, 4
$LN13@Orphan_all:
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00124	89 4d a4	 mov	 DWORD PTR tv83[ebp], ecx
  00127	8b 55 a4	 mov	 edx, DWORD PTR tv83[ebp]
  0012a	89 55 dc	 mov	 DWORD PTR tv180[ebp], edx
  0012d	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00130	c1 e8 03	 shr	 eax, 3
  00133	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00139	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  0013c	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00140	74 1a		 je	 SHORT $LN12@Orphan_all
  00142	8a 55 dc	 mov	 dl, BYTE PTR tv180[ebp]
  00145	80 e2 07	 and	 dl, 7
  00148	80 c2 03	 add	 dl, 3
  0014b	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  0014e	7c 0c		 jl	 SHORT $LN12@Orphan_all
  00150	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ___asan_report_store4
  00159	83 c4 04	 add	 esp, 4
$LN12@Orphan_all:
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  0015f	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  00162	8b 02		 mov	 eax, DWORD PTR [edx]
  00164	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Orphan_all:
  00166	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00169	89 4d a0	 mov	 DWORD PTR tv86[ebp], ecx
  0016c	8b 55 a0	 mov	 edx, DWORD PTR tv86[ebp]
  0016f	89 55 d8	 mov	 DWORD PTR tv170[ebp], edx
  00172	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00175	c1 e8 03	 shr	 eax, 3
  00178	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0017e	88 4d fa	 mov	 BYTE PTR tv173[ebp], cl
  00181	80 7d fa 00	 cmp	 BYTE PTR tv173[ebp], 0
  00185	74 1a		 je	 SHORT $LN11@Orphan_all
  00187	8a 55 d8	 mov	 dl, BYTE PTR tv170[ebp]
  0018a	80 e2 07	 and	 dl, 7
  0018d	80 c2 03	 add	 dl, 3
  00190	3a 55 fa	 cmp	 dl, BYTE PTR tv173[ebp]
  00193	7c 0c		 jl	 SHORT $LN11@Orphan_all
  00195	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ___asan_report_load4
  0019e	83 c4 04	 add	 esp, 4
$LN11@Orphan_all:
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  001a4	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001a7	0f 84 84 00 00
	00		 je	 $LN3@Orphan_all

; 1244 :         _Pnext->_Myproxy = nullptr;

  001ad	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001b0	89 55 9c	 mov	 DWORD PTR tv89[ebp], edx
  001b3	8b 45 9c	 mov	 eax, DWORD PTR tv89[ebp]
  001b6	89 45 d4	 mov	 DWORD PTR tv160[ebp], eax
  001b9	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001bc	c1 e9 03	 shr	 ecx, 3
  001bf	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001c5	88 55 f9	 mov	 BYTE PTR tv163[ebp], dl
  001c8	80 7d f9 00	 cmp	 BYTE PTR tv163[ebp], 0
  001cc	74 18		 je	 SHORT $LN10@Orphan_all
  001ce	8a 45 d4	 mov	 al, BYTE PTR tv160[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 45 f9	 cmp	 al, BYTE PTR tv163[ebp]
  001d8	7c 0c		 jl	 SHORT $LN10@Orphan_all
  001da	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ___asan_report_load4
  001e3	83 c4 04	 add	 esp, 4
$LN10@Orphan_all:
  001e6	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001e9	8b 02		 mov	 eax, DWORD PTR [edx]
  001eb	89 45 b4	 mov	 DWORD PTR tv70[ebp], eax
  001ee	8b 4d b4	 mov	 ecx, DWORD PTR tv70[ebp]
  001f1	89 4d d0	 mov	 DWORD PTR tv150[ebp], ecx
  001f4	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  001f7	c1 ea 03	 shr	 edx, 3
  001fa	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00200	88 45 f8	 mov	 BYTE PTR tv153[ebp], al
  00203	80 7d f8 00	 cmp	 BYTE PTR tv153[ebp], 0
  00207	74 1a		 je	 SHORT $LN9@Orphan_all
  00209	8a 4d d0	 mov	 cl, BYTE PTR tv150[ebp]
  0020c	80 e1 07	 and	 cl, 7
  0020f	80 c1 03	 add	 cl, 3
  00212	3a 4d f8	 cmp	 cl, BYTE PTR tv153[ebp]
  00215	7c 0c		 jl	 SHORT $LN9@Orphan_all
  00217	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ___asan_report_store4
  00220	83 c4 04	 add	 esp, 4
$LN9@Orphan_all:
  00223	8b 45 b4	 mov	 eax, DWORD PTR tv70[ebp]
  00226	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1245 :     }

  0022c	e9 75 fe ff ff	 jmp	 $LN2@Orphan_all
$LN3@Orphan_all:

; 1246 :     _Myproxy->_Myfirstiter = nullptr;

  00231	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	89 4d b0	 mov	 DWORD PTR tv71[ebp], ecx
  00237	8b 55 b0	 mov	 edx, DWORD PTR tv71[ebp]
  0023a	89 55 c8	 mov	 DWORD PTR tv140[ebp], edx
  0023d	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00240	c1 e8 03	 shr	 eax, 3
  00243	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00249	88 4d f7	 mov	 BYTE PTR tv143[ebp], cl
  0024c	80 7d f7 00	 cmp	 BYTE PTR tv143[ebp], 0
  00250	74 1a		 je	 SHORT $LN8@Orphan_all
  00252	8a 55 c8	 mov	 dl, BYTE PTR tv140[ebp]
  00255	80 e2 07	 and	 dl, 7
  00258	80 c2 03	 add	 dl, 3
  0025b	3a 55 f7	 cmp	 dl, BYTE PTR tv143[ebp]
  0025e	7c 0c		 jl	 SHORT $LN8@Orphan_all
  00260	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ___asan_report_load4
  00269	83 c4 04	 add	 esp, 4
$LN8@Orphan_all:
  0026c	8b 4d b0	 mov	 ecx, DWORD PTR tv71[ebp]
  0026f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00271	83 c2 04	 add	 edx, 4
  00274	89 55 ac	 mov	 DWORD PTR tv72[ebp], edx
  00277	8b 45 ac	 mov	 eax, DWORD PTR tv72[ebp]
  0027a	89 45 c4	 mov	 DWORD PTR tv130[ebp], eax
  0027d	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  00280	c1 e9 03	 shr	 ecx, 3
  00283	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00289	88 55 f6	 mov	 BYTE PTR tv133[ebp], dl
  0028c	80 7d f6 00	 cmp	 BYTE PTR tv133[ebp], 0
  00290	74 18		 je	 SHORT $LN7@Orphan_all
  00292	8a 45 c4	 mov	 al, BYTE PTR tv130[ebp]
  00295	24 07		 and	 al, 7
  00297	04 03		 add	 al, 3
  00299	3a 45 f6	 cmp	 al, BYTE PTR tv133[ebp]
  0029c	7c 0c		 jl	 SHORT $LN7@Orphan_all
  0029e	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 ___asan_report_store4
  002a7	83 c4 04	 add	 esp, 4
$LN7@Orphan_all:
  002aa	8b 55 ac	 mov	 edx, DWORD PTR tv72[ebp]
  002ad	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Orphan_all:

; 1247 : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1250 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1251 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1252 :     if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Orphan_all

; 1253 :         _Orphan_all_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1254 :     } else

  00025	eb 08		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 1255 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1256 :     {
; 1257 :         _Orphan_all_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN4@Orphan_all:

; 1258 :     }
; 1259 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1260 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1065 : 
; 1066 :     _Container_base12(const _Container_base12&) = delete;
; 1067 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1068 : 
; 1069 :     _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept;
; 1070 :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1071 : 
; 1072 :     template <class _Alloc>
; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {
; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1075 :         _Construct_in_place(*_New_proxy, this);
; 1076 :         _Myproxy            = _New_proxy;
; 1077 :         _New_proxy->_Mycont = this;
; 1078 :     }
; 1079 : 
; 1080 :     template <class _Alloc>
; 1081 :     _CONSTEXPR20_CONTAINER void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1082 :         // pre: no iterators refer to the existing proxy
; 1083 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1084 :         _Construct_in_place(*_New_proxy, this);
; 1085 :         _New_proxy->_Mycont = this;
; 1086 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1087 :     }
; 1088 : 
; 1089 :     _Container_proxy* _Myproxy = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Container_:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 1057 : 
; 1058 :     const _Container_base12* _Mycont       = nullptr;
; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@Container_
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Container_
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Container_:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 978  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 979  :     // convert size_t to size_t, unchanged
; 980  :     return _Len;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 981  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -84					; size = 4
tv154 = -80						; size = 4
tv151 = -76						; size = 4
tv144 = -72						; size = 4
tv64 = -68						; size = 4
tv141 = -64						; size = 4
tv138 = -60						; size = 4
__Ptr_container$ = -56					; size = 4
__Back_shift$ = -52					; size = 4
tv68 = -48						; size = 4
__Ptr_user$ = -44					; size = 4
tv66 = -40						; size = 4
tv157 = -36						; size = 4
tv167 = -32						; size = 4
tv177 = -28						; size = 4
tv187 = -24						; size = 4
tv197 = -20						; size = 4
tv207 = -16						; size = 4
tv217 = -12						; size = 4
tv160 = -7						; size = 1
tv170 = -6						; size = 1
tv180 = -5						; size = 1
tv190 = -4						; size = 1
tv200 = -3						; size = 1
tv210 = -2						; size = 1
tv220 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 153  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 154  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 155  :     _Bytes += _Non_user_size;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	89 45 c4	 mov	 DWORD PTR tv138[ebp], eax
  00016	8b 4d c4	 mov	 ecx, DWORD PTR tv138[ebp]
  00019	89 4d f4	 mov	 DWORD PTR tv217[ebp], ecx
  0001c	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv220[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv220[ebp], 0
  0002f	74 1a		 je	 SHORT $LN27@Adjust_man
  00031	8a 4d f4	 mov	 cl, BYTE PTR tv217[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv220[ebp]
  0003d	7c 0c		 jl	 SHORT $LN27@Adjust_man
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN27@Adjust_man:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	83 c1 27	 add	 ecx, 39			; 00000027H
  00053	89 4d bc	 mov	 DWORD PTR tv64[ebp], ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00059	89 55 c0	 mov	 DWORD PTR tv141[ebp], edx
  0005c	8b 45 c0	 mov	 eax, DWORD PTR tv141[ebp]
  0005f	89 45 f0	 mov	 DWORD PTR tv207[ebp], eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006e	88 55 fe	 mov	 BYTE PTR tv210[ebp], dl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv210[ebp], 0
  00075	74 18		 je	 SHORT $LN26@Adjust_man
  00077	8a 45 f0	 mov	 al, BYTE PTR tv207[ebp]
  0007a	24 07		 and	 al, 7
  0007c	04 03		 add	 al, 3
  0007e	3a 45 fe	 cmp	 al, BYTE PTR tv210[ebp]
  00081	7c 0c		 jl	 SHORT $LN26@Adjust_man
  00083	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN26@Adjust_man:
  0008f	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00092	8b 45 bc	 mov	 eax, DWORD PTR tv64[ebp]
  00095	89 02		 mov	 DWORD PTR [edx], eax

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009a	89 4d b8	 mov	 DWORD PTR tv144[ebp], ecx
  0009d	8b 55 b8	 mov	 edx, DWORD PTR tv144[ebp]
  000a0	89 55 ec	 mov	 DWORD PTR tv197[ebp], edx
  000a3	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000a6	c1 e8 03	 shr	 eax, 3
  000a9	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000af	88 4d fd	 mov	 BYTE PTR tv200[ebp], cl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv200[ebp], 0
  000b6	74 1a		 je	 SHORT $LN25@Adjust_man
  000b8	8a 55 ec	 mov	 dl, BYTE PTR tv197[ebp]
  000bb	80 e2 07	 and	 dl, 7
  000be	80 c2 03	 add	 dl, 3
  000c1	3a 55 fd	 cmp	 dl, BYTE PTR tv200[ebp]
  000c4	7c 0c		 jl	 SHORT $LN25@Adjust_man
  000c6	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ___asan_report_load4
  000cf	83 c4 04	 add	 esp, 4
$LN25@Adjust_man:
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d7	89 55 d4	 mov	 DWORD PTR __Ptr_user$[ebp], edx

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000da	b8 04 00 00 00	 mov	 eax, 4
  000df	6b c8 ff	 imul	 ecx, eax, -1
  000e2	8b 55 d4	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  000e5	03 d1		 add	 edx, ecx
  000e7	89 55 d8	 mov	 DWORD PTR tv66[ebp], edx
  000ea	8b 45 d8	 mov	 eax, DWORD PTR tv66[ebp]
  000ed	89 45 e8	 mov	 DWORD PTR tv187[ebp], eax
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  000f3	c1 e9 03	 shr	 ecx, 3
  000f6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000fc	88 55 fc	 mov	 BYTE PTR tv190[ebp], dl
  000ff	80 7d fc 00	 cmp	 BYTE PTR tv190[ebp], 0
  00103	74 18		 je	 SHORT $LN24@Adjust_man
  00105	8a 45 e8	 mov	 al, BYTE PTR tv187[ebp]
  00108	24 07		 and	 al, 7
  0010a	04 03		 add	 al, 3
  0010c	3a 45 fc	 cmp	 al, BYTE PTR tv190[ebp]
  0010f	7c 0c		 jl	 SHORT $LN24@Adjust_man
  00111	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ___asan_report_load4
  0011a	83 c4 04	 add	 esp, 4
$LN24@Adjust_man:
  0011d	8b 55 d8	 mov	 edx, DWORD PTR tv66[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	89 45 c8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00125	b9 04 00 00 00	 mov	 ecx, 4
  0012a	6b d1 fe	 imul	 edx, ecx, -2
  0012d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_user$[ebp]
  00130	03 c2		 add	 eax, edx
  00132	89 45 d0	 mov	 DWORD PTR tv68[ebp], eax
  00135	8b 4d d0	 mov	 ecx, DWORD PTR tv68[ebp]
  00138	89 4d e4	 mov	 DWORD PTR tv177[ebp], ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  0013e	c1 ea 03	 shr	 edx, 3
  00141	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00147	88 45 fb	 mov	 BYTE PTR tv180[ebp], al
  0014a	80 7d fb 00	 cmp	 BYTE PTR tv180[ebp], 0
  0014e	74 1a		 je	 SHORT $LN23@Adjust_man
  00150	8a 4d e4	 mov	 cl, BYTE PTR tv177[ebp]
  00153	80 e1 07	 and	 cl, 7
  00156	80 c1 03	 add	 cl, 3
  00159	3a 4d fb	 cmp	 cl, BYTE PTR tv180[ebp]
  0015c	7c 0c		 jl	 SHORT $LN23@Adjust_man
  0015e	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN23@Adjust_man:
  0016a	8b 45 d0	 mov	 eax, DWORD PTR tv68[ebp]
  0016d	81 38 fa fa fa
	fa		 cmp	 DWORD PTR [eax], -84215046 ; fafafafaH
  00173	75 02		 jne	 SHORT $LN7@Adjust_man
  00175	eb 4a		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00181	6a 00		 push	 0
  00183	68 a2 00 00 00	 push	 162			; 000000a2H
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0018d	6a 02		 push	 2
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00195	83 c4 18	 add	 esp, 24			; 00000018H
  00198	83 f8 01	 cmp	 eax, 1
  0019b	75 01		 jne	 SHORT $LN19@Adjust_man
  0019d	cc		 int	 3
$LN19@Adjust_man:
  0019e	6a 00		 push	 0
  001a0	68 a2 00 00 00	 push	 162			; 000000a2H
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001ba	83 c4 14	 add	 esp, 20			; 00000014H
  001bd	33 d2		 xor	 edx, edx
  001bf	75 b6		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  001c1	33 c0		 xor	 eax, eax
  001c3	0f 85 5c ff ff
	ff		 jne	 $LN4@Adjust_man

; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  001c9	c7 45 ac 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  001d3	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  001d6	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  001d9	89 55 e0	 mov	 DWORD PTR tv167[ebp], edx
  001dc	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  001df	c1 e8 03	 shr	 eax, 3
  001e2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e8	88 4d fa	 mov	 BYTE PTR tv170[ebp], cl
  001eb	80 7d fa 00	 cmp	 BYTE PTR tv170[ebp], 0
  001ef	74 1a		 je	 SHORT $LN22@Adjust_man
  001f1	8a 55 e0	 mov	 dl, BYTE PTR tv167[ebp]
  001f4	80 e2 07	 and	 dl, 7
  001f7	80 c2 03	 add	 dl, 3
  001fa	3a 55 fa	 cmp	 dl, BYTE PTR tv170[ebp]
  001fd	7c 0c		 jl	 SHORT $LN22@Adjust_man
  001ff	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ___asan_report_load4
  00208	83 c4 04	 add	 esp, 4
$LN22@Adjust_man:
  0020b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	2b 55 c8	 sub	 edx, DWORD PTR __Ptr_container$[ebp]
  00213	89 55 cc	 mov	 DWORD PTR __Back_shift$[ebp], edx
$LN10@Adjust_man:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00216	83 7d cc 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  0021a	72 08		 jb	 SHORT $LN13@Adjust_man
  0021c	83 7d cc 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  00220	77 02		 ja	 SHORT $LN13@Adjust_man
  00222	eb 4a		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0022e	6a 00		 push	 0
  00230	68 ac 00 00 00	 push	 172			; 000000acH
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0023a	6a 02		 push	 2
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00242	83 c4 18	 add	 esp, 24			; 00000018H
  00245	83 f8 01	 cmp	 eax, 1
  00248	75 01		 jne	 SHORT $LN20@Adjust_man
  0024a	cc		 int	 3
$LN20@Adjust_man:
  0024b	6a 00		 push	 0
  0024d	68 ac 00 00 00	 push	 172			; 000000acH
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00267	83 c4 14	 add	 esp, 20			; 00000014H
  0026a	33 c9		 xor	 ecx, ecx
  0026c	75 b6		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0026e	33 d2		 xor	 edx, edx
  00270	75 a4		 jne	 SHORT $LN10@Adjust_man

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00272	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00275	89 45 b0	 mov	 DWORD PTR tv154[ebp], eax
  00278	8b 4d b0	 mov	 ecx, DWORD PTR tv154[ebp]
  0027b	89 4d dc	 mov	 DWORD PTR tv157[ebp], ecx
  0027e	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  00281	c1 ea 03	 shr	 edx, 3
  00284	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0028a	88 45 f9	 mov	 BYTE PTR tv160[ebp], al
  0028d	80 7d f9 00	 cmp	 BYTE PTR tv160[ebp], 0
  00291	74 1a		 je	 SHORT $LN21@Adjust_man
  00293	8a 4d dc	 mov	 cl, BYTE PTR tv157[ebp]
  00296	80 e1 07	 and	 cl, 7
  00299	80 c1 03	 add	 cl, 3
  0029c	3a 4d f9	 cmp	 cl, BYTE PTR tv160[ebp]
  0029f	7c 0c		 jl	 SHORT $LN21@Adjust_man
  002a1	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 ___asan_report_store4
  002aa	83 c4 04	 add	 esp, 4
$LN21@Adjust_man:
  002ad	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  002b0	8b 4d c8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  002b3	89 08		 mov	 DWORD PTR [eax], ecx

; 174  : }

  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 84   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 85   :         return ::operator new(_Bytes);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 86   :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 12
tv70 = -12						; size = 4
tv68 = -8						; size = 4
tv73 = -4						; size = 4
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00020	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ
  00027	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0002e	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00040	89 4d f4	 mov	 DWORD PTR tv70[ebp], ecx
  00043	8b 55 f4	 mov	 edx, DWORD PTR tv70[ebp]
  00046	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0004c	83 45 f4 04	 add	 DWORD PTR tv70[ebp], 4
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  00053	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET __FF458F76_exception
  0005e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 321  :     _THROW(bad_array_new_length{});

  00063	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00066	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0006b	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00070	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  00079	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00080	8d 55 b0	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0008c	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  0008f	6a 08		 push	 8
  00091	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0009a	83 c4 08	 add	 esp, 8
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	8b e3		 mov	 esp, ebx
  000a2	5b		 pop	 ebx
  000a3	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_array_
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_array_
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
tv87 = -1						; size = 1
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00026	8b 4d f0	 mov	 ecx, DWORD PTR tv69[ebp]
  00029	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  0002f	c1 ea 03	 shr	 edx, 3
  00032	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00038	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  0003b	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0003f	74 1a		 je	 SHORT $LN3@bad_array_
  00041	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00044	80 e1 07	 and	 cl, 7
  00047	80 c1 03	 add	 cl, 3
  0004a	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0004d	7c 0c		 jl	 SHORT $LN3@bad_array_
  0004f	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ___asan_report_store4
  00058	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_alloc
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv85 = -12						; size = 4
_this$ = -8						; size = 4
tv88 = -1						; size = 1
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

  00013	6a 01		 push	 1
  00015	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  00027	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0002a	89 55 f4	 mov	 DWORD PTR tv85[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00030	c1 e8 03	 shr	 eax, 3
  00033	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00039	88 4d ff	 mov	 BYTE PTR tv88[ebp], cl
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00040	74 1a		 je	 SHORT $LN3@bad_alloc
  00042	8a 55 f4	 mov	 dl, BYTE PTR tv85[ebp]
  00045	80 e2 07	 and	 dl, 7
  00048	80 c2 03	 add	 dl, 3
  0004b	3a 55 ff	 cmp	 dl, BYTE PTR tv88[ebp]
  0004e	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ___asan_report_store4
  00059	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv67 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv85[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv88[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00035	74 1a		 je	 SHORT $LN6@what
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv85[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv88[ebp]
  00043	7c 0c		 jl	 SHORT $LN6@what
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN6@what:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 48		 je	 SHORT $LN3@what
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 04	 add	 ecx, 4
  0005f	89 4d e8	 mov	 DWORD PTR tv67[ebp], ecx
  00062	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00065	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00068	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0006b	c1 e8 03	 shr	 eax, 3
  0006e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00074	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00077	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  0007b	74 1a		 je	 SHORT $LN5@what
  0007d	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  00080	80 e2 07	 and	 dl, 7
  00083	80 c2 03	 add	 dl, 3
  00086	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00089	7c 0c		 jl	 SHORT $LN5@what
  0008b	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ___asan_report_load4
  00094	83 c4 04	 add	 esp, 4
$LN5@what:
  00097	8b 4d e8	 mov	 ecx, DWORD PTR tv67[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
  0009f	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  000a1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  000a8	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ___std_exception_destroy
  00063	83 c4 04	 add	 esp, 4

; 91   :     }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv64 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -1						; size = 1
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv76[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv79[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv79[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv76[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv79[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	52		 push	 edx
  00071	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00074	83 c0 04	 add	 eax, 4
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___std_exception_copy
  0007d	83 c4 08	 add	 esp, 8

; 74   :     }

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
tv76 = -16						; size = 4
tv86 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -2						; size = 1
tv89 = -1						; size = 1
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv86[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv86[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv89[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@exception:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   :         _Data._What = _Message;

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  00073	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00076	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0007c	c1 e9 03	 shr	 ecx, 3
  0007f	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00085	88 55 fe	 mov	 BYTE PTR tv79[ebp], dl
  00088	80 7d fe 00	 cmp	 BYTE PTR tv79[ebp], 0
  0008c	74 18		 je	 SHORT $LN3@exception
  0008e	8a 45 f0	 mov	 al, BYTE PTR tv76[ebp]
  00091	24 07		 and	 al, 7
  00093	04 03		 add	 al, 3
  00095	3a 45 fe	 cmp	 al, BYTE PTR tv79[ebp]
  00098	7c 0c		 jl	 SHORT $LN3@exception
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ___asan_report_store4
  000a3	83 c4 04	 add	 esp, 4
$LN3@exception:
  000a6	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  000a9	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  000ac	89 02		 mov	 DWORD PTR [edx], eax

; 68   :     }

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 556  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __7FE5F402_limits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 557  :         return INT_MAX;

  0000d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 558  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __93DC0B45_wchar@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00010	d1 e0		 shl	 eax, 1
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 180  : _NODISCARD constexpr bool is_constant_evaluated() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __47F37C5A_xtr1common
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 181  :     return __builtin_is_constant_evaluated();

  0000d	32 c0		 xor	 al, al

; 182  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __97D3638F_vcruntime_new@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         (void)_Size;
; 169  :         return _Where;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\ProjetTutore1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __059B899A_ProjetTutore1@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\ProjetTutore1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __059B899A_ProjetTutore1@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\ProjetTutore1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __059B899A_ProjetTutore1@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\ProjetTutore1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __059B899A_ProjetTutore1@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
