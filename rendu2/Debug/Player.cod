; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Debug\Player.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG90610 DB	'invalid argument', 00H
___asan_rrz_$SG90610 DD 0f9H
	ORG $+43
$SG90611 DB	'%s', 00H
___asan_rrz_$SG90611 DD 0f9H
	ORG $+57
$SG90612 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xmemory', 00H
___asan_rrz_$SG90612 DD 0f9H
	ORG $+52
$SG90613 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
___asan_rrz_$SG90613 DD 0f9H
	ORG $+44
$SG90614 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
___asan_rrz_$SG90614 DD 0f9H
	ORG $+46
$SG90615 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
___asan_rrz_$SG90615 DD 0f9H
	ORG $+54
$SG87968 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xlocale', 00H
___asan_rrz_$SG87968 DD 0f9H
CONST	ENDS
ASAN$GL	SEGMENT
_L___asan_global_$SG87968 DD FLAT:$SG87968
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.14
	DD	FLAT:_L___asan_gen_.13
	DD	00H
	DD	FLAT:_L___asan_gen_.15
	DD	00H
_L___asan_global_$SG90615 DD FLAT:$SG90615
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.11
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.12
	DD	00H
_L___asan_global_$SG90614 DD FLAT:$SG90614
	DD	04eH
	DD	080H
	DD	FLAT:_L___asan_gen_.9
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.10
	DD	00H
_L___asan_global_$SG90613 DD FLAT:$SG90613
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.7
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.8
	DD	00H
_L___asan_global_$SG90612 DD FLAT:$SG90612
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.5
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.6
	DD	00H
_L___asan_global_$SG90611 DD FLAT:$SG90611
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
_L___asan_global_$SG90610 DD FLAT:$SG90610
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
CONST	SEGMENT
	ORG $+52
_L___asan_gen_.0 DB 'xmemory', 00H
_L___asan_gen_.1 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.3 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.5 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.6 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.7 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.8 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.9 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.10 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.11 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.12 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.13 DB 'xlocale', 00H
_L___asan_gen_.14 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.15 DD FLAT:_L___asan_gen_.13
	DD	020eH
	DD	059H
CONST	ENDS
msvcjmc	SEGMENT
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__47F37C5A_xtr1common DB 01H
__81812A28_cstddef DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__7FE5F402_limits DB 01H
__589FA321_type_traits DB 01H
__97D3638F_vcruntime_new@h DB 01H
__DD5FCA34_compare DB 01H
__A751F051_corecrt_memory@h DB 01H
__32E5F013_string@h DB 01H
__12269DE6_xutility DB 01H
__C69F69CF_tuple DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__79D216CD_xmemory DB 01H
__374A57BA_xpolymorphic_allocator@h DB 01H
__60BC708E_cmath DB 01H
__0D019051_xstring DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__1B354CA2_system_error DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__C34BF88C_memory DB 01H
__EF0EAF83_xfacet DB 01H
__B2D2BA86_ctype@h DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__B2A9EE53_InputStream@hpp DB 01H
__62DD75E3_NonCopyable@hpp DB 01H
__B7987E10_string DB 01H
__1589CDA2_algorithm DB 01H
__FE33131C_xlocmes DB 01H
__67DA974F_xlocmon DB 01H
__D96D2425_xloctime DB 01H
__FC4CDF9C_Thread@inl DB 01H
__3C1C7D88_ContextSettings@hpp DB 01H
__8D991C03_Drawable@hpp DB 01H
__896EE8A8_Glyph@hpp DB 01H
__69958C8C_xtree DB 01H
__E3A1A8C3_Font@hpp DB 01H
__0D6BD463_Character@h DB 01H
__B4613F23_Sprite@hpp DB 01H
__4D0513DE_Player@cpp DB 01H
__324884E2_vector DB 01H
__68A60A21_locale DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__038A2AA6_iterator DB 01H
__B30C2184_iosfwd DB 01H
__1347750E_utility DB 01H
__E458E21C_xstddef DB 01H
__0A631FEE_Vector2@inl DB 01H
__CBE11649_Vector2@hpp DB 01H
__C23CD225_Rect@inl DB 01H
__03BEDB82_Rect@hpp DB 01H
__F54903A0_xatomic@h DB 01H
__B3577796_RenderStates@hpp DB 01H
__5808F286_Player@h DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	_wmemcpy
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0?$Vector2@I@sf@@QAE@XZ			; sf::Vector2<unsigned int>::Vector2<unsigned int>
PUBLIC	??0?$Rect@H@sf@@QAE@XZ				; sf::Rect<int>::Rect<int>
PUBLIC	??0?$Rect@H@sf@@QAE@HHHH@Z			; sf::Rect<int>::Rect<int>
PUBLIC	??_GSprite@sf@@UAEPAXI@Z			; sf::Sprite::`scalar deleting destructor'
PUBLIC	??0Character@@QAE@XZ				; Character::Character
PUBLIC	??0?$allocator@PAVSprite@sf@@@std@@QAE@XZ	; std::allocator<sf::Sprite *>::allocator<sf::Sprite *>
PUBLIC	?deallocate@?$allocator@PAVSprite@sf@@@std@@QAEXQAPAVSprite@sf@@I@Z ; std::allocator<sf::Sprite *>::deallocate
PUBLIC	?allocate@?$allocator@PAVSprite@sf@@@std@@QAEPAPAVSprite@sf@@I@Z ; std::allocator<sf::Sprite *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAIABV?$allocator@PAVSprite@sf@@@2@@Z ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::max_size
PUBLIC	??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::vector<sf::Sprite *,std::allocator<sf::Sprite *> >
PUBLIC	??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::~vector<sf::Sprite *,std::allocator<sf::Sprite *> >
PUBLIC	?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::max_size
PUBLIC	?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
PUBLIC	?_Ufill@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEPAPAVSprite@sf@@PAPAV34@IU_Value_init_tag@2@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Ufill
PUBLIC	?_Destroy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXPAPAVSprite@sf@@0@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xlength
PUBLIC	?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
PUBLIC	?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
PUBLIC	?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@ABEABV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sf::Sprite *> >::_Vector_val<std::_Simple_types<sf::Sprite *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSprite@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::__autoclassinit2
PUBLIC	??_G?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAXI@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::`scalar deleting destructor'
PUBLIC	??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z ; Player::Player
PUBLIC	??1Player@@QAE@XZ				; Player::~Player
PUBLIC	?size@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::size
PUBLIC	?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
PUBLIC	?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
PUBLIC	??0?$allocator@PAVTexture@sf@@@std@@QAE@XZ	; std::allocator<sf::Texture *>::allocator<sf::Texture *>
PUBLIC	?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z ; std::allocator<sf::Texture *>::deallocate
PUBLIC	?allocate@?$allocator@PAVTexture@sf@@@std@@QAEPAPAVTexture@sf@@I@Z ; std::allocator<sf::Texture *>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAIABV?$allocator@PAVTexture@sf@@@2@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::max_size
PUBLIC	??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::vector<sf::Texture *,std::allocator<sf::Texture *> >
PUBLIC	??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::~vector<sf::Texture *,std::allocator<sf::Texture *> >
PUBLIC	?push_back@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXABQAVTexture@sf@@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::push_back
PUBLIC	?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::max_size
PUBLIC	?capacity@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::capacity
PUBLIC	?_Umove@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEPAPAVTexture@sf@@PAPAV34@00@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove
PUBLIC	?_Umove_if_noexcept1@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00U?$integral_constant@_N$00@2@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept1
PUBLIC	?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept
PUBLIC	?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Destroy
PUBLIC	?_Calculate_growth@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEII@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXQAPAVTexture@sf@@II@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Change_array
PUBLIC	?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Tidy
PUBLIC	?_Xlength@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Xlength
PUBLIC	?_Orphan_range_unlocked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_unlocked
PUBLIC	?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_locked
PUBLIC	?_Orphan_range@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range
PUBLIC	?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
PUBLIC	?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEABV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sf::Texture *> >::_Vector_val<std::_Simple_types<sf::Texture *> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVTexture@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::__autoclassinit2
PUBLIC	??_G?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAXI@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::`scalar deleting destructor'
PUBLIC	??$emplace_back@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE?A_TABQAVTexture@sf@@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::emplace_back<sf::Texture * const &>
PUBLIC	??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
PUBLIC	??$_Emplace_back_with_unused_capacity@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAE?A_TABQAVTexture@sf@@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_back_with_unused_capacity<sf::Texture * const &>
PUBLIC	??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Texture *>
PUBLIC	??$construct@PAVTexture@sf@@ABQAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@ABQAV34@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture * const &>
PUBLIC	??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_reallocate<sf::Texture * const &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0PAVTexture@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVTexture@sf@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Texture *>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1><>
PUBLIC	??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0PAVSprite@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSprite@sf@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Sprite *>
PUBLIC	??$?0ABV?$allocator@PAVSprite@sf@@@std@@$$V@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVSprite@sf@@@1@@Z ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1><std::allocator<sf::Sprite *> const &>
PUBLIC	??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$_Destroy_range@V?$allocator@PAVTexture@sf@@@std@@@std@@YAXPAPAVTexture@sf@@QAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Destroy_range<std::allocator<sf::Texture *> >
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Destroy_range@V?$allocator@PAVSprite@sf@@@std@@@std@@YAXPAPAVSprite@sf@@QAPAV12@AAV?$allocator@PAVSprite@sf@@@0@@Z ; std::_Destroy_range<std::allocator<sf::Sprite *> >
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
PUBLIC	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
PUBLIC	??$construct_at@PAVTexture@sf@@ABQAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@ABQAV12@@Z ; std::construct_at<sf::Texture *,sf::Texture * const &,void>
PUBLIC	??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z ; std::_Voidify_iter<sf::Texture * *>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$forward@ABV?$allocator@PAVSprite@sf@@@std@@@std@@YAABV?$allocator@PAVSprite@sf@@@0@ABV10@@Z ; std::forward<std::allocator<sf::Sprite *> const &>
PUBLIC	??1?$_Tidy_guard@V?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >::~_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Uninitialized_move<sf::Texture * *,std::allocator<sf::Texture *> >
PUBLIC	??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<sf::Sprite *> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$_Get_unwrapped@ABQAPAVTexture@sf@@@std@@YA?A_TABQAPAVTexture@sf@@@Z ; std::_Get_unwrapped<sf::Texture * * const &>
PUBLIC	??$move@AAPAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::move<sf::Texture * &>
PUBLIC	??$to_address@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@QAPAV12@@Z ; std::to_address<sf::Texture *>
PUBLIC	??$_Copy_memmove@PAPAVTexture@sf@@PAPAV12@@std@@YAPAPAVTexture@sf@@PAPAV12@00@Z ; std::_Copy_memmove<sf::Texture * *,sf::Texture * *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@PAPAVTexture@sf@@AAV?$allocator@PAVTexture@sf@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Uninitialized_backout_al<std::allocator<sf::Texture *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::~_Uninitialized_backout_al<std::allocator<sf::Texture *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::__autoclassinit2
PUBLIC	??$_Emplace_back@PAVTexture@sf@@@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEX$$QAPAVTexture@sf@@@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Emplace_back<sf::Texture *>
PUBLIC	??$to_address@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@@Z ; std::to_address<sf::Sprite *>
PUBLIC	??$_Unfancy@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Sprite *>
PUBLIC	??$_Zero_range@PAPAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@0@Z ; std::_Zero_range<sf::Sprite * *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@PAPAVSprite@sf@@AAV?$allocator@PAVSprite@sf@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::~_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAPAVSprite@sf@@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::__autoclassinit2
PUBLIC	??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Emplace_back<>
PUBLIC	??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z ; std::_To_address<sf::Texture * *>
PUBLIC	??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::forward<sf::Texture *>
PUBLIC	??$construct@PAVTexture@sf@@PAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@$$QAPAV34@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture *>
PUBLIC	??$_To_address@PAPAVSprite@sf@@@std@@YA?A_PABQAPAVSprite@sf@@@Z ; std::_To_address<sf::Sprite * *>
PUBLIC	??$construct@PAVSprite@sf@@$$V@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAXAAV?$allocator@PAVSprite@sf@@@1@QAPAVSprite@sf@@@Z ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::construct<sf::Sprite *>
PUBLIC	??$construct_at@PAVTexture@sf@@PAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@$$QAPAV12@@Z ; std::construct_at<sf::Texture *,sf::Texture *,void>
PUBLIC	??$construct_at@PAVSprite@sf@@$$VX@std@@YAPAPAVSprite@sf@@QAPAV12@@Z ; std::construct_at<sf::Sprite *,void>
PUBLIC	??$_Voidify_iter@PAPAVSprite@sf@@@std@@YAPAXPAPAVSprite@sf@@@Z ; std::_Voidify_iter<sf::Sprite * *>
PUBLIC	??_ESprite@sf@@W3AEPAXI@Z			; [thunk]:sf::Sprite::`vector deleting destructor'
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_SSprite@sf@@6BDrawable@1@@			; sf::Sprite::`local vftable'
PUBLIC	??_SSprite@sf@@6BTransformable@1@@		; sf::Sprite::`local vftable'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Sprite@sf@@6BDrawable@1@@			; sf::Sprite::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVSprite@sf@@@8				; sf::Sprite `RTTI Type Descriptor'
PUBLIC	??_R3Sprite@sf@@8				; sf::Sprite::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Sprite@sf@@8				; sf::Sprite::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Sprite@sf@@8			; sf::Sprite::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@Drawable@sf@@8			; sf::Drawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVDrawable@sf@@@8				; sf::Drawable `RTTI Type Descriptor'
PUBLIC	??_R3Drawable@sf@@8				; sf::Drawable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Drawable@sf@@8				; sf::Drawable::`RTTI Base Class Array'
PUBLIC	??_R13?0A@EA@Transformable@sf@@8		; sf::Transformable::`RTTI Base Class Descriptor at (4,-1,0,64)'
PUBLIC	??_R0?AVTransformable@sf@@@8			; sf::Transformable `RTTI Type Descriptor'
PUBLIC	??_R3Transformable@sf@@8			; sf::Transformable::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2Transformable@sf@@8			; sf::Transformable::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@Transformable@sf@@8		; sf::Transformable::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4Sprite@sf@@6BTransformable@1@@		; sf::Sprite::`RTTI Complete Object Locator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	_memset:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?getSize@Image@sf@@QBE?AV?$Vector2@I@2@XZ:PROC
EXTRN	__imp_??0Texture@sf@@QAE@XZ:PROC
EXTRN	__imp_?loadFromImage@Texture@sf@@QAE_NABVImage@2@ABV?$Rect@H@2@@Z:PROC
EXTRN	__imp_?setSmooth@Texture@sf@@QAEX_N@Z:PROC
EXTRN	__imp_??0Sprite@sf@@QAE@ABVTexture@1@ABV?$Rect@H@1@@Z:PROC
EXTRN	__imp_??1Sprite@sf@@UAE@XZ:PROC
EXTRN	??_ESprite@sf@@UAEPAXI@Z:PROC			; sf::Sprite::`vector deleting destructor'
EXTRN	?draw@Sprite@sf@@EBEXAAVRenderTarget@2@VRenderStates@2@@Z:PROC ; sf::Sprite::draw
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___asan_loadN:PROC
EXTRN	___asan_memset:PROC
EXTRN	___asan_report_load1:PROC
EXTRN	___asan_report_load4:PROC
EXTRN	___asan_report_load8:PROC
EXTRN	___asan_report_store1:PROC
EXTRN	___asan_report_store2:PROC
EXTRN	___asan_report_store4:PROC
EXTRN	___asan_report_store8:PROC
EXTRN	___asan_set_shadow_00:PROC
EXTRN	___asan_set_shadow_f8:PROC
EXTRN	___asan_storeN:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
___asan_rrz_??_C@_0BC@EOODALEL@Unknown?5exception@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
___asan_rrz_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
___asan_rrz_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
___asan_rrz_??_C@_02DKCKIIND@?$CFs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xmemory', 00H	; `string'
___asan_rrz_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocale', 00H	; `string'
___asan_rrz_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocnum', 00H	; `string'
___asan_rrz_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
___asan_rrz_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
___asan_rrz_??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
___asan_rrz_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.32
	DD	FLAT:_L___asan_gen_.27
	DD	00H
	DD	FLAT:_L___asan_gen_.33
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.33 DD FLAT:_L___asan_gen_.27
	DD	06eeH
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.32 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	DD	01aH
	DD	040H
	DD	FLAT:_L___asan_gen_.30
	DD	FLAT:_L___asan_gen_.24
	DD	00H
	DD	FLAT:_L___asan_gen_.31
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.31 DD FLAT:_L___asan_gen_.24
	DD	0b4H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.30 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DD FLAT:??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
	DD	019H
	DD	040H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.27
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.27
	DD	06f2H
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.28 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.27 DB 'vector', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	DD	0dH
	DD	040H
	DD	FLAT:_L___asan_gen_.25
	DD	FLAT:_L___asan_gen_.24
	DD	00H
	DD	FLAT:_L___asan_gen_.26
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.26 DD FLAT:_L___asan_gen_.24
	DD	01b7H
	DD	030H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.25 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.24 DB 'xloctime', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.22
	DD	FLAT:_L___asan_gen_.21
	DD	00H
	DD	FLAT:_L___asan_gen_.23
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.23 DD FLAT:_L___asan_gen_.21
	DD	05dH
	DD	05fH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.22 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.21 DB 'xlocnum', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.19
	DD	FLAT:_L___asan_gen_.18
	DD	00H
	DD	FLAT:_L___asan_gen_.20
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.20 DD FLAT:_L___asan_gen_.18
	DD	049H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.19 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.18 DB 'xlocale', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.16
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.17
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.17 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.16 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD FLAT:??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	DD	04aH
	DD	080H
	DD	FLAT:_L___asan_gen_.14
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.15
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.15 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.14 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.12
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.13
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.13 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.12 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.10
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.11
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.11 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.10 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_02DKCKIIND@?$CFs@ DD FLAT:??_C@_02DKCKIIND@?$CFs@
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.8
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.9
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.9 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.8 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.6
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.7
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.7 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.6 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.5 DB 'xmemory', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	DD	015H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	08cH
	DD	014H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.3 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BC@EOODALEL@Unknown?5exception@ DD FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	DD	012H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	05fH
	DD	02bH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.1 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.0 DB 'vcruntime_exception.h', 00H
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R4Sprite@sf@@6BTransformable@1@@
rdata$r	SEGMENT
??_R4Sprite@sf@@6BTransformable@1@@ DD 00H		; sf::Sprite::`RTTI Complete Object Locator'
	DD	04H
	DD	00H
	DD	FLAT:??_R0?AVSprite@sf@@@8
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Transformable@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Transformable@sf@@8 DD FLAT:??_R0?AVTransformable@sf@@@8 ; sf::Transformable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Transformable@sf@@8
rdata$r	SEGMENT
??_R2Transformable@sf@@8 DD FLAT:??_R1A@?0A@EA@Transformable@sf@@8 ; sf::Transformable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Transformable@sf@@8
rdata$r	SEGMENT
??_R3Transformable@sf@@8 DD 00H				; sf::Transformable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVTransformable@sf@@@8
data$rs	SEGMENT
??_R0?AVTransformable@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Transformable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVTransformable@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R13?0A@EA@Transformable@sf@@8
rdata$r	SEGMENT
??_R13?0A@EA@Transformable@sf@@8 DD FLAT:??_R0?AVTransformable@sf@@@8 ; sf::Transformable::`RTTI Base Class Descriptor at (4,-1,0,64)'
	DD	00H
	DD	04H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Drawable@sf@@8
rdata$r	SEGMENT
??_R2Drawable@sf@@8 DD FLAT:??_R1A@?0A@EA@Drawable@sf@@8 ; sf::Drawable::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3Drawable@sf@@8
rdata$r	SEGMENT
??_R3Drawable@sf@@8 DD 00H				; sf::Drawable::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2Drawable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVDrawable@sf@@@8
data$rs	SEGMENT
??_R0?AVDrawable@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Drawable `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVDrawable@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R1A@?0A@EA@Drawable@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Drawable@sf@@8 DD FLAT:??_R0?AVDrawable@sf@@@8 ; sf::Drawable::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Drawable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@Sprite@sf@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@Sprite@sf@@8 DD FLAT:??_R0?AVSprite@sf@@@8 ; sf::Sprite::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R2Sprite@sf@@8
rdata$r	SEGMENT
??_R2Sprite@sf@@8 DD FLAT:??_R1A@?0A@EA@Sprite@sf@@8	; sf::Sprite::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@Drawable@sf@@8
	DD	FLAT:??_R13?0A@EA@Transformable@sf@@8
rdata$r	ENDS
;	COMDAT ??_R3Sprite@sf@@8
rdata$r	SEGMENT
??_R3Sprite@sf@@8 DD 00H				; sf::Sprite::`RTTI Class Hierarchy Descriptor'
	DD	01H
	DD	03H
	DD	FLAT:??_R2Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVSprite@sf@@@8
data$rs	SEGMENT
??_R0?AVSprite@sf@@@8 DD FLAT:??_7type_info@@6B@	; sf::Sprite `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVSprite@sf@@', 00H
data$rs	ENDS
;	COMDAT ??_R4Sprite@sf@@6BDrawable@1@@
rdata$r	SEGMENT
??_R4Sprite@sf@@6BDrawable@1@@ DD 00H			; sf::Sprite::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVSprite@sf@@@8
	DD	FLAT:??_R3Sprite@sf@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_SSprite@sf@@6BTransformable@1@@
CONST	SEGMENT
??_SSprite@sf@@6BTransformable@1@@ DD FLAT:??_R4Sprite@sf@@6BTransformable@1@@ ; sf::Sprite::`local vftable'
	DD	FLAT:??_ESprite@sf@@W3AEPAXI@Z
CONST	ENDS
;	COMDAT ??_SSprite@sf@@6BDrawable@1@@
CONST	SEGMENT
??_SSprite@sf@@6BDrawable@1@@ DD FLAT:??_R4Sprite@sf@@6BDrawable@1@@ ; sf::Sprite::`local vftable'
	DD	FLAT:??_ESprite@sf@@UAEPAXI@Z
	DD	FLAT:?draw@Sprite@sf@@EBEXAAVRenderTarget@2@VRenderStates@2@@Z
CONST	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0195H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bfH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z DB '1'
	DB	' 16 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	021H
	DB	02eH
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	025aH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1
__ehfuncinfo$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z DB '3'
	DB	' 16 1 4 $S19 32 8 6 _Proxy 48 4 6 _Guard'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z DB '1'
	DB	' 16 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z$0
__unwindtable$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z$2
__ehfuncinfo$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	017H
	DB	021H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	02fH
	DB	0f6H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z$0
__ehfuncinfo$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ DB '2'
	DB	' 16 1 3 $S1 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$0
	DD	06bH
	DD	078H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z
	DD	032H
	DD	0bbbH
voltbl	ENDS
xdata$x	SEGMENT
__ehfuncinfo$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$4
xdata$x	ENDS
CONST	SEGMENT
	ORG $+4
__L__asan_gen_.??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z DB '4'
	DB	' 16 8 18 compiler temporary 32 1 18 compiler temporary 48 4 3'
	DB	' tex 64 16 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ DB '2'
	DB	' 16 1 3 $S2 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z DB '1'
	DB	' 16 1 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	022dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z DB '3 16'
	DB	' 8 6 _Mbst1 32 2 3 _Wc 48 8 6 _Mbst2'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ DB '1 16 12 18 com'
	DB	'piler temporary'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odsp /RTCu
;	COMDAT ??_ESprite@sf@@W3AEPAXI@Z
_TEXT	SEGMENT
??_ESprite@sf@@W3AEPAXI@Z PROC				; [thunk]:sf::Sprite::`vector deleting destructor', COMDAT
  00000	83 e9 04	 sub	 ecx, 4
  00003	e9 00 00 00 00	 jmp	 ??_ESprite@sf@@UAEPAXI@Z
??_ESprite@sf@@W3AEPAXI@Z ENDP				; [thunk]:sf::Sprite::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAVSprite@sf@@@std@@YAPAXPAPAVSprite@sf@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAVSprite@sf@@@std@@YAPAXPAPAVSprite@sf@@@Z PROC ; std::_Voidify_iter<sf::Sprite * *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAPAVSprite@sf@@@std@@YAPAXPAPAVSprite@sf@@@Z ENDP ; std::_Voidify_iter<sf::Sprite * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@PAVSprite@sf@@$$VX@std@@YAPAPAVSprite@sf@@QAPAV12@@Z
_TEXT	SEGMENT
tv72 = -16						; size = 4
tv74 = -12						; size = 4
$T1 = -8						; size = 4
$T2 = -4						; size = 4
__Location$ = 8						; size = 4
??$construct_at@PAVSprite@sf@@$$VX@std@@YAPAPAVSprite@sf@@QAPAV12@@Z PROC ; std::construct_at<sf::Sprite *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR $T2[ebp], 4
  00017	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAVSprite@sf@@@std@@YAPAXPAPAVSprite@sf@@@Z ; std::_Voidify_iter<sf::Sprite * *>
  00020	83 c4 04	 add	 esp, 4
  00023	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00026	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00029	89 4d f0	 mov	 DWORD PTR tv72[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0002f	52		 push	 edx
  00030	8b 45 f0	 mov	 eax, DWORD PTR tv72[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00039	83 c4 08	 add	 esp, 8
  0003c	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0003f	8b 4d fc	 mov	 ecx, DWORD PTR $T2[ebp]
  00042	51		 push	 ecx
  00043	6a 00		 push	 0
  00045	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_memset
  0004e	83 c4 0c	 add	 esp, 12			; 0000000cH
  00051	8b 45 f8	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  00054	8b e5		 mov	 esp, ebp
  00056	5d		 pop	 ebp
  00057	c3		 ret	 0
??$construct_at@PAVSprite@sf@@$$VX@std@@YAPAPAVSprite@sf@@QAPAV12@@Z ENDP ; std::construct_at<sf::Sprite *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@PAVTexture@sf@@PAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@$$QAPAV12@@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@PAVTexture@sf@@PAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@$$QAPAV12@@Z PROC ; std::construct_at<sf::Texture *,sf::Texture *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z ; std::_Voidify_iter<sf::Texture * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::forward<sf::Texture *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@PAVTexture@sf@@PAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@$$QAPAV12@@Z ENDP ; std::construct_at<sf::Texture *,sf::Texture *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVSprite@sf@@$$V@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAXAAV?$allocator@PAVSprite@sf@@@1@QAPAVSprite@sf@@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 4
tv76 = -12						; size = 4
tv78 = -8						; size = 4
$T2 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$construct@PAVSprite@sf@@$$V@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAXAAV?$allocator@PAVSprite@sf@@@1@QAPAVSprite@sf@@@Z PROC ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::construct<sf::Sprite *>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 0e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$construct_at@PAVSprite@sf@@$$VX@std@@YAPAPAVSprite@sf@@QAPAV12@@Z ; std::construct_at<sf::Sprite *,void>
  00025	83 c4 04	 add	 esp, 4

; 711  :         } else

  00028	eb 41		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0002a	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR $T2[ebp], 4
  00031	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00034	52		 push	 edx
  00035	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAVSprite@sf@@@std@@YAPAXPAPAVSprite@sf@@@Z ; std::_Voidify_iter<sf::Sprite * *>
  0003a	83 c4 04	 add	 esp, 4
  0003d	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
  00040	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  00043	89 45 f4	 mov	 DWORD PTR tv76[ebp], eax
  00046	8b 4d f8	 mov	 ecx, DWORD PTR tv78[ebp]
  00049	51		 push	 ecx
  0004a	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00059	8b 45 fc	 mov	 eax, DWORD PTR $T2[ebp]
  0005c	50		 push	 eax
  0005d	6a 00		 push	 0
  0005f	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ___asan_memset
  00068	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??$construct@PAVSprite@sf@@$$V@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAXAAV?$allocator@PAVSprite@sf@@@1@QAPAVSprite@sf@@@Z ENDP ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::construct<sf::Sprite *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVSprite@sf@@@std@@YA?A_PABQAPAVSprite@sf@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAPAVSprite@sf@@@std@@YA?A_PABQAPAVSprite@sf@@@Z PROC ; std::_To_address<sf::Sprite * *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@@Z ; std::to_address<sf::Sprite *>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAPAVSprite@sf@@@std@@YA?A_PABQAPAVSprite@sf@@@Z ENDP ; std::_To_address<sf::Sprite * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVTexture@sf@@PAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@$$QAPAV34@@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVTexture@sf@@PAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@$$QAPAV34@@Z PROC ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture *>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::forward<sf::Texture *>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@PAVTexture@sf@@PAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@$$QAPAV12@@Z ; std::construct_at<sf::Texture *,sf::Texture *,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z ; std::_Voidify_iter<sf::Texture * *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::forward<sf::Texture *>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@PAVTexture@sf@@PAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@$$QAPAV34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z PROC ; std::forward<sf::Texture *>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ENDP ; std::forward<sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z PROC ; std::_To_address<sf::Texture * *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@QAPAV12@@Z ; std::to_address<sf::Texture *>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z ENDP ; std::_To_address<sf::Texture * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
tv76 = -52						; size = 4
tv71 = -48						; size = 4
tv73 = -44						; size = 4
tv75 = -40						; size = 4
tv74 = -36						; size = 4
tv68 = -32						; size = 4
tv65 = -28						; size = 4
tv86 = -24						; size = 4
tv128 = -20						; size = 4
tv138 = -16						; size = 4
tv148 = -12						; size = 4
_this$ = -8						; size = 4
tv89 = -4						; size = 1
tv131 = -3						; size = 1
tv141 = -2						; size = 1
tv151 = -1						; size = 1
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXXZ PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Emplace_back<>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  0001f	89 4d f4	 mov	 DWORD PTR tv148[ebp], ecx
  00022	8b 55 f4	 mov	 edx, DWORD PTR tv148[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv151[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv151[ebp], 0
  00035	74 1a		 je	 SHORT $LN6@Emplace_ba
  00037	8a 4d f4	 mov	 cl, BYTE PTR tv148[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv151[ebp]
  00043	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00045	8b 55 f4	 mov	 edx, DWORD PTR tv148[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00051	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$_Unfancy@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Sprite *>
  0005c	83 c4 04	 add	 esp, 4
  0005f	89 45 d4	 mov	 DWORD PTR tv73[ebp], eax
  00062	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00065	83 c2 08	 add	 edx, 8
  00068	89 55 e0	 mov	 DWORD PTR tv68[ebp], edx
  0006b	8b 45 e0	 mov	 eax, DWORD PTR tv68[ebp]
  0006e	89 45 f0	 mov	 DWORD PTR tv138[ebp], eax
  00071	8b 4d f0	 mov	 ecx, DWORD PTR tv138[ebp]
  00074	c1 e9 03	 shr	 ecx, 3
  00077	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0007d	88 55 fe	 mov	 BYTE PTR tv141[ebp], dl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv141[ebp], 0
  00084	74 18		 je	 SHORT $LN5@Emplace_ba
  00086	8a 45 f0	 mov	 al, BYTE PTR tv138[ebp]
  00089	24 07		 and	 al, 7
  0008b	04 03		 add	 al, 3
  0008d	3a 45 fe	 cmp	 al, BYTE PTR tv141[ebp]
  00090	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  00092	8b 4d f0	 mov	 ecx, DWORD PTR tv138[ebp]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ___asan_report_load4
  0009b	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  0009e	8b 55 e0	 mov	 edx, DWORD PTR tv68[ebp]
  000a1	8b 02		 mov	 eax, DWORD PTR [edx]
  000a3	89 45 d0	 mov	 DWORD PTR tv71[ebp], eax
  000a6	8b 4d d4	 mov	 ecx, DWORD PTR tv73[ebp]
  000a9	51		 push	 ecx
  000aa	8b 55 d0	 mov	 edx, DWORD PTR tv71[ebp]
  000ad	52		 push	 edx
  000ae	e8 00 00 00 00	 call	 ??$construct@PAVSprite@sf@@$$V@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAXAAV?$allocator@PAVSprite@sf@@@1@QAPAVSprite@sf@@@Z ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::construct<sf::Sprite *>
  000b3	83 c4 08	 add	 esp, 8

; 1632 :         ++_Last;

  000b6	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b9	83 c0 04	 add	 eax, 4
  000bc	89 45 dc	 mov	 DWORD PTR tv74[ebp], eax
  000bf	8b 4d dc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	89 4d ec	 mov	 DWORD PTR tv128[ebp], ecx
  000c5	8b 55 ec	 mov	 edx, DWORD PTR tv128[ebp]
  000c8	c1 ea 03	 shr	 edx, 3
  000cb	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d1	88 45 fd	 mov	 BYTE PTR tv131[ebp], al
  000d4	80 7d fd 00	 cmp	 BYTE PTR tv131[ebp], 0
  000d8	74 1a		 je	 SHORT $LN4@Emplace_ba
  000da	8a 4d ec	 mov	 cl, BYTE PTR tv128[ebp]
  000dd	80 e1 07	 and	 cl, 7
  000e0	80 c1 03	 add	 cl, 3
  000e3	3a 4d fd	 cmp	 cl, BYTE PTR tv131[ebp]
  000e6	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000e8	8b 55 ec	 mov	 edx, DWORD PTR tv128[ebp]
  000eb	52		 push	 edx
  000ec	e8 00 00 00 00	 call	 ___asan_report_load4
  000f1	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  000f4	8b 45 dc	 mov	 eax, DWORD PTR tv74[ebp]
  000f7	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f9	83 c1 04	 add	 ecx, 4
  000fc	89 4d cc	 mov	 DWORD PTR tv76[ebp], ecx
  000ff	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00102	83 c2 04	 add	 edx, 4
  00105	89 55 d8	 mov	 DWORD PTR tv75[ebp], edx
  00108	8b 45 d8	 mov	 eax, DWORD PTR tv75[ebp]
  0010b	89 45 e8	 mov	 DWORD PTR tv86[ebp], eax
  0010e	8b 4d e8	 mov	 ecx, DWORD PTR tv86[ebp]
  00111	c1 e9 03	 shr	 ecx, 3
  00114	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0011a	88 55 fc	 mov	 BYTE PTR tv89[ebp], dl
  0011d	80 7d fc 00	 cmp	 BYTE PTR tv89[ebp], 0
  00121	74 18		 je	 SHORT $LN3@Emplace_ba
  00123	8a 45 e8	 mov	 al, BYTE PTR tv86[ebp]
  00126	24 07		 and	 al, 7
  00128	04 03		 add	 al, 3
  0012a	3a 45 fc	 cmp	 al, BYTE PTR tv89[ebp]
  0012d	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  0012f	8b 4d e8	 mov	 ecx, DWORD PTR tv86[ebp]
  00132	51		 push	 ecx
  00133	e8 00 00 00 00	 call	 ___asan_report_store4
  00138	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  0013b	8b 55 d8	 mov	 edx, DWORD PTR tv75[ebp]
  0013e	8b 45 cc	 mov	 eax, DWORD PTR tv76[ebp]
  00141	89 02		 mov	 DWORD PTR [edx], eax

; 1633 :     }

  00143	8b e5		 mov	 esp, ebp
  00145	5d		 pop	 ebp
  00146	c3		 ret	 0
??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Emplace_back<>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAPAVSprite@sf@@XZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAPAVSprite@sf@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAPAVSprite@sf@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::~_Uninitialized_backout_al<std::allocator<sf::Sprite *> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVSprite@sf@@@std@@@std@@YAXPAPAVSprite@sf@@QAPAV12@AAV?$allocator@PAVSprite@sf@@@0@@Z ; std::_Destroy_range<std::allocator<sf::Sprite *> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::~_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@PAPAVSprite@sf@@AAV?$allocator@PAVSprite@sf@@@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@PAPAVSprite@sf@@AAV?$allocator@PAVSprite@sf@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@PAPAVSprite@sf@@AAV?$allocator@PAVSprite@sf@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Zero_range@PAPAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@0@Z
_TEXT	SEGMENT
__Last_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$_Zero_range@PAPAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@0@Z PROC ; std::_Zero_range<sf::Sprite * *>, COMDAT

; 1806 : _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1807 :     char* const _First_ch = reinterpret_cast<char*>(_To_address(_First));

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAPAVSprite@sf@@@std@@YA?A_PABQAPAVSprite@sf@@@Z ; std::_To_address<sf::Sprite * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 1808 :     char* const _Last_ch  = reinterpret_cast<char*>(_To_address(_Last));

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAPAVSprite@sf@@@std@@YA?A_PABQAPAVSprite@sf@@@Z ; std::_To_address<sf::Sprite * *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 f8	 mov	 DWORD PTR __Last_ch$[ebp], eax

; 1809 :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

  0002e	8b 55 f8	 mov	 edx, DWORD PTR __Last_ch$[ebp]
  00031	2b 55 fc	 sub	 edx, DWORD PTR __First_ch$[ebp]
  00034	52		 push	 edx
  00035	6a 00		 push	 0
  00037	8b 45 fc	 mov	 eax, DWORD PTR __First_ch$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 _memset
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1810 :     return _Last;

  00043	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]

; 1811 : }

  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??$_Zero_range@PAPAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@0@Z ENDP ; std::_Zero_range<sf::Sprite * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@PAPAV12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@PAPAV12@@Z PROC ; std::_Unfancy<sf::Sprite *>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@PAPAV12@@Z ENDP ; std::_Unfancy<sf::Sprite *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@@Z PROC ; std::to_address<sf::Sprite *>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@@Z ENDP ; std::to_address<sf::Sprite *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@PAVTexture@sf@@@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEX$$QAPAVTexture@sf@@@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@PAVTexture@sf@@@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEX$$QAPAVTexture@sf@@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Emplace_back<sf::Texture *>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@PAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::forward<sf::Texture *>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Texture *>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@PAVTexture@sf@@PAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@$$QAPAV34@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture *>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@PAVTexture@sf@@@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEX$$QAPAVTexture@sf@@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Emplace_back<sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@XZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::~_Uninitialized_backout_al<std::allocator<sf::Texture *> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVTexture@sf@@@std@@@std@@YAXPAPAVTexture@sf@@QAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Destroy_range<std::allocator<sf::Texture *> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::~_Uninitialized_backout_al<std::allocator<sf::Texture *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@PAPAVTexture@sf@@AAV?$allocator@PAVTexture@sf@@@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@PAPAVTexture@sf@@AAV?$allocator@PAVTexture@sf@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Uninitialized_backout_al<std::allocator<sf::Texture *> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@PAPAVTexture@sf@@AAV?$allocator@PAVTexture@sf@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Uninitialized_backout_al<std::allocator<sf::Texture *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVTexture@sf@@PAPAV12@@std@@YAPAPAVTexture@sf@@PAPAV12@00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAVTexture@sf@@PAPAV12@@std@@YAPAPAVTexture@sf@@PAPAV12@00@Z PROC ; std::_Copy_memmove<sf::Texture * *,sf::Texture * *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z ; std::_To_address<sf::Texture * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z ; std::_To_address<sf::Texture * *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAPAVTexture@sf@@@std@@YA?A_PABQAPAVTexture@sf@@@Z ; std::_To_address<sf::Texture * *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PAPAVTexture@sf@@PAPAV12@@std@@YAPAPAVTexture@sf@@PAPAV12@00@Z ENDP ; std::_Copy_memmove<sf::Texture * *,sf::Texture * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@QAPAV12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@QAPAV12@@Z PROC ; std::to_address<sf::Texture *>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@QAPAV12@@Z ENDP ; std::to_address<sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$move@AAPAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAPAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z PROC ; std::move<sf::Texture * &>, COMDAT

; 1455 : _NODISCARD constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept { // forward _Arg as movable

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1456 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1457 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$move@AAPAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ENDP ; std::move<sf::Texture * &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAPAVTexture@sf@@@std@@YA?A_TABQAPAVTexture@sf@@@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAPAVTexture@sf@@@std@@YA?A_TABQAPAVTexture@sf@@@Z PROC ; std::_Get_unwrapped<sf::Texture * * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQAPAVTexture@sf@@@std@@YA?A_TABQAPAVTexture@sf@@@Z ENDP ; std::_Get_unwrapped<sf::Texture * * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 693  :     static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 694  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 695  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 696  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN2@deallocate

; 697  :             _Al.deallocate(_Ptr, _Count);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00024	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 698  :         } else

  00029	eb 13		 jmp	 SHORT $LN1@deallocate
$LN2@deallocate:

; 699  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 700  :         {
; 701  :             (void) _Al;
; 702  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	c1 e0 03	 shl	 eax, 3
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003b	83 c4 08	 add	 esp, 8
$LN1@deallocate:

; 703  :         }
; 704  :     }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
tv93 = -68						; size = 4
__PFirst$3 = -64					; size = 4
tv91 = -60						; size = 4
tv128 = -56						; size = 4
tv78 = -52						; size = 4
$T4 = -48						; size = 4
tv134 = -44						; size = 4
tv90 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z PROC ; std::_Uninitialized_value_construct_n<std::allocator<sf::Sprite *> >, COMDAT

; 1815 :     _Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<sf::Sprite *> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv91[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv91[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv93[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv93[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv93[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv93[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1816 :     // value-initialize _Count objects to raw _First, using _Al
; 1817 :     using _Ptrty = typename _Alloc::value_type*;
; 1818 :     if constexpr (_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value) {
; 1819 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1820 :         if (!_STD is_constant_evaluated())

  00092	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00097	0f b6 c8	 movzx	 ecx, al
  0009a	85 c9		 test	 ecx, ecx
  0009c	75 63		 jne	 SHORT $LN5@Uninitiali

; 1821 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1822 :         {
; 1823 :             auto _PFirst = _Unfancy(_First);

  0009e	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  000a1	52		 push	 edx
  000a2	e8 00 00 00 00	 call	 ??$_Unfancy@PAVSprite@sf@@@std@@YAPAPAVSprite@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Sprite *>
  000a7	83 c4 04	 add	 esp, 4
  000aa	89 45 c0	 mov	 DWORD PTR __PFirst$3[ebp], eax

; 1824 :             _Zero_range(_PFirst, _PFirst + _Count);

  000ad	8b 43 0c	 mov	 eax, DWORD PTR __Count$[ebx]
  000b0	8b 4d c0	 mov	 ecx, DWORD PTR __PFirst$3[ebp]
  000b3	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000b6	52		 push	 edx
  000b7	8b 45 c0	 mov	 eax, DWORD PTR __PFirst$3[ebp]
  000ba	50		 push	 eax
  000bb	e8 00 00 00 00	 call	 ??$_Zero_range@PAPAVSprite@sf@@@std@@YAPAPAVSprite@sf@@QAPAV12@0@Z ; std::_Zero_range<sf::Sprite * *>
  000c0	83 c4 08	 add	 esp, 8

; 1825 :             return _First + _Count;

  000c3	8b 4b 0c	 mov	 ecx, DWORD PTR __Count$[ebx]
  000c6	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  000c9	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000cc	89 45 cc	 mov	 DWORD PTR tv78[ebp], eax
  000cf	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000d9	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000df	c1 e9 03	 shr	 ecx, 3
  000e2	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  000e8	89 4d c8	 mov	 DWORD PTR tv128[ebp], ecx
  000eb	6a 08		 push	 8
  000ed	8b 55 c8	 mov	 edx, DWORD PTR tv128[ebp]
  000f0	52		 push	 edx
  000f1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000f6	83 c4 08	 add	 esp, 8
  000f9	8b 45 cc	 mov	 eax, DWORD PTR tv78[ebp]
  000fc	e9 89 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1826 :         }
; 1827 :     }
; 1828 : 
; 1829 :     _Uninitialized_backout_al<_Alloc> _Backout{_First, _Al};

  00101	6a 0c		 push	 12			; 0000000cH
  00103	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00106	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z
  0010b	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  0010e	50		 push	 eax
  0010f	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  00112	51		 push	 ecx
  00113	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00116	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@PAPAVSprite@sf@@AAV?$allocator@PAVSprite@sf@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
  0011b	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1830 :     for (; 0 < _Count; --_Count) {

  00122	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00124	8b 53 0c	 mov	 edx, DWORD PTR __Count$[ebx]
  00127	83 ea 01	 sub	 edx, 1
  0012a	89 53 0c	 mov	 DWORD PTR __Count$[ebx], edx
$LN4@Uninitiali:
  0012d	83 7b 0c 00	 cmp	 DWORD PTR __Count$[ebx], 0
  00131	76 0a		 jbe	 SHORT $LN3@Uninitiali

; 1831 :         _Backout._Emplace_back();

  00133	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00136	e8 00 00 00 00	 call	 ??$_Emplace_back@$$V@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXXZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Emplace_back<>

; 1832 :     }

  0013b	eb e7		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1833 : 
; 1834 :     return _Backout._Release();

  0013d	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00140	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAPAVSprite@sf@@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::_Release
  00145	89 45 d0	 mov	 DWORD PTR $T4[ebp], eax
  00148	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0014f	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00152	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::~_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
  00157	8b 45 d0	 mov	 eax, DWORD PTR $T4[ebp]
  0015a	89 45 d8	 mov	 DWORD PTR tv90[ebp], eax
  0015d	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00167	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  0016d	c1 e9 03	 shr	 ecx, 3
  00170	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00176	89 4d d4	 mov	 DWORD PTR tv134[ebp], ecx
  00179	6a 08		 push	 8
  0017b	8b 55 d4	 mov	 edx, DWORD PTR tv134[ebp]
  0017e	52		 push	 edx
  0017f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00184	83 c4 08	 add	 esp, 8
  00187	8b 45 d8	 mov	 eax, DWORD PTR tv90[ebp]
$LN1@Uninitiali:

; 1835 : }

  0018a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0018d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00194	59		 pop	 ecx
  00195	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00198	33 cd		 xor	 ecx, ebp
  0019a	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0019f	8b e5		 mov	 esp, ebp
  001a1	5d		 pop	 ebp
  001a2	8b e3		 mov	 esp, ebx
  001a4	5b		 pop	 ebx
  001a5	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Sprite *> >::~_Uninitialized_backout_al<std::allocator<sf::Sprite *> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z ENDP ; std::_Uninitialized_value_construct_n<std::allocator<sf::Sprite *> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv133 = -68						; size = 4
__ULast$ = -64						; size = 4
tv131 = -60						; size = 4
tv136 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv142 = -44						; size = 4
tv130 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z PROC ; std::_Uninitialized_move<sf::Texture * *,std::allocator<sf::Texture *> >, COMDAT

; 1713 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Uninitialized_move<sf::Texture * *,std::allocator<sf::Texture *> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv131[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv131[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv133[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv133[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv133[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv133[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1714 :     // move [_First, _Last) to raw _Dest, using _Al
; 1715 :     // note: only called internally from elsewhere in the STL
; 1716 :     using _Ptrval     = typename _Alloc::value_type*;
; 1717 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAPAVTexture@sf@@@std@@YA?A_TABQAPAVTexture@sf@@@Z ; std::_Get_unwrapped<sf::Texture * * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1718 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAPAVTexture@sf@@@std@@YA?A_TABQAPAVTexture@sf@@@Z ; std::_Get_unwrapped<sf::Texture * * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1719 :     if constexpr (conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1720 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(_STD move(*_UFirst))>>) {
; 1721 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1722 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 61		 jne	 SHORT $LN5@Uninitiali

; 1723 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1724 :         {
; 1725 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Texture *>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAPAVTexture@sf@@PAPAV12@@std@@YAPAPAVTexture@sf@@PAPAV12@00@Z ; std::_Copy_memmove<sf::Texture * *,sf::Texture * *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1726 :             return _Dest + (_ULast - _UFirst);

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 45 cc	 mov	 DWORD PTR tv83[ebp], eax
  000eb	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000f5	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000fb	c1 e9 03	 shr	 ecx, 3
  000fe	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00104	89 4d c8	 mov	 DWORD PTR tv136[ebp], ecx
  00107	6a 08		 push	 8
  00109	8b 55 c8	 mov	 edx, DWORD PTR tv136[ebp]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00112	83 c4 08	 add	 esp, 8
  00115	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  00118	e9 97 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1727 :         }
; 1728 :     }
; 1729 : 
; 1730 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  0011d	6a 0c		 push	 12			; 0000000cH
  0011f	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00122	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z
  00127	8b 43 14	 mov	 eax, DWORD PTR __Al$[ebx]
  0012a	50		 push	 eax
  0012b	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  0012e	51		 push	 ecx
  0012f	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00132	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@PAPAVTexture@sf@@AAV?$allocator@PAVTexture@sf@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Uninitialized_backout_al<std::allocator<sf::Texture *> >
  00137	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1731 :     for (; _UFirst != _ULast; ++_UFirst) {

  0013e	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00140	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  00143	83 c2 04	 add	 edx, 4
  00146	89 55 b8	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  00149	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  0014c	3b 45 c0	 cmp	 eax, DWORD PTR __ULast$[ebp]
  0014f	74 17		 je	 SHORT $LN3@Uninitiali

; 1732 :         _Backout._Emplace_back(_STD move(*_UFirst));

  00151	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00154	51		 push	 ecx
  00155	e8 00 00 00 00	 call	 ??$move@AAPAVTexture@sf@@@std@@YA$$QAPAVTexture@sf@@AAPAV12@@Z ; std::move<sf::Texture * &>
  0015a	83 c4 04	 add	 esp, 4
  0015d	50		 push	 eax
  0015e	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00161	e8 00 00 00 00	 call	 ??$_Emplace_back@PAVTexture@sf@@@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEX$$QAPAVTexture@sf@@@Z ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Emplace_back<sf::Texture *>

; 1733 :     }

  00166	eb d8		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1734 : 
; 1735 :     return _Backout._Release();

  00168	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0016b	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::_Release
  00170	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00173	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0017a	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017d	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::~_Uninitialized_backout_al<std::allocator<sf::Texture *> >
  00182	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp]
  00185	89 55 d8	 mov	 DWORD PTR tv130[ebp], edx
  00188	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00192	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00198	c1 e8 03	 shr	 eax, 3
  0019b	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001a0	89 45 d4	 mov	 DWORD PTR tv142[ebp], eax
  001a3	6a 08		 push	 8
  001a5	8b 4d d4	 mov	 ecx, DWORD PTR tv142[ebp]
  001a8	51		 push	 ecx
  001a9	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ae	83 c4 08	 add	 esp, 8
  001b1	8b 45 d8	 mov	 eax, DWORD PTR tv130[ebp]
$LN1@Uninitiali:

; 1736 : }

  001b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001be	59		 pop	 ecx
  001bf	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c2	33 cd		 xor	 ecx, ebp
  001c4	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c9	8b e5		 mov	 esp, ebp
  001cb	5d		 pop	 ebp
  001cc	8b e3		 mov	 esp, ebx
  001ce	5b		 pop	 ebx
  001cf	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<sf::Texture *> >::~_Uninitialized_backout_al<std::allocator<sf::Texture *> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ENDP ; std::_Uninitialized_move<sf::Texture * *,std::allocator<sf::Texture *> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
tv90 = -32						; size = 4
tv88 = -28						; size = 4
__Block_size$ = -24					; size = 4
__Ptr$ = -20						; size = 4
tv128 = -16						; size = 4
__Ptr_container$ = -12					; size = 4
tv138 = -8						; size = 4
tv131 = -2						; size = 1
tv141 = -1						; size = 1
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	83 c0 27	 add	 eax, 39			; 00000027H
  00016	89 45 e8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 137  :     if (_Block_size <= _Bytes) {

  00019	8b 4d e8	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  0001c	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  0001f	77 05		 ja	 SHORT $LN8@Allocate_m

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00021	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00026	8b 55 e8	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f4	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00035	83 7d f4 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00039	74 02		 je	 SHORT $LN7@Allocate_m
  0003b	eb 4a		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  0003d	68 00 00 00 00	 push	 OFFSET $SG90610
  00042	68 00 00 00 00	 push	 OFFSET $SG90611
  00047	6a 00		 push	 0
  00049	68 8e 00 00 00	 push	 142			; 0000008eH
  0004e	68 00 00 00 00	 push	 OFFSET $SG90612
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN12@Allocate_m
  00063	cc		 int	 3
$LN12@Allocate_m:
  00064	6a 00		 push	 0
  00066	68 8e 00 00 00	 push	 142			; 0000008eH
  0006b	68 00 00 00 00	 push	 OFFSET $SG90613
  00070	68 00 00 00 00	 push	 OFFSET $SG90614
  00075	68 00 00 00 00	 push	 OFFSET $SG90615
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	33 c9		 xor	 ecx, ecx
  00085	75 b6		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00087	33 d2		 xor	 edx, edx
  00089	75 aa		 jne	 SHORT $LN4@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0008e	83 c0 27	 add	 eax, 39			; 00000027H
  00091	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00094	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00097	b9 04 00 00 00	 mov	 ecx, 4
  0009c	6b d1 ff	 imul	 edx, ecx, -1
  0009f	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a2	03 c2		 add	 eax, edx
  000a4	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR tv88[ebp]
  000aa	89 4d f8	 mov	 DWORD PTR tv138[ebp], ecx
  000ad	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000b0	c1 ea 03	 shr	 edx, 3
  000b3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b9	88 45 ff	 mov	 BYTE PTR tv141[ebp], al
  000bc	80 7d ff 00	 cmp	 BYTE PTR tv141[ebp], 0
  000c0	74 1a		 je	 SHORT $LN14@Allocate_m
  000c2	8a 4d f8	 mov	 cl, BYTE PTR tv138[ebp]
  000c5	80 e1 07	 and	 cl, 7
  000c8	80 c1 03	 add	 cl, 3
  000cb	3a 4d ff	 cmp	 cl, BYTE PTR tv141[ebp]
  000ce	7c 0c		 jl	 SHORT $LN14@Allocate_m
  000d0	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ___asan_report_store4
  000d9	83 c4 04	 add	 esp, 4
$LN14@Allocate_m:
  000dc	8b 45 e4	 mov	 eax, DWORD PTR tv88[ebp]
  000df	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e4	ba 04 00 00 00	 mov	 edx, 4
  000e9	6b c2 fe	 imul	 eax, edx, -2
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ef	03 c8		 add	 ecx, eax
  000f1	89 4d e0	 mov	 DWORD PTR tv90[ebp], ecx
  000f4	8b 55 e0	 mov	 edx, DWORD PTR tv90[ebp]
  000f7	89 55 f0	 mov	 DWORD PTR tv128[ebp], edx
  000fa	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  000fd	c1 e8 03	 shr	 eax, 3
  00100	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00106	88 4d fe	 mov	 BYTE PTR tv131[ebp], cl
  00109	80 7d fe 00	 cmp	 BYTE PTR tv131[ebp], 0
  0010d	74 1a		 je	 SHORT $LN13@Allocate_m
  0010f	8a 55 f0	 mov	 dl, BYTE PTR tv128[ebp]
  00112	80 e2 07	 and	 dl, 7
  00115	80 c2 03	 add	 dl, 3
  00118	3a 55 fe	 cmp	 dl, BYTE PTR tv131[ebp]
  0011b	7c 0c		 jl	 SHORT $LN13@Allocate_m
  0011d	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ___asan_report_store4
  00126	83 c4 04	 add	 esp, 4
$LN13@Allocate_m:
  00129	8b 4d e0	 mov	 ecx, DWORD PTR tv90[ebp]
  0012c	c7 01 fa fa fa
	fa		 mov	 DWORD PTR [ecx], -84215046 ; fafafafaH

; 148  : #endif // _DEBUG
; 149  :     return _Ptr;

  00132	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 150  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >::~_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >::~_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@PAVSprite@sf@@@std@@@std@@YAABV?$allocator@PAVSprite@sf@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@PAVSprite@sf@@@std@@@std@@YAABV?$allocator@PAVSprite@sf@@@0@ABV10@@Z PROC ; std::forward<std::allocator<sf::Sprite *> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@PAVSprite@sf@@@std@@@std@@YAABV?$allocator@PAVSprite@sf@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<sf::Sprite *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 985  : _CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 986  :     // deallocate a plain pointer using an allocator
; 987  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 988  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 989  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  0002c	6a 01		 push	 1
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 990  :     } else {
; 991  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 992  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 993  :     }
; 994  : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z PROC ; std::_Voidify_iter<sf::Texture * *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z ENDP ; std::_Voidify_iter<sf::Texture * *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@PAVTexture@sf@@ABQAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@ABQAV12@@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@PAVTexture@sf@@ABQAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@ABQAV12@@Z PROC ; std::construct_at<sf::Texture *,sf::Texture * const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z ; std::_Voidify_iter<sf::Texture * *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@PAVTexture@sf@@ABQAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@ABQAV12@@Z ENDP ; std::construct_at<sf::Texture *,sf::Texture * const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z PROC ; std::_Voidify_iter<std::_Container_proxy *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ENDP ; std::_Voidify_iter<std::_Container_proxy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv78 = -16						; size = 4
tv74 = -12						; size = 4
tv82 = -8						; size = 4
tv85 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 08		 push	 8
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv85[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00052	74 1a		 je	 SHORT $LN3@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv82[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv85[ebp]
  00060	7c 0c		 jl	 SHORT $LN3@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN3@construct_:
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
  00076	8b 45 f0	 mov	 eax, DWORD PTR tv78[ebp]
  00079	50		 push	 eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0007d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 145  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 02	 shl	 eax, 2
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVSprite@sf@@@std@@@std@@YAXPAPAVSprite@sf@@QAPAV12@AAV?$allocator@PAVSprite@sf@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVSprite@sf@@@std@@@std@@YAXPAPAVSprite@sf@@QAPAV12@AAV?$allocator@PAVSprite@sf@@@0@@Z PROC ; std::_Destroy_range<std::allocator<sf::Sprite *> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVSprite@sf@@@std@@@std@@YAXPAPAVSprite@sf@@QAPAV12@AAV?$allocator@PAVSprite@sf@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<sf::Sprite *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 251  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  0002c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4

; 256  :     } else

  00044	eb 29		 jmp	 SHORT $LN5@Deallocate
$LN2@Deallocate:

; 257  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00046	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0004d	72 10		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004f	8d 55 0c	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00052	52		 push	 edx
  00053	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0005c	83 c4 08	 add	 esp, 8
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006c	83 c4 08	 add	 esp, 8
$LN5@Deallocate:

; 265  :     }
; 266  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@PAVTexture@sf@@@std@@@std@@YAXPAPAVTexture@sf@@QAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVTexture@sf@@@std@@@std@@YAXPAPAVTexture@sf@@QAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z PROC ; std::_Destroy_range<std::allocator<sf::Texture *> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@PAVTexture@sf@@@std@@@std@@YAXPAPAVTexture@sf@@QAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<sf::Texture *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 17		 jne	 SHORT $LN2@Allocate

; 235  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00020	72 0e		 jb	 SHORT $LN2@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0002b	83 c4 04	 add	 esp, 4
  0002e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00030	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00034	74 0e		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00036	8b 55 08	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003f	83 c4 04	 add	 esp, 4
  00042	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00044	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv79 = -16						; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
tv85 = -1						; size = 1
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1353 :     _CONSTEXPR20_CONTAINER ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1354 :         if (_Ptr) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv79[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv82[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv85[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv82[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv85[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 15		 je	 SHORT $LN3@Container_

; 1355 :             _Delete_plain_internal(_Al, _Ptr);

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	52		 push	 edx
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00068	83 c4 08	 add	 esp, 8
$LN3@Container_:

; 1356 :         }
; 1357 :     }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
$T2 = -112						; size = 4
tv199 = -69						; size = 1
tv189 = -68						; size = 1
tv179 = -67						; size = 1
tv169 = -66						; size = 1
tv159 = -65						; size = 1
_this$ = -64						; size = 4
tv146 = -60						; size = 4
tv196 = -56						; size = 4
tv186 = -52						; size = 4
tv176 = -48						; size = 4
tv166 = -44						; size = 4
tv156 = -40						; size = 4
tv69 = -36						; size = 4
tv92 = -32						; size = 4
tv144 = -28						; size = 4
tv134 = -24						; size = 4
tv75 = -20						; size = 4
tv83 = -16						; size = 4
tv139 = -12						; size = 4
tv152 = -8						; size = 4
tv131 = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1339 :     _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
  0002d	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00034	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e4	 mov	 DWORD PTR tv144[ebp], eax
  0003a	8b 4d e4	 mov	 ecx, DWORD PTR tv144[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d c4	 mov	 DWORD PTR tv146[ebp], ecx
  00049	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  0004c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00052	83 45 c4 04	 add	 DWORD PTR tv146[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d c4	 mov	 ecx, DWORD PTR tv146[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 c4 02	 add	 DWORD PTR tv146[ebp], 2
  00065	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00070	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00075	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0007d	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 c0 04	 add	 eax, 4
  00083	89 45 dc	 mov	 DWORD PTR tv69[ebp], eax
  00086	8b 4d dc	 mov	 ecx, DWORD PTR tv69[ebp]
  00089	89 4d c8	 mov	 DWORD PTR tv196[ebp], ecx
  0008c	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  0008f	c1 ea 03	 shr	 edx, 3
  00092	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00098	88 45 bb	 mov	 BYTE PTR tv199[ebp], al
  0009b	80 7d bb 00	 cmp	 BYTE PTR tv199[ebp], 0
  0009f	74 1a		 je	 SHORT $LN7@Container_
  000a1	8a 4d c8	 mov	 cl, BYTE PTR tv196[ebp]
  000a4	80 e1 07	 and	 cl, 7
  000a7	80 c1 03	 add	 cl, 3
  000aa	3a 4d bb	 cmp	 cl, BYTE PTR tv199[ebp]
  000ad	7c 0c		 jl	 SHORT $LN7@Container_
  000af	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ___asan_report_store4
  000b8	83 c4 04	 add	 esp, 4
$LN7@Container_:
  000bb	8b 45 dc	 mov	 eax, DWORD PTR tv69[ebp]
  000be	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c1	89 08		 mov	 DWORD PTR [eax], ecx

; 1340 :         // create a new _Container_proxy pointing at _Mycont
; 1341 :         _Ptr = _Unfancy(_Al_.allocate(1));

  000c3	6a 01		 push	 1
  000c5	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  000d3	83 c4 04	 add	 esp, 4
  000d6	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  000d9	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000dc	89 55 e8	 mov	 DWORD PTR tv134[ebp], edx
  000df	8b 45 e8	 mov	 eax, DWORD PTR tv134[ebp]
  000e2	89 45 cc	 mov	 DWORD PTR tv186[ebp], eax
  000e5	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  000e8	c1 e9 03	 shr	 ecx, 3
  000eb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f1	88 55 bc	 mov	 BYTE PTR tv189[ebp], dl
  000f4	80 7d bc 00	 cmp	 BYTE PTR tv189[ebp], 0
  000f8	74 18		 je	 SHORT $LN6@Container_
  000fa	8a 45 cc	 mov	 al, BYTE PTR tv186[ebp]
  000fd	24 07		 and	 al, 7
  000ff	04 03		 add	 al, 3
  00101	3a 45 bc	 cmp	 al, BYTE PTR tv189[ebp]
  00104	7c 0c		 jl	 SHORT $LN6@Container_
  00106	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 ___asan_report_store4
  0010f	83 c4 04	 add	 esp, 4
$LN6@Container_:
  00112	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00115	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00118	89 02		 mov	 DWORD PTR [edx], eax

; 1342 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  0011a	8b 4b 0c	 mov	 ecx, DWORD PTR __Mycont$[ebx]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00123	83 c4 04	 add	 esp, 4
  00126	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  00129	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  0012c	89 55 d0	 mov	 DWORD PTR tv176[ebp], edx
  0012f	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00132	c1 e8 03	 shr	 eax, 3
  00135	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0013b	88 4d bd	 mov	 BYTE PTR tv179[ebp], cl
  0013e	80 7d bd 00	 cmp	 BYTE PTR tv179[ebp], 0
  00142	74 1a		 je	 SHORT $LN5@Container_
  00144	8a 55 d0	 mov	 dl, BYTE PTR tv176[ebp]
  00147	80 e2 07	 and	 dl, 7
  0014a	80 c2 03	 add	 dl, 3
  0014d	3a 55 bd	 cmp	 dl, BYTE PTR tv179[ebp]
  00150	7c 0c		 jl	 SHORT $LN5@Container_
  00152	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ___asan_report_store4
  0015b	83 c4 04	 add	 esp, 4
$LN5@Container_:
  0015e	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00161	89 4d 90	 mov	 DWORD PTR $T2[ebp], ecx
  00164	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00167	52		 push	 edx
  00168	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00173	83 c4 08	 add	 esp, 8
  00176	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00179	c1 ea 03	 shr	 edx, 3
  0017c	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 1343 :         _Mycont._Myproxy = _Ptr;

  00183	8b 43 0c	 mov	 eax, DWORD PTR __Mycont$[ebx]
  00186	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  00189	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0018f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00192	89 55 d4	 mov	 DWORD PTR tv166[ebp], edx
  00195	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  00198	c1 e8 03	 shr	 eax, 3
  0019b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001a1	88 4d be	 mov	 BYTE PTR tv169[ebp], cl
  001a4	80 7d be 00	 cmp	 BYTE PTR tv169[ebp], 0
  001a8	74 1a		 je	 SHORT $LN4@Container_
  001aa	8a 55 d4	 mov	 dl, BYTE PTR tv166[ebp]
  001ad	80 e2 07	 and	 dl, 7
  001b0	80 c2 03	 add	 dl, 3
  001b3	3a 55 be	 cmp	 dl, BYTE PTR tv169[ebp]
  001b6	7c 0c		 jl	 SHORT $LN4@Container_
  001b8	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ___asan_report_load4
  001c1	83 c4 04	 add	 esp, 4
$LN4@Container_:
  001c4	8b 4d e0	 mov	 ecx, DWORD PTR tv92[ebp]
  001c7	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
  001ca	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001cd	c1 ea 03	 shr	 edx, 3
  001d0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001d6	88 45 bf	 mov	 BYTE PTR tv159[ebp], al
  001d9	80 7d bf 00	 cmp	 BYTE PTR tv159[ebp], 0
  001dd	74 1a		 je	 SHORT $LN3@Container_
  001df	8a 4d d8	 mov	 cl, BYTE PTR tv156[ebp]
  001e2	80 e1 07	 and	 cl, 7
  001e5	80 c1 03	 add	 cl, 3
  001e8	3a 4d bf	 cmp	 cl, BYTE PTR tv159[ebp]
  001eb	7c 0c		 jl	 SHORT $LN3@Container_
  001ed	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001f0	52		 push	 edx
  001f1	e8 00 00 00 00	 call	 ___asan_report_store4
  001f6	83 c4 04	 add	 esp, 4
$LN3@Container_:
  001f9	8b 45 e0	 mov	 eax, DWORD PTR tv92[ebp]
  001fc	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00201	89 10		 mov	 DWORD PTR [eax], edx

; 1344 :     }

  00203	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00206	89 45 fc	 mov	 DWORD PTR tv131[ebp], eax
  00209	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00210	8d 4d 80	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00213	c1 e9 03	 shr	 ecx, 3
  00216	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0021c	89 4d f8	 mov	 DWORD PTR tv152[ebp], ecx
  0021f	6a 07		 push	 7
  00221	8b 55 f8	 mov	 edx, DWORD PTR tv152[ebp]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022a	83 c4 08	 add	 esp, 8
  0022d	8b 45 fc	 mov	 eax, DWORD PTR tv131[ebp]
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	8b e3		 mov	 esp, ebx
  00235	5b		 pop	 ebx
  00236	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
tv67 = -20						; size = 4
tv65 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 66   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 67   :     // return smaller of _Left and _Right
; 68   :     return _Right < _Left ? _Right : _Left;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@min
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@min
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@min:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv70[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv76[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@min
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv73[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv76[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@min
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@min:
  00086	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	73 08		 jae	 SHORT $LN3@min
  00092	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00098	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009d	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  000a3	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000a6	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 69   : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -176					; size = 4
__asan_gen_1$ = -172					; size = 4
__asan_gen_2$ = -168					; size = 4
_$S19$ = -160						; size = 1
__Proxy$ = -144						; size = 8
__Guard$3 = -128					; size = 4
tv173 = -83						; size = 1
tv163 = -82						; size = 1
tv153 = -81						; size = 1
tv137 = -80						; size = 4
_this$ = -76						; size = 4
tv170 = -72						; size = 4
__My_data$ = -68					; size = 4
tv160 = -64						; size = 4
tv150 = -60						; size = 4
tv83 = -56						; size = 4
tv135 = -52						; size = 4
__Alproxy$ = -48					; size = 4
tv85 = -44						; size = 4
tv146 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Count$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Construct_n_copies_of_ty<std::_Value_init_tag>, COMDAT
; _this$ = ecx

; 486  :     _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d b4	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 50 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 54 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  00056	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
  00060	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  00069	8b 4d cc	 mov	 ecx, DWORD PTR tv135[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b0	 mov	 DWORD PTR tv137[ebp], ecx
  00078	8b 55 b0	 mov	 edx, DWORD PTR tv137[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b0 04	 add	 DWORD PTR tv137[ebp], 4
  00085	8b 45 b0	 mov	 eax, DWORD PTR tv137[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b0 04	 add	 DWORD PTR tv137[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b0	 mov	 edx, DWORD PTR tv137[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b0 02	 add	 DWORD PTR tv137[ebp], 2
  000a1	8b 45 b0	 mov	 eax, DWORD PTR tv137[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000ac	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 487  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000b1	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b4	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  000b9	50		 push	 eax
  000ba	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _$S19$[ebp]
  000c0	e8 00 00 00 00	 call	 ??$?0PAVSprite@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSprite@sf@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Sprite *>
  000c5	8d 8d 60 ff ff
	ff		 lea	 ecx, DWORD PTR _$S19$[ebp]
  000cb	89 4d d0	 mov	 DWORD PTR __Alproxy$[ebp], ecx

; 488  :         auto& _My_data  = _Mypair._Myval2;

  000ce	8b 55 b4	 mov	 edx, DWORD PTR _this$[ebp]
  000d1	89 55 bc	 mov	 DWORD PTR __My_data$[ebp], edx

; 489  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  000d4	8b 45 bc	 mov	 eax, DWORD PTR __My_data$[ebp]
  000d7	50		 push	 eax
  000d8	8b 4d d0	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000db	51		 push	 ecx
  000dc	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000e2	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  000e7	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 490  :         if (_Count != 0) {

  000ee	83 7b 08 00	 cmp	 DWORD PTR __Count$[ebx], 0
  000f2	0f 84 10 01 00
	00		 je	 $LN2@Construct_
  000f8	8d 55 80	 lea	 edx, DWORD PTR __Guard$3[ebp]
  000fb	c1 ea 03	 shr	 edx, 3
  000fe	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 491  :             _Buy_nonzero(_Count);

  00105	8b 43 08	 mov	 eax, DWORD PTR __Count$[ebx]
  00108	50		 push	 eax
  00109	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  0010c	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_nonzero

; 492  :             _Tidy_guard<vector> _Guard{this};

  00111	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00114	89 4d b8	 mov	 DWORD PTR tv170[ebp], ecx
  00117	8b 55 b8	 mov	 edx, DWORD PTR tv170[ebp]
  0011a	c1 ea 03	 shr	 edx, 3
  0011d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00123	88 45 ad	 mov	 BYTE PTR tv173[ebp], al
  00126	80 7d ad 00	 cmp	 BYTE PTR tv173[ebp], 0
  0012a	74 1a		 je	 SHORT $LN8@Construct_
  0012c	8a 4d b8	 mov	 cl, BYTE PTR tv170[ebp]
  0012f	80 e1 07	 and	 cl, 7
  00132	80 c1 03	 add	 cl, 3
  00135	3a 4d ad	 cmp	 cl, BYTE PTR tv173[ebp]
  00138	7c 0c		 jl	 SHORT $LN8@Construct_
  0013a	8b 55 b8	 mov	 edx, DWORD PTR tv170[ebp]
  0013d	52		 push	 edx
  0013e	e8 00 00 00 00	 call	 ___asan_report_store4
  00143	83 c4 04	 add	 esp, 4
$LN8@Construct_:
  00146	8b 45 b4	 mov	 eax, DWORD PTR _this$[ebp]
  00149	89 45 80	 mov	 DWORD PTR __Guard$3[ebp], eax
  0014c	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 493  :             _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);

  00150	8b 4b 0c	 mov	 ecx, DWORD PTR __Val$[ebx]
  00153	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00156	52		 push	 edx
  00157	8b 43 08	 mov	 eax, DWORD PTR __Count$[ebx]
  0015a	50		 push	 eax
  0015b	8b 4d bc	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0015e	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00161	52		 push	 edx
  00162	8b 4d b4	 mov	 ecx, DWORD PTR _this$[ebp]
  00165	e8 00 00 00 00	 call	 ?_Ufill@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEPAPAVSprite@sf@@PAPAV34@IU_Value_init_tag@2@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Ufill
  0016a	89 45 d4	 mov	 DWORD PTR tv85[ebp], eax
  0016d	8b 45 bc	 mov	 eax, DWORD PTR __My_data$[ebp]
  00170	83 c0 08	 add	 eax, 8
  00173	89 45 c8	 mov	 DWORD PTR tv83[ebp], eax
  00176	8b 4d c8	 mov	 ecx, DWORD PTR tv83[ebp]
  00179	89 4d c0	 mov	 DWORD PTR tv160[ebp], ecx
  0017c	8b 55 c0	 mov	 edx, DWORD PTR tv160[ebp]
  0017f	c1 ea 03	 shr	 edx, 3
  00182	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00188	88 45 ae	 mov	 BYTE PTR tv163[ebp], al
  0018b	80 7d ae 00	 cmp	 BYTE PTR tv163[ebp], 0
  0018f	74 1a		 je	 SHORT $LN7@Construct_
  00191	8a 4d c0	 mov	 cl, BYTE PTR tv160[ebp]
  00194	80 e1 07	 and	 cl, 7
  00197	80 c1 03	 add	 cl, 3
  0019a	3a 4d ae	 cmp	 cl, BYTE PTR tv163[ebp]
  0019d	7c 0c		 jl	 SHORT $LN7@Construct_
  0019f	8b 55 c0	 mov	 edx, DWORD PTR tv160[ebp]
  001a2	52		 push	 edx
  001a3	e8 00 00 00 00	 call	 ___asan_report_store4
  001a8	83 c4 04	 add	 esp, 4
$LN7@Construct_:
  001ab	8b 45 c8	 mov	 eax, DWORD PTR tv83[ebp]
  001ae	8b 4d d4	 mov	 ecx, DWORD PTR tv85[ebp]
  001b1	89 08		 mov	 DWORD PTR [eax], ecx

; 494  :             _Guard._Target   = nullptr;

  001b3	8d 55 80	 lea	 edx, DWORD PTR __Guard$3[ebp]
  001b6	89 55 c4	 mov	 DWORD PTR tv150[ebp], edx
  001b9	8b 45 c4	 mov	 eax, DWORD PTR tv150[ebp]
  001bc	c1 e8 03	 shr	 eax, 3
  001bf	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001c5	88 4d af	 mov	 BYTE PTR tv153[ebp], cl
  001c8	80 7d af 00	 cmp	 BYTE PTR tv153[ebp], 0
  001cc	74 1a		 je	 SHORT $LN6@Construct_
  001ce	8a 55 c4	 mov	 dl, BYTE PTR tv150[ebp]
  001d1	80 e2 07	 and	 dl, 7
  001d4	80 c2 03	 add	 dl, 3
  001d7	3a 55 af	 cmp	 dl, BYTE PTR tv153[ebp]
  001da	7c 0c		 jl	 SHORT $LN6@Construct_
  001dc	8b 45 c4	 mov	 eax, DWORD PTR tv150[ebp]
  001df	50		 push	 eax
  001e0	e8 00 00 00 00	 call	 ___asan_report_store4
  001e5	83 c4 04	 add	 esp, 4
$LN6@Construct_:
  001e8	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __Guard$3[ebp], 0

; 495  :         }

  001ef	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  001f3	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  001f6	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >::~_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >
  001fb	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  001fe	c1 e9 03	 shr	 ecx, 3
  00201	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN2@Construct_:

; 496  : 
; 497  :         _Proxy._Release();

  00208	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0020e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 498  :     }

  00213	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0021a	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00220	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00225	c7 85 50 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0022f	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00235	c1 ea 03	 shr	 edx, 3
  00238	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0023e	89 55 d8	 mov	 DWORD PTR tv146[ebp], edx
  00241	6a 0b		 push	 11			; 0000000bH
  00243	8b 45 d8	 mov	 eax, DWORD PTR tv146[ebp]
  00246	50		 push	 eax
  00247	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0024c	83 c4 08	 add	 esp, 8
  0024f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00252	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00259	59		 pop	 ecx
  0025a	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0025d	33 cd		 xor	 ecx, ebp
  0025f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00264	8b e5		 mov	 esp, ebp
  00266	5d		 pop	 ebp
  00267	8b e3		 mov	 esp, ebx
  00269	5b		 pop	 ebx
  0026a	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$0:
  00000	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z$1:
  0000b	8d 4d 80	 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0000e	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >::~_Tidy_guard<std::vector<sf::Sprite *,std::allocator<sf::Sprite *> > >
  00013	cc		 int	 3
  00014	cc		 int	 3
  00015	cc		 int	 3
  00016	cc		 int	 3
  00017	cc		 int	 3
__ehhandler$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z:
  00018	90		 npad	 1
  00019	90		 npad	 1
  0001a	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001e	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00021	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00031	33 c8		 xor	 ecx, eax
  00033	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00038	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z
  0003d	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@PAVSprite@sf@@@std@@$$V@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVSprite@sf@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@PAVSprite@sf@@@std@@$$V@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVSprite@sf@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1><std::allocator<sf::Sprite *> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@PAVSprite@sf@@@std@@@std@@YAABV?$allocator@PAVSprite@sf@@@0@ABV10@@Z ; std::forward<std::allocator<sf::Sprite *> const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sf::Sprite *> >::_Vector_val<std::_Simple_types<sf::Sprite *> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@PAVSprite@sf@@@std@@$$V@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVSprite@sf@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1><std::allocator<sf::Sprite *> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0PAVSprite@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSprite@sf@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVSprite@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSprite@sf@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Sprite *>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0PAVSprite@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSprite@sf@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Sprite *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
$T2 = -88						; size = 4
tv153 = -43						; size = 1
tv143 = -42						; size = 1
tv133 = -41						; size = 1
tv85 = -40						; size = 4
tv150 = -36						; size = 4
tv140 = -32						; size = 4
__New_proxy$ = -28					; size = 4
tv130 = -24						; size = 4
_this$ = -20						; size = 4
tv74 = -16						; size = 4
tv75 = -12						; size = 4
tv83 = -8						; size = 4
tv94 = -4						; size = 4
__Al$ = 8						; size = 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z PROC ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z
  0002d	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
  00034	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 f8	 mov	 DWORD PTR tv83[ebp], eax
  0003a	8b 4d f8	 mov	 ecx, DWORD PTR tv83[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d8	 mov	 DWORD PTR tv85[ebp], ecx
  00049	8b 55 d8	 mov	 edx, DWORD PTR tv85[ebp]
  0004c	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00052	83 45 d8 04	 add	 DWORD PTR tv85[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d d8	 mov	 ecx, DWORD PTR tv85[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 d8 02	 add	 DWORD PTR tv85[ebp], 2
  00065	8b 55 d8	 mov	 edx, DWORD PTR tv85[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  0006e	c1 e8 03	 shr	 eax, 3
  00071	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4
  00078	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0007d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));

  00082	6a 01		 push	 1
  00084	8b 4b 08	 mov	 ecx, DWORD PTR __Al$[ebx]
  00087	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  00092	83 c4 04	 add	 esp, 4
  00095	89 45 e4	 mov	 DWORD PTR __New_proxy$[ebp], eax

; 1075 :         _Construct_in_place(*_New_proxy, this);

  00098	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  0009b	89 4d dc	 mov	 DWORD PTR tv150[ebp], ecx
  0009e	8b 55 dc	 mov	 edx, DWORD PTR tv150[ebp]
  000a1	c1 ea 03	 shr	 edx, 3
  000a4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000aa	88 45 d5	 mov	 BYTE PTR tv153[ebp], al
  000ad	80 7d d5 00	 cmp	 BYTE PTR tv153[ebp], 0
  000b1	74 1a		 je	 SHORT $LN5@Alloc_prox
  000b3	8a 4d dc	 mov	 cl, BYTE PTR tv150[ebp]
  000b6	80 e1 07	 and	 cl, 7
  000b9	80 c1 03	 add	 cl, 3
  000bc	3a 4d d5	 cmp	 cl, BYTE PTR tv153[ebp]
  000bf	7c 0c		 jl	 SHORT $LN5@Alloc_prox
  000c1	8b 55 dc	 mov	 edx, DWORD PTR tv150[ebp]
  000c4	52		 push	 edx
  000c5	e8 00 00 00 00	 call	 ___asan_report_store4
  000ca	83 c4 04	 add	 esp, 4
$LN5@Alloc_prox:
  000cd	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000d0	89 45 a8	 mov	 DWORD PTR $T2[ebp], eax
  000d3	8d 4d a8	 lea	 ecx, DWORD PTR $T2[ebp]
  000d6	51		 push	 ecx
  000d7	8b 55 e4	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  000da	52		 push	 edx
  000db	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  000e0	83 c4 08	 add	 esp, 8
  000e3	8d 45 a8	 lea	 eax, DWORD PTR $T2[ebp]
  000e6	c1 e8 03	 shr	 eax, 3
  000e9	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 1076 :         _Myproxy            = _New_proxy;

  000f0	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000f3	89 4d f0	 mov	 DWORD PTR tv74[ebp], ecx
  000f6	8b 55 f0	 mov	 edx, DWORD PTR tv74[ebp]
  000f9	89 55 e0	 mov	 DWORD PTR tv140[ebp], edx
  000fc	8b 45 e0	 mov	 eax, DWORD PTR tv140[ebp]
  000ff	c1 e8 03	 shr	 eax, 3
  00102	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00108	88 4d d6	 mov	 BYTE PTR tv143[ebp], cl
  0010b	80 7d d6 00	 cmp	 BYTE PTR tv143[ebp], 0
  0010f	74 1a		 je	 SHORT $LN4@Alloc_prox
  00111	8a 55 e0	 mov	 dl, BYTE PTR tv140[ebp]
  00114	80 e2 07	 and	 dl, 7
  00117	80 c2 03	 add	 dl, 3
  0011a	3a 55 d6	 cmp	 dl, BYTE PTR tv143[ebp]
  0011d	7c 0c		 jl	 SHORT $LN4@Alloc_prox
  0011f	8b 45 e0	 mov	 eax, DWORD PTR tv140[ebp]
  00122	50		 push	 eax
  00123	e8 00 00 00 00	 call	 ___asan_report_store4
  00128	83 c4 04	 add	 esp, 4
$LN4@Alloc_prox:
  0012b	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0012e	8b 55 e4	 mov	 edx, DWORD PTR __New_proxy$[ebp]
  00131	89 11		 mov	 DWORD PTR [ecx], edx

; 1077 :         _New_proxy->_Mycont = this;

  00133	8b 45 e4	 mov	 eax, DWORD PTR __New_proxy$[ebp]
  00136	89 45 f4	 mov	 DWORD PTR tv75[ebp], eax
  00139	8b 4d f4	 mov	 ecx, DWORD PTR tv75[ebp]
  0013c	89 4d e8	 mov	 DWORD PTR tv130[ebp], ecx
  0013f	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  00142	c1 ea 03	 shr	 edx, 3
  00145	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0014b	88 45 d7	 mov	 BYTE PTR tv133[ebp], al
  0014e	80 7d d7 00	 cmp	 BYTE PTR tv133[ebp], 0
  00152	74 1a		 je	 SHORT $LN3@Alloc_prox
  00154	8a 4d e8	 mov	 cl, BYTE PTR tv130[ebp]
  00157	80 e1 07	 and	 cl, 7
  0015a	80 c1 03	 add	 cl, 3
  0015d	3a 4d d7	 cmp	 cl, BYTE PTR tv133[ebp]
  00160	7c 0c		 jl	 SHORT $LN3@Alloc_prox
  00162	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  00165	52		 push	 edx
  00166	e8 00 00 00 00	 call	 ___asan_report_store4
  0016b	83 c4 04	 add	 esp, 4
$LN3@Alloc_prox:
  0016e	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00171	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00174	89 08		 mov	 DWORD PTR [eax], ecx

; 1078 :     }

  00176	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0017d	8d 55 98	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00180	c1 ea 03	 shr	 edx, 3
  00183	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00189	89 55 fc	 mov	 DWORD PTR tv94[ebp], edx
  0018c	6a 07		 push	 7
  0018e	8b 45 fc	 mov	 eax, DWORD PTR tv94[ebp]
  00191	50		 push	 eax
  00192	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00197	83 c4 08	 add	 esp, 8
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	8b e3		 mov	 esp, ebx
  0019f	5b		 pop	 ebx
  001a0	c2 04 00	 ret	 4
??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ENDP ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1><>, COMDAT
; _this$ = ecx

; 1390 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??0?$allocator@PAVTexture@sf@@@std@@QAE@XZ ; std::allocator<sf::Texture *>::allocator<sf::Texture *>
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<sf::Texture *> >::_Vector_val<std::_Simple_types<sf::Texture *> >
  00021	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 04 00	 ret	 4
??$?0$$V@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : _CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 999  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1000 :     using _Ty = typename _Alloc::value_type;
; 1001 :     _Ptr->~_Ty();
; 1002 :     _Deallocate_plain(_Al, _Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0001a	83 c4 08	 add	 esp, 8

; 1003 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -32					; size = 4
tv71 = -28						; size = 4
tv68 = -24						; size = 4
tv65 = -20						; size = 4
tv74 = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 614  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0002f	74 1a		 je	 SHORT $LN5@exchange
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv94[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  0003d	7c 0c		 jl	 SHORT $LN5@exchange
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN5@exchange:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	89 4d e0	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00053	8b 55 0c	 mov	 edx, DWORD PTR __New_val$[ebp]
  00056	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00062	c1 e9 03	 shr	 ecx, 3
  00065	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006b	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  0006e	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00072	74 18		 je	 SHORT $LN4@exchange
  00074	8a 45 f4	 mov	 al, BYTE PTR tv84[ebp]
  00077	24 07		 and	 al, 7
  00079	04 03		 add	 al, 3
  0007b	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@exchange
  00080	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ___asan_report_load4
  00089	83 c4 04	 add	 esp, 4
$LN4@exchange:
  0008c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0008f	89 55 e4	 mov	 DWORD PTR tv71[ebp], edx
  00092	8b 45 e4	 mov	 eax, DWORD PTR tv71[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00098	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0009b	c1 e9 03	 shr	 ecx, 3
  0009e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a4	88 55 fd	 mov	 BYTE PTR tv77[ebp], dl
  000a7	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000ab	74 18		 je	 SHORT $LN3@exchange
  000ad	8a 45 f0	 mov	 al, BYTE PTR tv74[ebp]
  000b0	24 07		 and	 al, 7
  000b2	04 03		 add	 al, 3
  000b4	3a 45 fd	 cmp	 al, BYTE PTR tv77[ebp]
  000b7	7c 0c		 jl	 SHORT $LN3@exchange
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ___asan_report_store4
  000c2	83 c4 04	 add	 esp, 4
$LN3@exchange:
  000c5	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 0a		 mov	 DWORD PTR [edx], ecx

; 618  :     return _Old_val;

  000cf	8b 45 e0	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 619  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0PAVTexture@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVTexture@sf@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVTexture@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVTexture@sf@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Texture *>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0PAVTexture@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVTexture@sf@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 03	 shl	 eax, 3
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z
_TEXT	SEGMENT
tv178 = -108						; size = 4
tv132 = -104						; size = 4
tv134 = -100						; size = 4
tv175 = -96						; size = 4
tv172 = -92						; size = 4
tv169 = -88						; size = 4
__Newsize$ = -84					; size = 4
__Constructed_last$ = -80				; size = 4
__Oldsize$ = -76					; size = 4
__My_data$ = -72					; size = 4
__Newcapacity$ = -68					; size = 4
__Al$ = -64						; size = 4
__Constructed_first$ = -60				; size = 4
tv181 = -56						; size = 4
tv191 = -52						; size = 4
tv201 = -48						; size = 4
tv211 = -44						; size = 4
__Whereoff$ = -40					; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
__Newvec$ = -24						; size = 4
tv184 = -20						; size = 1
tv194 = -19						; size = 1
tv204 = -18						; size = 1
tv214 = -17						; size = 1
__$EHRec$ = -16						; size = 16
__Whereptr$ = 8						; size = 4
_<_Val_0>$ = 12						; size = 4
??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_reallocate<sf::Texture * const &>, COMDAT
; _this$ = ecx

; 765  :     _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	83 ec 5c	 sub	 esp, 92			; 0000005cH
  00015	53		 push	 ebx
  00016	56		 push	 esi
  00017	57		 push	 edi
  00018	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001d	33 c5		 xor	 eax, ebp
  0001f	50		 push	 eax
  00020	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  00023	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00029	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  0002c	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00034	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 766  :         // reallocate and insert by perfectly forwarding _Val at _Whereptr
; 767  :         _Alty& _Al        = _Getal();

  00039	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003c	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  00041	89 45 c0	 mov	 DWORD PTR __Al$[ebp], eax

; 768  :         auto& _My_data    = _Mypair._Myval2;

  00044	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00047	89 45 b8	 mov	 DWORD PTR __My_data$[ebp], eax

; 769  :         pointer& _Myfirst = _My_data._Myfirst;

  0004a	8b 4d b8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0004d	83 c1 04	 add	 ecx, 4
  00050	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 770  :         pointer& _Mylast  = _My_data._Mylast;

  00053	8b 55 b8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00056	83 c2 08	 add	 edx, 8
  00059	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 771  : 
; 772  :         _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity
; 773  : 
; 774  :         const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);

  0005c	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0005f	89 45 a8	 mov	 DWORD PTR tv169[ebp], eax
  00062	8b 4d a8	 mov	 ecx, DWORD PTR tv169[ebp]
  00065	89 4d d4	 mov	 DWORD PTR tv211[ebp], ecx
  00068	8b 55 d4	 mov	 edx, DWORD PTR tv211[ebp]
  0006b	c1 ea 03	 shr	 edx, 3
  0006e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00074	88 45 ef	 mov	 BYTE PTR tv214[ebp], al
  00077	80 7d ef 00	 cmp	 BYTE PTR tv214[ebp], 0
  0007b	74 1a		 je	 SHORT $LN14@Emplace_re
  0007d	8a 4d d4	 mov	 cl, BYTE PTR tv211[ebp]
  00080	80 e1 07	 and	 cl, 7
  00083	80 c1 03	 add	 cl, 3
  00086	3a 4d ef	 cmp	 cl, BYTE PTR tv214[ebp]
  00089	7c 0c		 jl	 SHORT $LN14@Emplace_re
  0008b	8b 55 d4	 mov	 edx, DWORD PTR tv211[ebp]
  0008e	52		 push	 edx
  0008f	e8 00 00 00 00	 call	 ___asan_report_load4
  00094	83 c4 04	 add	 esp, 4
$LN14@Emplace_re:
  00097	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Whereptr$[ebp]
  0009d	2b 08		 sub	 ecx, DWORD PTR [eax]
  0009f	c1 f9 02	 sar	 ecx, 2
  000a2	89 4d d8	 mov	 DWORD PTR __Whereoff$[ebp], ecx

; 775  :         const auto _Oldsize  = static_cast<size_type>(_Mylast - _Myfirst);

  000a5	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a8	89 55 a4	 mov	 DWORD PTR tv172[ebp], edx
  000ab	8b 45 a4	 mov	 eax, DWORD PTR tv172[ebp]
  000ae	89 45 d0	 mov	 DWORD PTR tv201[ebp], eax
  000b1	8b 4d d0	 mov	 ecx, DWORD PTR tv201[ebp]
  000b4	c1 e9 03	 shr	 ecx, 3
  000b7	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000bd	88 55 ee	 mov	 BYTE PTR tv204[ebp], dl
  000c0	80 7d ee 00	 cmp	 BYTE PTR tv204[ebp], 0
  000c4	74 18		 je	 SHORT $LN13@Emplace_re
  000c6	8a 45 d0	 mov	 al, BYTE PTR tv201[ebp]
  000c9	24 07		 and	 al, 7
  000cb	04 03		 add	 al, 3
  000cd	3a 45 ee	 cmp	 al, BYTE PTR tv204[ebp]
  000d0	7c 0c		 jl	 SHORT $LN13@Emplace_re
  000d2	8b 4d d0	 mov	 ecx, DWORD PTR tv201[ebp]
  000d5	51		 push	 ecx
  000d6	e8 00 00 00 00	 call	 ___asan_report_load4
  000db	83 c4 04	 add	 esp, 4
$LN13@Emplace_re:
  000de	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  000e1	89 55 a0	 mov	 DWORD PTR tv175[ebp], edx
  000e4	8b 45 a0	 mov	 eax, DWORD PTR tv175[ebp]
  000e7	89 45 cc	 mov	 DWORD PTR tv191[ebp], eax
  000ea	8b 4d cc	 mov	 ecx, DWORD PTR tv191[ebp]
  000ed	c1 e9 03	 shr	 ecx, 3
  000f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f6	88 55 ed	 mov	 BYTE PTR tv194[ebp], dl
  000f9	80 7d ed 00	 cmp	 BYTE PTR tv194[ebp], 0
  000fd	74 18		 je	 SHORT $LN12@Emplace_re
  000ff	8a 45 cc	 mov	 al, BYTE PTR tv191[ebp]
  00102	24 07		 and	 al, 7
  00104	04 03		 add	 al, 3
  00106	3a 45 ed	 cmp	 al, BYTE PTR tv194[ebp]
  00109	7c 0c		 jl	 SHORT $LN12@Emplace_re
  0010b	8b 4d cc	 mov	 ecx, DWORD PTR tv191[ebp]
  0010e	51		 push	 ecx
  0010f	e8 00 00 00 00	 call	 ___asan_report_load4
  00114	83 c4 04	 add	 esp, 4
$LN12@Emplace_re:
  00117	8b 55 dc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0011a	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0011d	8b 0a		 mov	 ecx, DWORD PTR [edx]
  0011f	2b 08		 sub	 ecx, DWORD PTR [eax]
  00121	c1 f9 02	 sar	 ecx, 2
  00124	89 4d b4	 mov	 DWORD PTR __Oldsize$[ebp], ecx

; 776  : 
; 777  :         if (_Oldsize == max_size()) {

  00127	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0012a	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::max_size
  0012f	39 45 b4	 cmp	 DWORD PTR __Oldsize$[ebp], eax
  00132	75 05		 jne	 SHORT $LN2@Emplace_re

; 778  :             _Xlength();

  00134	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Xlength
$LN2@Emplace_re:

; 779  :         }
; 780  : 
; 781  :         const size_type _Newsize     = _Oldsize + 1;

  00139	8b 55 b4	 mov	 edx, DWORD PTR __Oldsize$[ebp]
  0013c	83 c2 01	 add	 edx, 1
  0013f	89 55 ac	 mov	 DWORD PTR __Newsize$[ebp], edx

; 782  :         const size_type _Newcapacity = _Calculate_growth(_Newsize);

  00142	8b 45 ac	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00145	50		 push	 eax
  00146	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00149	e8 00 00 00 00	 call	 ?_Calculate_growth@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEII@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Calculate_growth
  0014e	89 45 bc	 mov	 DWORD PTR __Newcapacity$[ebp], eax

; 783  : 
; 784  :         const pointer _Newvec           = _Al.allocate(_Newcapacity);

  00151	8b 4d bc	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00154	51		 push	 ecx
  00155	8b 4d c0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00158	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVTexture@sf@@@std@@QAEPAPAVTexture@sf@@I@Z ; std::allocator<sf::Texture *>::allocate
  0015d	89 45 e8	 mov	 DWORD PTR __Newvec$[ebp], eax

; 785  :         const pointer _Constructed_last = _Newvec + _Whereoff + 1;

  00160	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  00163	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00166	8d 4c 90 04	 lea	 ecx, DWORD PTR [eax+edx*4+4]
  0016a	89 4d b0	 mov	 DWORD PTR __Constructed_last$[ebp], ecx

; 786  :         pointer _Constructed_first      = _Constructed_last;

  0016d	8b 55 b0	 mov	 edx, DWORD PTR __Constructed_last$[ebp]
  00170	89 55 c4	 mov	 DWORD PTR __Constructed_first$[ebp], edx

; 787  : 
; 788  :         _TRY_BEGIN

  00173	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 789  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

  0017a	8b 45 0c	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  0017d	50		 push	 eax
  0017e	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  00183	83 c4 04	 add	 esp, 4
  00186	89 45 9c	 mov	 DWORD PTR tv134[ebp], eax
  00189	8b 4d d8	 mov	 ecx, DWORD PTR __Whereoff$[ebp]
  0018c	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  0018f	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  00192	50		 push	 eax
  00193	e8 00 00 00 00	 call	 ??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Texture *>
  00198	83 c4 04	 add	 esp, 4
  0019b	89 45 98	 mov	 DWORD PTR tv132[ebp], eax
  0019e	8b 4d 9c	 mov	 ecx, DWORD PTR tv134[ebp]
  001a1	51		 push	 ecx
  001a2	8b 55 98	 mov	 edx, DWORD PTR tv132[ebp]
  001a5	52		 push	 edx
  001a6	8b 45 c0	 mov	 eax, DWORD PTR __Al$[ebp]
  001a9	50		 push	 eax
  001aa	e8 00 00 00 00	 call	 ??$construct@PAVTexture@sf@@ABQAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@ABQAV34@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture * const &>
  001af	83 c4 0c	 add	 esp, 12			; 0000000cH

; 790  :         _Constructed_first = _Newvec + _Whereoff;

  001b2	8b 4d d8	 mov	 ecx, DWORD PTR __Whereoff$[ebp]
  001b5	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001b8	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  001bb	89 45 c4	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 791  : 
; 792  :         if (_Whereptr == _Mylast) { // at back, provide strong guarantee

  001be	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  001c1	89 4d 94	 mov	 DWORD PTR tv178[ebp], ecx
  001c4	8b 55 94	 mov	 edx, DWORD PTR tv178[ebp]
  001c7	89 55 c8	 mov	 DWORD PTR tv181[ebp], edx
  001ca	8b 45 c8	 mov	 eax, DWORD PTR tv181[ebp]
  001cd	c1 e8 03	 shr	 eax, 3
  001d0	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001d6	88 4d ec	 mov	 BYTE PTR tv184[ebp], cl
  001d9	80 7d ec 00	 cmp	 BYTE PTR tv184[ebp], 0
  001dd	74 1a		 je	 SHORT $LN11@Emplace_re
  001df	8a 55 c8	 mov	 dl, BYTE PTR tv181[ebp]
  001e2	80 e2 07	 and	 dl, 7
  001e5	80 c2 03	 add	 dl, 3
  001e8	3a 55 ec	 cmp	 dl, BYTE PTR tv184[ebp]
  001eb	7c 0c		 jl	 SHORT $LN11@Emplace_re
  001ed	8b 45 c8	 mov	 eax, DWORD PTR tv181[ebp]
  001f0	50		 push	 eax
  001f1	e8 00 00 00 00	 call	 ___asan_report_load4
  001f6	83 c4 04	 add	 esp, 4
$LN11@Emplace_re:
  001f9	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  001fc	8b 55 08	 mov	 edx, DWORD PTR __Whereptr$[ebp]
  001ff	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00201	75 1a		 jne	 SHORT $LN4@Emplace_re

; 793  :             _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);

  00203	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00206	50		 push	 eax
  00207	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0020a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0020c	52		 push	 edx
  0020d	8b 45 e0	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00210	8b 08		 mov	 ecx, DWORD PTR [eax]
  00212	51		 push	 ecx
  00213	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00216	e8 00 00 00 00	 call	 ?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept

; 794  :         } else { // provide basic guarantee

  0021b	eb 39		 jmp	 SHORT $LN5@Emplace_re
$LN4@Emplace_re:

; 795  :             _Umove(_Myfirst, _Whereptr, _Newvec);

  0021d	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00220	52		 push	 edx
  00221	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  00224	50		 push	 eax
  00225	8b 4d e0	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00228	8b 11		 mov	 edx, DWORD PTR [ecx]
  0022a	52		 push	 edx
  0022b	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0022e	e8 00 00 00 00	 call	 ?_Umove@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEPAPAVTexture@sf@@PAPAV34@00@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove

; 796  :             _Constructed_first = _Newvec;

  00233	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  00236	89 45 c4	 mov	 DWORD PTR __Constructed_first$[ebp], eax

; 797  :             _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);

  00239	8b 4d d8	 mov	 ecx, DWORD PTR __Whereoff$[ebp]
  0023c	8b 55 e8	 mov	 edx, DWORD PTR __Newvec$[ebp]
  0023f	8d 44 8a 04	 lea	 eax, DWORD PTR [edx+ecx*4+4]
  00243	50		 push	 eax
  00244	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00247	8b 11		 mov	 edx, DWORD PTR [ecx]
  00249	52		 push	 edx
  0024a	8b 45 08	 mov	 eax, DWORD PTR __Whereptr$[ebp]
  0024d	50		 push	 eax
  0024e	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00251	e8 00 00 00 00	 call	 ?_Umove@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEPAPAVTexture@sf@@PAPAV34@00@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove
$LN5@Emplace_re:
  00256	eb 2f		 jmp	 SHORT $LN7@Emplace_re
__catch$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z$0:

; 798  :         }
; 799  :         _CATCH_ALL
; 800  :         _Destroy(_Constructed_first, _Constructed_last);

  00258	8b 4d b0	 mov	 ecx, DWORD PTR __Constructed_last$[ebp]
  0025b	51		 push	 ecx
  0025c	8b 55 c4	 mov	 edx, DWORD PTR __Constructed_first$[ebp]
  0025f	52		 push	 edx
  00260	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00263	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Destroy

; 801  :         _Al.deallocate(_Newvec, _Newcapacity);

  00268	8b 45 bc	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  0026b	50		 push	 eax
  0026c	8b 4d e8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  0026f	51		 push	 ecx
  00270	8b 4d c0	 mov	 ecx, DWORD PTR __Al$[ebp]
  00273	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z ; std::allocator<sf::Texture *>::deallocate

; 802  :         _RERAISE;

  00278	6a 00		 push	 0
  0027a	6a 00		 push	 0
  0027c	e8 00 00 00 00	 call	 __CxxThrowException@8

; 803  :         _CATCH_END

  00281	b8 00 00 00 00	 mov	 eax, $LN10@Emplace_re
  00286	c3		 ret	 0
$LN7@Emplace_re:
  00287	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0028e	eb 07		 jmp	 SHORT __tryend$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z$1
$LN10@Emplace_re:
  00290	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z$1:

; 804  : 
; 805  :         _Change_array(_Newvec, _Newsize, _Newcapacity);

  00297	8b 55 bc	 mov	 edx, DWORD PTR __Newcapacity$[ebp]
  0029a	52		 push	 edx
  0029b	8b 45 ac	 mov	 eax, DWORD PTR __Newsize$[ebp]
  0029e	50		 push	 eax
  0029f	8b 4d e8	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  002a2	51		 push	 ecx
  002a3	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  002a6	e8 00 00 00 00	 call	 ?_Change_array@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXQAPAVTexture@sf@@II@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Change_array

; 806  :         return _Newvec + _Whereoff;

  002ab	8b 55 d8	 mov	 edx, DWORD PTR __Whereoff$[ebp]
  002ae	8b 45 e8	 mov	 eax, DWORD PTR __Newvec$[ebp]
  002b1	8d 04 90	 lea	 eax, DWORD PTR [eax+edx*4]
$LN6@Emplace_re:

; 807  :     }

  002b4	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  002b7	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  002be	59		 pop	 ecx
  002bf	5f		 pop	 edi
  002c0	5e		 pop	 esi
  002c1	5b		 pop	 ebx
  002c2	8b e5		 mov	 esp, ebp
  002c4	5d		 pop	 ebp
  002c5	c2 08 00	 ret	 8
  002c8	cc		 int	 3
  002c9	cc		 int	 3
  002ca	cc		 int	 3
  002cb	cc		 int	 3
  002cc	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 90	 mov	 ecx, DWORD PTR [edx-112]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_reallocate<sf::Texture * const &>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@PAVTexture@sf@@ABQAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@ABQAV34@@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVTexture@sf@@ABQAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@ABQAV34@@Z PROC ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture * const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@PAVTexture@sf@@ABQAV12@X@std@@YAPAPAVTexture@sf@@QAPAV12@ABQAV12@@Z ; std::construct_at<sf::Texture *,sf::Texture * const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAPAVTexture@sf@@@std@@YAPAXPAPAVTexture@sf@@@Z ; std::_Voidify_iter<sf::Texture * *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@PAVTexture@sf@@ABQAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@ABQAV34@@Z ENDP ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z PROC ; std::_Unfancy<sf::Texture *>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z ENDP ; std::_Unfancy<sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAE?A_TABQAVTexture@sf@@@Z
_TEXT	SEGMENT
__Result$ = -60						; size = 4
tv85 = -56						; size = 4
tv93 = -52						; size = 4
tv90 = -48						; size = 4
tv87 = -44						; size = 4
tv77 = -40						; size = 4
tv79 = -36						; size = 4
tv81 = -32						; size = 4
__My_data$ = -28					; size = 4
tv128 = -24						; size = 4
tv138 = -20						; size = 4
tv148 = -16						; size = 4
_this$ = -12						; size = 4
__Mylast$ = -8						; size = 4
tv131 = -3						; size = 1
tv141 = -2						; size = 1
tv151 = -1						; size = 1
_<_Val_0>$ = 8						; size = 4
??$_Emplace_back_with_unused_capacity@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAE?A_TABQAVTexture@sf@@@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_back_with_unused_capacity<sf::Texture * const &>, COMDAT
; _this$ = ecx

; 721  :     _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 722  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 723  :         auto& _My_data   = _Mypair._Myval2;

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 724  :         pointer& _Mylast = _My_data._Mylast;

  00019	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d f8	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 725  :         _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
; 726  :         _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward<_Valty>(_Val)...);

  00022	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  0002b	83 c4 04	 add	 esp, 4
  0002e	89 45 e0	 mov	 DWORD PTR tv81[ebp], eax
  00031	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00034	8b 08		 mov	 ecx, DWORD PTR [eax]
  00036	51		 push	 ecx
  00037	e8 00 00 00 00	 call	 ??$_Unfancy@PAVTexture@sf@@@std@@YAPAPAVTexture@sf@@PAPAV12@@Z ; std::_Unfancy<sf::Texture *>
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 dc	 mov	 DWORD PTR tv79[ebp], eax
  00042	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00045	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  0004a	89 45 d8	 mov	 DWORD PTR tv77[ebp], eax
  0004d	8b 55 e0	 mov	 edx, DWORD PTR tv81[ebp]
  00050	52		 push	 edx
  00051	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  00054	50		 push	 eax
  00055	8b 4d d8	 mov	 ecx, DWORD PTR tv77[ebp]
  00058	51		 push	 ecx
  00059	e8 00 00 00 00	 call	 ??$construct@PAVTexture@sf@@ABQAV12@@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAXAAV?$allocator@PAVTexture@sf@@@1@QAPAVTexture@sf@@ABQAV34@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::construct<sf::Texture *,sf::Texture * const &>
  0005e	83 c4 0c	 add	 esp, 12			; 0000000cH

; 727  :         _Orphan_range(_Mylast, _Mylast);

  00061	8b 55 f8	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00064	8b 02		 mov	 eax, DWORD PTR [edx]
  00066	50		 push	 eax
  00067	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0006a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0006c	52		 push	 edx
  0006d	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00070	e8 00 00 00 00	 call	 ?_Orphan_range@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range

; 728  :         _Ty& _Result = *_Mylast;

  00075	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  00078	89 45 d4	 mov	 DWORD PTR tv87[ebp], eax
  0007b	8b 4d d4	 mov	 ecx, DWORD PTR tv87[ebp]
  0007e	89 4d f0	 mov	 DWORD PTR tv148[ebp], ecx
  00081	8b 55 f0	 mov	 edx, DWORD PTR tv148[ebp]
  00084	c1 ea 03	 shr	 edx, 3
  00087	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008d	88 45 ff	 mov	 BYTE PTR tv151[ebp], al
  00090	80 7d ff 00	 cmp	 BYTE PTR tv151[ebp], 0
  00094	74 1a		 je	 SHORT $LN5@Emplace_ba
  00096	8a 4d f0	 mov	 cl, BYTE PTR tv148[ebp]
  00099	80 e1 07	 and	 cl, 7
  0009c	80 c1 03	 add	 cl, 3
  0009f	3a 4d ff	 cmp	 cl, BYTE PTR tv151[ebp]
  000a2	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a4	8b 55 f0	 mov	 edx, DWORD PTR tv148[ebp]
  000a7	52		 push	 edx
  000a8	e8 00 00 00 00	 call	 ___asan_report_load4
  000ad	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000b0	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  000b3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b5	89 4d c4	 mov	 DWORD PTR __Result$[ebp], ecx

; 729  :         ++_Mylast;

  000b8	8b 55 f8	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000bb	89 55 d0	 mov	 DWORD PTR tv90[ebp], edx
  000be	8b 45 d0	 mov	 eax, DWORD PTR tv90[ebp]
  000c1	89 45 ec	 mov	 DWORD PTR tv138[ebp], eax
  000c4	8b 4d ec	 mov	 ecx, DWORD PTR tv138[ebp]
  000c7	c1 e9 03	 shr	 ecx, 3
  000ca	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000d0	88 55 fe	 mov	 BYTE PTR tv141[ebp], dl
  000d3	80 7d fe 00	 cmp	 BYTE PTR tv141[ebp], 0
  000d7	74 18		 je	 SHORT $LN4@Emplace_ba
  000d9	8a 45 ec	 mov	 al, BYTE PTR tv138[ebp]
  000dc	24 07		 and	 al, 7
  000de	04 03		 add	 al, 3
  000e0	3a 45 fe	 cmp	 al, BYTE PTR tv141[ebp]
  000e3	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000e5	8b 4d ec	 mov	 ecx, DWORD PTR tv138[ebp]
  000e8	51		 push	 ecx
  000e9	e8 00 00 00 00	 call	 ___asan_report_load4
  000ee	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  000f1	8b 55 f8	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000f4	8b 02		 mov	 eax, DWORD PTR [edx]
  000f6	83 c0 04	 add	 eax, 4
  000f9	89 45 c8	 mov	 DWORD PTR tv85[ebp], eax
  000fc	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000ff	89 4d cc	 mov	 DWORD PTR tv93[ebp], ecx
  00102	8b 55 cc	 mov	 edx, DWORD PTR tv93[ebp]
  00105	89 55 e8	 mov	 DWORD PTR tv128[ebp], edx
  00108	8b 45 e8	 mov	 eax, DWORD PTR tv128[ebp]
  0010b	c1 e8 03	 shr	 eax, 3
  0010e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00114	88 4d fd	 mov	 BYTE PTR tv131[ebp], cl
  00117	80 7d fd 00	 cmp	 BYTE PTR tv131[ebp], 0
  0011b	74 1a		 je	 SHORT $LN3@Emplace_ba
  0011d	8a 55 e8	 mov	 dl, BYTE PTR tv128[ebp]
  00120	80 e2 07	 and	 dl, 7
  00123	80 c2 03	 add	 dl, 3
  00126	3a 55 fd	 cmp	 dl, BYTE PTR tv131[ebp]
  00129	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  0012b	8b 45 e8	 mov	 eax, DWORD PTR tv128[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ___asan_report_store4
  00134	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00137	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  0013a	8b 55 c8	 mov	 edx, DWORD PTR tv85[ebp]
  0013d	89 11		 mov	 DWORD PTR [ecx], edx

; 730  : #if _HAS_CXX17
; 731  :         return _Result;

  0013f	8b 45 c4	 mov	 eax, DWORD PTR __Result$[ebp]

; 732  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 733  :         (void) _Result;
; 734  : #endif // _HAS_CXX17
; 735  :     }

  00142	8b e5		 mov	 esp, ebp
  00144	5d		 pop	 ebp
  00145	c2 04 00	 ret	 4
??$_Emplace_back_with_unused_capacity@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAE?A_TABQAVTexture@sf@@@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_back_with_unused_capacity<sf::Texture * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z PROC ; std::forward<sf::Texture * const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ENDP ; std::forward<sf::Texture * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$emplace_back@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE?A_TABQAVTexture@sf@@@Z
_TEXT	SEGMENT
__Result$ = -52						; size = 4
tv81 = -48						; size = 4
tv83 = -44						; size = 4
tv90 = -40						; size = 4
tv85 = -36						; size = 4
tv67 = -32						; size = 4
__My_data$ = -28					; size = 4
_this$ = -24						; size = 4
tv93 = -20						; size = 4
tv135 = -16						; size = 4
tv145 = -12						; size = 4
__Mylast$ = -8						; size = 4
tv128 = -3						; size = 1
tv138 = -2						; size = 1
tv148 = -1						; size = 1
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE?A_TABQAVTexture@sf@@@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::emplace_back<sf::Texture * const &>, COMDAT
; _this$ = ecx

; 739  :     _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&&... _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 740  :         // insert by perfectly forwarding into element at end, provide strong guarantee
; 741  :         auto& _My_data   = _Mypair._Myval2;

  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 742  :         pointer& _Mylast = _My_data._Mylast;

  00019	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d f8	 mov	 DWORD PTR __Mylast$[ebp], ecx

; 743  :         if (_Mylast != _My_data._Myend) {

  00022	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 0c	 add	 edx, 12			; 0000000cH
  00028	89 55 e0	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR __Mylast$[ebp]
  0002e	89 45 dc	 mov	 DWORD PTR tv85[ebp], eax
  00031	8b 4d dc	 mov	 ecx, DWORD PTR tv85[ebp]
  00034	89 4d f4	 mov	 DWORD PTR tv145[ebp], ecx
  00037	8b 55 f4	 mov	 edx, DWORD PTR tv145[ebp]
  0003a	c1 ea 03	 shr	 edx, 3
  0003d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00043	88 45 ff	 mov	 BYTE PTR tv148[ebp], al
  00046	80 7d ff 00	 cmp	 BYTE PTR tv148[ebp], 0
  0004a	74 1a		 je	 SHORT $LN6@emplace_ba
  0004c	8a 4d f4	 mov	 cl, BYTE PTR tv145[ebp]
  0004f	80 e1 07	 and	 cl, 7
  00052	80 c1 03	 add	 cl, 3
  00055	3a 4d ff	 cmp	 cl, BYTE PTR tv148[ebp]
  00058	7c 0c		 jl	 SHORT $LN6@emplace_ba
  0005a	8b 55 f4	 mov	 edx, DWORD PTR tv145[ebp]
  0005d	52		 push	 edx
  0005e	e8 00 00 00 00	 call	 ___asan_report_load4
  00063	83 c4 04	 add	 esp, 4
$LN6@emplace_ba:
  00066	8b 45 e0	 mov	 eax, DWORD PTR tv67[ebp]
  00069	89 45 f0	 mov	 DWORD PTR tv135[ebp], eax
  0006c	8b 4d f0	 mov	 ecx, DWORD PTR tv135[ebp]
  0006f	c1 e9 03	 shr	 ecx, 3
  00072	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00078	88 55 fe	 mov	 BYTE PTR tv138[ebp], dl
  0007b	80 7d fe 00	 cmp	 BYTE PTR tv138[ebp], 0
  0007f	74 18		 je	 SHORT $LN5@emplace_ba
  00081	8a 45 f0	 mov	 al, BYTE PTR tv135[ebp]
  00084	24 07		 and	 al, 7
  00086	04 03		 add	 al, 3
  00088	3a 45 fe	 cmp	 al, BYTE PTR tv138[ebp]
  0008b	7c 0c		 jl	 SHORT $LN5@emplace_ba
  0008d	8b 4d f0	 mov	 ecx, DWORD PTR tv135[ebp]
  00090	51		 push	 ecx
  00091	e8 00 00 00 00	 call	 ___asan_report_load4
  00096	83 c4 04	 add	 esp, 4
$LN5@emplace_ba:
  00099	8b 55 f8	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0009c	8b 45 e0	 mov	 eax, DWORD PTR tv67[ebp]
  0009f	8b 0a		 mov	 ecx, DWORD PTR [edx]
  000a1	3b 08		 cmp	 ecx, DWORD PTR [eax]
  000a3	74 17		 je	 SHORT $LN2@emplace_ba

; 744  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

  000a5	8b 55 08	 mov	 edx, DWORD PTR _<_Val_0>$[ebp]
  000a8	52		 push	 edx
  000a9	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  000ae	83 c4 04	 add	 esp, 4
  000b1	50		 push	 eax
  000b2	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b5	e8 00 00 00 00	 call	 ??$_Emplace_back_with_unused_capacity@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAE?A_TABQAVTexture@sf@@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_back_with_unused_capacity<sf::Texture * const &>
  000ba	eb 68		 jmp	 SHORT $LN1@emplace_ba
$LN2@emplace_ba:

; 745  :         }
; 746  : 
; 747  :         _Ty& _Result = *_Emplace_reallocate(_Mylast, _STD forward<_Valty>(_Val)...);

  000bc	8b 45 08	 mov	 eax, DWORD PTR _<_Val_0>$[ebp]
  000bf	50		 push	 eax
  000c0	e8 00 00 00 00	 call	 ??$forward@ABQAVTexture@sf@@@std@@YAABQAVTexture@sf@@ABQAV12@@Z ; std::forward<sf::Texture * const &>
  000c5	83 c4 04	 add	 esp, 4
  000c8	89 45 d4	 mov	 DWORD PTR tv83[ebp], eax
  000cb	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000ce	89 4d d8	 mov	 DWORD PTR tv90[ebp], ecx
  000d1	8b 55 d8	 mov	 edx, DWORD PTR tv90[ebp]
  000d4	89 55 ec	 mov	 DWORD PTR tv93[ebp], edx
  000d7	8b 45 ec	 mov	 eax, DWORD PTR tv93[ebp]
  000da	c1 e8 03	 shr	 eax, 3
  000dd	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000e3	88 4d fd	 mov	 BYTE PTR tv128[ebp], cl
  000e6	80 7d fd 00	 cmp	 BYTE PTR tv128[ebp], 0
  000ea	74 1a		 je	 SHORT $LN4@emplace_ba
  000ec	8a 55 ec	 mov	 dl, BYTE PTR tv93[ebp]
  000ef	80 e2 07	 and	 dl, 7
  000f2	80 c2 03	 add	 dl, 3
  000f5	3a 55 fd	 cmp	 dl, BYTE PTR tv128[ebp]
  000f8	7c 0c		 jl	 SHORT $LN4@emplace_ba
  000fa	8b 45 ec	 mov	 eax, DWORD PTR tv93[ebp]
  000fd	50		 push	 eax
  000fe	e8 00 00 00 00	 call	 ___asan_report_load4
  00103	83 c4 04	 add	 esp, 4
$LN4@emplace_ba:
  00106	8b 4d f8	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00109	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010b	89 55 d0	 mov	 DWORD PTR tv81[ebp], edx
  0010e	8b 45 d4	 mov	 eax, DWORD PTR tv83[ebp]
  00111	50		 push	 eax
  00112	8b 4d d0	 mov	 ecx, DWORD PTR tv81[ebp]
  00115	51		 push	 ecx
  00116	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00119	e8 00 00 00 00	 call	 ??$_Emplace_reallocate@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAPAVTexture@sf@@QAPAV23@ABQAV23@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Emplace_reallocate<sf::Texture * const &>
  0011e	89 45 cc	 mov	 DWORD PTR __Result$[ebp], eax

; 748  : #if _HAS_CXX17
; 749  :         return _Result;

  00121	8b 45 cc	 mov	 eax, DWORD PTR __Result$[ebp]
$LN1@emplace_ba:

; 750  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 751  :         (void) _Result;
; 752  : #endif // _HAS_CXX17
; 753  :     }

  00124	8b e5		 mov	 esp, ebp
  00126	5d		 pop	 ebp
  00127	c2 04 00	 ret	 4
??$emplace_back@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE?A_TABQAVTexture@sf@@@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::emplace_back<sf::Texture * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_G?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAXI@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::~vector<sf::Texture *,std::allocator<sf::Texture *> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAXI@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVTexture@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVTexture@sf@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVTexture@sf@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVTexture@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVTexture@sf@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVTexture@sf@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<sf::Texture *> >::_Vector_val<std::_Simple_types<sf::Texture *> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<sf::Texture *> >::_Vector_val<std::_Simple_types<sf::Texture *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEABV?$allocator@PAVTexture@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEABV?$allocator@PAVTexture@sf@@@2@XZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVTexture@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEABV?$allocator@PAVTexture@sf@@@2@XZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1802 :     _CONSTEXPR20_CONTAINER void _Orphan_range(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1803 :         // orphan iterators within specified (inclusive) range
; 1804 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1805 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 12		 je	 SHORT $LN2@Orphan_ran

; 1806 :             _Orphan_range_unlocked(_First, _Last);

  0001d	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00020	51		 push	 ecx
  00021	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00024	52		 push	 edx
  00025	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00028	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_unlocked

; 1807 :         } else

  0002d	eb 10		 jmp	 SHORT $LN1@Orphan_ran
$LN2@Orphan_ran:

; 1808 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1809 :         {
; 1810 :             _Orphan_range_locked(_First, _Last);

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_locked
$LN1@Orphan_ran:

; 1811 :         }
; 1812 :     }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 08 00	 ret	 8
?_Orphan_range@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
_TEXT	SEGMENT
__asan_gen_0$ = -112					; size = 4
__asan_gen_1$ = -108					; size = 4
__asan_gen_2$ = -104					; size = 4
__Lock$ = -96						; size = 4
tv74 = -52						; size = 4
tv65 = -48						; size = 4
_this$ = -44						; size = 4
tv77 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_locked, COMDAT
; _this$ = ecx

; 1797 :     void _Orphan_range_locked(pointer _First, pointer _Last) const {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d d4	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	c7 45 90 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00046	c7 45 94 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
  0004d	c7 45 98 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_locked
  00054	8d 45 90	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00057	89 45 d0	 mov	 DWORD PTR tv65[ebp], eax
  0005a	8b 4d d0	 mov	 ecx, DWORD PTR tv65[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00066	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  00069	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  0006c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00072	83 45 cc 04	 add	 DWORD PTR tv74[ebp], 4
  00076	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0007b	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  0007e	66 89 01	 mov	 WORD PTR [ecx], ax
  00081	83 45 cc 02	 add	 DWORD PTR tv74[ebp], 2
  00085	8b 55 cc	 mov	 edx, DWORD PTR tv74[ebp]
  00088	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1798 :         _Lockit _Lock(_LOCK_DEBUG);

  00095	6a 03		 push	 3
  00097	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0009a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  000a0	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1799 :         _Orphan_range_unlocked(_First, _Last);

  000a7	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000aa	50		 push	 eax
  000ab	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ae	51		 push	 ecx
  000af	8b 4d d4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b2	e8 00 00 00 00	 call	 ?_Orphan_range_unlocked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_unlocked

; 1800 :     }

  000b7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000be	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  000c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  000c7	c7 45 90 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000ce	8d 55 90	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000d1	c1 ea 03	 shr	 edx, 3
  000d4	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000da	89 55 d8	 mov	 DWORD PTR tv77[ebp], edx
  000dd	6a 07		 push	 7
  000df	8b 45 d8	 mov	 eax, DWORD PTR tv77[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e8	83 c4 08	 add	 esp, 8
  000eb	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ee	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000f5	59		 pop	 ecx
  000f6	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000f9	33 cd		 xor	 ecx, ebp
  000fb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00100	8b e5		 mov	 esp, ebp
  00102	5d		 pop	 ebp
  00103	8b e3		 mov	 esp, ebx
  00105	5b		 pop	 ebx
  00106	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z$0:
  00000	8d 4d a0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00003	ff 25 00 00 00
	00		 jmp	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
__ehhandler$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z:
  0000e	90		 npad	 1
  0000f	90		 npad	 1
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0001a	33 c8		 xor	 ecx, eax
  0001c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00021	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00024	33 c8		 xor	 ecx, eax
  00026	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
  00030	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Orphan_range_locked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_locked
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Orphan_range_unlocked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z
_TEXT	SEGMENT
tv136 = -104						; size = 4
tv129 = -100						; size = 4
__Temp$1 = -96						; size = 4
tv94 = -92						; size = 4
tv89 = -88						; size = 4
tv86 = -84						; size = 4
_this$ = -80						; size = 4
tv82 = -76						; size = 4
__Temp$2 = -72						; size = 4
tv81 = -68						; size = 4
__Pnextptr$3 = -64					; size = 4
tv77 = -60						; size = 4
tv69 = -56						; size = 4
tv139 = -52						; size = 4
tv149 = -48						; size = 4
tv159 = -44						; size = 4
tv169 = -40						; size = 4
tv179 = -36						; size = 4
tv189 = -32						; size = 4
tv199 = -28						; size = 4
tv209 = -24						; size = 4
tv219 = -20						; size = 4
__Pnext$ = -16						; size = 4
tv142 = -9						; size = 1
tv152 = -8						; size = 1
tv162 = -7						; size = 1
tv172 = -6						; size = 1
tv182 = -5						; size = 1
tv192 = -4						; size = 1
tv202 = -3						; size = 1
tv212 = -2						; size = 1
tv222 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range_unlocked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_unlocked, COMDAT
; _this$ = ecx

; 1782 :     _CONSTEXPR20_CONTAINER void _Orphan_range_unlocked(pointer _First, pointer _Last) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d b0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1783 :         _Iterator_base12** _Pnext = &_Mypair._Myval2._Myproxy->_Myfirstiter;

  00013	8b 45 b0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c8	 mov	 DWORD PTR tv69[ebp], eax
  00019	8b 4d c8	 mov	 ecx, DWORD PTR tv69[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv219[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv219[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv222[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv222[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_ran
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv219[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv222[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_ran
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv219[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_ran:
  0004e	8b 45 c8	 mov	 eax, DWORD PTR tv69[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	83 c1 04	 add	 ecx, 4
  00056	89 4d f0	 mov	 DWORD PTR __Pnext$[ebp], ecx
$LN2@Orphan_ran:

; 1784 :         while (*_Pnext) {

  00059	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0005c	89 55 ac	 mov	 DWORD PTR tv86[ebp], edx
  0005f	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  00062	89 45 e8	 mov	 DWORD PTR tv209[ebp], eax
  00065	8b 4d e8	 mov	 ecx, DWORD PTR tv209[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv212[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv212[ebp], 0
  00078	74 18		 je	 SHORT $LN15@Orphan_ran
  0007a	8a 45 e8	 mov	 al, BYTE PTR tv209[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv212[ebp]
  00084	7c 0c		 jl	 SHORT $LN15@Orphan_ran
  00086	8b 4d e8	 mov	 ecx, DWORD PTR tv209[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_load4
  0008f	83 c4 04	 add	 esp, 4
$LN15@Orphan_ran:
  00092	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00095	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00098	0f 84 eb 01 00
	00		 je	 $LN1@Orphan_ran

; 1785 :             const auto _Pnextptr = static_cast<const_iterator&>(**_Pnext)._Ptr;

  0009e	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a1	89 45 a8	 mov	 DWORD PTR tv89[ebp], eax
  000a4	8b 4d a8	 mov	 ecx, DWORD PTR tv89[ebp]
  000a7	89 4d e4	 mov	 DWORD PTR tv199[ebp], ecx
  000aa	8b 55 e4	 mov	 edx, DWORD PTR tv199[ebp]
  000ad	c1 ea 03	 shr	 edx, 3
  000b0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b6	88 45 fd	 mov	 BYTE PTR tv202[ebp], al
  000b9	80 7d fd 00	 cmp	 BYTE PTR tv202[ebp], 0
  000bd	74 1a		 je	 SHORT $LN14@Orphan_ran
  000bf	8a 4d e4	 mov	 cl, BYTE PTR tv199[ebp]
  000c2	80 e1 07	 and	 cl, 7
  000c5	80 c1 03	 add	 cl, 3
  000c8	3a 4d fd	 cmp	 cl, BYTE PTR tv202[ebp]
  000cb	7c 0c		 jl	 SHORT $LN14@Orphan_ran
  000cd	8b 55 e4	 mov	 edx, DWORD PTR tv199[ebp]
  000d0	52		 push	 edx
  000d1	e8 00 00 00 00	 call	 ___asan_report_load4
  000d6	83 c4 04	 add	 esp, 4
$LN14@Orphan_ran:
  000d9	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000dc	8b 08		 mov	 ecx, DWORD PTR [eax]
  000de	83 c1 08	 add	 ecx, 8
  000e1	89 4d c4	 mov	 DWORD PTR tv77[ebp], ecx
  000e4	8b 55 c4	 mov	 edx, DWORD PTR tv77[ebp]
  000e7	89 55 e0	 mov	 DWORD PTR tv189[ebp], edx
  000ea	8b 45 e0	 mov	 eax, DWORD PTR tv189[ebp]
  000ed	c1 e8 03	 shr	 eax, 3
  000f0	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000f6	88 4d fc	 mov	 BYTE PTR tv192[ebp], cl
  000f9	80 7d fc 00	 cmp	 BYTE PTR tv192[ebp], 0
  000fd	74 1a		 je	 SHORT $LN13@Orphan_ran
  000ff	8a 55 e0	 mov	 dl, BYTE PTR tv189[ebp]
  00102	80 e2 07	 and	 dl, 7
  00105	80 c2 03	 add	 dl, 3
  00108	3a 55 fc	 cmp	 dl, BYTE PTR tv192[ebp]
  0010b	7c 0c		 jl	 SHORT $LN13@Orphan_ran
  0010d	8b 45 e0	 mov	 eax, DWORD PTR tv189[ebp]
  00110	50		 push	 eax
  00111	e8 00 00 00 00	 call	 ___asan_report_load4
  00116	83 c4 04	 add	 esp, 4
$LN13@Orphan_ran:
  00119	8b 4d c4	 mov	 ecx, DWORD PTR tv77[ebp]
  0011c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0011e	89 55 c0	 mov	 DWORD PTR __Pnextptr$3[ebp], edx

; 1786 :             if (_Pnextptr < _First || _Last < _Pnextptr) { // skip the iterator

  00121	8b 45 c0	 mov	 eax, DWORD PTR __Pnextptr$3[ebp]
  00124	3b 45 08	 cmp	 eax, DWORD PTR __First$[ebp]
  00127	72 08		 jb	 SHORT $LN6@Orphan_ran
  00129	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  0012c	3b 4d c0	 cmp	 ecx, DWORD PTR __Pnextptr$3[ebp]
  0012f	73 4f		 jae	 SHORT $LN4@Orphan_ran
$LN6@Orphan_ran:

; 1787 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00131	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00134	89 55 a4	 mov	 DWORD PTR tv94[ebp], edx
  00137	8b 45 a4	 mov	 eax, DWORD PTR tv94[ebp]
  0013a	89 45 dc	 mov	 DWORD PTR tv179[ebp], eax
  0013d	8b 4d dc	 mov	 ecx, DWORD PTR tv179[ebp]
  00140	c1 e9 03	 shr	 ecx, 3
  00143	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00149	88 55 fb	 mov	 BYTE PTR tv182[ebp], dl
  0014c	80 7d fb 00	 cmp	 BYTE PTR tv182[ebp], 0
  00150	74 18		 je	 SHORT $LN12@Orphan_ran
  00152	8a 45 dc	 mov	 al, BYTE PTR tv179[ebp]
  00155	24 07		 and	 al, 7
  00157	04 03		 add	 al, 3
  00159	3a 45 fb	 cmp	 al, BYTE PTR tv182[ebp]
  0015c	7c 0c		 jl	 SHORT $LN12@Orphan_ran
  0015e	8b 4d dc	 mov	 ecx, DWORD PTR tv179[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN12@Orphan_ran:
  0016a	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0016d	8b 02		 mov	 eax, DWORD PTR [edx]
  0016f	89 45 a0	 mov	 DWORD PTR __Temp$1[ebp], eax

; 1788 :                 _Pnext           = &_Temp->_Mynextiter;

  00172	8b 4d a0	 mov	 ecx, DWORD PTR __Temp$1[ebp]
  00175	83 c1 04	 add	 ecx, 4
  00178	89 4d f0	 mov	 DWORD PTR __Pnext$[ebp], ecx

; 1789 :             } else { // orphan the iterator

  0017b	e9 04 01 00 00	 jmp	 $LN5@Orphan_ran
$LN4@Orphan_ran:

; 1790 :                 const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  00180	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00183	89 55 9c	 mov	 DWORD PTR tv129[ebp], edx
  00186	8b 45 9c	 mov	 eax, DWORD PTR tv129[ebp]
  00189	89 45 d8	 mov	 DWORD PTR tv169[ebp], eax
  0018c	8b 4d d8	 mov	 ecx, DWORD PTR tv169[ebp]
  0018f	c1 e9 03	 shr	 ecx, 3
  00192	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00198	88 55 fa	 mov	 BYTE PTR tv172[ebp], dl
  0019b	80 7d fa 00	 cmp	 BYTE PTR tv172[ebp], 0
  0019f	74 18		 je	 SHORT $LN11@Orphan_ran
  001a1	8a 45 d8	 mov	 al, BYTE PTR tv169[ebp]
  001a4	24 07		 and	 al, 7
  001a6	04 03		 add	 al, 3
  001a8	3a 45 fa	 cmp	 al, BYTE PTR tv172[ebp]
  001ab	7c 0c		 jl	 SHORT $LN11@Orphan_ran
  001ad	8b 4d d8	 mov	 ecx, DWORD PTR tv169[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 ___asan_report_load4
  001b6	83 c4 04	 add	 esp, 4
$LN11@Orphan_ran:
  001b9	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  001bc	8b 02		 mov	 eax, DWORD PTR [edx]
  001be	89 45 b8	 mov	 DWORD PTR __Temp$2[ebp], eax

; 1791 :                 _Temp->_Myproxy  = nullptr;

  001c1	8b 4d b8	 mov	 ecx, DWORD PTR __Temp$2[ebp]
  001c4	89 4d bc	 mov	 DWORD PTR tv81[ebp], ecx
  001c7	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  001ca	89 55 d4	 mov	 DWORD PTR tv159[ebp], edx
  001cd	8b 45 d4	 mov	 eax, DWORD PTR tv159[ebp]
  001d0	c1 e8 03	 shr	 eax, 3
  001d3	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001d9	88 4d f9	 mov	 BYTE PTR tv162[ebp], cl
  001dc	80 7d f9 00	 cmp	 BYTE PTR tv162[ebp], 0
  001e0	74 1a		 je	 SHORT $LN10@Orphan_ran
  001e2	8a 55 d4	 mov	 dl, BYTE PTR tv159[ebp]
  001e5	80 e2 07	 and	 dl, 7
  001e8	80 c2 03	 add	 dl, 3
  001eb	3a 55 f9	 cmp	 dl, BYTE PTR tv162[ebp]
  001ee	7c 0c		 jl	 SHORT $LN10@Orphan_ran
  001f0	8b 45 d4	 mov	 eax, DWORD PTR tv159[ebp]
  001f3	50		 push	 eax
  001f4	e8 00 00 00 00	 call	 ___asan_report_store4
  001f9	83 c4 04	 add	 esp, 4
$LN10@Orphan_ran:
  001fc	8b 4d bc	 mov	 ecx, DWORD PTR tv81[ebp]
  001ff	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1792 :                 *_Pnext          = _Temp->_Mynextiter;

  00205	8b 55 b8	 mov	 edx, DWORD PTR __Temp$2[ebp]
  00208	83 c2 04	 add	 edx, 4
  0020b	89 55 b4	 mov	 DWORD PTR tv82[ebp], edx
  0020e	8b 45 b4	 mov	 eax, DWORD PTR tv82[ebp]
  00211	89 45 d0	 mov	 DWORD PTR tv149[ebp], eax
  00214	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  00217	c1 e9 03	 shr	 ecx, 3
  0021a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00220	88 55 f8	 mov	 BYTE PTR tv152[ebp], dl
  00223	80 7d f8 00	 cmp	 BYTE PTR tv152[ebp], 0
  00227	74 18		 je	 SHORT $LN9@Orphan_ran
  00229	8a 45 d0	 mov	 al, BYTE PTR tv149[ebp]
  0022c	24 07		 and	 al, 7
  0022e	04 03		 add	 al, 3
  00230	3a 45 f8	 cmp	 al, BYTE PTR tv152[ebp]
  00233	7c 0c		 jl	 SHORT $LN9@Orphan_ran
  00235	8b 4d d0	 mov	 ecx, DWORD PTR tv149[ebp]
  00238	51		 push	 ecx
  00239	e8 00 00 00 00	 call	 ___asan_report_load4
  0023e	83 c4 04	 add	 esp, 4
$LN9@Orphan_ran:
  00241	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  00244	89 55 98	 mov	 DWORD PTR tv136[ebp], edx
  00247	8b 45 98	 mov	 eax, DWORD PTR tv136[ebp]
  0024a	89 45 cc	 mov	 DWORD PTR tv139[ebp], eax
  0024d	8b 4d cc	 mov	 ecx, DWORD PTR tv139[ebp]
  00250	c1 e9 03	 shr	 ecx, 3
  00253	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00259	88 55 f7	 mov	 BYTE PTR tv142[ebp], dl
  0025c	80 7d f7 00	 cmp	 BYTE PTR tv142[ebp], 0
  00260	74 18		 je	 SHORT $LN8@Orphan_ran
  00262	8a 45 cc	 mov	 al, BYTE PTR tv139[ebp]
  00265	24 07		 and	 al, 7
  00267	04 03		 add	 al, 3
  00269	3a 45 f7	 cmp	 al, BYTE PTR tv142[ebp]
  0026c	7c 0c		 jl	 SHORT $LN8@Orphan_ran
  0026e	8b 4d cc	 mov	 ecx, DWORD PTR tv139[ebp]
  00271	51		 push	 ecx
  00272	e8 00 00 00 00	 call	 ___asan_report_store4
  00277	83 c4 04	 add	 esp, 4
$LN8@Orphan_ran:
  0027a	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$[ebp]
  0027d	8b 45 b4	 mov	 eax, DWORD PTR tv82[ebp]
  00280	8b 08		 mov	 ecx, DWORD PTR [eax]
  00282	89 0a		 mov	 DWORD PTR [edx], ecx
$LN5@Orphan_ran:

; 1793 :             }
; 1794 :         }

  00284	e9 d0 fd ff ff	 jmp	 $LN2@Orphan_ran
$LN1@Orphan_ran:

; 1795 :     }

  00289	8b e5		 mov	 esp, ebp
  0028b	5d		 pop	 ebp
  0028c	c2 08 00	 ret	 8
?_Orphan_range_unlocked@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEXPAPAVTexture@sf@@0@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Orphan_range_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z ; std::allocator<sf::Texture *>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Change_array@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXQAPAVTexture@sf@@II@Z
_TEXT	SEGMENT
tv94 = -104						; size = 4
tv146 = -100						; size = 4
tv92 = -96						; size = 4
tv143 = -92						; size = 4
tv140 = -88						; size = 4
tv90 = -84						; size = 4
tv86 = -80						; size = 4
tv88 = -76						; size = 4
tv137 = -72						; size = 4
tv134 = -68						; size = 4
tv131 = -64						; size = 4
tv128 = -60						; size = 4
tv149 = -56						; size = 4
__Mylast$ = -52						; size = 4
tv159 = -48						; size = 4
tv169 = -44						; size = 4
tv179 = -40						; size = 4
tv189 = -36						; size = 4
tv199 = -32						; size = 4
_this$ = -28						; size = 4
tv209 = -24						; size = 4
__Myend$ = -20						; size = 4
__My_data$ = -16					; size = 4
__Myfirst$ = -12					; size = 4
tv152 = -7						; size = 1
tv162 = -6						; size = 1
tv172 = -5						; size = 1
tv182 = -4						; size = 1
tv192 = -3						; size = 1
tv202 = -2						; size = 1
tv212 = -1						; size = 1
__Newvec$ = 8						; size = 4
__Newsize$ = 12						; size = 4
__Newcapacity$ = 16					; size = 4
?_Change_array@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXQAPAVTexture@sf@@II@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Change_array, COMDAT
; _this$ = ecx

; 1736 :         const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1737 :         // orphan all iterators, discard old array, acquire new array
; 1738 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1739 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d f4	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1740 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 cc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1741 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 ec	 mov	 DWORD PTR __Myend$[ebp], eax

; 1742 : 
; 1743 :         _My_data._Orphan_all();

  00034	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1744 : 
; 1745 :         if (_Myfirst) { // destroy and deallocate old array

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0003f	89 4d c4	 mov	 DWORD PTR tv128[ebp], ecx
  00042	8b 55 c4	 mov	 edx, DWORD PTR tv128[ebp]
  00045	89 55 e8	 mov	 DWORD PTR tv209[ebp], edx
  00048	8b 45 e8	 mov	 eax, DWORD PTR tv209[ebp]
  0004b	c1 e8 03	 shr	 eax, 3
  0004e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00054	88 4d ff	 mov	 BYTE PTR tv212[ebp], cl
  00057	80 7d ff 00	 cmp	 BYTE PTR tv212[ebp], 0
  0005b	74 1a		 je	 SHORT $LN10@Change_arr
  0005d	8a 55 e8	 mov	 dl, BYTE PTR tv209[ebp]
  00060	80 e2 07	 and	 dl, 7
  00063	80 c2 03	 add	 dl, 3
  00066	3a 55 ff	 cmp	 dl, BYTE PTR tv212[ebp]
  00069	7c 0c		 jl	 SHORT $LN10@Change_arr
  0006b	8b 45 e8	 mov	 eax, DWORD PTR tv209[ebp]
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 ___asan_report_load4
  00074	83 c4 04	 add	 esp, 4
$LN10@Change_arr:
  00077	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0007a	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0007d	0f 84 f8 00 00
	00		 je	 $LN2@Change_arr

; 1746 :             _Destroy(_Myfirst, _Mylast);

  00083	8b 55 cc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00086	8b 02		 mov	 eax, DWORD PTR [edx]
  00088	50		 push	 eax
  00089	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0008c	8b 11		 mov	 edx, DWORD PTR [ecx]
  0008e	52		 push	 edx
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00092	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Destroy

; 1747 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  00097	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  0009a	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  0009f	89 45 ac	 mov	 DWORD PTR tv90[ebp], eax
  000a2	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  000a5	89 45 c0	 mov	 DWORD PTR tv131[ebp], eax
  000a8	8b 4d c0	 mov	 ecx, DWORD PTR tv131[ebp]
  000ab	89 4d e0	 mov	 DWORD PTR tv199[ebp], ecx
  000ae	8b 55 e0	 mov	 edx, DWORD PTR tv199[ebp]
  000b1	c1 ea 03	 shr	 edx, 3
  000b4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000ba	88 45 fe	 mov	 BYTE PTR tv202[ebp], al
  000bd	80 7d fe 00	 cmp	 BYTE PTR tv202[ebp], 0
  000c1	74 1a		 je	 SHORT $LN9@Change_arr
  000c3	8a 4d e0	 mov	 cl, BYTE PTR tv199[ebp]
  000c6	80 e1 07	 and	 cl, 7
  000c9	80 c1 03	 add	 cl, 3
  000cc	3a 4d fe	 cmp	 cl, BYTE PTR tv202[ebp]
  000cf	7c 0c		 jl	 SHORT $LN9@Change_arr
  000d1	8b 55 e0	 mov	 edx, DWORD PTR tv199[ebp]
  000d4	52		 push	 edx
  000d5	e8 00 00 00 00	 call	 ___asan_report_load4
  000da	83 c4 04	 add	 esp, 4
$LN9@Change_arr:
  000dd	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000e0	89 45 bc	 mov	 DWORD PTR tv134[ebp], eax
  000e3	8b 4d bc	 mov	 ecx, DWORD PTR tv134[ebp]
  000e6	89 4d dc	 mov	 DWORD PTR tv189[ebp], ecx
  000e9	8b 55 dc	 mov	 edx, DWORD PTR tv189[ebp]
  000ec	c1 ea 03	 shr	 edx, 3
  000ef	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f5	88 45 fd	 mov	 BYTE PTR tv192[ebp], al
  000f8	80 7d fd 00	 cmp	 BYTE PTR tv192[ebp], 0
  000fc	74 1a		 je	 SHORT $LN8@Change_arr
  000fe	8a 4d dc	 mov	 cl, BYTE PTR tv189[ebp]
  00101	80 e1 07	 and	 cl, 7
  00104	80 c1 03	 add	 cl, 3
  00107	3a 4d fd	 cmp	 cl, BYTE PTR tv192[ebp]
  0010a	7c 0c		 jl	 SHORT $LN8@Change_arr
  0010c	8b 55 dc	 mov	 edx, DWORD PTR tv189[ebp]
  0010f	52		 push	 edx
  00110	e8 00 00 00 00	 call	 ___asan_report_load4
  00115	83 c4 04	 add	 esp, 4
$LN8@Change_arr:
  00118	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0011b	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0011e	8b 10		 mov	 edx, DWORD PTR [eax]
  00120	2b 11		 sub	 edx, DWORD PTR [ecx]
  00122	c1 fa 02	 sar	 edx, 2
  00125	89 55 b4	 mov	 DWORD PTR tv88[ebp], edx
  00128	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0012b	89 45 b8	 mov	 DWORD PTR tv137[ebp], eax
  0012e	8b 4d b8	 mov	 ecx, DWORD PTR tv137[ebp]
  00131	89 4d d8	 mov	 DWORD PTR tv179[ebp], ecx
  00134	8b 55 d8	 mov	 edx, DWORD PTR tv179[ebp]
  00137	c1 ea 03	 shr	 edx, 3
  0013a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00140	88 45 fc	 mov	 BYTE PTR tv182[ebp], al
  00143	80 7d fc 00	 cmp	 BYTE PTR tv182[ebp], 0
  00147	74 1a		 je	 SHORT $LN7@Change_arr
  00149	8a 4d d8	 mov	 cl, BYTE PTR tv179[ebp]
  0014c	80 e1 07	 and	 cl, 7
  0014f	80 c1 03	 add	 cl, 3
  00152	3a 4d fc	 cmp	 cl, BYTE PTR tv182[ebp]
  00155	7c 0c		 jl	 SHORT $LN7@Change_arr
  00157	8b 55 d8	 mov	 edx, DWORD PTR tv179[ebp]
  0015a	52		 push	 edx
  0015b	e8 00 00 00 00	 call	 ___asan_report_load4
  00160	83 c4 04	 add	 esp, 4
$LN7@Change_arr:
  00163	8b 45 f4	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00166	8b 08		 mov	 ecx, DWORD PTR [eax]
  00168	89 4d b0	 mov	 DWORD PTR tv86[ebp], ecx
  0016b	8b 55 b4	 mov	 edx, DWORD PTR tv88[ebp]
  0016e	52		 push	 edx
  0016f	8b 45 b0	 mov	 eax, DWORD PTR tv86[ebp]
  00172	50		 push	 eax
  00173	8b 4d ac	 mov	 ecx, DWORD PTR tv90[ebp]
  00176	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z ; std::allocator<sf::Texture *>::deallocate
$LN2@Change_arr:

; 1748 :         }
; 1749 : 
; 1750 :         _Myfirst = _Newvec;

  0017b	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0017e	89 4d a8	 mov	 DWORD PTR tv140[ebp], ecx
  00181	8b 55 a8	 mov	 edx, DWORD PTR tv140[ebp]
  00184	89 55 d4	 mov	 DWORD PTR tv169[ebp], edx
  00187	8b 45 d4	 mov	 eax, DWORD PTR tv169[ebp]
  0018a	c1 e8 03	 shr	 eax, 3
  0018d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00193	88 4d fb	 mov	 BYTE PTR tv172[ebp], cl
  00196	80 7d fb 00	 cmp	 BYTE PTR tv172[ebp], 0
  0019a	74 1a		 je	 SHORT $LN6@Change_arr
  0019c	8a 55 d4	 mov	 dl, BYTE PTR tv169[ebp]
  0019f	80 e2 07	 and	 dl, 7
  001a2	80 c2 03	 add	 dl, 3
  001a5	3a 55 fb	 cmp	 dl, BYTE PTR tv172[ebp]
  001a8	7c 0c		 jl	 SHORT $LN6@Change_arr
  001aa	8b 45 d4	 mov	 eax, DWORD PTR tv169[ebp]
  001ad	50		 push	 eax
  001ae	e8 00 00 00 00	 call	 ___asan_report_store4
  001b3	83 c4 04	 add	 esp, 4
$LN6@Change_arr:
  001b6	8b 4d f4	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001b9	8b 55 08	 mov	 edx, DWORD PTR __Newvec$[ebp]
  001bc	89 11		 mov	 DWORD PTR [ecx], edx

; 1751 :         _Mylast  = _Newvec + _Newsize;

  001be	8b 45 0c	 mov	 eax, DWORD PTR __Newsize$[ebp]
  001c1	c1 e0 02	 shl	 eax, 2
  001c4	8b 4d 08	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  001c7	03 c8		 add	 ecx, eax
  001c9	89 4d a0	 mov	 DWORD PTR tv92[ebp], ecx
  001cc	8b 55 cc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001cf	89 55 a4	 mov	 DWORD PTR tv143[ebp], edx
  001d2	8b 45 a4	 mov	 eax, DWORD PTR tv143[ebp]
  001d5	89 45 d0	 mov	 DWORD PTR tv159[ebp], eax
  001d8	8b 4d d0	 mov	 ecx, DWORD PTR tv159[ebp]
  001db	c1 e9 03	 shr	 ecx, 3
  001de	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e4	88 55 fa	 mov	 BYTE PTR tv162[ebp], dl
  001e7	80 7d fa 00	 cmp	 BYTE PTR tv162[ebp], 0
  001eb	74 18		 je	 SHORT $LN5@Change_arr
  001ed	8a 45 d0	 mov	 al, BYTE PTR tv159[ebp]
  001f0	24 07		 and	 al, 7
  001f2	04 03		 add	 al, 3
  001f4	3a 45 fa	 cmp	 al, BYTE PTR tv162[ebp]
  001f7	7c 0c		 jl	 SHORT $LN5@Change_arr
  001f9	8b 4d d0	 mov	 ecx, DWORD PTR tv159[ebp]
  001fc	51		 push	 ecx
  001fd	e8 00 00 00 00	 call	 ___asan_report_store4
  00202	83 c4 04	 add	 esp, 4
$LN5@Change_arr:
  00205	8b 55 cc	 mov	 edx, DWORD PTR __Mylast$[ebp]
  00208	8b 45 a0	 mov	 eax, DWORD PTR tv92[ebp]
  0020b	89 02		 mov	 DWORD PTR [edx], eax

; 1752 :         _Myend   = _Newvec + _Newcapacity;

  0020d	8b 4d 10	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00210	c1 e1 02	 shl	 ecx, 2
  00213	8b 55 08	 mov	 edx, DWORD PTR __Newvec$[ebp]
  00216	03 d1		 add	 edx, ecx
  00218	89 55 98	 mov	 DWORD PTR tv94[ebp], edx
  0021b	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  0021e	89 45 9c	 mov	 DWORD PTR tv146[ebp], eax
  00221	8b 4d 9c	 mov	 ecx, DWORD PTR tv146[ebp]
  00224	89 4d c8	 mov	 DWORD PTR tv149[ebp], ecx
  00227	8b 55 c8	 mov	 edx, DWORD PTR tv149[ebp]
  0022a	c1 ea 03	 shr	 edx, 3
  0022d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00233	88 45 f9	 mov	 BYTE PTR tv152[ebp], al
  00236	80 7d f9 00	 cmp	 BYTE PTR tv152[ebp], 0
  0023a	74 1a		 je	 SHORT $LN4@Change_arr
  0023c	8a 4d c8	 mov	 cl, BYTE PTR tv149[ebp]
  0023f	80 e1 07	 and	 cl, 7
  00242	80 c1 03	 add	 cl, 3
  00245	3a 4d f9	 cmp	 cl, BYTE PTR tv152[ebp]
  00248	7c 0c		 jl	 SHORT $LN4@Change_arr
  0024a	8b 55 c8	 mov	 edx, DWORD PTR tv149[ebp]
  0024d	52		 push	 edx
  0024e	e8 00 00 00 00	 call	 ___asan_report_store4
  00253	83 c4 04	 add	 esp, 4
$LN4@Change_arr:
  00256	8b 45 ec	 mov	 eax, DWORD PTR __Myend$[ebp]
  00259	8b 4d 98	 mov	 ecx, DWORD PTR tv94[ebp]
  0025c	89 08		 mov	 DWORD PTR [eax], ecx

; 1753 :     }

  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c2 0c 00	 ret	 12			; 0000000cH
?_Change_array@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXQAPAVTexture@sf@@II@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Calculate_growth@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEII@Z
_TEXT	SEGMENT
__Geometric$ = -16					; size = 4
__Max$ = -12						; size = 4
_this$ = -8						; size = 4
__Oldcapacity$ = -4					; size = 4
__Newsize$ = 8						; size = 4
?_Calculate_growth@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEII@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Calculate_growth, COMDAT
; _this$ = ecx

; 1683 :     _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1684 :         // given _Oldcapacity and _Newsize, calculate geometric growth
; 1685 :         const size_type _Oldcapacity = capacity();

  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?capacity@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::capacity
  0001b	89 45 fc	 mov	 DWORD PTR __Oldcapacity$[ebp], eax

; 1686 :         const auto _Max              = max_size();

  0001e	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::max_size
  00026	89 45 f4	 mov	 DWORD PTR __Max$[ebp], eax

; 1687 : 
; 1688 :         if (_Oldcapacity > _Max - _Oldcapacity / 2) {

  00029	8b 45 fc	 mov	 eax, DWORD PTR __Oldcapacity$[ebp]
  0002c	d1 e8		 shr	 eax, 1
  0002e	8b 4d f4	 mov	 ecx, DWORD PTR __Max$[ebp]
  00031	2b c8		 sub	 ecx, eax
  00033	39 4d fc	 cmp	 DWORD PTR __Oldcapacity$[ebp], ecx
  00036	76 05		 jbe	 SHORT $LN2@Calculate_

; 1689 :             return _Max; // geometric growth would overflow

  00038	8b 45 f4	 mov	 eax, DWORD PTR __Max$[ebp]
  0003b	eb 1b		 jmp	 SHORT $LN1@Calculate_
$LN2@Calculate_:

; 1690 :         }
; 1691 : 
; 1692 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

  0003d	8b 55 fc	 mov	 edx, DWORD PTR __Oldcapacity$[ebp]
  00040	d1 ea		 shr	 edx, 1
  00042	03 55 fc	 add	 edx, DWORD PTR __Oldcapacity$[ebp]
  00045	89 55 f0	 mov	 DWORD PTR __Geometric$[ebp], edx

; 1693 : 
; 1694 :         if (_Geometric < _Newsize) {

  00048	8b 45 f0	 mov	 eax, DWORD PTR __Geometric$[ebp]
  0004b	3b 45 08	 cmp	 eax, DWORD PTR __Newsize$[ebp]
  0004e	73 05		 jae	 SHORT $LN3@Calculate_

; 1695 :             return _Newsize; // geometric growth would be insufficient

  00050	8b 45 08	 mov	 eax, DWORD PTR __Newsize$[ebp]
  00053	eb 03		 jmp	 SHORT $LN1@Calculate_
$LN3@Calculate_:

; 1696 :         }
; 1697 : 
; 1698 :         return _Geometric; // geometric growth is sufficient

  00055	8b 45 f0	 mov	 eax, DWORD PTR __Geometric$[ebp]
$LN1@Calculate_:

; 1699 :     }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 04 00	 ret	 4
?_Calculate_growth@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEII@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVTexture@sf@@@std@@@std@@YAXPAPAVTexture@sf@@QAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Destroy_range<std::allocator<sf::Texture *> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@0@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z
_TEXT	SEGMENT
__asan_gen_0$ = -72					; size = 4
__asan_gen_1$ = -68					; size = 4
__asan_gen_2$ = -64					; size = 4
$T2 = -56						; size = 1
tv75 = -16						; size = 4
tv73 = -12						; size = 4
_this$ = -8						; size = 4
tv81 = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept, COMDAT
; _this$ = ecx

; 1672 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 b8 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00023	c7 45 bc 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z
  0002a	c7 45 c0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept
  00031	8d 45 b8	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00034	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00037	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00043	89 4d f0	 mov	 DWORD PTR tv75[ebp], ecx
  00046	8b 55 f0	 mov	 edx, DWORD PTR tv75[ebp]
  00049	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0004f	83 45 f0 04	 add	 DWORD PTR tv75[ebp], 4
  00053	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00058	8b 4d f0	 mov	 ecx, DWORD PTR tv75[ebp]
  0005b	66 89 01	 mov	 WORD PTR [ecx], ax
  0005e	83 45 f0 02	 add	 DWORD PTR tv75[ebp], 2
  00062	8b 55 f0	 mov	 edx, DWORD PTR tv75[ebp]
  00065	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1673 :         // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
; 1674 :         _Umove_if_noexcept1(_First, _Last, _Dest,

  00072	6a 01		 push	 1
  00074	6a 00		 push	 0
  00076	8d 45 c8	 lea	 eax, DWORD PTR $T2[ebp]
  00079	50		 push	 eax
  0007a	e8 00 00 00 00	 call	 ___asan_memset
  0007f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00082	0f b6 4d c8	 movzx	 ecx, BYTE PTR $T2[ebp]
  00086	51		 push	 ecx
  00087	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  0008a	52		 push	 edx
  0008b	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  0008e	50		 push	 eax
  0008f	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  00092	51		 push	 ecx
  00093	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00096	e8 00 00 00 00	 call	 ?_Umove_if_noexcept1@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00U?$integral_constant@_N$00@2@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept1
  0009b	8d 55 c8	 lea	 edx, DWORD PTR $T2[ebp]
  0009e	c1 ea 03	 shr	 edx, 3
  000a1	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 1675 :             bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
; 1676 :     }

  000a8	c7 45 b8 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000af	8d 45 b8	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000b2	c1 e8 03	 shr	 eax, 3
  000b5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000ba	89 45 fc	 mov	 DWORD PTR tv81[ebp], eax
  000bd	6a 07		 push	 7
  000bf	8b 4d fc	 mov	 ecx, DWORD PTR tv81[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000c8	83 c4 08	 add	 esp, 8
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	8b e3		 mov	 esp, ebx
  000d0	5b		 pop	 ebx
  000d1	c2 0c 00	 ret	 12			; 0000000cH
?_Umove_if_noexcept@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
?_Umove_if_noexcept1@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept1, COMDAT
; _this$ = ecx

; 1662 :     _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1663 :         // move [_First, _Last) to raw _Dest, using allocator
; 1664 :         _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Uninitialized_move<sf::Texture * *,std::allocator<sf::Texture *> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1665 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 10 00	 ret	 16			; 00000010H
?_Umove_if_noexcept1@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXPAPAVTexture@sf@@00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Umove@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEPAPAVTexture@sf@@PAPAV34@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
?_Umove@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEPAPAVTexture@sf@@PAPAV34@00@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove, COMDAT
; _this$ = ecx

; 1657 :     _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1658 :         // move [_First, _Last) to raw _Dest, using allocator
; 1659 :         return _Uninitialized_move(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_move@PAPAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@YAPAPAVTexture@sf@@QAPAV12@0PAPAV12@AAV?$allocator@PAVTexture@sf@@@0@@Z ; std::_Uninitialized_move<sf::Texture * *,std::allocator<sf::Texture *> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1660 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
?_Umove@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEPAPAVTexture@sf@@PAPAV34@00@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Umove
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?capacity@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
__My_data$ = -16					; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?capacity@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::capacity, COMDAT
; _this$ = ecx

; 1557 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type capacity() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1558 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1559 :         return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0001f	89 4d ec	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00044	74 18		 je	 SHORT $LN4@capacity
  00046	8a 45 f8	 mov	 al, BYTE PTR tv85[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00050	7c 0c		 jl	 SHORT $LN4@capacity
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN4@capacity:
  0005e	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00077	74 1a		 je	 SHORT $LN3@capacity
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00085	7c 0c		 jl	 SHORT $LN3@capacity
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN3@capacity:
  00093	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2

; 1560 :     }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?capacity@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@ABEABV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAIABV?$allocator@PAVTexture@sf@@@2@@Z ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QBEIXZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?push_back@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXABQAVTexture@sf@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXABQAVTexture@sf@@@Z PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::push_back, COMDAT
; _this$ = ecx

; 755  :     _CONSTEXPR20_CONTAINER void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 756  :         emplace_back(_Val);

  00011	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	e8 00 00 00 00	 call	 ??$emplace_back@ABQAVTexture@sf@@@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE?A_TABQAVTexture@sf@@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::emplace_back<sf::Texture * const &>

; 757  :     }

  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c2 04 00	 ret	 4
?push_back@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXABQAVTexture@sf@@@Z ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S1$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::~vector<sf::Texture *,std::allocator<sf::Texture *> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::~vector<sf::Texture *,std::allocator<sf::Texture *> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEXXZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S1$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0PAVTexture@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVTexture@sf@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Texture *>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S1$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::~vector<sf::Texture *,std::allocator<sf::Texture *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T3 = -104						; size = 1
$T4 = -61						; size = 1
tv88 = -60						; size = 4
_this$ = -56						; size = 4
tv86 = -52						; size = 4
tv69 = -48						; size = 4
tv83 = -44						; size = 4
tv94 = -40						; size = 4
tv85 = -36						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ PROC ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::vector<sf::Texture *,std::allocator<sf::Texture *> >, COMDAT
; _this$ = ecx

; 476  :         : _Mypair(_Zero_then_variadic_args_t{}) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	50		 push	 eax
  00030	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00033	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00039	89 4d c8	 mov	 DWORD PTR _this$[ebp], ecx
  0003c	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00043	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
  0004a	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::vector<sf::Texture *,std::allocator<sf::Texture *> >
  00051	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00054	89 45 cc	 mov	 DWORD PTR tv86[ebp], eax
  00057	8b 4d cc	 mov	 ecx, DWORD PTR tv86[ebp]
  0005a	c1 e9 03	 shr	 ecx, 3
  0005d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00063	89 4d c4	 mov	 DWORD PTR tv88[ebp], ecx
  00066	8b 55 c4	 mov	 edx, DWORD PTR tv88[ebp]
  00069	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0006f	83 45 c4 04	 add	 DWORD PTR tv88[ebp], 4
  00073	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00078	8b 4d c4	 mov	 ecx, DWORD PTR tv88[ebp]
  0007b	66 89 01	 mov	 WORD PTR [ecx], ax
  0007e	83 45 c4 02	 add	 DWORD PTR tv88[ebp], 2
  00082	8b 55 c4	 mov	 edx, DWORD PTR tv88[ebp]
  00085	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00092	8b 45 c8	 mov	 eax, DWORD PTR _this$[ebp]
  00095	89 45 d0	 mov	 DWORD PTR tv69[ebp], eax
  00098	0f b6 4d c3	 movzx	 ecx, BYTE PTR $T4[ebp]
  0009c	51		 push	 ecx
  0009d	8b 4d d0	 mov	 ecx, DWORD PTR tv69[ebp]
  000a0	e8 00 00 00 00	 call	 ??$?0$$V@?$_Compressed_pair@V?$allocator@PAVTexture@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVTexture@sf@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1>::_Compressed_pair<std::allocator<sf::Texture *>,std::_Vector_val<std::_Simple_types<sf::Texture *> >,1><>

; 477  :         _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));

  000a5	8b 55 c8	 mov	 edx, DWORD PTR _this$[ebp]
  000a8	89 55 d4	 mov	 DWORD PTR tv83[ebp], edx
  000ab	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ae	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@AAEAAV?$allocator@PAVTexture@sf@@@2@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::_Getal
  000b3	50		 push	 eax
  000b4	8d 4d 98	 lea	 ecx, DWORD PTR $T3[ebp]
  000b7	e8 00 00 00 00	 call	 ??$?0PAVTexture@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVTexture@sf@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Texture *>
  000bc	50		 push	 eax
  000bd	8b 4d d4	 mov	 ecx, DWORD PTR tv83[ebp]
  000c0	e8 00 00 00 00	 call	 ??$_Alloc_proxy@V?$allocator@U_Container_proxy@std@@@std@@@_Container_base12@std@@QAEX$$QAV?$allocator@U_Container_proxy@std@@@1@@Z ; std::_Container_base12::_Alloc_proxy<std::allocator<std::_Container_proxy> >
  000c5	8d 45 98	 lea	 eax, DWORD PTR $T3[ebp]
  000c8	c1 e8 03	 shr	 eax, 3
  000cb	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 478  :     }

  000d2	8b 4d c8	 mov	 ecx, DWORD PTR _this$[ebp]
  000d5	89 4d dc	 mov	 DWORD PTR tv85[ebp], ecx
  000d8	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000df	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  000e2	c1 ea 03	 shr	 edx, 3
  000e5	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  000eb	89 55 d8	 mov	 DWORD PTR tv94[ebp], edx
  000ee	6a 07		 push	 7
  000f0	8b 45 d8	 mov	 eax, DWORD PTR tv94[ebp]
  000f3	50		 push	 eax
  000f4	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000f9	83 c4 08	 add	 esp, 8
  000fc	8b 45 dc	 mov	 eax, DWORD PTR tv85[ebp]
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00102	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00109	59		 pop	 ecx
  0010a	8b e5		 mov	 esp, ebp
  0010c	5d		 pop	 ebp
  0010d	8b e3		 mov	 esp, ebx
  0010f	5b		 pop	 ebx
  00110	c3		 ret	 0
  00111	cc		 int	 3
  00112	cc		 int	 3
  00113	cc		 int	 3
  00114	cc		 int	 3
  00115	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ENDP ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::vector<sf::Texture *,std::allocator<sf::Texture *> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAIABV?$allocator@PAVTexture@sf@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAIABV?$allocator@PAVTexture@sf@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PAVTexture@sf@@@std@@@std@@SAIABV?$allocator@PAVTexture@sf@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<sf::Texture *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVTexture@sf@@@std@@QAEPAPAVTexture@sf@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVTexture@sf@@@std@@QAEPAPAVTexture@sf@@I@Z PROC ; std::allocator<sf::Texture *>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@PAVTexture@sf@@@std@@QAEPAPAVTexture@sf@@I@Z ENDP ; std::allocator<sf::Texture *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z PROC ; std::allocator<sf::Texture *>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVTexture@sf@@@std@@QAEXQAPAVTexture@sf@@I@Z ENDP ; std::allocator<sf::Texture *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PAVTexture@sf@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVTexture@sf@@@std@@QAE@XZ PROC		; std::allocator<sf::Texture *>::allocator<sf::Texture *>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@PAVTexture@sf@@@std@@QAE@XZ ENDP		; std::allocator<sf::Texture *>::allocator<sf::Texture *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -28						; size = 4
tv67 = -24						; size = 4
tv66 = -20						; size = 4
__My_data$ = -16					; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?size@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QBEIXZ PROC ; std::vector<sf::Image *,std::allocator<sf::Image *> >::size, COMDAT
; _this$ = ecx

; 1547 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1548 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1549 :         return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d ec	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e8	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 ec	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv85[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv88[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00044	74 18		 je	 SHORT $LN4@size
  00046	8a 45 f8	 mov	 al, BYTE PTR tv85[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv88[ebp]
  00050	7c 0c		 jl	 SHORT $LN4@size
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv85[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN4@size:
  0005e	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  00077	74 1a		 je	 SHORT $LN3@size
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00085	7c 0c		 jl	 SHORT $LN3@size
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN3@size:
  00093	8b 4d ec	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2

; 1550 :     }

  000a0	8b e5		 mov	 esp, ebp
  000a2	5d		 pop	 ebp
  000a3	c3		 ret	 0
?size@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QBEIXZ ENDP ; std::vector<sf::Image *,std::allocator<sf::Image *> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.cpp
_TEXT	SEGMENT
$T1 = -52						; size = 4
tv83 = -48						; size = 4
tv73 = -44						; size = 4
tv84 = -40						; size = 4
$T2 = -36						; size = 4
tv74 = -32						; size = 4
$T3 = -28						; size = 4
tv64 = -24						; size = 4
tv130 = -20						; size = 4
_this$ = -16						; size = 4
tv140 = -12						; size = 4
tv150 = -8						; size = 4
tv133 = -3						; size = 1
tv143 = -2						; size = 1
tv153 = -1						; size = 1
??1Player@@QAE@XZ PROC					; Player::~Player
; _this$ = ecx

; 25   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 34	 sub	 esp, 52			; 00000034H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __4D0513DE_Player@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 26   : 	delete(_sprite);

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv150[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv150[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv153[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv153[ebp], 0
  00035	74 1a		 je	 SHORT $LN9@Player
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv150[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv153[ebp]
  00043	7c 0c		 jl	 SHORT $LN9@Player
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv150[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN9@Player:
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d e4	 mov	 DWORD PTR $T3[ebp], ecx
  00059	83 7d e4 00	 cmp	 DWORD PTR $T3[ebp], 0
  0005d	74 0f		 je	 SHORT $LN3@Player
  0005f	6a 01		 push	 1
  00061	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  00064	e8 00 00 00 00	 call	 ??_G?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAXI@Z
  00069	89 45 d4	 mov	 DWORD PTR tv73[ebp], eax
  0006c	eb 07		 jmp	 SHORT $LN4@Player
$LN3@Player:
  0006e	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN4@Player:

; 27   : 	delete(_tex);

  00075	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00078	83 c2 10	 add	 edx, 16			; 00000010H
  0007b	89 55 e0	 mov	 DWORD PTR tv74[ebp], edx
  0007e	8b 45 e0	 mov	 eax, DWORD PTR tv74[ebp]
  00081	89 45 f4	 mov	 DWORD PTR tv140[ebp], eax
  00084	8b 4d f4	 mov	 ecx, DWORD PTR tv140[ebp]
  00087	c1 e9 03	 shr	 ecx, 3
  0008a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00090	88 55 fe	 mov	 BYTE PTR tv143[ebp], dl
  00093	80 7d fe 00	 cmp	 BYTE PTR tv143[ebp], 0
  00097	74 18		 je	 SHORT $LN8@Player
  00099	8a 45 f4	 mov	 al, BYTE PTR tv140[ebp]
  0009c	24 07		 and	 al, 7
  0009e	04 03		 add	 al, 3
  000a0	3a 45 fe	 cmp	 al, BYTE PTR tv143[ebp]
  000a3	7c 0c		 jl	 SHORT $LN8@Player
  000a5	8b 4d f4	 mov	 ecx, DWORD PTR tv140[ebp]
  000a8	51		 push	 ecx
  000a9	e8 00 00 00 00	 call	 ___asan_report_load4
  000ae	83 c4 04	 add	 esp, 4
$LN8@Player:
  000b1	8b 55 e0	 mov	 edx, DWORD PTR tv74[ebp]
  000b4	8b 02		 mov	 eax, DWORD PTR [edx]
  000b6	89 45 dc	 mov	 DWORD PTR $T2[ebp], eax
  000b9	83 7d dc 00	 cmp	 DWORD PTR $T2[ebp], 0
  000bd	74 0f		 je	 SHORT $LN5@Player
  000bf	6a 01		 push	 1
  000c1	8b 4d dc	 mov	 ecx, DWORD PTR $T2[ebp]
  000c4	e8 00 00 00 00	 call	 ??_G?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEPAXI@Z
  000c9	89 45 d0	 mov	 DWORD PTR tv83[ebp], eax
  000cc	eb 07		 jmp	 SHORT $LN6@Player
$LN5@Player:
  000ce	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv83[ebp], 0
$LN6@Player:

; 28   : 	delete(_rect);

  000d5	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	83 c1 08	 add	 ecx, 8
  000db	89 4d d8	 mov	 DWORD PTR tv84[ebp], ecx
  000de	8b 55 d8	 mov	 edx, DWORD PTR tv84[ebp]
  000e1	89 55 ec	 mov	 DWORD PTR tv130[ebp], edx
  000e4	8b 45 ec	 mov	 eax, DWORD PTR tv130[ebp]
  000e7	c1 e8 03	 shr	 eax, 3
  000ea	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000f0	88 4d fd	 mov	 BYTE PTR tv133[ebp], cl
  000f3	80 7d fd 00	 cmp	 BYTE PTR tv133[ebp], 0
  000f7	74 1a		 je	 SHORT $LN7@Player
  000f9	8a 55 ec	 mov	 dl, BYTE PTR tv130[ebp]
  000fc	80 e2 07	 and	 dl, 7
  000ff	80 c2 03	 add	 dl, 3
  00102	3a 55 fd	 cmp	 dl, BYTE PTR tv133[ebp]
  00105	7c 0c		 jl	 SHORT $LN7@Player
  00107	8b 45 ec	 mov	 eax, DWORD PTR tv130[ebp]
  0010a	50		 push	 eax
  0010b	e8 00 00 00 00	 call	 ___asan_report_load4
  00110	83 c4 04	 add	 esp, 4
$LN7@Player:
  00113	8b 4d d8	 mov	 ecx, DWORD PTR tv84[ebp]
  00116	8b 11		 mov	 edx, DWORD PTR [ecx]
  00118	89 55 cc	 mov	 DWORD PTR $T1[ebp], edx
  0011b	6a 10		 push	 16			; 00000010H
  0011d	8b 45 cc	 mov	 eax, DWORD PTR $T1[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00126	83 c4 08	 add	 esp, 8

; 29   : }

  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c3		 ret	 0
??1Player@@QAE@XZ ENDP					; Player::~Player
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -464					; size = 4
__asan_gen_1$ = -460					; size = 4
__asan_gen_2$ = -456					; size = 4
$T3 = -448						; size = 8
$T4 = -432						; size = 1
_tex$5 = -416						; size = 4
$T6 = -400						; size = 16
tv556 = -346						; size = 1
tv546 = -345						; size = 1
tv536 = -344						; size = 1
tv526 = -343						; size = 1
tv516 = -342						; size = 1
tv506 = -341						; size = 1
tv496 = -340						; size = 1
tv486 = -339						; size = 1
tv476 = -338						; size = 1
tv466 = -337						; size = 1
tv456 = -336						; size = 1
tv446 = -335						; size = 1
tv436 = -334						; size = 1
tv426 = -333						; size = 1
tv416 = -332						; size = 1
tv406 = -331						; size = 1
tv396 = -330						; size = 1
tv386 = -329						; size = 1
_this$ = -328						; size = 4
tv346 = -324						; size = 4
$T7 = -320						; size = 4
_i$8 = -316						; size = 4
tv553 = -312						; size = 4
tv543 = -308						; size = 4
tv533 = -304						; size = 4
tv523 = -300						; size = 4
tv513 = -296						; size = 4
tv503 = -292						; size = 4
tv493 = -288						; size = 4
tv483 = -284						; size = 4
$T9 = -280						; size = 4
tv473 = -276						; size = 4
$T10 = -272						; size = 4
tv463 = -268						; size = 4
tv453 = -264						; size = 4
tv443 = -260						; size = 4
tv433 = -256						; size = 4
tv423 = -252						; size = 4
tv413 = -248						; size = 4
tv403 = -244						; size = 4
tv393 = -240						; size = 4
tv383 = -236						; size = 4
tv75 = -232						; size = 4
tv87 = -228						; size = 4
tv90 = -224						; size = 4
tv81 = -220						; size = 4
tv148 = -216						; size = 4
$T11 = -212						; size = 4
tv159 = -208						; size = 4
tv95 = -204						; size = 4
tv175 = -200						; size = 4
$T12 = -196						; size = 4
tv186 = -192						; size = 4
tv166 = -188						; size = 4
tv201 = -184						; size = 4
tv226 = -180						; size = 4
tv202 = -176						; size = 4
$T13 = -172						; size = 4
tv241 = -168						; size = 4
tv247 = -164						; size = 4
tv255 = -160						; size = 4
tv287 = -156						; size = 4
tv288 = -152						; size = 4
tv284 = -148						; size = 4
tv264 = -144						; size = 4
tv270 = -140						; size = 4
tv290 = -136						; size = 4
tv344 = -132						; size = 4
tv307 = -128						; size = 4
tv74 = -124						; size = 4
tv80 = -120						; size = 4
tv93 = -116						; size = 4
$T14 = -112						; size = 4
$T15 = -108						; size = 4
tv225 = -104						; size = 4
$T16 = -100						; size = 4
tv364 = -96						; size = 4
$T17 = -92						; size = 4
tv253 = -88						; size = 4
tv251 = -84						; size = 4
tv370 = -80						; size = 4
tv263 = -76						; size = 4
_texrect$ = -72						; size = 4
$T18 = -68						; size = 4
tv273 = -64						; size = 4
tv289 = -60						; size = 4
tv379 = -56						; size = 4
tv306 = -52						; size = 4
tv94 = -48						; size = 8
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
_x$ = 8							; size = 4
_y$ = 12						; size = 4
_imgs$ = 16						; size = 4
??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z PROC ; Player::Player
; _this$ = ecx

; 4    : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 30 fe ff
	ff		 add	 esp, -464		; fffffe30H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 8d b8 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00045	c7 85 30 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004f	c7 85 34 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z
  00059	c7 85 38 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z ; Player::Player
  00063	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00069	89 85 7c ff ff
	ff		 mov	 DWORD PTR tv344[ebp], eax
  0006f	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR tv344[ebp]
  00075	c1 e9 03	 shr	 ecx, 3
  00078	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0007e	89 8d bc fe ff
	ff		 mov	 DWORD PTR tv346[ebp], ecx
  00084	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR tv346[ebp]
  0008a	c7 02 f1 f1 f8
	f2		 mov	 DWORD PTR [edx], -218566159 ; f2f8f1f1H
  00090	83 85 bc fe ff
	ff 04		 add	 DWORD PTR tv346[ebp], 4
  00097	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv346[ebp]
  0009d	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  000a3	83 85 bc fe ff
	ff 04		 add	 DWORD PTR tv346[ebp], 4
  000aa	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv346[ebp]
  000b0	c7 01 f8 f8 f3
	f3		 mov	 DWORD PTR [ecx], -202114824 ; f3f3f8f8H
  000b6	83 85 bc fe ff
	ff 04		 add	 DWORD PTR tv346[ebp], 4
  000bd	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  000c2	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv346[ebp]
  000c8	66 89 10	 mov	 WORD PTR [eax], dx
  000cb	8d 8d 40 fe ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  000d1	c1 e9 03	 shr	 ecx, 3
  000d4	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0
  000db	b9 00 00 00 00	 mov	 ecx, OFFSET __4D0513DE_Player@cpp
  000e0	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000e5	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  000eb	e8 00 00 00 00	 call	 ??0Character@@QAE@XZ

; 5    : 	_x = x;

  000f0	f3 0f 2a 43 08	 cvtsi2ss xmm0, DWORD PTR _x$[ebx]
  000f5	f3 0f 11 45 84	 movss	 DWORD PTR tv74[ebp], xmm0
  000fa	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00100	89 55 80	 mov	 DWORD PTR tv307[ebp], edx
  00103	8b 45 80	 mov	 eax, DWORD PTR tv307[ebp]
  00106	89 85 c8 fe ff
	ff		 mov	 DWORD PTR tv553[ebp], eax
  0010c	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv553[ebp]
  00112	c1 e9 03	 shr	 ecx, 3
  00115	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0011b	88 95 a6 fe ff
	ff		 mov	 BYTE PTR tv556[ebp], dl
  00121	80 bd a6 fe ff
	ff 00		 cmp	 BYTE PTR tv556[ebp], 0
  00128	74 21		 je	 SHORT $LN40@Player
  0012a	8a 85 c8 fe ff
	ff		 mov	 al, BYTE PTR tv553[ebp]
  00130	24 07		 and	 al, 7
  00132	04 03		 add	 al, 3
  00134	3a 85 a6 fe ff
	ff		 cmp	 al, BYTE PTR tv556[ebp]
  0013a	7c 0f		 jl	 SHORT $LN40@Player
  0013c	8b 8d c8 fe ff
	ff		 mov	 ecx, DWORD PTR tv553[ebp]
  00142	51		 push	 ecx
  00143	e8 00 00 00 00	 call	 ___asan_report_store4
  00148	83 c4 04	 add	 esp, 4
$LN40@Player:
  0014b	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00151	f3 0f 10 45 84	 movss	 xmm0, DWORD PTR tv74[ebp]
  00156	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 6    : 	_y = y;

  0015a	f3 0f 2a 43 0c	 cvtsi2ss xmm0, DWORD PTR _y$[ebx]
  0015f	f3 0f 11 45 88	 movss	 DWORD PTR tv80[ebp], xmm0
  00164	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0016a	83 c0 04	 add	 eax, 4
  0016d	89 85 18 ff ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  00173	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  00179	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv543[ebp], ecx
  0017f	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv543[ebp]
  00185	c1 ea 03	 shr	 edx, 3
  00188	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0018e	88 85 a7 fe ff
	ff		 mov	 BYTE PTR tv546[ebp], al
  00194	80 bd a7 fe ff
	ff 00		 cmp	 BYTE PTR tv546[ebp], 0
  0019b	74 23		 je	 SHORT $LN39@Player
  0019d	8a 8d cc fe ff
	ff		 mov	 cl, BYTE PTR tv543[ebp]
  001a3	80 e1 07	 and	 cl, 7
  001a6	80 c1 03	 add	 cl, 3
  001a9	3a 8d a7 fe ff
	ff		 cmp	 cl, BYTE PTR tv546[ebp]
  001af	7c 0f		 jl	 SHORT $LN39@Player
  001b1	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv543[ebp]
  001b7	52		 push	 edx
  001b8	e8 00 00 00 00	 call	 ___asan_report_store4
  001bd	83 c4 04	 add	 esp, 4
$LN39@Player:
  001c0	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv75[ebp]
  001c6	f3 0f 10 45 88	 movss	 xmm0, DWORD PTR tv80[ebp]
  001cb	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 7    : 	_size = imgs->at(0)->getSize();

  001cf	6a 00		 push	 0
  001d1	8b 4b 10	 mov	 ecx, DWORD PTR _imgs$[ebx]
  001d4	e8 00 00 00 00	 call	 ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
  001d9	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  001df	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv87[ebp]
  001e5	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv533[ebp], ecx
  001eb	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv533[ebp]
  001f1	c1 ea 03	 shr	 edx, 3
  001f4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001fa	88 85 a8 fe ff
	ff		 mov	 BYTE PTR tv536[ebp], al
  00200	80 bd a8 fe ff
	ff 00		 cmp	 BYTE PTR tv536[ebp], 0
  00207	74 23		 je	 SHORT $LN38@Player
  00209	8a 8d d0 fe ff
	ff		 mov	 cl, BYTE PTR tv533[ebp]
  0020f	80 e1 07	 and	 cl, 7
  00212	80 c1 03	 add	 cl, 3
  00215	3a 8d a8 fe ff
	ff		 cmp	 cl, BYTE PTR tv536[ebp]
  0021b	7c 0f		 jl	 SHORT $LN38@Player
  0021d	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv533[ebp]
  00223	52		 push	 edx
  00224	e8 00 00 00 00	 call	 ___asan_report_load4
  00229	83 c4 04	 add	 esp, 4
$LN38@Player:
  0022c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv87[ebp]
  00232	8b 08		 mov	 ecx, DWORD PTR [eax]
  00234	89 4d 8c	 mov	 DWORD PTR tv93[ebp], ecx
  00237	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0023d	52		 push	 edx
  0023e	8b 4d 8c	 mov	 ecx, DWORD PTR tv93[ebp]
  00241	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?getSize@Image@sf@@QBE?AV?$Vector2@I@2@XZ
  00247	89 85 20 ff ff
	ff		 mov	 DWORD PTR tv90[ebp], eax
  0024d	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR tv90[ebp]
  00253	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv523[ebp], eax
  00259	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv523[ebp]
  0025f	c1 e9 03	 shr	 ecx, 3
  00262	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00268	88 95 a9 fe ff
	ff		 mov	 BYTE PTR tv526[ebp], dl
  0026e	80 bd a9 fe ff
	ff 00		 cmp	 BYTE PTR tv526[ebp], 0
  00275	74 21		 je	 SHORT $LN37@Player
  00277	8a 85 d4 fe ff
	ff		 mov	 al, BYTE PTR tv523[ebp]
  0027d	24 07		 and	 al, 7
  0027f	04 07		 add	 al, 7
  00281	3a 85 a9 fe ff
	ff		 cmp	 al, BYTE PTR tv526[ebp]
  00287	7c 0f		 jl	 SHORT $LN37@Player
  00289	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv523[ebp]
  0028f	51		 push	 ecx
  00290	e8 00 00 00 00	 call	 ___asan_report_load8
  00295	83 c4 04	 add	 esp, 4
$LN37@Player:
  00298	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv90[ebp]
  0029e	8b 02		 mov	 eax, DWORD PTR [edx]
  002a0	8b 4a 04	 mov	 ecx, DWORD PTR [edx+4]
  002a3	89 45 d0	 mov	 DWORD PTR tv94[ebp], eax
  002a6	89 4d d4	 mov	 DWORD PTR tv94[ebp+4], ecx
  002a9	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  002af	83 c2 20	 add	 edx, 32			; 00000020H
  002b2	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv81[ebp], edx
  002b8	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv81[ebp]
  002be	89 85 d8 fe ff
	ff		 mov	 DWORD PTR tv513[ebp], eax
  002c4	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv513[ebp]
  002ca	c1 e9 03	 shr	 ecx, 3
  002cd	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  002d3	88 95 aa fe ff
	ff		 mov	 BYTE PTR tv516[ebp], dl
  002d9	80 bd aa fe ff
	ff 00		 cmp	 BYTE PTR tv516[ebp], 0
  002e0	74 21		 je	 SHORT $LN36@Player
  002e2	8a 85 d8 fe ff
	ff		 mov	 al, BYTE PTR tv513[ebp]
  002e8	24 07		 and	 al, 7
  002ea	04 07		 add	 al, 7
  002ec	3a 85 aa fe ff
	ff		 cmp	 al, BYTE PTR tv516[ebp]
  002f2	7c 0f		 jl	 SHORT $LN36@Player
  002f4	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv513[ebp]
  002fa	51		 push	 ecx
  002fb	e8 00 00 00 00	 call	 ___asan_report_store8
  00300	83 c4 04	 add	 esp, 4
$LN36@Player:
  00303	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv81[ebp]
  00309	8b 45 d0	 mov	 eax, DWORD PTR tv94[ebp]
  0030c	8b 4d d4	 mov	 ecx, DWORD PTR tv94[ebp+4]
  0030f	89 02		 mov	 DWORD PTR [edx], eax
  00311	89 4a 04	 mov	 DWORD PTR [edx+4], ecx
  00314	8d 95 40 fe ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  0031a	c1 ea 03	 shr	 edx, 3
  0031d	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 8    : 	_rect = new sf::IntRect(x, y,_size.x, _size.y);

  00324	6a 10		 push	 16			; 00000010H
  00326	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0032b	83 c4 04	 add	 esp, 4
  0032e	89 85 2c ff ff
	ff		 mov	 DWORD PTR $T11[ebp], eax
  00334	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0033b	83 bd 2c ff ff
	ff 00		 cmp	 DWORD PTR $T11[ebp], 0
  00342	0f 84 8a 00 00
	00		 je	 $LN6@Player
  00348	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0034e	83 c0 24	 add	 eax, 36			; 00000024H
  00351	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv148[ebp], eax
  00357	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv148[ebp]
  0035d	89 8d dc fe ff
	ff		 mov	 DWORD PTR tv503[ebp], ecx
  00363	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv503[ebp]
  00369	c1 ea 03	 shr	 edx, 3
  0036c	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00372	88 85 ab fe ff
	ff		 mov	 BYTE PTR tv506[ebp], al
  00378	80 bd ab fe ff
	ff 00		 cmp	 BYTE PTR tv506[ebp], 0
  0037f	74 23		 je	 SHORT $LN35@Player
  00381	8a 8d dc fe ff
	ff		 mov	 cl, BYTE PTR tv503[ebp]
  00387	80 e1 07	 and	 cl, 7
  0038a	80 c1 03	 add	 cl, 3
  0038d	3a 8d ab fe ff
	ff		 cmp	 cl, BYTE PTR tv506[ebp]
  00393	7c 0f		 jl	 SHORT $LN35@Player
  00395	8b 95 dc fe ff
	ff		 mov	 edx, DWORD PTR tv503[ebp]
  0039b	52		 push	 edx
  0039c	e8 00 00 00 00	 call	 ___asan_report_load4
  003a1	83 c4 04	 add	 esp, 4
$LN35@Player:
  003a4	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv148[ebp]
  003aa	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ac	51		 push	 ecx
  003ad	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  003b3	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  003b6	50		 push	 eax
  003b7	8b 4b 0c	 mov	 ecx, DWORD PTR _y$[ebx]
  003ba	51		 push	 ecx
  003bb	8b 53 08	 mov	 edx, DWORD PTR _x$[ebx]
  003be	52		 push	 edx
  003bf	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR $T11[ebp]
  003c5	e8 00 00 00 00	 call	 ??0?$Rect@H@sf@@QAE@HHHH@Z ; sf::Rect<int>::Rect<int>
  003ca	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv159[ebp], eax
  003d0	eb 0a		 jmp	 SHORT $LN7@Player
$LN6@Player:
  003d2	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv159[ebp], 0
$LN7@Player:
  003dc	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv159[ebp]
  003e2	89 45 90	 mov	 DWORD PTR $T14[ebp], eax
  003e5	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ec	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003f2	83 c1 08	 add	 ecx, 8
  003f5	89 8d 34 ff ff
	ff		 mov	 DWORD PTR tv95[ebp], ecx
  003fb	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv95[ebp]
  00401	89 95 e0 fe ff
	ff		 mov	 DWORD PTR tv493[ebp], edx
  00407	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv493[ebp]
  0040d	c1 e8 03	 shr	 eax, 3
  00410	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00416	88 8d ac fe ff
	ff		 mov	 BYTE PTR tv496[ebp], cl
  0041c	80 bd ac fe ff
	ff 00		 cmp	 BYTE PTR tv496[ebp], 0
  00423	74 23		 je	 SHORT $LN34@Player
  00425	8a 95 e0 fe ff
	ff		 mov	 dl, BYTE PTR tv493[ebp]
  0042b	80 e2 07	 and	 dl, 7
  0042e	80 c2 03	 add	 dl, 3
  00431	3a 95 ac fe ff
	ff		 cmp	 dl, BYTE PTR tv496[ebp]
  00437	7c 0f		 jl	 SHORT $LN34@Player
  00439	8b 85 e0 fe ff
	ff		 mov	 eax, DWORD PTR tv493[ebp]
  0043f	50		 push	 eax
  00440	e8 00 00 00 00	 call	 ___asan_report_store4
  00445	83 c4 04	 add	 esp, 4
$LN34@Player:
  00448	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv95[ebp]
  0044e	8b 55 90	 mov	 edx, DWORD PTR $T14[ebp]
  00451	89 11		 mov	 DWORD PTR [ecx], edx

; 9    : 	sf::IntRect* texrect = new sf::IntRect(0, 0, _size.x, _size.y);

  00453	6a 10		 push	 16			; 00000010H
  00455	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  0045a	83 c4 04	 add	 esp, 4
  0045d	89 85 3c ff ff
	ff		 mov	 DWORD PTR $T12[ebp], eax
  00463	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 1
  0046a	83 bd 3c ff ff
	ff 00		 cmp	 DWORD PTR $T12[ebp], 0
  00471	0f 84 86 00 00
	00		 je	 $LN8@Player
  00477	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0047d	83 c0 24	 add	 eax, 36			; 00000024H
  00480	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv175[ebp], eax
  00486	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv175[ebp]
  0048c	89 8d e4 fe ff
	ff		 mov	 DWORD PTR tv483[ebp], ecx
  00492	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR tv483[ebp]
  00498	c1 ea 03	 shr	 edx, 3
  0049b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  004a1	88 85 ad fe ff
	ff		 mov	 BYTE PTR tv486[ebp], al
  004a7	80 bd ad fe ff
	ff 00		 cmp	 BYTE PTR tv486[ebp], 0
  004ae	74 23		 je	 SHORT $LN33@Player
  004b0	8a 8d e4 fe ff
	ff		 mov	 cl, BYTE PTR tv483[ebp]
  004b6	80 e1 07	 and	 cl, 7
  004b9	80 c1 03	 add	 cl, 3
  004bc	3a 8d ad fe ff
	ff		 cmp	 cl, BYTE PTR tv486[ebp]
  004c2	7c 0f		 jl	 SHORT $LN33@Player
  004c4	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR tv483[ebp]
  004ca	52		 push	 edx
  004cb	e8 00 00 00 00	 call	 ___asan_report_load4
  004d0	83 c4 04	 add	 esp, 4
$LN33@Player:
  004d3	8b 85 38 ff ff
	ff		 mov	 eax, DWORD PTR tv175[ebp]
  004d9	8b 08		 mov	 ecx, DWORD PTR [eax]
  004db	51		 push	 ecx
  004dc	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  004e2	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  004e5	50		 push	 eax
  004e6	6a 00		 push	 0
  004e8	6a 00		 push	 0
  004ea	8b 8d 3c ff ff
	ff		 mov	 ecx, DWORD PTR $T12[ebp]
  004f0	e8 00 00 00 00	 call	 ??0?$Rect@H@sf@@QAE@HHHH@Z ; sf::Rect<int>::Rect<int>
  004f5	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], eax
  004fb	eb 0a		 jmp	 SHORT $LN9@Player
$LN8@Player:
  004fd	c7 85 40 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv186[ebp], 0
$LN9@Player:
  00507	8b 8d 40 ff ff
	ff		 mov	 ecx, DWORD PTR tv186[ebp]
  0050d	89 4d 94	 mov	 DWORD PTR $T15[ebp], ecx
  00510	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00517	8b 55 94	 mov	 edx, DWORD PTR $T15[ebp]
  0051a	89 55 b8	 mov	 DWORD PTR _texrect$[ebp], edx

; 10   : 	 _tex = new std::vector<sf::Texture*>;

  0051d	6a 10		 push	 16			; 00000010H
  0051f	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00524	83 c4 04	 add	 esp, 4
  00527	89 85 e8 fe ff
	ff		 mov	 DWORD PTR $T9[ebp], eax
  0052d	83 bd e8 fe ff
	ff 00		 cmp	 DWORD PTR $T9[ebp], 0
  00534	74 20		 je	 SHORT $LN10@Player
  00536	6a 10		 push	 16			; 00000010H
  00538	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  0053e	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXI@Z
  00543	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR $T9[ebp]
  00549	e8 00 00 00 00	 call	 ??0?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::vector<sf::Texture *,std::allocator<sf::Texture *> >
  0054e	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv201[ebp], eax
  00554	eb 0a		 jmp	 SHORT $LN11@Player
$LN10@Player:
  00556	c7 85 48 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv201[ebp], 0
$LN11@Player:
  00560	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00566	83 c0 10	 add	 eax, 16			; 00000010H
  00569	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv166[ebp], eax
  0056f	8b 8d 44 ff ff
	ff		 mov	 ecx, DWORD PTR tv166[ebp]
  00575	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv473[ebp], ecx
  0057b	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv473[ebp]
  00581	c1 ea 03	 shr	 edx, 3
  00584	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0058a	88 85 ae fe ff
	ff		 mov	 BYTE PTR tv476[ebp], al
  00590	80 bd ae fe ff
	ff 00		 cmp	 BYTE PTR tv476[ebp], 0
  00597	74 23		 je	 SHORT $LN32@Player
  00599	8a 8d ec fe ff
	ff		 mov	 cl, BYTE PTR tv473[ebp]
  0059f	80 e1 07	 and	 cl, 7
  005a2	80 c1 03	 add	 cl, 3
  005a5	3a 8d ae fe ff
	ff		 cmp	 cl, BYTE PTR tv476[ebp]
  005ab	7c 0f		 jl	 SHORT $LN32@Player
  005ad	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv473[ebp]
  005b3	52		 push	 edx
  005b4	e8 00 00 00 00	 call	 ___asan_report_store4
  005b9	83 c4 04	 add	 esp, 4
$LN32@Player:
  005bc	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv166[ebp]
  005c2	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv201[ebp]
  005c8	89 08		 mov	 DWORD PTR [eax], ecx
  005ca	8d 95 50 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  005d0	c1 ea 03	 shr	 edx, 3
  005d3	c6 82 00 00 00
	30 01		 mov	 BYTE PTR [edx+805306368], 1

; 11   : 	_sprite = new std::vector <sf::Sprite*>(4);

  005da	6a 10		 push	 16			; 00000010H
  005dc	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  005e1	83 c4 04	 add	 esp, 4
  005e4	89 85 f0 fe ff
	ff		 mov	 DWORD PTR $T10[ebp], eax
  005ea	c7 45 fc 02 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 2
  005f1	83 bd f0 fe ff
	ff 00		 cmp	 DWORD PTR $T10[ebp], 0
  005f8	74 34		 je	 SHORT $LN12@Player
  005fa	6a 10		 push	 16			; 00000010H
  005fc	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  00602	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z
  00607	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  0060d	e8 00 00 00 00	 call	 ??0?$allocator@PAVSprite@sf@@@std@@QAE@XZ ; std::allocator<sf::Sprite *>::allocator<sf::Sprite *>
  00612	89 45 98	 mov	 DWORD PTR tv225[ebp], eax
  00615	8b 45 98	 mov	 eax, DWORD PTR tv225[ebp]
  00618	50		 push	 eax
  00619	6a 04		 push	 4
  0061b	8b 8d f0 fe ff
	ff		 mov	 ecx, DWORD PTR $T10[ebp]
  00621	e8 00 00 00 00	 call	 ??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::vector<sf::Sprite *,std::allocator<sf::Sprite *> >
  00626	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  0062c	eb 0a		 jmp	 SHORT $LN13@Player
$LN12@Player:
  0062e	c7 85 4c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv226[ebp], 0
$LN13@Player:
  00638	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv226[ebp]
  0063e	89 4d 9c	 mov	 DWORD PTR $T16[ebp], ecx
  00641	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00648	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  0064e	83 c2 0c	 add	 edx, 12			; 0000000cH
  00651	89 95 50 ff ff
	ff		 mov	 DWORD PTR tv202[ebp], edx
  00657	8b 85 50 ff ff
	ff		 mov	 eax, DWORD PTR tv202[ebp]
  0065d	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv463[ebp], eax
  00663	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv463[ebp]
  00669	c1 e9 03	 shr	 ecx, 3
  0066c	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00672	88 95 af fe ff
	ff		 mov	 BYTE PTR tv466[ebp], dl
  00678	80 bd af fe ff
	ff 00		 cmp	 BYTE PTR tv466[ebp], 0
  0067f	74 21		 je	 SHORT $LN31@Player
  00681	8a 85 f4 fe ff
	ff		 mov	 al, BYTE PTR tv463[ebp]
  00687	24 07		 and	 al, 7
  00689	04 03		 add	 al, 3
  0068b	3a 85 af fe ff
	ff		 cmp	 al, BYTE PTR tv466[ebp]
  00691	7c 0f		 jl	 SHORT $LN31@Player
  00693	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv463[ebp]
  00699	51		 push	 ecx
  0069a	e8 00 00 00 00	 call	 ___asan_report_store4
  0069f	83 c4 04	 add	 esp, 4
$LN31@Player:
  006a2	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv202[ebp]
  006a8	8b 45 9c	 mov	 eax, DWORD PTR $T16[ebp]
  006ab	89 02		 mov	 DWORD PTR [edx], eax
  006ad	8d 8d 50 fe ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  006b3	c1 e9 03	 shr	 ecx, 3
  006b6	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 12   : 	for (uint32_t i = 0; i < imgs->size(); i++) {

  006bd	c7 85 c4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR _i$8[ebp], 0
  006c7	eb 0f		 jmp	 SHORT $LN4@Player
$LN2@Player:
  006c9	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR _i$8[ebp]
  006cf	83 c2 01	 add	 edx, 1
  006d2	89 95 c4 fe ff
	ff		 mov	 DWORD PTR _i$8[ebp], edx
$LN4@Player:
  006d8	8b 4b 10	 mov	 ecx, DWORD PTR _imgs$[ebx]
  006db	e8 00 00 00 00	 call	 ?size@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Image *,std::allocator<sf::Image *> >::size
  006e0	39 85 c4 fe ff
	ff		 cmp	 DWORD PTR _i$8[ebp], eax
  006e6	0f 83 27 04 00
	00		 jae	 $LN3@Player
  006ec	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _tex$5[ebp]
  006f2	c1 e8 03	 shr	 eax, 3
  006f5	c6 80 00 00 00
	30 04		 mov	 BYTE PTR [eax+805306368], 4

; 13   : 		sf::Texture *tex = new sf::Texture();

  006fc	6a 28		 push	 40			; 00000028H
  006fe	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00703	83 c4 04	 add	 esp, 4
  00706	89 85 54 ff ff
	ff		 mov	 DWORD PTR $T13[ebp], eax
  0070c	c7 45 fc 03 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 3
  00713	83 bd 54 ff ff
	ff 00		 cmp	 DWORD PTR $T13[ebp], 0
  0071a	74 14		 je	 SHORT $LN14@Player
  0071c	8b 8d 54 ff ff
	ff		 mov	 ecx, DWORD PTR $T13[ebp]
  00722	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Texture@sf@@QAE@XZ
  00728	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  0072e	eb 0a		 jmp	 SHORT $LN15@Player
$LN14@Player:
  00730	c7 85 58 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv241[ebp], 0
$LN15@Player:
  0073a	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00740	c1 e9 03	 shr	 ecx, 3
  00743	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00749	89 4d a0	 mov	 DWORD PTR tv364[ebp], ecx
  0074c	6a 02		 push	 2
  0074e	8b 55 a0	 mov	 edx, DWORD PTR tv364[ebp]
  00751	52		 push	 edx
  00752	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00757	83 c4 08	 add	 esp, 8
  0075a	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv241[ebp]
  00760	89 45 a4	 mov	 DWORD PTR $T17[ebp], eax
  00763	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0076a	8d 8d 60 fe ff
	ff		 lea	 ecx, DWORD PTR _tex$5[ebp]
  00770	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv453[ebp], ecx
  00776	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv453[ebp]
  0077c	c1 ea 03	 shr	 edx, 3
  0077f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00785	88 85 b0 fe ff
	ff		 mov	 BYTE PTR tv456[ebp], al
  0078b	80 bd b0 fe ff
	ff 00		 cmp	 BYTE PTR tv456[ebp], 0
  00792	74 23		 je	 SHORT $LN30@Player
  00794	8a 8d f8 fe ff
	ff		 mov	 cl, BYTE PTR tv453[ebp]
  0079a	80 e1 07	 and	 cl, 7
  0079d	80 c1 03	 add	 cl, 3
  007a0	3a 8d b0 fe ff
	ff		 cmp	 cl, BYTE PTR tv456[ebp]
  007a6	7c 0f		 jl	 SHORT $LN30@Player
  007a8	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv453[ebp]
  007ae	52		 push	 edx
  007af	e8 00 00 00 00	 call	 ___asan_report_store4
  007b4	83 c4 04	 add	 esp, 4
$LN30@Player:
  007b7	8b 45 a4	 mov	 eax, DWORD PTR $T17[ebp]
  007ba	89 85 60 fe ff
	ff		 mov	 DWORD PTR _tex$5[ebp], eax

; 14   : 		tex->loadFromImage(*imgs->at(i));

  007c0	8d 8d 70 fe ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  007c6	e8 00 00 00 00	 call	 ??0?$Rect@H@sf@@QAE@XZ	; sf::Rect<int>::Rect<int>
  007cb	89 45 a8	 mov	 DWORD PTR tv253[ebp], eax
  007ce	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$8[ebp]
  007d4	51		 push	 ecx
  007d5	8b 4b 10	 mov	 ecx, DWORD PTR _imgs$[ebx]
  007d8	e8 00 00 00 00	 call	 ?at@?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@QAEAAPAVImage@sf@@I@Z ; std::vector<sf::Image *,std::allocator<sf::Image *> >::at
  007dd	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv247[ebp], eax
  007e3	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv247[ebp]
  007e9	89 95 fc fe ff
	ff		 mov	 DWORD PTR tv443[ebp], edx
  007ef	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv443[ebp]
  007f5	c1 e8 03	 shr	 eax, 3
  007f8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  007fe	88 8d b1 fe ff
	ff		 mov	 BYTE PTR tv446[ebp], cl
  00804	80 bd b1 fe ff
	ff 00		 cmp	 BYTE PTR tv446[ebp], 0
  0080b	74 23		 je	 SHORT $LN29@Player
  0080d	8a 95 fc fe ff
	ff		 mov	 dl, BYTE PTR tv443[ebp]
  00813	80 e2 07	 and	 dl, 7
  00816	80 c2 03	 add	 dl, 3
  00819	3a 95 b1 fe ff
	ff		 cmp	 dl, BYTE PTR tv446[ebp]
  0081f	7c 0f		 jl	 SHORT $LN29@Player
  00821	8b 85 fc fe ff
	ff		 mov	 eax, DWORD PTR tv443[ebp]
  00827	50		 push	 eax
  00828	e8 00 00 00 00	 call	 ___asan_report_load4
  0082d	83 c4 04	 add	 esp, 4
$LN29@Player:
  00830	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv247[ebp]
  00836	8b 11		 mov	 edx, DWORD PTR [ecx]
  00838	89 55 ac	 mov	 DWORD PTR tv251[ebp], edx
  0083b	8b 45 a8	 mov	 eax, DWORD PTR tv253[ebp]
  0083e	50		 push	 eax
  0083f	8b 4d ac	 mov	 ecx, DWORD PTR tv251[ebp]
  00842	51		 push	 ecx
  00843	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR _tex$5[ebp]
  00849	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?loadFromImage@Texture@sf@@QAE_NABVImage@2@ABV?$Rect@H@2@@Z
  0084f	8d 95 70 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00855	c1 ea 03	 shr	 edx, 3
  00858	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0085e	89 55 b0	 mov	 DWORD PTR tv370[ebp], edx
  00861	6a 02		 push	 2
  00863	8b 45 b0	 mov	 eax, DWORD PTR tv370[ebp]
  00866	50		 push	 eax
  00867	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0086c	83 c4 08	 add	 esp, 8

; 15   : 		tex->setSmooth(true);

  0086f	6a 01		 push	 1
  00871	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR _tex$5[ebp]
  00877	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setSmooth@Texture@sf@@QAEX_N@Z

; 16   : 		_tex->push_back(tex);

  0087d	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00883	83 c1 10	 add	 ecx, 16			; 00000010H
  00886	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv255[ebp], ecx
  0088c	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv255[ebp]
  00892	89 95 00 ff ff
	ff		 mov	 DWORD PTR tv433[ebp], edx
  00898	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv433[ebp]
  0089e	c1 e8 03	 shr	 eax, 3
  008a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  008a7	88 8d b2 fe ff
	ff		 mov	 BYTE PTR tv436[ebp], cl
  008ad	80 bd b2 fe ff
	ff 00		 cmp	 BYTE PTR tv436[ebp], 0
  008b4	74 23		 je	 SHORT $LN28@Player
  008b6	8a 95 00 ff ff
	ff		 mov	 dl, BYTE PTR tv433[ebp]
  008bc	80 e2 07	 and	 dl, 7
  008bf	80 c2 03	 add	 dl, 3
  008c2	3a 95 b2 fe ff
	ff		 cmp	 dl, BYTE PTR tv436[ebp]
  008c8	7c 0f		 jl	 SHORT $LN28@Player
  008ca	8b 85 00 ff ff
	ff		 mov	 eax, DWORD PTR tv433[ebp]
  008d0	50		 push	 eax
  008d1	e8 00 00 00 00	 call	 ___asan_report_load4
  008d6	83 c4 04	 add	 esp, 4
$LN28@Player:
  008d9	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv255[ebp]
  008df	8b 11		 mov	 edx, DWORD PTR [ecx]
  008e1	89 55 b4	 mov	 DWORD PTR tv263[ebp], edx
  008e4	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _tex$5[ebp]
  008ea	50		 push	 eax
  008eb	8b 4d b4	 mov	 ecx, DWORD PTR tv263[ebp]
  008ee	e8 00 00 00 00	 call	 ?push_back@?$vector@PAVTexture@sf@@V?$allocator@PAVTexture@sf@@@std@@@std@@QAEXABQAVTexture@sf@@@Z ; std::vector<sf::Texture *,std::allocator<sf::Texture *> >::push_back

; 17   : 		_sprite->at(i) = new sf::Sprite(*tex, *texrect);

  008f3	68 10 01 00 00	 push	 272			; 00000110H
  008f8	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  008fd	83 c4 04	 add	 esp, 4
  00900	89 85 c0 fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00906	c7 45 fc 04 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 4
  0090d	83 bd c0 fe ff
	ff 00		 cmp	 DWORD PTR $T7[ebp], 0
  00914	0f 84 f2 00 00
	00		 je	 $LN16@Player
  0091a	8b 4d b8	 mov	 ecx, DWORD PTR _texrect$[ebp]
  0091d	51		 push	 ecx
  0091e	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR _tex$5[ebp]
  00924	52		 push	 edx
  00925	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  0092b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0Sprite@sf@@QAE@ABVTexture@1@ABV?$Rect@H@1@@Z
  00931	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00937	89 85 64 ff ff
	ff		 mov	 DWORD PTR tv287[ebp], eax
  0093d	8b 8d 64 ff ff
	ff		 mov	 ecx, DWORD PTR tv287[ebp]
  00943	89 8d 04 ff ff
	ff		 mov	 DWORD PTR tv423[ebp], ecx
  00949	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv423[ebp]
  0094f	c1 ea 03	 shr	 edx, 3
  00952	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00958	88 85 b3 fe ff
	ff		 mov	 BYTE PTR tv426[ebp], al
  0095e	80 bd b3 fe ff
	ff 00		 cmp	 BYTE PTR tv426[ebp], 0
  00965	74 23		 je	 SHORT $LN27@Player
  00967	8a 8d 04 ff ff
	ff		 mov	 cl, BYTE PTR tv423[ebp]
  0096d	80 e1 07	 and	 cl, 7
  00970	80 c1 03	 add	 cl, 3
  00973	3a 8d b3 fe ff
	ff		 cmp	 cl, BYTE PTR tv426[ebp]
  00979	7c 0f		 jl	 SHORT $LN27@Player
  0097b	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv423[ebp]
  00981	52		 push	 edx
  00982	e8 00 00 00 00	 call	 ___asan_report_store4
  00987	83 c4 04	 add	 esp, 4
$LN27@Player:
  0098a	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv287[ebp]
  00990	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_SSprite@sf@@6BDrawable@1@@
  00996	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR $T7[ebp]
  0099c	83 c1 04	 add	 ecx, 4
  0099f	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv288[ebp], ecx
  009a5	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv288[ebp]
  009ab	89 95 08 ff ff
	ff		 mov	 DWORD PTR tv413[ebp], edx
  009b1	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv413[ebp]
  009b7	c1 e8 03	 shr	 eax, 3
  009ba	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  009c0	88 8d b4 fe ff
	ff		 mov	 BYTE PTR tv416[ebp], cl
  009c6	80 bd b4 fe ff
	ff 00		 cmp	 BYTE PTR tv416[ebp], 0
  009cd	74 23		 je	 SHORT $LN26@Player
  009cf	8a 95 08 ff ff
	ff		 mov	 dl, BYTE PTR tv413[ebp]
  009d5	80 e2 07	 and	 dl, 7
  009d8	80 c2 03	 add	 dl, 3
  009db	3a 95 b4 fe ff
	ff		 cmp	 dl, BYTE PTR tv416[ebp]
  009e1	7c 0f		 jl	 SHORT $LN26@Player
  009e3	8b 85 08 ff ff
	ff		 mov	 eax, DWORD PTR tv413[ebp]
  009e9	50		 push	 eax
  009ea	e8 00 00 00 00	 call	 ___asan_report_store4
  009ef	83 c4 04	 add	 esp, 4
$LN26@Player:
  009f2	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR tv288[ebp]
  009f8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_SSprite@sf@@6BTransformable@1@@
  009fe	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR $T7[ebp]
  00a04	89 95 6c ff ff
	ff		 mov	 DWORD PTR tv284[ebp], edx
  00a0a	eb 0a		 jmp	 SHORT $LN17@Player
$LN16@Player:
  00a0c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv284[ebp], 0
$LN17@Player:
  00a16	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR tv284[ebp]
  00a1c	89 45 bc	 mov	 DWORD PTR $T18[ebp], eax
  00a1f	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00a26	8b 4d bc	 mov	 ecx, DWORD PTR $T18[ebp]
  00a29	89 4d c4	 mov	 DWORD PTR tv289[ebp], ecx
  00a2c	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00a32	83 c2 0c	 add	 edx, 12			; 0000000cH
  00a35	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv264[ebp], edx
  00a3b	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv264[ebp]
  00a41	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv403[ebp], eax
  00a47	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv403[ebp]
  00a4d	c1 e9 03	 shr	 ecx, 3
  00a50	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00a56	88 95 b5 fe ff
	ff		 mov	 BYTE PTR tv406[ebp], dl
  00a5c	80 bd b5 fe ff
	ff 00		 cmp	 BYTE PTR tv406[ebp], 0
  00a63	74 21		 je	 SHORT $LN25@Player
  00a65	8a 85 0c ff ff
	ff		 mov	 al, BYTE PTR tv403[ebp]
  00a6b	24 07		 and	 al, 7
  00a6d	04 03		 add	 al, 3
  00a6f	3a 85 b5 fe ff
	ff		 cmp	 al, BYTE PTR tv406[ebp]
  00a75	7c 0f		 jl	 SHORT $LN25@Player
  00a77	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv403[ebp]
  00a7d	51		 push	 ecx
  00a7e	e8 00 00 00 00	 call	 ___asan_report_load4
  00a83	83 c4 04	 add	 esp, 4
$LN25@Player:
  00a86	8b 95 70 ff ff
	ff		 mov	 edx, DWORD PTR tv264[ebp]
  00a8c	8b 02		 mov	 eax, DWORD PTR [edx]
  00a8e	89 45 c0	 mov	 DWORD PTR tv273[ebp], eax
  00a91	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR _i$8[ebp]
  00a97	51		 push	 ecx
  00a98	8b 4d c0	 mov	 ecx, DWORD PTR tv273[ebp]
  00a9b	e8 00 00 00 00	 call	 ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
  00aa0	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv270[ebp], eax
  00aa6	8b 95 74 ff ff
	ff		 mov	 edx, DWORD PTR tv270[ebp]
  00aac	89 95 10 ff ff
	ff		 mov	 DWORD PTR tv393[ebp], edx
  00ab2	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv393[ebp]
  00ab8	c1 e8 03	 shr	 eax, 3
  00abb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00ac1	88 8d b6 fe ff
	ff		 mov	 BYTE PTR tv396[ebp], cl
  00ac7	80 bd b6 fe ff
	ff 00		 cmp	 BYTE PTR tv396[ebp], 0
  00ace	74 23		 je	 SHORT $LN24@Player
  00ad0	8a 95 10 ff ff
	ff		 mov	 dl, BYTE PTR tv393[ebp]
  00ad6	80 e2 07	 and	 dl, 7
  00ad9	80 c2 03	 add	 dl, 3
  00adc	3a 95 b6 fe ff
	ff		 cmp	 dl, BYTE PTR tv396[ebp]
  00ae2	7c 0f		 jl	 SHORT $LN24@Player
  00ae4	8b 85 10 ff ff
	ff		 mov	 eax, DWORD PTR tv393[ebp]
  00aea	50		 push	 eax
  00aeb	e8 00 00 00 00	 call	 ___asan_report_store4
  00af0	83 c4 04	 add	 esp, 4
$LN24@Player:
  00af3	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv270[ebp]
  00af9	8b 55 c4	 mov	 edx, DWORD PTR tv289[ebp]
  00afc	89 11		 mov	 DWORD PTR [ecx], edx

; 18   : 	}

  00afe	8d 85 60 fe ff
	ff		 lea	 eax, DWORD PTR _tex$5[ebp]
  00b04	c1 e8 03	 shr	 eax, 3
  00b07	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  00b0e	e9 b6 fb ff ff	 jmp	 $LN2@Player
$LN3@Player:

; 19   : 	_maxX = 0;

  00b13	8b 8d b8 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00b19	83 c1 18	 add	 ecx, 24			; 00000018H
  00b1c	89 8d 78 ff ff
	ff		 mov	 DWORD PTR tv290[ebp], ecx
  00b22	8b 95 78 ff ff
	ff		 mov	 edx, DWORD PTR tv290[ebp]
  00b28	89 95 14 ff ff
	ff		 mov	 DWORD PTR tv383[ebp], edx
  00b2e	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv383[ebp]
  00b34	c1 e8 03	 shr	 eax, 3
  00b37	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00b3d	88 8d b7 fe ff
	ff		 mov	 BYTE PTR tv386[ebp], cl
  00b43	80 bd b7 fe ff
	ff 00		 cmp	 BYTE PTR tv386[ebp], 0
  00b4a	74 23		 je	 SHORT $LN23@Player
  00b4c	8a 95 14 ff ff
	ff		 mov	 dl, BYTE PTR tv383[ebp]
  00b52	80 e2 07	 and	 dl, 7
  00b55	80 c2 03	 add	 dl, 3
  00b58	3a 95 b7 fe ff
	ff		 cmp	 dl, BYTE PTR tv386[ebp]
  00b5e	7c 0f		 jl	 SHORT $LN23@Player
  00b60	8b 85 14 ff ff
	ff		 mov	 eax, DWORD PTR tv383[ebp]
  00b66	50		 push	 eax
  00b67	e8 00 00 00 00	 call	 ___asan_report_store4
  00b6c	83 c4 04	 add	 esp, 4
$LN23@Player:
  00b6f	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR tv290[ebp]
  00b75	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 20   : 
; 21   : }

  00b7b	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00b81	89 55 cc	 mov	 DWORD PTR tv306[ebp], edx
  00b84	c7 85 30 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00b8e	8d 85 30 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00b94	c1 e8 03	 shr	 eax, 3
  00b97	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00b9c	89 45 c8	 mov	 DWORD PTR tv379[ebp], eax
  00b9f	6a 0e		 push	 14			; 0000000eH
  00ba1	8b 4d c8	 mov	 ecx, DWORD PTR tv379[ebp]
  00ba4	51		 push	 ecx
  00ba5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00baa	83 c4 08	 add	 esp, 8
  00bad	8b 45 cc	 mov	 eax, DWORD PTR tv306[ebp]
  00bb0	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00bb3	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00bba	59		 pop	 ecx
  00bbb	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00bbe	33 cd		 xor	 ecx, ebp
  00bc0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00bc5	8b e5		 mov	 esp, ebp
  00bc7	5d		 pop	 ebp
  00bc8	8b e3		 mov	 esp, ebx
  00bca	5b		 pop	 ebx
  00bcb	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$0:
  00000	6a 10		 push	 16			; 00000010H
  00002	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR $T11[ebp]
  00008	50		 push	 eax
  00009	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000e	83 c4 08	 add	 esp, 8
  00011	c3		 ret	 0
__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$1:
  00012	6a 10		 push	 16			; 00000010H
  00014	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR $T12[ebp]
  0001a	50		 push	 eax
  0001b	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00020	83 c4 08	 add	 esp, 8
  00023	c3		 ret	 0
__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$2:
  00024	6a 10		 push	 16			; 00000010H
  00026	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR $T10[ebp]
  0002c	50		 push	 eax
  0002d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00032	83 c4 08	 add	 esp, 8
  00035	c3		 ret	 0
__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$3:
  00036	6a 28		 push	 40			; 00000028H
  00038	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR $T13[ebp]
  0003e	50		 push	 eax
  0003f	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00044	83 c4 08	 add	 esp, 8
  00047	c3		 ret	 0
__unwindfunclet$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z$4:
  00048	68 10 01 00 00	 push	 272			; 00000110H
  0004d	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00059	83 c4 08	 add	 esp, 8
  0005c	c3		 ret	 0
  0005d	cc		 int	 3
  0005e	cc		 int	 3
  0005f	cc		 int	 3
  00060	cc		 int	 3
  00061	cc		 int	 3
__ehhandler$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z:
  00062	90		 npad	 1
  00063	90		 npad	 1
  00064	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00068	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0006b	8b 8a 28 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-472]
  00071	33 c8		 xor	 ecx, eax
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  0007b	33 c8		 xor	 ecx, eax
  0007d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00082	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z
  00087	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Player@@QAE@HHPAV?$vector@PAVImage@sf@@V?$allocator@PAVImage@sf@@@std@@@std@@@Z ENDP ; Player::Player
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_G?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAXI@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::~vector<sf::Sprite *,std::allocator<sf::Sprite *> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEPAXI@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEXI@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSprite@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSprite@sf@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSprite@sf@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSprite@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSprite@sf@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSprite@sf@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<sf::Sprite *> >::_Vector_val<std::_Simple_types<sf::Sprite *> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<sf::Sprite *> >::_Vector_val<std::_Simple_types<sf::Sprite *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@ABEABV?$allocator@PAVSprite@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@ABEABV?$allocator@PAVSprite@sf@@@2@XZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QBEABV?$allocator@PAVSprite@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@ABEABV?$allocator@PAVSprite@sf@@@2@XZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXPAPAVSprite@sf@@0@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@PAVSprite@sf@@@std@@QAEXQAPAVSprite@sf@@I@Z ; std::allocator<sf::Sprite *>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@PAVSprite@sf@@@std@@QAEPAPAVSprite@sf@@I@Z ; std::allocator<sf::Sprite *>::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 02	 shl	 eax, 2
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXI@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXPAPAVSprite@sf@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXPAPAVSprite@sf@@0@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@PAVSprite@sf@@@std@@@std@@YAXPAPAVSprite@sf@@QAPAV12@AAV?$allocator@PAVSprite@sf@@@0@@Z ; std::_Destroy_range<std::allocator<sf::Sprite *> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXPAPAVSprite@sf@@0@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Ufill@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEPAPAVSprite@sf@@PAPAV34@IU_Value_init_tag@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Dest$ = 8						; size = 4
__Count$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Ufill@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEPAPAVSprite@sf@@PAPAV34@IU_Value_init_tag@2@@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Ufill, COMDAT
; _this$ = ecx

; 1646 :     _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1647 :         // fill raw _Dest with _Count value-initialized objects, using allocator
; 1648 :         return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Uninitialized_value_construct_n@V?$allocator@PAVSprite@sf@@@std@@@std@@YAPAPAVSprite@sf@@PAPAV12@IAAV?$allocator@PAVSprite@sf@@@0@@Z ; std::_Uninitialized_value_construct_n<std::allocator<sf::Sprite *> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1649 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 0c 00	 ret	 12			; 0000000cH
?_Ufill@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEPAPAVSprite@sf@@PAPAV34@IU_Value_init_tag@2@@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@ABEABV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAIABV?$allocator@PAVSprite@sf@@@2@@Z ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QBEIXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S2$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::~vector<sf::Sprite *,std::allocator<sf::Sprite *> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::~vector<sf::Sprite *,std::allocator<sf::Sprite *> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEAAV?$allocator@PAVSprite@sf@@@2@XZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S2$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0PAVSprite@sf@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVSprite@sf@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><sf::Sprite *>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S2$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@XZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::~vector<sf::Sprite *,std::allocator<sf::Sprite *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -88					; size = 4
__asan_gen_1$ = -84					; size = 4
__asan_gen_2$ = -80					; size = 4
$T2 = -72						; size = 1
$T3 = -25						; size = 1
tv77 = -24						; size = 4
_this$ = -20						; size = 4
tv75 = -16						; size = 4
tv70 = -12						; size = 4
tv83 = -8						; size = 4
tv74 = -4						; size = 4
__Count$ = 8						; size = 4
__Al$ = 12						; size = 4
??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::vector<sf::Sprite *,std::allocator<sf::Sprite *> >, COMDAT
; _this$ = ecx

; 502  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001c	c7 45 a8 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00023	c7 45 ac 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z
  0002a	c7 45 b0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::vector<sf::Sprite *,std::allocator<sf::Sprite *> >
  00031	8d 45 a8	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00034	89 45 f0	 mov	 DWORD PTR tv75[ebp], eax
  00037	8b 4d f0	 mov	 ecx, DWORD PTR tv75[ebp]
  0003a	c1 e9 03	 shr	 ecx, 3
  0003d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00043	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00046	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00049	c7 02 f1 f1 01
	f3		 mov	 DWORD PTR [edx], -217976335 ; f301f1f1H
  0004f	83 45 e8 04	 add	 DWORD PTR tv77[ebp], 4
  00053	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00058	8b 4d e8	 mov	 ecx, DWORD PTR tv77[ebp]
  0005b	66 89 01	 mov	 WORD PTR [ecx], ax
  0005e	83 45 e8 02	 add	 DWORD PTR tv77[ebp], 2
  00062	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00065	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00068	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00072	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00075	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  00078	8b 4b 0c	 mov	 ecx, DWORD PTR __Al$[ebx]
  0007b	51		 push	 ecx
  0007c	0f b6 55 e7	 movzx	 edx, BYTE PTR $T3[ebp]
  00080	52		 push	 edx
  00081	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00084	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@PAVSprite@sf@@@std@@$$V@?$_Compressed_pair@V?$allocator@PAVSprite@sf@@@std@@V?$_Vector_val@U?$_Simple_types@PAVSprite@sf@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@PAVSprite@sf@@@1@@Z ; std::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1>::_Compressed_pair<std::allocator<sf::Sprite *>,std::_Vector_val<std::_Simple_types<sf::Sprite *> >,1><std::allocator<sf::Sprite *> const &>

; 503  :         _Construct_n_copies_of_ty(_Count, _Value_init_tag{});

  00089	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  0008c	50		 push	 eax
  0008d	8b 4b 08	 mov	 ecx, DWORD PTR __Count$[ebx]
  00090	51		 push	 ecx
  00091	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00094	e8 00 00 00 00	 call	 ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@AAEXIABU_Value_init_tag@1@@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
  00099	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  0009c	c1 ea 03	 shr	 edx, 3
  0009f	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 504  :     }

  000a6	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000a9	89 45 fc	 mov	 DWORD PTR tv74[ebp], eax
  000ac	c7 45 a8 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000b3	8d 4d a8	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000b6	c1 e9 03	 shr	 ecx, 3
  000b9	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  000bf	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  000c2	6a 07		 push	 7
  000c4	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  000c7	52		 push	 edx
  000c8	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000cd	83 c4 08	 add	 esp, 8
  000d0	8b 45 fc	 mov	 eax, DWORD PTR tv74[ebp]
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	8b e3		 mov	 esp, ebx
  000d8	5b		 pop	 ebx
  000d9	c2 08 00	 ret	 8
??0?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAE@IABV?$allocator@PAVSprite@sf@@@1@@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::vector<sf::Sprite *,std::allocator<sf::Sprite *> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAIABV?$allocator@PAVSprite@sf@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAIABV?$allocator@PAVSprite@sf@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@PAVSprite@sf@@@std@@@std@@SAIABV?$allocator@PAVSprite@sf@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<sf::Sprite *> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@PAVSprite@sf@@@std@@QAEPAPAVSprite@sf@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVSprite@sf@@@std@@QAEPAPAVSprite@sf@@I@Z PROC ; std::allocator<sf::Sprite *>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@PAVSprite@sf@@@std@@QAEPAPAVSprite@sf@@I@Z ENDP ; std::allocator<sf::Sprite *>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@PAVSprite@sf@@@std@@QAEXQAPAVSprite@sf@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVSprite@sf@@@std@@QAEXQAPAVSprite@sf@@I@Z PROC ; std::allocator<sf::Sprite *>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@PAVSprite@sf@@@std@@QAEXQAPAVSprite@sf@@I@Z ENDP ; std::allocator<sf::Sprite *>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@PAVSprite@sf@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVSprite@sf@@@std@@QAE@XZ PROC		; std::allocator<sf::Sprite *>::allocator<sf::Sprite *>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@PAVSprite@sf@@@std@@QAE@XZ ENDP		; std::allocator<sf::Sprite *>::allocator<sf::Sprite *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0Character@@QAE@XZ
_TEXT	SEGMENT
tv72 = -68						; size = 4
tv71 = -64						; size = 4
tv70 = -60						; size = 4
tv67 = -56						; size = 4
tv66 = -52						; size = 4
tv65 = -48						; size = 4
tv64 = -44						; size = 4
tv87 = -40						; size = 4
tv129 = -36						; size = 4
tv139 = -32						; size = 4
tv149 = -28						; size = 4
tv159 = -24						; size = 4
tv169 = -20						; size = 4
tv179 = -16						; size = 4
_this$ = -12						; size = 4
tv90 = -7						; size = 1
tv132 = -6						; size = 1
tv142 = -5						; size = 1
tv152 = -4						; size = 1
tv162 = -3						; size = 1
tv172 = -2						; size = 1
tv182 = -1						; size = 1
??0Character@@QAE@XZ PROC				; Character::Character, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0000c	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  0000f	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  00012	89 4d f0	 mov	 DWORD PTR tv179[ebp], ecx
  00015	8b 55 f0	 mov	 edx, DWORD PTR tv179[ebp]
  00018	c1 ea 03	 shr	 edx, 3
  0001b	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00021	88 45 ff	 mov	 BYTE PTR tv182[ebp], al
  00024	80 7d ff 00	 cmp	 BYTE PTR tv182[ebp], 0
  00028	74 1a		 je	 SHORT $LN9@Character
  0002a	8a 4d f0	 mov	 cl, BYTE PTR tv179[ebp]
  0002d	80 e1 07	 and	 cl, 7
  00030	80 c1 03	 add	 cl, 3
  00033	3a 4d ff	 cmp	 cl, BYTE PTR tv182[ebp]
  00036	7c 0c		 jl	 SHORT $LN9@Character
  00038	8b 55 f0	 mov	 edx, DWORD PTR tv179[ebp]
  0003b	52		 push	 edx
  0003c	e8 00 00 00 00	 call	 ___asan_report_store4
  00041	83 c4 04	 add	 esp, 4
$LN9@Character:
  00044	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00047	0f 57 c0	 xorps	 xmm0, xmm0
  0004a	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
  0004e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00051	83 c1 04	 add	 ecx, 4
  00054	89 4d d0	 mov	 DWORD PTR tv65[ebp], ecx
  00057	8b 55 d0	 mov	 edx, DWORD PTR tv65[ebp]
  0005a	89 55 ec	 mov	 DWORD PTR tv169[ebp], edx
  0005d	8b 45 ec	 mov	 eax, DWORD PTR tv169[ebp]
  00060	c1 e8 03	 shr	 eax, 3
  00063	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00069	88 4d fe	 mov	 BYTE PTR tv172[ebp], cl
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv172[ebp], 0
  00070	74 1a		 je	 SHORT $LN8@Character
  00072	8a 55 ec	 mov	 dl, BYTE PTR tv169[ebp]
  00075	80 e2 07	 and	 dl, 7
  00078	80 c2 03	 add	 dl, 3
  0007b	3a 55 fe	 cmp	 dl, BYTE PTR tv172[ebp]
  0007e	7c 0c		 jl	 SHORT $LN8@Character
  00080	8b 45 ec	 mov	 eax, DWORD PTR tv169[ebp]
  00083	50		 push	 eax
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN8@Character:
  0008c	8b 4d d0	 mov	 ecx, DWORD PTR tv65[ebp]
  0008f	0f 57 c0	 xorps	 xmm0, xmm0
  00092	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0
  00096	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00099	83 c2 14	 add	 edx, 20			; 00000014H
  0009c	89 55 cc	 mov	 DWORD PTR tv66[ebp], edx
  0009f	8b 45 cc	 mov	 eax, DWORD PTR tv66[ebp]
  000a2	89 45 e8	 mov	 DWORD PTR tv159[ebp], eax
  000a5	8b 4d e8	 mov	 ecx, DWORD PTR tv159[ebp]
  000a8	c1 e9 03	 shr	 ecx, 3
  000ab	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000b1	88 55 fd	 mov	 BYTE PTR tv162[ebp], dl
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv162[ebp], 0
  000b8	74 18		 je	 SHORT $LN7@Character
  000ba	8a 45 e8	 mov	 al, BYTE PTR tv159[ebp]
  000bd	24 07		 and	 al, 7
  000bf	04 03		 add	 al, 3
  000c1	3a 45 fd	 cmp	 al, BYTE PTR tv162[ebp]
  000c4	7c 0c		 jl	 SHORT $LN7@Character
  000c6	8b 4d e8	 mov	 ecx, DWORD PTR tv159[ebp]
  000c9	51		 push	 ecx
  000ca	e8 00 00 00 00	 call	 ___asan_report_store4
  000cf	83 c4 04	 add	 esp, 4
$LN7@Character:
  000d2	8b 55 cc	 mov	 edx, DWORD PTR tv66[ebp]
  000d5	0f 57 c0	 xorps	 xmm0, xmm0
  000d8	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0
  000dc	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000df	83 c0 1c	 add	 eax, 28			; 0000001cH
  000e2	89 45 c8	 mov	 DWORD PTR tv67[ebp], eax
  000e5	8b 4d c8	 mov	 ecx, DWORD PTR tv67[ebp]
  000e8	89 4d e4	 mov	 DWORD PTR tv149[ebp], ecx
  000eb	8b 55 e4	 mov	 edx, DWORD PTR tv149[ebp]
  000ee	c1 ea 03	 shr	 edx, 3
  000f1	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000f7	88 45 fc	 mov	 BYTE PTR tv152[ebp], al
  000fa	80 7d fc 00	 cmp	 BYTE PTR tv152[ebp], 0
  000fe	74 1a		 je	 SHORT $LN6@Character
  00100	8a 4d e4	 mov	 cl, BYTE PTR tv149[ebp]
  00103	80 e1 07	 and	 cl, 7
  00106	80 c1 03	 add	 cl, 3
  00109	3a 4d fc	 cmp	 cl, BYTE PTR tv152[ebp]
  0010c	7c 0c		 jl	 SHORT $LN6@Character
  0010e	8b 55 e4	 mov	 edx, DWORD PTR tv149[ebp]
  00111	52		 push	 edx
  00112	e8 00 00 00 00	 call	 ___asan_report_store4
  00117	83 c4 04	 add	 esp, 4
$LN6@Character:
  0011a	8b 45 c8	 mov	 eax, DWORD PTR tv67[ebp]
  0011d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00123	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00126	83 c1 20	 add	 ecx, 32			; 00000020H
  00129	e8 00 00 00 00	 call	 ??0?$Vector2@I@sf@@QAE@XZ ; sf::Vector2<unsigned int>::Vector2<unsigned int>
  0012e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	83 c1 28	 add	 ecx, 40			; 00000028H
  00134	89 4d c4	 mov	 DWORD PTR tv70[ebp], ecx
  00137	8b 55 c4	 mov	 edx, DWORD PTR tv70[ebp]
  0013a	89 55 e0	 mov	 DWORD PTR tv139[ebp], edx
  0013d	8b 45 e0	 mov	 eax, DWORD PTR tv139[ebp]
  00140	c1 e8 03	 shr	 eax, 3
  00143	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00149	88 4d fb	 mov	 BYTE PTR tv142[ebp], cl
  0014c	80 7d fb 00	 cmp	 BYTE PTR tv142[ebp], 0
  00150	74 17		 je	 SHORT $LN5@Character
  00152	8a 55 e0	 mov	 dl, BYTE PTR tv139[ebp]
  00155	80 e2 07	 and	 dl, 7
  00158	3a 55 fb	 cmp	 dl, BYTE PTR tv142[ebp]
  0015b	7c 0c		 jl	 SHORT $LN5@Character
  0015d	8b 45 e0	 mov	 eax, DWORD PTR tv139[ebp]
  00160	50		 push	 eax
  00161	e8 00 00 00 00	 call	 ___asan_report_store1
  00166	83 c4 04	 add	 esp, 4
$LN5@Character:
  00169	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  0016c	c6 01 00	 mov	 BYTE PTR [ecx], 0
  0016f	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00172	83 c2 29	 add	 edx, 41			; 00000029H
  00175	89 55 c0	 mov	 DWORD PTR tv71[ebp], edx
  00178	8b 45 c0	 mov	 eax, DWORD PTR tv71[ebp]
  0017b	89 45 dc	 mov	 DWORD PTR tv129[ebp], eax
  0017e	8b 4d dc	 mov	 ecx, DWORD PTR tv129[ebp]
  00181	c1 e9 03	 shr	 ecx, 3
  00184	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0018a	88 55 fa	 mov	 BYTE PTR tv132[ebp], dl
  0018d	80 7d fa 00	 cmp	 BYTE PTR tv132[ebp], 0
  00191	74 16		 je	 SHORT $LN4@Character
  00193	8a 45 dc	 mov	 al, BYTE PTR tv129[ebp]
  00196	24 07		 and	 al, 7
  00198	3a 45 fa	 cmp	 al, BYTE PTR tv132[ebp]
  0019b	7c 0c		 jl	 SHORT $LN4@Character
  0019d	8b 4d dc	 mov	 ecx, DWORD PTR tv129[ebp]
  001a0	51		 push	 ecx
  001a1	e8 00 00 00 00	 call	 ___asan_report_store1
  001a6	83 c4 04	 add	 esp, 4
$LN4@Character:
  001a9	8b 55 c0	 mov	 edx, DWORD PTR tv71[ebp]
  001ac	c6 02 00	 mov	 BYTE PTR [edx], 0
  001af	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001b2	83 c0 2a	 add	 eax, 42			; 0000002aH
  001b5	89 45 bc	 mov	 DWORD PTR tv72[ebp], eax
  001b8	8b 4d bc	 mov	 ecx, DWORD PTR tv72[ebp]
  001bb	89 4d d8	 mov	 DWORD PTR tv87[ebp], ecx
  001be	8b 55 d8	 mov	 edx, DWORD PTR tv87[ebp]
  001c1	c1 ea 03	 shr	 edx, 3
  001c4	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001ca	88 45 f9	 mov	 BYTE PTR tv90[ebp], al
  001cd	80 7d f9 00	 cmp	 BYTE PTR tv90[ebp], 0
  001d1	74 17		 je	 SHORT $LN3@Character
  001d3	8a 4d d8	 mov	 cl, BYTE PTR tv87[ebp]
  001d6	80 e1 07	 and	 cl, 7
  001d9	3a 4d f9	 cmp	 cl, BYTE PTR tv90[ebp]
  001dc	7c 0c		 jl	 SHORT $LN3@Character
  001de	8b 55 d8	 mov	 edx, DWORD PTR tv87[ebp]
  001e1	52		 push	 edx
  001e2	e8 00 00 00 00	 call	 ___asan_report_store1
  001e7	83 c4 04	 add	 esp, 4
$LN3@Character:
  001ea	8b 45 bc	 mov	 eax, DWORD PTR tv72[ebp]
  001ed	c6 00 00	 mov	 BYTE PTR [eax], 0
  001f0	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001f3	8b e5		 mov	 esp, ebp
  001f5	5d		 pop	 ebp
  001f6	c3		 ret	 0
??0Character@@QAE@XZ ENDP				; Character::Character
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_GSprite@sf@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GSprite@sf@@UAEPAXI@Z PROC				; sf::Sprite::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1Sprite@sf@@UAE@XZ
  00010	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00013	83 e0 01	 and	 eax, 1
  00016	74 11		 je	 SHORT $LN2@scalar
  00018	68 10 01 00 00	 push	 272			; 00000110H
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	51		 push	 ecx
  00021	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00026	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00029	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
??_GSprite@sf@@UAEPAXI@Z ENDP				; sf::Sprite::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Graphics\Rect.inl
;	COMDAT ??0?$Rect@H@sf@@QAE@HHHH@Z
_TEXT	SEGMENT
tv67 = -40						; size = 4
tv66 = -36						; size = 4
tv65 = -32						; size = 4
tv64 = -28						; size = 4
tv77 = -24						; size = 4
tv87 = -20						; size = 4
tv129 = -16						; size = 4
tv139 = -12						; size = 4
_this$ = -8						; size = 4
tv80 = -4						; size = 1
tv90 = -3						; size = 1
tv132 = -2						; size = 1
tv142 = -1						; size = 1
_rectLeft$ = 8						; size = 4
_rectTop$ = 12						; size = 4
_rectWidth$ = 16					; size = 4
_rectHeight$ = 20					; size = 4
??0?$Rect@H@sf@@QAE@HHHH@Z PROC				; sf::Rect<int>::Rect<int>, COMDAT
; _this$ = ecx

; 45   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C23CD225_Rect@inl
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 41   : left  (rectLeft),

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv142[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv142[ebp], 0
  00032	74 1a		 je	 SHORT $LN6@Rect
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv139[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv142[ebp]
  00040	7c 0c		 jl	 SHORT $LN6@Rect
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN6@Rect:
  0004e	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR _rectLeft$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 42   : top   (rectTop),

  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e0	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e0	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv129[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv129[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv132[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv132[ebp], 0
  00078	74 18		 je	 SHORT $LN5@Rect
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv129[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv132[ebp]
  00084	7c 0c		 jl	 SHORT $LN5@Rect
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv129[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN5@Rect:
  00092	8b 55 e0	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR _rectTop$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax

; 43   : width (rectWidth),

  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d dc	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 dc	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv87[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv87[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv90[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv90[ebp], 0
  000bc	74 1a		 je	 SHORT $LN4@Rect
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv87[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv90[ebp]
  000ca	7c 0c		 jl	 SHORT $LN4@Rect
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv87[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN4@Rect:
  000d8	8b 4d dc	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 10	 mov	 edx, DWORD PTR _rectWidth$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx

; 44   : height(rectHeight)

  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e6	89 45 d8	 mov	 DWORD PTR tv67[ebp], eax
  000e9	8b 4d d8	 mov	 ecx, DWORD PTR tv67[ebp]
  000ec	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  000ef	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 fc	 mov	 BYTE PTR tv80[ebp], al
  000fe	80 7d fc 00	 cmp	 BYTE PTR tv80[ebp], 0
  00102	74 1a		 je	 SHORT $LN3@Rect
  00104	8a 4d e8	 mov	 cl, BYTE PTR tv77[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d fc	 cmp	 cl, BYTE PTR tv80[ebp]
  00110	7c 0c		 jl	 SHORT $LN3@Rect
  00112	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN3@Rect:
  0011e	8b 45 d8	 mov	 eax, DWORD PTR tv67[ebp]
  00121	8b 4d 14	 mov	 ecx, DWORD PTR _rectHeight$[ebp]
  00124	89 08		 mov	 DWORD PTR [eax], ecx

; 46   : 
; 47   : }

  00126	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00129	8b e5		 mov	 esp, ebp
  0012b	5d		 pop	 ebp
  0012c	c2 10 00	 ret	 16			; 00000010H
??0?$Rect@H@sf@@QAE@HHHH@Z ENDP				; sf::Rect<int>::Rect<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\Graphics\Rect.inl
;	COMDAT ??0?$Rect@H@sf@@QAE@XZ
_TEXT	SEGMENT
tv67 = -40						; size = 4
tv66 = -36						; size = 4
tv65 = -32						; size = 4
tv64 = -28						; size = 4
tv77 = -24						; size = 4
tv87 = -20						; size = 4
tv129 = -16						; size = 4
tv139 = -12						; size = 4
_this$ = -8						; size = 4
tv80 = -4						; size = 1
tv90 = -3						; size = 1
tv132 = -2						; size = 1
tv142 = -1						; size = 1
??0?$Rect@H@sf@@QAE@XZ PROC				; sf::Rect<int>::Rect<int>, COMDAT
; _this$ = ecx

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __C23CD225_Rect@inl
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 29   : left  (0),

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv142[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv142[ebp], 0
  00032	74 1a		 je	 SHORT $LN6@Rect
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv139[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv142[ebp]
  00040	7c 0c		 jl	 SHORT $LN6@Rect
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN6@Rect:
  0004e	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 30   : top   (0),

  00057	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	89 4d e0	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e0	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f0	 mov	 DWORD PTR tv129[ebp], edx
  00066	8b 45 f0	 mov	 eax, DWORD PTR tv129[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv132[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv132[ebp], 0
  00079	74 1a		 je	 SHORT $LN5@Rect
  0007b	8a 55 f0	 mov	 dl, BYTE PTR tv129[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv132[ebp]
  00087	7c 0c		 jl	 SHORT $LN5@Rect
  00089	8b 45 f0	 mov	 eax, DWORD PTR tv129[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_store4
  00092	83 c4 04	 add	 esp, 4
$LN5@Rect:
  00095	8b 4d e0	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 31   : width (0),

  0009e	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000a1	83 c2 08	 add	 edx, 8
  000a4	89 55 dc	 mov	 DWORD PTR tv66[ebp], edx
  000a7	8b 45 dc	 mov	 eax, DWORD PTR tv66[ebp]
  000aa	89 45 ec	 mov	 DWORD PTR tv87[ebp], eax
  000ad	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000b0	c1 e9 03	 shr	 ecx, 3
  000b3	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000b9	88 55 fd	 mov	 BYTE PTR tv90[ebp], dl
  000bc	80 7d fd 00	 cmp	 BYTE PTR tv90[ebp], 0
  000c0	74 18		 je	 SHORT $LN4@Rect
  000c2	8a 45 ec	 mov	 al, BYTE PTR tv87[ebp]
  000c5	24 07		 and	 al, 7
  000c7	04 03		 add	 al, 3
  000c9	3a 45 fd	 cmp	 al, BYTE PTR tv90[ebp]
  000cc	7c 0c		 jl	 SHORT $LN4@Rect
  000ce	8b 4d ec	 mov	 ecx, DWORD PTR tv87[ebp]
  000d1	51		 push	 ecx
  000d2	e8 00 00 00 00	 call	 ___asan_report_store4
  000d7	83 c4 04	 add	 esp, 4
$LN4@Rect:
  000da	8b 55 dc	 mov	 edx, DWORD PTR tv66[ebp]
  000dd	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 32   : height(0)

  000e3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e6	83 c0 0c	 add	 eax, 12			; 0000000cH
  000e9	89 45 d8	 mov	 DWORD PTR tv67[ebp], eax
  000ec	8b 4d d8	 mov	 ecx, DWORD PTR tv67[ebp]
  000ef	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  000f2	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  000f5	c1 ea 03	 shr	 edx, 3
  000f8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fe	88 45 fc	 mov	 BYTE PTR tv80[ebp], al
  00101	80 7d fc 00	 cmp	 BYTE PTR tv80[ebp], 0
  00105	74 1a		 je	 SHORT $LN3@Rect
  00107	8a 4d e8	 mov	 cl, BYTE PTR tv77[ebp]
  0010a	80 e1 07	 and	 cl, 7
  0010d	80 c1 03	 add	 cl, 3
  00110	3a 4d fc	 cmp	 cl, BYTE PTR tv80[ebp]
  00113	7c 0c		 jl	 SHORT $LN3@Rect
  00115	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00118	52		 push	 edx
  00119	e8 00 00 00 00	 call	 ___asan_report_store4
  0011e	83 c4 04	 add	 esp, 4
$LN3@Rect:
  00121	8b 45 d8	 mov	 eax, DWORD PTR tv67[ebp]
  00124	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 34   : 
; 35   : }

  0012a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0012d	8b e5		 mov	 esp, ebp
  0012f	5d		 pop	 ebp
  00130	c3		 ret	 0
??0?$Rect@H@sf@@QAE@XZ ENDP				; sf::Rect<int>::Rect<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\vcpkg_installed\x86-windows\x86-windows\include\SFML\System\Vector2.inl
;	COMDAT ??0?$Vector2@I@sf@@QAE@XZ
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
??0?$Vector2@I@sf@@QAE@XZ PROC				; sf::Vector2<unsigned int>::Vector2<unsigned int>, COMDAT
; _this$ = ecx

; 31   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __0A631FEE_Vector2@inl
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 29   : x(0),

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Vector2
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Vector2
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Vector2:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 30   : y(0)

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00066	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv74[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00079	74 1a		 je	 SHORT $LN3@Vector2
  0007b	8a 55 f4	 mov	 dl, BYTE PTR tv71[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv74[ebp]
  00087	7c 0c		 jl	 SHORT $LN3@Vector2
  00089	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_store4
  00092	83 c4 04	 add	 esp, 4
$LN3@Vector2:
  00095	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 32   : 
; 33   : }

  0009e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
??0?$Vector2@I@sf@@QAE@XZ ENDP				; sf::Vector2<unsigned int>::Vector2<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv85 = -32						; size = 4
tv82 = -28						; size = 4
__Ptrdest$ = -24					; size = 4
tv88 = -20						; size = 4
tv130 = -16						; size = 4
__Ptrnext$1 = -12					; size = 4
__Count$ = -8						; size = 4
tv91 = -2						; size = 1
tv133 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00022	68 0e 02 00 00	 push	 526			; 0000020eH
  00027	68 00 00 00 00	 push	 OFFSET $SG87968
  0002c	6a 02		 push	 2
  0002e	6a 01		 push	 1
  00030	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	89 45 e8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 527  : 
; 528  :     if (!_Ptrdest) {

  00040	83 7d e8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00044	75 05		 jne	 SHORT $LN5@Maklocstr

; 529  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0004b	8b 55 e8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  00051	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00053	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	83 e8 01	 sub	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f4	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00068	83 c2 01	 add	 edx, 1
  0006b	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0006e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00072	76 7f		 jbe	 SHORT $LN3@Maklocstr

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00074	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00077	89 45 e4	 mov	 DWORD PTR tv82[ebp], eax
  0007a	8b 4d e4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv130[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 ff	 mov	 BYTE PTR tv133[ebp], al
  0008f	80 7d ff 00	 cmp	 BYTE PTR tv133[ebp], 0
  00093	74 17		 je	 SHORT $LN8@Maklocstr
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv130[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	3a 4d ff	 cmp	 cl, BYTE PTR tv133[ebp]
  0009e	7c 0c		 jl	 SHORT $LN8@Maklocstr
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load1
  000a9	83 c4 04	 add	 esp, 4
$LN8@Maklocstr:
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000af	89 45 e0	 mov	 DWORD PTR tv85[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR tv85[ebp]
  000b5	89 4d ec	 mov	 DWORD PTR tv88[ebp], ecx
  000b8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000bb	c1 ea 03	 shr	 edx, 3
  000be	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c4	88 45 fe	 mov	 BYTE PTR tv91[ebp], al
  000c7	80 7d fe 00	 cmp	 BYTE PTR tv91[ebp], 0
  000cb	74 17		 je	 SHORT $LN7@Maklocstr
  000cd	8a 4d ec	 mov	 cl, BYTE PTR tv88[ebp]
  000d0	80 e1 07	 and	 cl, 7
  000d3	3a 4d fe	 cmp	 cl, BYTE PTR tv91[ebp]
  000d6	7c 0c		 jl	 SHORT $LN7@Maklocstr
  000d8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ___asan_report_store1
  000e1	83 c4 04	 add	 esp, 4
$LN7@Maklocstr:
  000e4	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ea	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ec	88 10		 mov	 BYTE PTR [eax], dl

; 534  :     }

  000ee	e9 60 ff ff ff	 jmp	 $LN2@Maklocstr
$LN3@Maklocstr:

; 535  : 
; 536  :     return _Ptrdest;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 537  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__Ptrdest$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __4CB88277_xlocnum
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0001a	83 c4 04	 add	 esp, 4
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00023	6a 5d		 push	 93			; 0000005dH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0002a	6a 02		 push	 2
  0002c	6a 02		 push	 2
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 94   : 
; 95   :     if (!_Ptrdest) {

  0003e	83 7d fc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00042	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  00044	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00049	8b 55 f8	 mov	 edx, DWORD PTR __Count$[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _wmemcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :     return _Ptrdest;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 101  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Mbst1$ = -136						; size = 8
__Wc$ = -120						; size = 2
__Mbst2$ = -104						; size = 8
tv156 = -57						; size = 1
tv146 = -56						; size = 4
__Wchars$ = -52						; size = 4
__Bytes$ = -48						; size = 4
__Count$ = -44						; size = 4
__Ptrnext$ = -40					; size = 4
__Ptr1$ = -36						; size = 4
tv153 = -32						; size = 4
__Ptrdest$ = -28					; size = 4
__Count1$ = -24						; size = 4
tv144 = -20						; size = 4
tv141 = -16						; size = 4
tv149 = -12						; size = 4
tv140 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 540  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
  0003a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00044	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR tv144[ebp], eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c8	 mov	 DWORD PTR tv146[ebp], ecx
  0005c	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0005f	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00065	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00069	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  0006c	c7 00 02 f2 00
	f3		 mov	 DWORD PTR [eax], -218041854 ; f300f202H
  00072	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00076	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  0007b	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0007e	66 89 0a	 mov	 WORD PTR [edx], cx
  00081	83 45 c8 02	 add	 DWORD PTR tv146[ebp], 2
  00085	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  00088	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 541  :     // convert C string to wchar_t sequence using _Cvtvec
; 542  :     size_t _Count;
; 543  :     size_t _Count1;
; 544  :     size_t _Wchars;
; 545  :     const char* _Ptr1;
; 546  :     int _Bytes;
; 547  :     wchar_t _Wc;
; 548  :     mbstate_t _Mbst1 = {};

  00095	6a 08		 push	 8
  00097	6a 00		 push	 0
  00099	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ___asan_memset
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 549  : 
; 550  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  000a8	8b 53 08	 mov	 edx, DWORD PTR __Ptr$[ebx]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _strlen
  000b1	83 c4 04	 add	 esp, 4
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 e8	 mov	 DWORD PTR __Count1$[ebp], eax

; 551  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  000ba	8b 45 e8	 mov	 eax, DWORD PTR __Count1$[ebp]
  000bd	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  000c0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  000c7	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000ca	89 4d dc	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  000cd	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  000cf	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  000d2	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  000d5	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  000d8	8b 45 dc	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  000db	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  000de	89 45 dc	 mov	 DWORD PTR __Ptr1$[ebp], eax
  000e1	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
$LN4@Maklocstr:
  000ea	83 7d d4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000ee	76 2c		 jbe	 SHORT $LN3@Maklocstr

; 552  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  000f0	8b 53 10	 mov	 edx, DWORD PTR __Cvt$[ebx]
  000f3	52		 push	 edx
  000f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __Mbst1$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 dc	 mov	 edx, DWORD PTR __Ptr1$[ebp]
  00102	52		 push	 edx
  00103	8d 45 88	 lea	 eax, DWORD PTR __Wc$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __Mbrtowc
  0010c	83 c4 14	 add	 esp, 20			; 00000014H
  0010f	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00112	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00116	7f 02		 jg	 SHORT $LN8@Maklocstr

; 553  :             break;

  00118	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 554  :         }
; 555  :     }

  0011a	eb b3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 556  : 
; 557  :     ++_Wchars; // count terminating nul

  0011c	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx

; 558  : 
; 559  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00125	68 2f 02 00 00	 push	 559			; 0000022fH
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0012f	6a 02		 push	 2
  00131	6a 02		 push	 2
  00133	8b 55 cc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  00136	52		 push	 edx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0013d	83 c4 14	 add	 esp, 20			; 00000014H
  00140	89 45 e4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 560  : 
; 561  :     if (!_Ptrdest) {

  00143	83 7d e4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00147	75 05		 jne	 SHORT $LN9@Maklocstr

; 562  :         _Xbad_alloc();

  00149	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 563  :     }
; 564  : 
; 565  :     wchar_t* _Ptrnext = _Ptrdest;

  0014e	8b 45 e4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00151	89 45 d8	 mov	 DWORD PTR __Ptrnext$[ebp], eax

; 566  :     mbstate_t _Mbst2  = {};

  00154	6a 08		 push	 8
  00156	6a 00		 push	 0
  00158	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ___asan_memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 
; 568  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00164	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  00166	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  00169	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  0016c	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  0016f	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00172	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00175	89 43 08	 mov	 DWORD PTR __Ptr$[ebx], eax
  00178	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0017b	83 e9 01	 sub	 ecx, 1
  0017e	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
  00181	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  00184	83 c2 02	 add	 edx, 2
  00187	89 55 d8	 mov	 DWORD PTR __Ptrnext$[ebp], edx
$LN7@Maklocstr:
  0018a	83 7d cc 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0018e	76 29		 jbe	 SHORT $LN6@Maklocstr

; 569  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00190	8b 43 10	 mov	 eax, DWORD PTR __Cvt$[ebx]
  00193	50		 push	 eax
  00194	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 e8	 mov	 edx, DWORD PTR __Count1$[ebp]
  0019b	52		 push	 edx
  0019c	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  0019f	50		 push	 eax
  001a0	8b 4d d8	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 __Mbrtowc
  001a9	83 c4 14	 add	 esp, 20			; 00000014H
  001ac	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  001af	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  001b3	7f 02		 jg	 SHORT $LN10@Maklocstr

; 570  :             break;

  001b5	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 571  :         }
; 572  :     }

  001b7	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 573  : 
; 574  :     *_Ptrnext = L'\0';

  001b9	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  001bc	89 55 f0	 mov	 DWORD PTR tv141[ebp], edx
  001bf	8b 45 f0	 mov	 eax, DWORD PTR tv141[ebp]
  001c2	89 45 e0	 mov	 DWORD PTR tv153[ebp], eax
  001c5	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001c8	c1 e9 03	 shr	 ecx, 3
  001cb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001d1	88 55 c7	 mov	 BYTE PTR tv156[ebp], dl
  001d4	80 7d c7 00	 cmp	 BYTE PTR tv156[ebp], 0
  001d8	74 18		 je	 SHORT $LN12@Maklocstr
  001da	8a 45 e0	 mov	 al, BYTE PTR tv153[ebp]
  001dd	24 07		 and	 al, 7
  001df	04 01		 add	 al, 1
  001e1	3a 45 c7	 cmp	 al, BYTE PTR tv156[ebp]
  001e4	7c 0c		 jl	 SHORT $LN12@Maklocstr
  001e6	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 ___asan_report_store2
  001ef	83 c4 04	 add	 esp, 4
$LN12@Maklocstr:
  001f2	33 d2		 xor	 edx, edx
  001f4	8b 45 d8	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  001f7	66 89 10	 mov	 WORD PTR [eax], dx

; 575  : 
; 576  :     return _Ptrdest;

  001fa	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  001fd	89 4d f8	 mov	 DWORD PTR tv140[ebp], ecx
  00200	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0020a	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00210	c1 ea 03	 shr	 edx, 3
  00213	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00219	89 55 f4	 mov	 DWORD PTR tv149[ebp], edx
  0021c	6a 0b		 push	 11			; 0000000bH
  0021e	8b 45 f4	 mov	 eax, DWORD PTR tv149[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00227	83 c4 08	 add	 esp, 8
  0022a	8b 45 f8	 mov	 eax, DWORD PTR tv140[ebp]
$LN11@Maklocstr:

; 577  : }

  0022d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00230	33 cd		 xor	 ecx, ebp
  00232	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	8b e3		 mov	 esp, ebx
  0023c	5b		 pop	 ebx
  0023d	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv93 = -24						; size = 4
tv75 = -20						; size = 4
tv77 = -16						; size = 4
tv89 = -12						; size = 4
tv128 = -8						; size = 4
tv131 = -1						; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 30		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
  00047	83 c4 08	 add	 esp, 8

; 155  :     } else

  0004a	eb 7b		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0004c	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	6a 08		 push	 8
  00064	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00078	83 c4 04	 add	 esp, 4
  0007b	89 45 f4	 mov	 DWORD PTR tv89[ebp], eax
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR tv89[ebp]
  00081	89 4d f8	 mov	 DWORD PTR tv128[ebp], ecx
  00084	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00087	c1 ea 03	 shr	 edx, 3
  0008a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00090	88 45 ff	 mov	 BYTE PTR tv131[ebp], al
  00093	80 7d ff 00	 cmp	 BYTE PTR tv131[ebp], 0
  00097	74 1a		 je	 SHORT $LN5@Construct_
  00099	8a 4d f8	 mov	 cl, BYTE PTR tv128[ebp]
  0009c	80 e1 07	 and	 cl, 7
  0009f	80 c1 03	 add	 cl, 3
  000a2	3a 4d ff	 cmp	 cl, BYTE PTR tv131[ebp]
  000a5	7c 0c		 jl	 SHORT $LN5@Construct_
  000a7	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ___asan_report_load4
  000b0	83 c4 04	 add	 esp, 4
$LN5@Construct_:
  000b3	8b 45 f4	 mov	 eax, DWORD PTR tv89[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	89 4d e8	 mov	 DWORD PTR tv93[ebp], ecx
  000bb	8b 55 e8	 mov	 edx, DWORD PTR tv93[ebp]
  000be	52		 push	 edx
  000bf	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c2	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1316 :     _Container_proxy* _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Basic_cont
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Basic_cont
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Basic_cont:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1318 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1319 :         _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Release
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Release
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Release:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1320 :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1095 :     void _Orphan_all_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1096 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1097 :         _Orphan_all_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1098 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv89 = -100						; size = 4
tv86 = -96						; size = 4
tv83 = -92						; size = 4
tv78 = -88						; size = 4
tv72 = -84						; size = 4
tv71 = -80						; size = 4
tv70 = -76						; size = 4
tv68 = -72						; size = 4
tv66 = -68						; size = 4
tv64 = -64						; size = 4
tv130 = -60						; size = 4
tv140 = -56						; size = 4
_this$ = -52						; size = 4
tv150 = -48						; size = 4
tv160 = -44						; size = 4
tv170 = -40						; size = 4
tv180 = -36						; size = 4
tv190 = -32						; size = 4
tv200 = -28						; size = 4
tv210 = -24						; size = 4
tv220 = -20						; size = 4
__Pnext$1 = -16						; size = 4
tv133 = -10						; size = 1
tv143 = -9						; size = 1
tv153 = -8						; size = 1
tv163 = -7						; size = 1
tv173 = -6						; size = 1
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 :     if (!_Myproxy) { // no proxy, already done

  00013	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv220[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_all
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv220[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_all
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_all:
  0004e	8b 45 c0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN5@Orphan_all

; 1239 :         return;

  00056	e9 58 02 00 00	 jmp	 $LN6@Orphan_all
$LN5@Orphan_all:

; 1240 :     }
; 1241 : 
; 1242 :     // proxy allocated, drain it
; 1243 :     for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { // TRANSITION, VSO-1269037

  0005b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e8	 mov	 DWORD PTR tv210[ebp], edx
  00067	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv213[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  0007a	74 1a		 je	 SHORT $LN15@Orphan_all
  0007c	8a 55 e8	 mov	 dl, BYTE PTR tv210[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv213[ebp]
  00088	7c 0c		 jl	 SHORT $LN15@Orphan_all
  0008a	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN15@Orphan_all:
  00096	8b 4d bc	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$1[ebp], edx
  000a1	e9 c0 00 00 00	 jmp	 $LN4@Orphan_all
$LN2@Orphan_all:
  000a6	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000a9	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  000ac	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  000af	89 4d e4	 mov	 DWORD PTR tv200[ebp], ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000b5	c1 ea 03	 shr	 edx, 3
  000b8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000be	88 45 fd	 mov	 BYTE PTR tv203[ebp], al
  000c1	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  000c5	74 1a		 je	 SHORT $LN14@Orphan_all
  000c7	8a 4d e4	 mov	 cl, BYTE PTR tv200[ebp]
  000ca	80 e1 07	 and	 cl, 7
  000cd	80 c1 03	 add	 cl, 3
  000d0	3a 4d fd	 cmp	 cl, BYTE PTR tv203[ebp]
  000d3	7c 0c		 jl	 SHORT $LN14@Orphan_all
  000d5	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ___asan_report_load4
  000de	83 c4 04	 add	 esp, 4
$LN14@Orphan_all:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	83 c1 04	 add	 ecx, 4
  000e9	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  000ec	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  000ef	89 55 e0	 mov	 DWORD PTR tv190[ebp], edx
  000f2	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  000f5	c1 e8 03	 shr	 eax, 3
  000f8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000fe	88 4d fc	 mov	 BYTE PTR tv193[ebp], cl
  00101	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  00105	74 1a		 je	 SHORT $LN13@Orphan_all
  00107	8a 55 e0	 mov	 dl, BYTE PTR tv190[ebp]
  0010a	80 e2 07	 and	 dl, 7
  0010d	80 c2 03	 add	 dl, 3
  00110	3a 55 fc	 cmp	 dl, BYTE PTR tv193[ebp]
  00113	7c 0c		 jl	 SHORT $LN13@Orphan_all
  00115	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ___asan_report_load4
  0011e	83 c4 04	 add	 esp, 4
$LN13@Orphan_all:
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00124	89 4d a4	 mov	 DWORD PTR tv83[ebp], ecx
  00127	8b 55 a4	 mov	 edx, DWORD PTR tv83[ebp]
  0012a	89 55 dc	 mov	 DWORD PTR tv180[ebp], edx
  0012d	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00130	c1 e8 03	 shr	 eax, 3
  00133	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00139	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  0013c	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00140	74 1a		 je	 SHORT $LN12@Orphan_all
  00142	8a 55 dc	 mov	 dl, BYTE PTR tv180[ebp]
  00145	80 e2 07	 and	 dl, 7
  00148	80 c2 03	 add	 dl, 3
  0014b	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  0014e	7c 0c		 jl	 SHORT $LN12@Orphan_all
  00150	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ___asan_report_store4
  00159	83 c4 04	 add	 esp, 4
$LN12@Orphan_all:
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  0015f	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  00162	8b 02		 mov	 eax, DWORD PTR [edx]
  00164	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Orphan_all:
  00166	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00169	89 4d a0	 mov	 DWORD PTR tv86[ebp], ecx
  0016c	8b 55 a0	 mov	 edx, DWORD PTR tv86[ebp]
  0016f	89 55 d8	 mov	 DWORD PTR tv170[ebp], edx
  00172	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00175	c1 e8 03	 shr	 eax, 3
  00178	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0017e	88 4d fa	 mov	 BYTE PTR tv173[ebp], cl
  00181	80 7d fa 00	 cmp	 BYTE PTR tv173[ebp], 0
  00185	74 1a		 je	 SHORT $LN11@Orphan_all
  00187	8a 55 d8	 mov	 dl, BYTE PTR tv170[ebp]
  0018a	80 e2 07	 and	 dl, 7
  0018d	80 c2 03	 add	 dl, 3
  00190	3a 55 fa	 cmp	 dl, BYTE PTR tv173[ebp]
  00193	7c 0c		 jl	 SHORT $LN11@Orphan_all
  00195	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ___asan_report_load4
  0019e	83 c4 04	 add	 esp, 4
$LN11@Orphan_all:
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  001a4	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001a7	0f 84 84 00 00
	00		 je	 $LN3@Orphan_all

; 1244 :         _Pnext->_Myproxy = nullptr;

  001ad	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001b0	89 55 9c	 mov	 DWORD PTR tv89[ebp], edx
  001b3	8b 45 9c	 mov	 eax, DWORD PTR tv89[ebp]
  001b6	89 45 d4	 mov	 DWORD PTR tv160[ebp], eax
  001b9	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001bc	c1 e9 03	 shr	 ecx, 3
  001bf	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001c5	88 55 f9	 mov	 BYTE PTR tv163[ebp], dl
  001c8	80 7d f9 00	 cmp	 BYTE PTR tv163[ebp], 0
  001cc	74 18		 je	 SHORT $LN10@Orphan_all
  001ce	8a 45 d4	 mov	 al, BYTE PTR tv160[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 45 f9	 cmp	 al, BYTE PTR tv163[ebp]
  001d8	7c 0c		 jl	 SHORT $LN10@Orphan_all
  001da	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ___asan_report_load4
  001e3	83 c4 04	 add	 esp, 4
$LN10@Orphan_all:
  001e6	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001e9	8b 02		 mov	 eax, DWORD PTR [edx]
  001eb	89 45 b4	 mov	 DWORD PTR tv70[ebp], eax
  001ee	8b 4d b4	 mov	 ecx, DWORD PTR tv70[ebp]
  001f1	89 4d d0	 mov	 DWORD PTR tv150[ebp], ecx
  001f4	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  001f7	c1 ea 03	 shr	 edx, 3
  001fa	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00200	88 45 f8	 mov	 BYTE PTR tv153[ebp], al
  00203	80 7d f8 00	 cmp	 BYTE PTR tv153[ebp], 0
  00207	74 1a		 je	 SHORT $LN9@Orphan_all
  00209	8a 4d d0	 mov	 cl, BYTE PTR tv150[ebp]
  0020c	80 e1 07	 and	 cl, 7
  0020f	80 c1 03	 add	 cl, 3
  00212	3a 4d f8	 cmp	 cl, BYTE PTR tv153[ebp]
  00215	7c 0c		 jl	 SHORT $LN9@Orphan_all
  00217	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ___asan_report_store4
  00220	83 c4 04	 add	 esp, 4
$LN9@Orphan_all:
  00223	8b 45 b4	 mov	 eax, DWORD PTR tv70[ebp]
  00226	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1245 :     }

  0022c	e9 75 fe ff ff	 jmp	 $LN2@Orphan_all
$LN3@Orphan_all:

; 1246 :     _Myproxy->_Myfirstiter = nullptr;

  00231	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	89 4d b0	 mov	 DWORD PTR tv71[ebp], ecx
  00237	8b 55 b0	 mov	 edx, DWORD PTR tv71[ebp]
  0023a	89 55 c8	 mov	 DWORD PTR tv140[ebp], edx
  0023d	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00240	c1 e8 03	 shr	 eax, 3
  00243	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00249	88 4d f7	 mov	 BYTE PTR tv143[ebp], cl
  0024c	80 7d f7 00	 cmp	 BYTE PTR tv143[ebp], 0
  00250	74 1a		 je	 SHORT $LN8@Orphan_all
  00252	8a 55 c8	 mov	 dl, BYTE PTR tv140[ebp]
  00255	80 e2 07	 and	 dl, 7
  00258	80 c2 03	 add	 dl, 3
  0025b	3a 55 f7	 cmp	 dl, BYTE PTR tv143[ebp]
  0025e	7c 0c		 jl	 SHORT $LN8@Orphan_all
  00260	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ___asan_report_load4
  00269	83 c4 04	 add	 esp, 4
$LN8@Orphan_all:
  0026c	8b 4d b0	 mov	 ecx, DWORD PTR tv71[ebp]
  0026f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00271	83 c2 04	 add	 edx, 4
  00274	89 55 ac	 mov	 DWORD PTR tv72[ebp], edx
  00277	8b 45 ac	 mov	 eax, DWORD PTR tv72[ebp]
  0027a	89 45 c4	 mov	 DWORD PTR tv130[ebp], eax
  0027d	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  00280	c1 e9 03	 shr	 ecx, 3
  00283	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00289	88 55 f6	 mov	 BYTE PTR tv133[ebp], dl
  0028c	80 7d f6 00	 cmp	 BYTE PTR tv133[ebp], 0
  00290	74 18		 je	 SHORT $LN7@Orphan_all
  00292	8a 45 c4	 mov	 al, BYTE PTR tv130[ebp]
  00295	24 07		 and	 al, 7
  00297	04 03		 add	 al, 3
  00299	3a 45 f6	 cmp	 al, BYTE PTR tv133[ebp]
  0029c	7c 0c		 jl	 SHORT $LN7@Orphan_all
  0029e	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 ___asan_report_store4
  002a7	83 c4 04	 add	 esp, 4
$LN7@Orphan_all:
  002aa	8b 55 ac	 mov	 edx, DWORD PTR tv72[ebp]
  002ad	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Orphan_all:

; 1247 : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1250 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1251 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1252 :     if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Orphan_all

; 1253 :         _Orphan_all_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1254 :     } else

  00025	eb 08		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 1255 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1256 :     {
; 1257 :         _Orphan_all_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN4@Orphan_all:

; 1258 :     }
; 1259 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1260 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1065 : 
; 1066 :     _Container_base12(const _Container_base12&) = delete;
; 1067 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1068 : 
; 1069 :     _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept;
; 1070 :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1071 : 
; 1072 :     template <class _Alloc>
; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {
; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1075 :         _Construct_in_place(*_New_proxy, this);
; 1076 :         _Myproxy            = _New_proxy;
; 1077 :         _New_proxy->_Mycont = this;
; 1078 :     }
; 1079 : 
; 1080 :     template <class _Alloc>
; 1081 :     _CONSTEXPR20_CONTAINER void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1082 :         // pre: no iterators refer to the existing proxy
; 1083 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1084 :         _Construct_in_place(*_New_proxy, this);
; 1085 :         _New_proxy->_Mycont = this;
; 1086 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1087 :     }
; 1088 : 
; 1089 :     _Container_proxy* _Myproxy = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Container_:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 1057 : 
; 1058 :     const _Container_base12* _Mycont       = nullptr;
; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@Container_
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Container_
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Container_:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -84					; size = 4
tv154 = -80						; size = 4
tv151 = -76						; size = 4
tv144 = -72						; size = 4
tv64 = -68						; size = 4
tv141 = -64						; size = 4
tv138 = -60						; size = 4
__Ptr_container$ = -56					; size = 4
__Back_shift$ = -52					; size = 4
tv68 = -48						; size = 4
__Ptr_user$ = -44					; size = 4
tv66 = -40						; size = 4
tv157 = -36						; size = 4
tv167 = -32						; size = 4
tv177 = -28						; size = 4
tv187 = -24						; size = 4
tv197 = -20						; size = 4
tv207 = -16						; size = 4
tv217 = -12						; size = 4
tv160 = -7						; size = 1
tv170 = -6						; size = 1
tv180 = -5						; size = 1
tv190 = -4						; size = 1
tv200 = -3						; size = 1
tv210 = -2						; size = 1
tv220 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 153  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 154  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 155  :     _Bytes += _Non_user_size;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	89 45 c4	 mov	 DWORD PTR tv138[ebp], eax
  00016	8b 4d c4	 mov	 ecx, DWORD PTR tv138[ebp]
  00019	89 4d f4	 mov	 DWORD PTR tv217[ebp], ecx
  0001c	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv220[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv220[ebp], 0
  0002f	74 1a		 je	 SHORT $LN27@Adjust_man
  00031	8a 4d f4	 mov	 cl, BYTE PTR tv217[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv220[ebp]
  0003d	7c 0c		 jl	 SHORT $LN27@Adjust_man
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN27@Adjust_man:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	83 c1 27	 add	 ecx, 39			; 00000027H
  00053	89 4d bc	 mov	 DWORD PTR tv64[ebp], ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00059	89 55 c0	 mov	 DWORD PTR tv141[ebp], edx
  0005c	8b 45 c0	 mov	 eax, DWORD PTR tv141[ebp]
  0005f	89 45 f0	 mov	 DWORD PTR tv207[ebp], eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006e	88 55 fe	 mov	 BYTE PTR tv210[ebp], dl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv210[ebp], 0
  00075	74 18		 je	 SHORT $LN26@Adjust_man
  00077	8a 45 f0	 mov	 al, BYTE PTR tv207[ebp]
  0007a	24 07		 and	 al, 7
  0007c	04 03		 add	 al, 3
  0007e	3a 45 fe	 cmp	 al, BYTE PTR tv210[ebp]
  00081	7c 0c		 jl	 SHORT $LN26@Adjust_man
  00083	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN26@Adjust_man:
  0008f	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00092	8b 45 bc	 mov	 eax, DWORD PTR tv64[ebp]
  00095	89 02		 mov	 DWORD PTR [edx], eax

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009a	89 4d b8	 mov	 DWORD PTR tv144[ebp], ecx
  0009d	8b 55 b8	 mov	 edx, DWORD PTR tv144[ebp]
  000a0	89 55 ec	 mov	 DWORD PTR tv197[ebp], edx
  000a3	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000a6	c1 e8 03	 shr	 eax, 3
  000a9	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000af	88 4d fd	 mov	 BYTE PTR tv200[ebp], cl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv200[ebp], 0
  000b6	74 1a		 je	 SHORT $LN25@Adjust_man
  000b8	8a 55 ec	 mov	 dl, BYTE PTR tv197[ebp]
  000bb	80 e2 07	 and	 dl, 7
  000be	80 c2 03	 add	 dl, 3
  000c1	3a 55 fd	 cmp	 dl, BYTE PTR tv200[ebp]
  000c4	7c 0c		 jl	 SHORT $LN25@Adjust_man
  000c6	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ___asan_report_load4
  000cf	83 c4 04	 add	 esp, 4
$LN25@Adjust_man:
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d7	89 55 d4	 mov	 DWORD PTR __Ptr_user$[ebp], edx

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000da	b8 04 00 00 00	 mov	 eax, 4
  000df	6b c8 ff	 imul	 ecx, eax, -1
  000e2	8b 55 d4	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  000e5	03 d1		 add	 edx, ecx
  000e7	89 55 d8	 mov	 DWORD PTR tv66[ebp], edx
  000ea	8b 45 d8	 mov	 eax, DWORD PTR tv66[ebp]
  000ed	89 45 e8	 mov	 DWORD PTR tv187[ebp], eax
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  000f3	c1 e9 03	 shr	 ecx, 3
  000f6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000fc	88 55 fc	 mov	 BYTE PTR tv190[ebp], dl
  000ff	80 7d fc 00	 cmp	 BYTE PTR tv190[ebp], 0
  00103	74 18		 je	 SHORT $LN24@Adjust_man
  00105	8a 45 e8	 mov	 al, BYTE PTR tv187[ebp]
  00108	24 07		 and	 al, 7
  0010a	04 03		 add	 al, 3
  0010c	3a 45 fc	 cmp	 al, BYTE PTR tv190[ebp]
  0010f	7c 0c		 jl	 SHORT $LN24@Adjust_man
  00111	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ___asan_report_load4
  0011a	83 c4 04	 add	 esp, 4
$LN24@Adjust_man:
  0011d	8b 55 d8	 mov	 edx, DWORD PTR tv66[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	89 45 c8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00125	b9 04 00 00 00	 mov	 ecx, 4
  0012a	6b d1 fe	 imul	 edx, ecx, -2
  0012d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_user$[ebp]
  00130	03 c2		 add	 eax, edx
  00132	89 45 d0	 mov	 DWORD PTR tv68[ebp], eax
  00135	8b 4d d0	 mov	 ecx, DWORD PTR tv68[ebp]
  00138	89 4d e4	 mov	 DWORD PTR tv177[ebp], ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  0013e	c1 ea 03	 shr	 edx, 3
  00141	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00147	88 45 fb	 mov	 BYTE PTR tv180[ebp], al
  0014a	80 7d fb 00	 cmp	 BYTE PTR tv180[ebp], 0
  0014e	74 1a		 je	 SHORT $LN23@Adjust_man
  00150	8a 4d e4	 mov	 cl, BYTE PTR tv177[ebp]
  00153	80 e1 07	 and	 cl, 7
  00156	80 c1 03	 add	 cl, 3
  00159	3a 4d fb	 cmp	 cl, BYTE PTR tv180[ebp]
  0015c	7c 0c		 jl	 SHORT $LN23@Adjust_man
  0015e	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN23@Adjust_man:
  0016a	8b 45 d0	 mov	 eax, DWORD PTR tv68[ebp]
  0016d	81 38 fa fa fa
	fa		 cmp	 DWORD PTR [eax], -84215046 ; fafafafaH
  00173	75 02		 jne	 SHORT $LN7@Adjust_man
  00175	eb 4a		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00181	6a 00		 push	 0
  00183	68 a2 00 00 00	 push	 162			; 000000a2H
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0018d	6a 02		 push	 2
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00195	83 c4 18	 add	 esp, 24			; 00000018H
  00198	83 f8 01	 cmp	 eax, 1
  0019b	75 01		 jne	 SHORT $LN19@Adjust_man
  0019d	cc		 int	 3
$LN19@Adjust_man:
  0019e	6a 00		 push	 0
  001a0	68 a2 00 00 00	 push	 162			; 000000a2H
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001ba	83 c4 14	 add	 esp, 20			; 00000014H
  001bd	33 d2		 xor	 edx, edx
  001bf	75 b6		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  001c1	33 c0		 xor	 eax, eax
  001c3	0f 85 5c ff ff
	ff		 jne	 $LN4@Adjust_man

; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  001c9	c7 45 ac 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  001d3	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  001d6	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  001d9	89 55 e0	 mov	 DWORD PTR tv167[ebp], edx
  001dc	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  001df	c1 e8 03	 shr	 eax, 3
  001e2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e8	88 4d fa	 mov	 BYTE PTR tv170[ebp], cl
  001eb	80 7d fa 00	 cmp	 BYTE PTR tv170[ebp], 0
  001ef	74 1a		 je	 SHORT $LN22@Adjust_man
  001f1	8a 55 e0	 mov	 dl, BYTE PTR tv167[ebp]
  001f4	80 e2 07	 and	 dl, 7
  001f7	80 c2 03	 add	 dl, 3
  001fa	3a 55 fa	 cmp	 dl, BYTE PTR tv170[ebp]
  001fd	7c 0c		 jl	 SHORT $LN22@Adjust_man
  001ff	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ___asan_report_load4
  00208	83 c4 04	 add	 esp, 4
$LN22@Adjust_man:
  0020b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	2b 55 c8	 sub	 edx, DWORD PTR __Ptr_container$[ebp]
  00213	89 55 cc	 mov	 DWORD PTR __Back_shift$[ebp], edx
$LN10@Adjust_man:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00216	83 7d cc 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  0021a	72 08		 jb	 SHORT $LN13@Adjust_man
  0021c	83 7d cc 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  00220	77 02		 ja	 SHORT $LN13@Adjust_man
  00222	eb 4a		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0022e	6a 00		 push	 0
  00230	68 ac 00 00 00	 push	 172			; 000000acH
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0023a	6a 02		 push	 2
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00242	83 c4 18	 add	 esp, 24			; 00000018H
  00245	83 f8 01	 cmp	 eax, 1
  00248	75 01		 jne	 SHORT $LN20@Adjust_man
  0024a	cc		 int	 3
$LN20@Adjust_man:
  0024b	6a 00		 push	 0
  0024d	68 ac 00 00 00	 push	 172			; 000000acH
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00267	83 c4 14	 add	 esp, 20			; 00000014H
  0026a	33 c9		 xor	 ecx, ecx
  0026c	75 b6		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0026e	33 d2		 xor	 edx, edx
  00270	75 a4		 jne	 SHORT $LN10@Adjust_man

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00272	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00275	89 45 b0	 mov	 DWORD PTR tv154[ebp], eax
  00278	8b 4d b0	 mov	 ecx, DWORD PTR tv154[ebp]
  0027b	89 4d dc	 mov	 DWORD PTR tv157[ebp], ecx
  0027e	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  00281	c1 ea 03	 shr	 edx, 3
  00284	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0028a	88 45 f9	 mov	 BYTE PTR tv160[ebp], al
  0028d	80 7d f9 00	 cmp	 BYTE PTR tv160[ebp], 0
  00291	74 1a		 je	 SHORT $LN21@Adjust_man
  00293	8a 4d dc	 mov	 cl, BYTE PTR tv157[ebp]
  00296	80 e1 07	 and	 cl, 7
  00299	80 c1 03	 add	 cl, 3
  0029c	3a 4d f9	 cmp	 cl, BYTE PTR tv160[ebp]
  0029f	7c 0c		 jl	 SHORT $LN21@Adjust_man
  002a1	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 ___asan_report_store4
  002aa	83 c4 04	 add	 esp, 4
$LN21@Adjust_man:
  002ad	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  002b0	8b 4d c8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  002b3	89 08		 mov	 DWORD PTR [eax], ecx

; 174  : }

  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 84   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 85   :         return ::operator new(_Bytes);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 86   :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 12
tv70 = -12						; size = 4
tv68 = -8						; size = 4
tv73 = -4						; size = 4
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00020	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ
  00027	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0002e	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00040	89 4d f4	 mov	 DWORD PTR tv70[ebp], ecx
  00043	8b 55 f4	 mov	 edx, DWORD PTR tv70[ebp]
  00046	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0004c	83 45 f4 04	 add	 DWORD PTR tv70[ebp], 4
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  00053	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET __FF458F76_exception
  0005e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 321  :     _THROW(bad_array_new_length{});

  00063	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00066	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0006b	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00070	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  00079	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00080	8d 55 b0	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0008c	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  0008f	6a 08		 push	 8
  00091	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0009a	83 c4 08	 add	 esp, 8
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	8b e3		 mov	 esp, ebx
  000a2	5b		 pop	 ebx
  000a3	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_array_
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_array_
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
tv87 = -1						; size = 1
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00026	8b 4d f0	 mov	 ecx, DWORD PTR tv69[ebp]
  00029	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  0002f	c1 ea 03	 shr	 edx, 3
  00032	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00038	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  0003b	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0003f	74 1a		 je	 SHORT $LN3@bad_array_
  00041	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00044	80 e1 07	 and	 cl, 7
  00047	80 c1 03	 add	 cl, 3
  0004a	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0004d	7c 0c		 jl	 SHORT $LN3@bad_array_
  0004f	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ___asan_report_store4
  00058	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_alloc
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv85 = -12						; size = 4
_this$ = -8						; size = 4
tv88 = -1						; size = 1
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

  00013	6a 01		 push	 1
  00015	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  00027	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0002a	89 55 f4	 mov	 DWORD PTR tv85[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00030	c1 e8 03	 shr	 eax, 3
  00033	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00039	88 4d ff	 mov	 BYTE PTR tv88[ebp], cl
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00040	74 1a		 je	 SHORT $LN3@bad_alloc
  00042	8a 55 f4	 mov	 dl, BYTE PTR tv85[ebp]
  00045	80 e2 07	 and	 dl, 7
  00048	80 c2 03	 add	 dl, 3
  0004b	3a 55 ff	 cmp	 dl, BYTE PTR tv88[ebp]
  0004e	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ___asan_report_store4
  00059	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv67 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv85[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv88[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00035	74 1a		 je	 SHORT $LN6@what
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv85[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv88[ebp]
  00043	7c 0c		 jl	 SHORT $LN6@what
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN6@what:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 48		 je	 SHORT $LN3@what
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 04	 add	 ecx, 4
  0005f	89 4d e8	 mov	 DWORD PTR tv67[ebp], ecx
  00062	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00065	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00068	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0006b	c1 e8 03	 shr	 eax, 3
  0006e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00074	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00077	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  0007b	74 1a		 je	 SHORT $LN5@what
  0007d	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  00080	80 e2 07	 and	 dl, 7
  00083	80 c2 03	 add	 dl, 3
  00086	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00089	7c 0c		 jl	 SHORT $LN5@what
  0008b	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ___asan_report_load4
  00094	83 c4 04	 add	 esp, 4
$LN5@what:
  00097	8b 4d e8	 mov	 ecx, DWORD PTR tv67[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
  0009f	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  000a1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  000a8	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ___std_exception_destroy
  00063	83 c4 04	 add	 esp, 4

; 91   :     }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv64 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -1						; size = 1
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv76[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv79[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv79[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv76[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv79[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	52		 push	 edx
  00071	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00074	83 c0 04	 add	 eax, 4
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___std_exception_copy
  0007d	83 c4 08	 add	 esp, 8

; 74   :     }

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
tv76 = -16						; size = 4
tv86 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -2						; size = 1
tv89 = -1						; size = 1
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv86[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv86[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv89[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@exception:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   :         _Data._What = _Message;

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  00073	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00076	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0007c	c1 e9 03	 shr	 ecx, 3
  0007f	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00085	88 55 fe	 mov	 BYTE PTR tv79[ebp], dl
  00088	80 7d fe 00	 cmp	 BYTE PTR tv79[ebp], 0
  0008c	74 18		 je	 SHORT $LN3@exception
  0008e	8a 45 f0	 mov	 al, BYTE PTR tv76[ebp]
  00091	24 07		 and	 al, 7
  00093	04 03		 add	 al, 3
  00095	3a 45 fe	 cmp	 al, BYTE PTR tv79[ebp]
  00098	7c 0c		 jl	 SHORT $LN3@exception
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ___asan_report_store4
  000a3	83 c4 04	 add	 esp, 4
$LN3@exception:
  000a6	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  000a9	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  000ac	89 02		 mov	 DWORD PTR [edx], eax

; 68   :     }

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __97D3638F_vcruntime_new@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         (void)_Size;
; 169  :         return _Where;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 556  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __7FE5F402_limits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 557  :         return INT_MAX;

  0000d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 558  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 180  : _NODISCARD constexpr bool is_constant_evaluated() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __47F37C5A_xtr1common
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 181  :     return __builtin_is_constant_evaluated();

  0000d	32 c0		 xor	 al, al

; 182  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __93DC0B45_wchar@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00010	d1 e0		 shl	 eax, 1
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __4D0513DE_Player@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __4D0513DE_Player@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __4D0513DE_Player@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Player.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __4D0513DE_Player@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
