; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Debug\Terrain.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG253969 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xlocale', 00H
___asan_rrz_$SG253969 DD 0f9H
	ORG $+52
$SG248400 DB	'Unable to open message catalog: ', 00H
___asan_rrz_$SG248400 DD 0f9H
	ORG $+59
$SG248407 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
___asan_rrz_$SG248407 DD 0f9H
	ORG $+86
$SG248408 DB	'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H
___asan_rrz_$SG248408 DD 0f9H
	ORG $+46
$SG248410 DB	'C', 00H, ':', 00H, '\', 00H, 'U', 00H, 's', 00H, 'e', 00H
	DB	'r', 00H, 's', 00H, '\', 00H, 't', 00H, 'h', 00H, 'e', 00H, 'o'
	DB	00H, 'b', 00H, '\', 00H, 'D', 00H, 'o', 00H, 'c', 00H, 'u', 00H
	DB	'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, 's', 00H, '\', 00H, 'G'
	DB	00H, 'i', 00H, 't', 00H, 'H', 00H, 'u', 00H, 'b', 00H, '\', 00H
	DB	'a', 00H, 's', 00H, '-', 00H, 'p', 00H, 't', 00H, 's', 00H, '1'
	DB	00H, '\', 00H, 'r', 00H, 'e', 00H, 'n', 00H, 'd', 00H, 'u', 00H
	DB	'2', 00H, '\', 00H, 'v', 00H, 'c', 00H, 'p', 00H, 'k', 00H, 'g'
	DB	00H, '_', 00H, 'i', 00H, 'n', 00H, 's', 00H, 't', 00H, 'a', 00H
	DB	'l', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '\', 00H, 'x', 00H, '8'
	DB	00H, '6', 00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H
	DB	'o', 00H, 'w', 00H, 's', 00H, '\', 00H, 'x', 00H, '8', 00H, '6'
	DB	00H, '-', 00H, 'w', 00H, 'i', 00H, 'n', 00H, 'd', 00H, 'o', 00H
	DB	'w', 00H, 's', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'b', 00H, 'o', 00H
	DB	'o', 00H, 's', 00H, 't', 00H, '\', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '\', 00H, 'v', 00H, '5', 00H, '\', 00H
	DB	'w', 00H, '3', 00H, '2', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'g'
	DB	00H, 'e', 00H, 'x', 00H, '_', 00H, 't', 00H, 'r', 00H, 'a', 00H
	DB	'i', 00H, 't', 00H, 's', 00H, '.', 00H, 'h', 00H, 'p', 00H, 'p'
	DB	00H, 00H, 00H
___asan_rrz_$SG248410 DD 0f9H
	ORG $+86
$SG248411 DB	'0', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, 'r', 00H
	DB	00H, 00H
___asan_rrz_$SG248411 DD 0f9H
	ORG $+46
$SG257810 DB	'invalid argument', 00H
___asan_rrz_$SG257810 DD 0f9H
	ORG $+43
$SG257811 DB	'%s', 00H
___asan_rrz_$SG257811 DD 0f9H
	ORG $+57
$SG257812 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xmemory', 00H
___asan_rrz_$SG257812 DD 0f9H
	ORG $+52
$SG257813 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
___asan_rrz_$SG257813 DD 0f9H
	ORG $+44
$SG257814 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
___asan_rrz_$SG257814 DD 0f9H
	ORG $+46
$SG257815 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
___asan_rrz_$SG257815 DD 0f9H
CONST	ENDS
ASAN$GL	SEGMENT
_L___asan_global_$SG257815 DD FLAT:$SG257815
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.25
	DD	FLAT:_L___asan_gen_.14
	DD	00H
	DD	FLAT:_L___asan_gen_.26
	DD	00H
_L___asan_global_$SG257814 DD FLAT:$SG257814
	DD	04eH
	DD	080H
	DD	FLAT:_L___asan_gen_.23
	DD	FLAT:_L___asan_gen_.14
	DD	00H
	DD	FLAT:_L___asan_gen_.24
	DD	00H
_L___asan_global_$SG257813 DD FLAT:$SG257813
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.21
	DD	FLAT:_L___asan_gen_.14
	DD	00H
	DD	FLAT:_L___asan_gen_.22
	DD	00H
_L___asan_global_$SG257812 DD FLAT:$SG257812
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.19
	DD	FLAT:_L___asan_gen_.14
	DD	00H
	DD	FLAT:_L___asan_gen_.20
	DD	00H
_L___asan_global_$SG257811 DD FLAT:$SG257811
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.17
	DD	FLAT:_L___asan_gen_.14
	DD	00H
	DD	FLAT:_L___asan_gen_.18
	DD	00H
_L___asan_global_$SG257810 DD FLAT:$SG257810
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.15
	DD	FLAT:_L___asan_gen_.14
	DD	00H
	DD	FLAT:_L___asan_gen_.16
	DD	00H
_L___asan_global_$SG248411 DD FLAT:$SG248411
	DD	0eH
	DD	040H
	DD	FLAT:_L___asan_gen_.12
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.13
	DD	00H
_L___asan_global_$SG248410 DD FLAT:$SG248410
	DD	0106H
	DD	0160H
	DD	FLAT:_L___asan_gen_.10
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.11
	DD	00H
_L___asan_global_$SG248408 DD FLAT:$SG248408
	DD	0eH
	DD	040H
	DD	FLAT:_L___asan_gen_.8
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.9
	DD	00H
_L___asan_global_$SG248407 DD FLAT:$SG248407
	DD	0106H
	DD	0160H
	DD	FLAT:_L___asan_gen_.6
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.7
	DD	00H
_L___asan_global_$SG248400 DD FLAT:$SG248400
	DD	021H
	DD	060H
	DD	FLAT:_L___asan_gen_.4
	DD	FLAT:_L___asan_gen_.3
	DD	00H
	DD	FLAT:_L___asan_gen_.5
	DD	00H
_L___asan_global_$SG253969 DD FLAT:$SG253969
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
CONST	SEGMENT
	ORG $+54
_L___asan_gen_.0 DB 'xlocale', 00H
_L___asan_gen_.1 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	020eH
	DD	059H
_L___asan_gen_.3 DB 'w32_regex_traits.hpp', 00H
	ORG $+3
_L___asan_gen_.4 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.5 DD FLAT:_L___asan_gen_.3
	DD	02c1H
	DD	01aH
_L___asan_gen_.6 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.7 DD FLAT:_L___asan_gen_.3
	DD	02f7H
	DD	06H
_L___asan_gen_.8 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.9 DD FLAT:_L___asan_gen_.3
	DD	02f7H
	DD	06H
_L___asan_gen_.10 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.11 DD FLAT:_L___asan_gen_.3
	DD	0314H
	DD	06H
_L___asan_gen_.12 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.13 DD FLAT:_L___asan_gen_.3
	DD	0314H
	DD	06H
_L___asan_gen_.14 DB 'xmemory', 00H
_L___asan_gen_.15 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.16 DD FLAT:_L___asan_gen_.14
	DD	08eH
	DD	04H
_L___asan_gen_.17 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.18 DD FLAT:_L___asan_gen_.14
	DD	08eH
	DD	04H
_L___asan_gen_.19 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.20 DD FLAT:_L___asan_gen_.14
	DD	08eH
	DD	04H
_L___asan_gen_.21 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.22 DD FLAT:_L___asan_gen_.14
	DD	08eH
	DD	04H
_L___asan_gen_.23 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.24 DD FLAT:_L___asan_gen_.14
	DD	08eH
	DD	04H
_L___asan_gen_.25 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.26 DD FLAT:_L___asan_gen_.14
	DD	08eH
	DD	04H
CONST	ENDS
msvcjmc	SEGMENT
__B3577796_RenderStates@hpp DB 01H
__59466570_predefined C++ types (compiler internal) DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__47F37C5A_xtr1common DB 01H
__81812A28_cstddef DB 01H
__7FE5F402_limits DB 01H
__97D3638F_vcruntime_new@h DB 01H
__589FA321_type_traits DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__A751F051_corecrt_memory@h DB 01H
__32E5F013_string@h DB 01H
__DD5FCA34_compare DB 01H
__12269DE6_xutility DB 01H
__C69F69CF_tuple DB 01H
__79D216CD_xmemory DB 01H
__374A57BA_xpolymorphic_allocator@h DB 01H
__0D019051_xstring DB 01H
__B2D2BA86_ctype@h DB 01H
__B7987E10_string DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__C34BF88C_memory DB 01H
__60BC708E_cmath DB 01H
__68B92D9D_xbit_ops@h DB 01H
__0F13B0E8_xhash DB 01H
__BFE0F84B_functional DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__1B354CA2_system_error DB 01H
__3A667B81_error_category@hpp DB 01H
__25339F4A_generic_category_message@hpp DB 01H
__A4E336F0_generic_category@hpp DB 01H
__2DD6F2A3_error_condition@hpp DB 01H
__C6D9B9B2_system_category@hpp DB 01H
__1B11AAFA_snprintf@hpp DB 01H
__6767E947_error_handling@hpp DB 01H
__EE1D0242_system_category_message_win32@hpp DB 01H
__F4D1038E_system_category_condition_win32@hpp DB 01H
__1D2FDE06_system_category_impl@hpp DB 01H
__13E3B269_interop_category@hpp DB 01H
__EF0EAF83_xfacet DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__F4A89B3F_error_code@hpp DB 01H
__C655F023_std_category@hpp DB 01H
__51E12D41_error_category_impl@hpp DB 01H
__FE33131C_xlocmes DB 01H
__67DA974F_xlocmon DB 01H
__D96D2425_xloctime DB 01H
__147DD91B_path_traits@hpp DB 01H
__CE27CDA6_facade_iterator_category@hpp DB 01H
__FCD69F0E_ios_state@hpp DB 01H
__32E57CF6_path@hpp DB 01H
__0269C046_errc@hpp DB 01H
__38C7FDF2_throws@hpp DB 01H
__B76B1A2C_system_error@hpp DB 01H
__8868518C_atomic_count_std_atomic@hpp DB 01H
__BFCE1B3F_intrusive_ref_counter@hpp DB 01H
__203D301F_exception@hpp DB 01H
__6D84B491_file_status@hpp DB 01H
__9E7B425B_directory@hpp DB 01H
__994C2822_operations@hpp DB 01H
__85CA39D3_convenience@hpp DB 01H
__54B77B77_fstream DB 01H
__819F9458_fstream@hpp DB 01H
__807252DF_string_file@hpp DB 01H
__1589CDA2_algorithm DB 01H
__2B558C5C_implementation_help@hpp DB 01H
__53FD89EC_noncopyable@hpp DB 01H
__249AC1FF_as_literal@hpp DB 01H
__CCA81496_classification@hpp DB 01H
__9E8302C5_classification@hpp DB 01H
__291069DD_compare@hpp DB 01H
__6E0894BC_finder@hpp DB 01H
__6005BCF8_finder@hpp DB 01H
__876C1A82_exception@hpp DB 01H
__C6048E53_current_function@hpp DB 01H
__550A1F1C_source_location@hpp DB 01H
__78E6F2C5_throw_exception@hpp DB 01H
__36989B12_demangle@hpp DB 01H
__DBA21239_stl_type_index@hpp DB 01H
__DFD8B503_function_base@hpp DB 01H
__0C0FE920_ratio DB 01H
__2D75401A___msvc_tzdb@hpp DB 01H
__7BF231E7_optional DB 01H
__324884E2_vector DB 01H
__1347750E_utility DB 01H
__20D3AEFC_forward_list DB 01H
__1B08F288_chrono DB 01H
__491EF713_xfilesystem_abi@h DB 01H
__2B6093AE_list DB 01H
__B111E740_filesystem DB 01H
__B26BA995_regex DB 01H
__B2A9EE53_InputStream@hpp DB 01H
__62DD75E3_NonCopyable@hpp DB 01H
__FC4CDF9C_Thread@inl DB 01H
__69958C8C_xtree DB 01H
__C78A343B_SoundFileReader@hpp DB 01H
__5D3957BC_SoundFileWriter@hpp DB 01H
__A5341E86_regex_workaround@hpp DB 01H
__84A6C509_regex_traits_defaults@hpp DB 01H
__C72864EE_pattern_except@hpp DB 01H
__8A32E06C_stop_token DB 01H
__1806803A_thread DB 01H
__1EA2E370_mutex DB 01H
__BC8232E2_cpp_regex_traits@hpp DB 01H
__EF9A24B2_c_regex_traits@hpp DB 01H
__79C7FC57_basetsd@h DB 01H
__D545DD43_guiddef@h DB 01H
__D5DDFBF3_winnt@h DB 01H
__439612F0_processthreadsapi@h DB 01H
__5733279A_memoryapi@h DB 01H
__D4435474_winerror@h DB 01H
__B3ED30D4_winbase@h DB 01H
__DB057BA3_winuser@h DB 01H
__A118E6DC_stralign@h DB 01H
__43AE03FC_w32_regex_traits@hpp DB 01H
__ED044598_match_flags@hpp DB 01H
__9829EA86_regex_raw_buffer@hpp DB 01H
__BA42420E_basic_regex@hpp DB 01H
__F162022C_set DB 01H
__3C41319C_indexed_bit_flag@hpp DB 01H
__A750400E_basic_regex_creator@hpp DB 01H
__CFA0C522_basic_regex_parser@hpp DB 01H
__23D98615_mem_block_cache@hpp DB 01H
__0A52C9A5_perl_matcher_non_recursive@hpp DB 01H
__C1A77E9F_perl_matcher@hpp DB 01H
__28BBFA9C_RessourcePack@h DB 01H
__3C1C7D88_ContextSettings@hpp DB 01H
__8D991C03_Drawable@hpp DB 01H
__896EE8A8_Glyph@hpp DB 01H
__E3A1A8C3_Font@hpp DB 01H
__0D6BD463_Character@h DB 01H
__372D2D08_initializer_list DB 01H
__E458E21C_xstddef DB 01H
__218DFE2C_Levels@h DB 01H
__9344C8DF_Block@h DB 01H
__7385D044_any DB 01H
__78BC29F0_TerrainConstructor@h DB 01H
__9D99E827_Terrain@h DB 01H
__077BA29D_Terrain@cpp DB 01H
__A2FF0B9E_istream DB 01H
__FA839AC8_operator_bool@hpp DB 01H
__0FFFED91_intrusive_ptr@hpp DB 01H
__B38B2551_iterator_facade@hpp DB 01H
__68A60A21_locale DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__038A2AA6_iterator DB 01H
__B30C2184_iosfwd DB 01H
__C23CD225_Rect@inl DB 01H
__03BEDB82_Rect@hpp DB 01H
__F1CBF088_type_index@hpp DB 01H
__68C17CDA_primary_transform@hpp DB 01H
__F54903A0_xatomic@h DB 01H
__1CB4EB11_addressof@hpp DB 01H
__1EB17C13_integral_constant@hpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	_wmemcpy
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?max@?$numeric_limits@H@std@@SAHXZ		; std::numeric_limits<int>::max
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0exception@std@@QAE@QBDH@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@AAE@QBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_array_new_length@std@@QAE@XZ		; std::bad_array_new_length::bad_array_new_length
PUBLIC	??1bad_array_new_length@std@@UAE@XZ		; std::bad_array_new_length::~bad_array_new_length
PUBLIC	??0bad_array_new_length@std@@QAE@ABV01@@Z	; std::bad_array_new_length::bad_array_new_length
PUBLIC	??_Gbad_array_new_length@std@@UAEPAXI@Z		; std::bad_array_new_length::`scalar deleting destructor'
PUBLIC	?_Throw_bad_array_new_length@std@@YAXXZ		; std::_Throw_bad_array_new_length
PUBLIC	?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	??$_Convert_size@I@std@@YAII@Z			; std::_Convert_size<unsigned int>
PUBLIC	??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release
PUBLIC	??0_Basic_container_proxy_ptr12@std@@IAE@XZ	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
PUBLIC	??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
PUBLIC	??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	??0?$allocator@H@std@@QAE@XZ			; std::allocator<int>::allocator<int>
PUBLIC	?deallocate@?$allocator@H@std@@QAEXQAHI@Z	; std::allocator<int>::deallocate
PUBLIC	?allocate@?$allocator@H@std@@QAEPAHI@Z		; std::allocator<int>::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
PUBLIC	??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
PUBLIC	?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
PUBLIC	?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy
PUBLIC	?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
PUBLIC	?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
PUBLIC	??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
PUBLIC	??0?$initializer_list@H@std@@QAE@PBH0@Z		; std::initializer_list<int>::initializer_list<int>
PUBLIC	?begin@?$initializer_list@H@std@@QBEPBHXZ	; std::initializer_list<int>::begin
PUBLIC	?end@?$initializer_list@H@std@@QBEPBHXZ		; std::initializer_list<int>::end
PUBLIC	??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
PUBLIC	?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
PUBLIC	?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
PUBLIC	?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
PUBLIC	?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
PUBLIC	?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
PUBLIC	?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
PUBLIC	?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
PUBLIC	??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
PUBLIC	?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
PUBLIC	?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
PUBLIC	?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
PUBLIC	??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
PUBLIC	??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
PUBLIC	??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
PUBLIC	??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
PUBLIC	??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
PUBLIC	??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
PUBLIC	??$distance@PBH@std@@YAHPBH0@Z			; std::distance<int const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
PUBLIC	??$min@I@std@@YAABIABI0@Z			; std::min<unsigned int>
PUBLIC	??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z	; std::_Get_unwrapped<int const * const &>
PUBLIC	??$to_address@$$CBH@std@@YAPBHQBH@Z		; std::to_address<int const >
PUBLIC	??$to_address@H@std@@YAPAHQAH@Z			; std::to_address<int>
PUBLIC	??$_Unfancy@H@std@@YAPAHPAH@Z			; std::_Unfancy<int>
PUBLIC	??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z	; std::_Copy_memmove<int const *,int *>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
PUBLIC	??$forward@ABH@std@@YAABHABH@Z			; std::forward<int const &>
PUBLIC	??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
PUBLIC	??$construct_at@HABHX@std@@YAPAHQAHABH@Z	; std::construct_at<int,int const &,void>
PUBLIC	??$_Voidify_iter@PAH@std@@YAPAXPAH@Z		; std::_Voidify_iter<int *>
PUBLIC	??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
PUBLIC	??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
PUBLIC	??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
PUBLIC	??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
PUBLIC	??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
PUBLIC	??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
PUBLIC	??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
PUBLIC	?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
PUBLIC	??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
PUBLIC	??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
PUBLIC	??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
PUBLIC	??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
PUBLIC	??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
PUBLIC	??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
PUBLIC	??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
PUBLIC	??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
PUBLIC	??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z	; std::_Get_unwrapped<int * const &>
PUBLIC	??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z	; std::_Copy_memmove<int *,int *>
PUBLIC	??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
PUBLIC	??$forward@AAH@std@@YAAAHAAH@Z			; std::forward<int &>
PUBLIC	??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
PUBLIC	??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z	; std::construct_at<int,int &,void>
PUBLIC	??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
PUBLIC	??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
PUBLIC	??_GBlock@@QAEPAXI@Z				; Block::`scalar deleting destructor'
PUBLIC	?__autoclassinit2@TerrainConstructor@@QAEXI@Z	; TerrainConstructor::__autoclassinit2
PUBLIC	??0Terrain@@QAE@PAVRessourcePack@@@Z		; Terrain::Terrain
PUBLIC	?loadTerrain@Terrain@@QAEXH@Z			; Terrain::loadTerrain
PUBLIC	??1Terrain@@QAE@XZ				; Terrain::~Terrain
PUBLIC	?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
PUBLIC	??$_Get_size_of_n@$07@std@@YAII@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Get_size_of_n@$0BA@@std@@YAII@Z		; std::_Get_size_of_n<16>
PUBLIC	??$_Get_size_of_n@$03@std@@YAII@Z		; std::_Get_size_of_n<4>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_To_address@PBH@std@@YA?A_PABQBH@Z		; std::_To_address<int const *>
PUBLIC	??$_To_address@PAH@std@@YA?A_PABQAH@Z		; std::_To_address<int *>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
PUBLIC	??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception@		; `string'
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7bad_array_new_length@std@@6B@		; std::bad_array_new_length::`vftable'
PUBLIC	??_C@_0BF@KINCDENJ@bad?5array?5new?5length@	; `string'
PUBLIC	__TI3?AVbad_array_new_length@std@@
PUBLIC	__CTA3?AVbad_array_new_length@std@@
PUBLIC	??_R0?AVbad_array_new_length@std@@@8		; std::bad_array_new_length `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
PUBLIC	??_C@_0BA@FOIKENOD@vector?5too?5long@		; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_array_new_length@std@@6B@		; std::bad_array_new_length::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_array_new_length@std@@8		; std::bad_array_new_length::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_array_new_length@std@@8	; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_memcpy:PROC
EXTRN	_memmove:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	___std_exception_copy:PROC
EXTRN	___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Ebad_array_new_length@std@@UAEPAXI@Z:PROC	; std::bad_array_new_length::`vector deleting destructor'
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	??1Block@@QAE@XZ:PROC				; Block::~Block
EXTRN	??0TerrainConstructor@@QAE@XZ:PROC		; TerrainConstructor::TerrainConstructor
EXTRN	?ConstructTerrainFromLevelFile@TerrainConstructor@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@HAAVRessourcePack@@@Z:PROC ; TerrainConstructor::ConstructTerrainFromLevelFile
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___asan_loadN:PROC
EXTRN	___asan_memcpy:PROC
EXTRN	___asan_memset:PROC
EXTRN	___asan_report_load1:PROC
EXTRN	___asan_report_load4:PROC
EXTRN	___asan_report_store1:PROC
EXTRN	___asan_report_store2:PROC
EXTRN	___asan_report_store4:PROC
EXTRN	___asan_set_shadow_00:PROC
EXTRN	___asan_set_shadow_f8:PROC
EXTRN	___asan_storeN:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
;	COMDAT ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A
_BSS	SEGMENT
?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 010H DUP (?) ; level1
___asan_rrz_?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A DB 030H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception@ DB 'Unknown exception', 00H ; `string'
___asan_rrz_??_C@_0BC@EOODALEL@Unknown?5exception@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
CONST	SEGMENT
??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DB 'bad array new length', 00H ; `string'
___asan_rrz_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
___asan_rrz_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
___asan_rrz_??_C@_02DKCKIIND@?$CFs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xmemory', 00H	; `string'
___asan_rrz_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocale', 00H	; `string'
___asan_rrz_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocnum', 00H	; `string'
___asan_rrz_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BA@FOIKENOD@vector?5too?5long@
CONST	SEGMENT
??_C@_0BA@FOIKENOD@vector?5too?5long@ DB 'vector too long', 00H ; `string'
___asan_rrz_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
___asan_rrz_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD 0f9H
CONST	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
?level1$initializer$@@3P6AXXZA DD FLAT:??__Elevel1@@YAXXZ ; level1$initializer$
CRT$XCU	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	DD	01aH
	DD	040H
	DD	FLAT:_L___asan_gen_.30
	DD	FLAT:_L___asan_gen_.27
	DD	00H
	DD	FLAT:_L___asan_gen_.31
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.31 DD FLAT:_L___asan_gen_.27
	DD	0b4H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.30 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	DD	0dH
	DD	040H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.27
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.27
	DD	01b7H
	DD	030H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.28 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.27 DB 'xloctime', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BA@FOIKENOD@vector?5too?5long@ DD FLAT:??_C@_0BA@FOIKENOD@vector?5too?5long@
	DD	010H
	DD	040H
	DD	FLAT:_L___asan_gen_.25
	DD	FLAT:_L___asan_gen_.24
	DD	00H
	DD	FLAT:_L___asan_gen_.26
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.26 DD FLAT:_L___asan_gen_.24
	DD	06eeH
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.25 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.24 DB 'vector', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.22
	DD	FLAT:_L___asan_gen_.21
	DD	00H
	DD	FLAT:_L___asan_gen_.23
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.23 DD FLAT:_L___asan_gen_.21
	DD	05dH
	DD	05fH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.22 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.21 DB 'xlocnum', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.19
	DD	FLAT:_L___asan_gen_.18
	DD	00H
	DD	FLAT:_L___asan_gen_.20
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.20 DD FLAT:_L___asan_gen_.18
	DD	049H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.19 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.18 DB 'xlocale', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.16
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.17
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.17 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.16 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD FLAT:??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	DD	04aH
	DD	080H
	DD	FLAT:_L___asan_gen_.14
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.15
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.15 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.14 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.12
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.13
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.13 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.12 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.10
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.11
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.11 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.10 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_02DKCKIIND@?$CFs@ DD FLAT:??_C@_02DKCKIIND@?$CFs@
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.8
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.9
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.9 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.8 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.6
	DD	FLAT:_L___asan_gen_.5
	DD	00H
	DD	FLAT:_L___asan_gen_.7
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.7 DD FLAT:_L___asan_gen_.5
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.6 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.5 DB 'xmemory', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BF@KINCDENJ@bad?5array?5new?5length@ DD FLAT:??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
	DD	015H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	08cH
	DD	014H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.3 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BC@EOODALEL@Unknown?5exception@ DD FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	DD	012H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	05fH
	DD	02bH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.1 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.0 DB 'vcruntime_exception.h', 00H
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_array_new_length@std@@8 DD FLAT:??_R0?AVbad_array_new_length@std@@@8 ; std::bad_array_new_length::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R2bad_array_new_length@std@@8 DD FLAT:??_R1A@?0A@EA@bad_array_new_length@std@@8 ; std::bad_array_new_length::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@bad_alloc@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_array_new_length@std@@8
rdata$r	SEGMENT
??_R3bad_array_new_length@std@@8 DD 00H			; std::bad_array_new_length::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_array_new_length@std@@6B@
rdata$r	SEGMENT
??_R4bad_array_new_length@std@@6B@ DD 00H		; std::bad_array_new_length::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	FLAT:??_R3bad_array_new_length@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 010H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
data$r	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
data$r	ENDS
;	COMDAT __CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_array_new_length@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_array_new_length@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_array_new_length@std@@@8
data$r	SEGMENT
??_R0?AVbad_array_new_length@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::bad_array_new_length `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_array_new_length@std@@', 00H
data$r	ENDS
;	COMDAT __CTA3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__CTA3?AVbad_array_new_length@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVbad_array_new_length@std@@@8??0bad_array_new_length@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __TI3?AVbad_array_new_length@std@@
xdata$x	SEGMENT
__TI3?AVbad_array_new_length@std@@ DD 00H
	DD	FLAT:??1bad_array_new_length@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVbad_array_new_length@std@@
xdata$x	ENDS
;	COMDAT ??_7bad_array_new_length@std@@6B@
CONST	SEGMENT
??_7bad_array_new_length@std@@6B@ DD FLAT:??_R4bad_array_new_length@std@@6B@ ; std::bad_array_new_length::`vftable'
	DD	FLAT:??_Ebad_array_new_length@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$??0Terrain@@QAE@PAVRessourcePack@@@Z$0
	DD	01dH
voltbl	ENDS
xdata$x	SEGMENT
__unwindtable$??0Terrain@@QAE@PAVRessourcePack@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Terrain@@QAE@PAVRessourcePack@@@Z$0
__ehfuncinfo$??0Terrain@@QAE@PAVRessourcePack@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Terrain@@QAE@PAVRessourcePack@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	0b3H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??__Elevel1@@YAXXZ DD 019930522H
	DD	0eH
	DD	FLAT:__unwindtable$??__Elevel1@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??__Elevel1@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$3
	DD	03H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$5
	DD	05H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$8
	DD	08H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$9
	DD	09H
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$10
	DD	0aH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$11
	DD	0bH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??__Elevel1@@YAXXZ$14
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??__Elevel1@@YAXXZ DB '45 16 224 18 compiler temporary 32 '
	DB	'36 18 compiler temporary 48 36 18 compiler temporary 64 36 18'
	DB	' compiler temporary 80 36 18 compiler temporary 96 36 18 comp'
	DB	'iler temporary 112 36 18 compiler temporary 128 36 18 compile'
	DB	'r temporary 144 36 18 compiler temporary 160 36 18 compiler t'
	DB	'emporary 176 36 18 compiler temporary 192 36 18 compiler temp'
	DB	'orary 208 36 18 compiler temporary 224 36 18 compiler tempora'
	DB	'ry 240 36 18 compiler temporary 256 1 18 compiler temporary 2'
	DB	'72 1 18 compiler temporary 288 8 18 compiler temporary 304 1 '
	DB	'18 compiler temporary 320 8 18 compiler temporary 336 1 18 co'
	DB	'mpiler temporary 352 8 18 compiler temporary 368 1 18 compile'
	DB	'r temporary 384 8 18 compiler temporary 400 1 18 compiler tem'
	DB	'porary 416 8 18 compiler temporary 432 1 18 compiler temporar'
	DB	'y 448 8 18 compiler temporary 464 1 18 compiler temporary 480'
	DB	' 8 18 compiler temporary 496 1 18 compiler temporary 512 8 18'
	DB	' compiler temporary 528 1 18 compiler temporary 544 8 18 comp'
	DB	'iler temporary 560 1 18 compiler temporary 576 8 18 compiler '
	DB	'temporary 592 1 18 compiler temporary 608 8 18 compiler tempo'
	DB	'rary 624 1 18 compiler temporary 640 8 18 compiler temporary '
	DB	'656 1 18 compiler temporary 672 8 18 compiler temporary 688 1'
	DB	' 18 compiler temporary 704 8 18 compiler temporary 720 8 18 c'
	DB	'ompiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	020H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	02fH
	DW	0137H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0268H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z DB '1'
	DB	' 16 4 6 _Guard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01bdH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0
__ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z DB '1'
	DB	' 16 12 8 _Backout'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	0268H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0
__ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z DB '1'
	DB	' 16 4 6 _Guard'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z DB '1'
	DB	' 16 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ DB '2'
	DB	' 16 1 4 $S10 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01d2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0
__ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z DB '3'
	DB	' 16 1 3 $S8 32 8 6 _Proxy 48 1 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ DB '2'
	DB	' 16 4 18 compiler temporary 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ DB '2 16 1 4'
	DB	' $S13 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	031H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	03f7H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z DB '4 '
	DB	'16 1 18 compiler temporary 32 1 3 $S9 48 8 6 _Proxy 64 4 6 _G'
	DB	'uard'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	032H
	DW	01d2H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0
__ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z DB '3'
	DB	' 16 1 3 $S7 32 8 6 _Proxy 48 1 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	022dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z DB '3 16'
	DB	' 8 6 _Mbst1 32 2 3 _Wc 48 8 6 _Mbst2'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ DB '1 16 12 18 com'
	DB	'piler temporary'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 693  :     static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 694  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 695  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 696  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN2@deallocate

; 697  :             _Al.deallocate(_Ptr, _Count);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00024	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 698  :         } else

  00029	eb 13		 jmp	 SHORT $LN1@deallocate
$LN2@deallocate:

; 699  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 700  :         {
; 701  :             (void) _Al;
; 702  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	c1 e0 03	 shl	 eax, 3
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003b	83 c4 08	 add	 esp, 8
$LN1@deallocate:

; 703  :         }
; 704  :     }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z
_TEXT	SEGMENT
tv90 = -32						; size = 4
tv88 = -28						; size = 4
__Block_size$ = -24					; size = 4
__Ptr$ = -20						; size = 4
tv128 = -16						; size = 4
__Ptr_container$ = -12					; size = 4
tv138 = -8						; size = 4
tv131 = -2						; size = 1
tv141 = -1						; size = 1
__Bytes$ = 8						; size = 4
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z PROC ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>, COMDAT

; 134  : __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 135  :     // allocate _Bytes manually aligned to at least _Big_allocation_alignment
; 136  :     const size_t _Block_size = _Non_user_size + _Bytes;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	83 c0 27	 add	 eax, 39			; 00000027H
  00016	89 45 e8	 mov	 DWORD PTR __Block_size$[ebp], eax

; 137  :     if (_Block_size <= _Bytes) {

  00019	8b 4d e8	 mov	 ecx, DWORD PTR __Block_size$[ebp]
  0001c	3b 4d 08	 cmp	 ecx, DWORD PTR __Bytes$[ebp]
  0001f	77 05		 ja	 SHORT $LN8@Allocate_m

; 138  :         _Throw_bad_array_new_length(); // add overflow

  00021	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN8@Allocate_m:

; 139  :     }
; 140  : 
; 141  :     const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));

  00026	8b 55 e8	 mov	 edx, DWORD PTR __Block_size$[ebp]
  00029	52		 push	 edx
  0002a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0002f	83 c4 04	 add	 esp, 4
  00032	89 45 f4	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Allocate_m:

; 142  :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

  00035	83 7d f4 00	 cmp	 DWORD PTR __Ptr_container$[ebp], 0
  00039	74 02		 je	 SHORT $LN7@Allocate_m
  0003b	eb 4a		 jmp	 SHORT $LN2@Allocate_m
$LN7@Allocate_m:
  0003d	68 00 00 00 00	 push	 OFFSET $SG257810
  00042	68 00 00 00 00	 push	 OFFSET $SG257811
  00047	6a 00		 push	 0
  00049	68 8e 00 00 00	 push	 142			; 0000008eH
  0004e	68 00 00 00 00	 push	 OFFSET $SG257812
  00053	6a 02		 push	 2
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0005b	83 c4 18	 add	 esp, 24			; 00000018H
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN12@Allocate_m
  00063	cc		 int	 3
$LN12@Allocate_m:
  00064	6a 00		 push	 0
  00066	68 8e 00 00 00	 push	 142			; 0000008eH
  0006b	68 00 00 00 00	 push	 OFFSET $SG257813
  00070	68 00 00 00 00	 push	 OFFSET $SG257814
  00075	68 00 00 00 00	 push	 OFFSET $SG257815
  0007a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00080	83 c4 14	 add	 esp, 20			; 00000014H
  00083	33 c9		 xor	 ecx, ecx
  00085	75 b6		 jne	 SHORT $LN7@Allocate_m
$LN2@Allocate_m:
  00087	33 d2		 xor	 edx, edx
  00089	75 aa		 jne	 SHORT $LN4@Allocate_m

; 143  :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

  0008b	8b 45 f4	 mov	 eax, DWORD PTR __Ptr_container$[ebp]
  0008e	83 c0 27	 add	 eax, 39			; 00000027H
  00091	83 e0 e0	 and	 eax, -32		; ffffffe0H
  00094	89 45 ec	 mov	 DWORD PTR __Ptr$[ebp], eax

; 144  :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

  00097	b9 04 00 00 00	 mov	 ecx, 4
  0009c	6b d1 ff	 imul	 edx, ecx, -1
  0009f	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000a2	03 c2		 add	 eax, edx
  000a4	89 45 e4	 mov	 DWORD PTR tv88[ebp], eax
  000a7	8b 4d e4	 mov	 ecx, DWORD PTR tv88[ebp]
  000aa	89 4d f8	 mov	 DWORD PTR tv138[ebp], ecx
  000ad	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000b0	c1 ea 03	 shr	 edx, 3
  000b3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b9	88 45 ff	 mov	 BYTE PTR tv141[ebp], al
  000bc	80 7d ff 00	 cmp	 BYTE PTR tv141[ebp], 0
  000c0	74 1a		 je	 SHORT $LN14@Allocate_m
  000c2	8a 4d f8	 mov	 cl, BYTE PTR tv138[ebp]
  000c5	80 e1 07	 and	 cl, 7
  000c8	80 c1 03	 add	 cl, 3
  000cb	3a 4d ff	 cmp	 cl, BYTE PTR tv141[ebp]
  000ce	7c 0c		 jl	 SHORT $LN14@Allocate_m
  000d0	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ___asan_report_store4
  000d9	83 c4 04	 add	 esp, 4
$LN14@Allocate_m:
  000dc	8b 45 e4	 mov	 eax, DWORD PTR tv88[ebp]
  000df	8b 4d f4	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  000e2	89 08		 mov	 DWORD PTR [eax], ecx

; 145  : 
; 146  : #ifdef _DEBUG
; 147  :     static_cast<uintptr_t*>(_Ptr)[-2] = _Big_allocation_sentinel;

  000e4	ba 04 00 00 00	 mov	 edx, 4
  000e9	6b c2 fe	 imul	 eax, edx, -2
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ef	03 c8		 add	 ecx, eax
  000f1	89 4d e0	 mov	 DWORD PTR tv90[ebp], ecx
  000f4	8b 55 e0	 mov	 edx, DWORD PTR tv90[ebp]
  000f7	89 55 f0	 mov	 DWORD PTR tv128[ebp], edx
  000fa	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  000fd	c1 e8 03	 shr	 eax, 3
  00100	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00106	88 4d fe	 mov	 BYTE PTR tv131[ebp], cl
  00109	80 7d fe 00	 cmp	 BYTE PTR tv131[ebp], 0
  0010d	74 1a		 je	 SHORT $LN13@Allocate_m
  0010f	8a 55 f0	 mov	 dl, BYTE PTR tv128[ebp]
  00112	80 e2 07	 and	 dl, 7
  00115	80 c2 03	 add	 dl, 3
  00118	3a 55 fe	 cmp	 dl, BYTE PTR tv131[ebp]
  0011b	7c 0c		 jl	 SHORT $LN13@Allocate_m
  0011d	8b 45 f0	 mov	 eax, DWORD PTR tv128[ebp]
  00120	50		 push	 eax
  00121	e8 00 00 00 00	 call	 ___asan_report_store4
  00126	83 c4 04	 add	 esp, 4
$LN13@Allocate_m:
  00129	8b 4d e0	 mov	 ecx, DWORD PTR tv90[ebp]
  0012c	c7 01 fa fa fa
	fa		 mov	 DWORD PTR [ecx], -84215046 ; fafafafaH

; 148  : #endif // _DEBUG
; 149  :     return _Ptr;

  00132	8b 45 ec	 mov	 eax, DWORD PTR __Ptr$[ebp]
$LN11@Allocate_m:

; 150  : }

  00135	8b e5		 mov	 esp, ebp
  00137	5d		 pop	 ebp
  00138	c3		 ret	 0
??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ENDP ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__Location$ = 8						; size = 4
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::destroy_at<std::vector<int,std::allocator<int> > >, COMDAT

; 318  : _CONSTEXPR20_DYNALLOC void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 319  : #if _HAS_CXX20
; 320  :     if constexpr (is_array_v<_Ty>) {
; 321  :         _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
; 322  :     } else
; 323  : #endif // _HAS_CXX20
; 324  :     {
; 325  :         _Location->~_Ty();

  0000d	6a 00		 push	 0
  0000f	8b 4d 08	 mov	 ecx, DWORD PTR __Location$[ebp]
  00012	e8 00 00 00 00	 call	 ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z

; 326  :     }
; 327  : }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::destroy_at<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 985  : _CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 986  :     // deallocate a plain pointer using an allocator
; 987  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 988  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 989  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  0002c	6a 01		 push	 1
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 990  :     } else {
; 991  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 992  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 993  :     }
; 994  : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PAH@std@@YA?A_PABQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PAH@std@@YA?A_PABQAH@Z PROC		; std::_To_address<int *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@H@std@@YAPAHQAH@Z ; std::to_address<int>
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PAH@std@@YA?A_PABQAH@Z ENDP		; std::_To_address<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_To_address@PBH@std@@YA?A_PABQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_To_address@PBH@std@@YA?A_PABQBH@Z PROC		; std::_To_address<int const *>, COMDAT

; 4070 : _NODISCARD constexpr auto _To_address(const _Iter& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4071 :     _STL_INTERNAL_STATIC_ASSERT(contiguous_iterator<_Iter>);
; 4072 :     return _STD to_address(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00010	8b 08		 mov	 ecx, DWORD PTR [eax]
  00012	51		 push	 ecx
  00013	e8 00 00 00 00	 call	 ??$to_address@$$CBH@std@@YAPBHQBH@Z ; std::to_address<int const >
  00018	83 c4 04	 add	 esp, 4

; 4073 : }

  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??$_To_address@PBH@std@@YA?A_PABQBH@Z ENDP		; std::_To_address<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 251  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  0002c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4

; 256  :     } else

  00044	eb 29		 jmp	 SHORT $LN5@Deallocate
$LN2@Deallocate:

; 257  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00046	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0004d	72 10		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004f	8d 55 0c	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00052	52		 push	 edx
  00053	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0005c	83 c4 08	 add	 esp, 8
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006c	83 c4 08	 add	 esp, 8
$LN5@Deallocate:

; 265  :     }
; 266  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$03@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$03@std@@YAII@Z PROC			; std::_Get_size_of_n<4>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 3f		 mov	 DWORD PTR __Max_possible$1[ebp], 1073741823 ; 3fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 3f		 cmp	 DWORD PTR __Count$[ebp], 1073741823 ; 3fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 02	 shl	 eax, 2
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$03@std@@YAII@Z ENDP			; std::_Get_size_of_n<4>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$0BA@@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$0BA@@std@@YAII@Z PROC		; std::_Get_size_of_n<16>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 0f		 mov	 DWORD PTR __Max_possible$1[ebp], 268435455 ; 0fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 0f		 cmp	 DWORD PTR __Count$[ebp], 268435455 ; 0fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 04	 shl	 eax, 4
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$0BA@@std@@YAII@Z ENDP		; std::_Get_size_of_n<16>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -32					; size = 4
tv71 = -28						; size = 4
tv68 = -24						; size = 4
tv65 = -20						; size = 4
tv74 = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 614  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0002f	74 1a		 je	 SHORT $LN5@exchange
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv94[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  0003d	7c 0c		 jl	 SHORT $LN5@exchange
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN5@exchange:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	89 4d e0	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00053	8b 55 0c	 mov	 edx, DWORD PTR __New_val$[ebp]
  00056	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00062	c1 e9 03	 shr	 ecx, 3
  00065	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006b	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  0006e	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00072	74 18		 je	 SHORT $LN4@exchange
  00074	8a 45 f4	 mov	 al, BYTE PTR tv84[ebp]
  00077	24 07		 and	 al, 7
  00079	04 03		 add	 al, 3
  0007b	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@exchange
  00080	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ___asan_report_load4
  00089	83 c4 04	 add	 esp, 4
$LN4@exchange:
  0008c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0008f	89 55 e4	 mov	 DWORD PTR tv71[ebp], edx
  00092	8b 45 e4	 mov	 eax, DWORD PTR tv71[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00098	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0009b	c1 e9 03	 shr	 ecx, 3
  0009e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a4	88 55 fd	 mov	 BYTE PTR tv77[ebp], dl
  000a7	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000ab	74 18		 je	 SHORT $LN3@exchange
  000ad	8a 45 f0	 mov	 al, BYTE PTR tv74[ebp]
  000b0	24 07		 and	 al, 7
  000b2	04 03		 add	 al, 3
  000b4	3a 45 fd	 cmp	 al, BYTE PTR tv77[ebp]
  000b7	7c 0c		 jl	 SHORT $LN3@exchange
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ___asan_report_store4
  000c2	83 c4 04	 add	 esp, 4
$LN3@exchange:
  000c5	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 0a		 mov	 DWORD PTR [edx], ecx

; 618  :     return _Old_val;

  000cf	8b 45 e0	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 619  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z PROC ; std::_Allocate<8,std::_Default_allocate_traits,0>, COMDAT

; 230  : __declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 231  :     // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 232  : #if defined(_M_IX86) || defined(_M_X64)
; 233  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 234  :     if (!_STD is_constant_evaluated())

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	75 17		 jne	 SHORT $LN2@Allocate

; 235  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 236  :     {
; 237  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00019	81 7d 08 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00020	72 0e		 jb	 SHORT $LN2@Allocate

; 238  :             return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

  00022	8b 4d 08	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00025	51		 push	 ecx
  00026	e8 00 00 00 00	 call	 ??$_Allocate_manually_vector_aligned@U_Default_allocate_traits@std@@@std@@YAPAXI@Z ; std::_Allocate_manually_vector_aligned<std::_Default_allocate_traits>
  0002b	83 c4 04	 add	 esp, 4
  0002e	eb 16		 jmp	 SHORT $LN1@Allocate
$LN2@Allocate:

; 239  :         }
; 240  :     }
; 241  : #endif // defined(_M_IX86) || defined(_M_X64)
; 242  : 
; 243  :     if (_Bytes != 0) {

  00030	83 7d 08 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00034	74 0e		 je	 SHORT $LN4@Allocate

; 244  :         return _Traits::_Allocate(_Bytes);

  00036	8b 55 08	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00039	52		 push	 edx
  0003a	e8 00 00 00 00	 call	 ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ; std::_Default_allocate_traits::_Allocate
  0003f	83 c4 04	 add	 esp, 4
  00042	eb 02		 jmp	 SHORT $LN1@Allocate
$LN4@Allocate:

; 245  :     }
; 246  : 
; 247  :     return nullptr;

  00044	33 c0		 xor	 eax, eax
$LN1@Allocate:

; 248  : }

  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ENDP ; std::_Allocate<8,std::_Default_allocate_traits,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Get_size_of_n@$07@std@@YAII@Z
_TEXT	SEGMENT
__Max_possible$1 = -8					; size = 4
__Overflow_is_possible$ = -1				; size = 1
__Count$ = 8						; size = 4
??$_Get_size_of_n@$07@std@@YAII@Z PROC			; std::_Get_size_of_n<8>, COMDAT

; 59   : _NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 60   :     constexpr bool _Overflow_is_possible = _Ty_size > 1;

  00010	c6 45 ff 01	 mov	 BYTE PTR __Overflow_is_possible$[ebp], 1

; 61   : 
; 62   :     if constexpr (_Overflow_is_possible) {
; 63   :         constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;

  00014	c7 45 f8 ff ff
	ff 1f		 mov	 DWORD PTR __Max_possible$1[ebp], 536870911 ; 1fffffffH

; 64   :         if (_Count > _Max_possible) {

  0001b	81 7d 08 ff ff
	ff 1f		 cmp	 DWORD PTR __Count$[ebp], 536870911 ; 1fffffffH
  00022	76 05		 jbe	 SHORT $LN2@Get_size_o

; 65   :             _Throw_bad_array_new_length(); // multiply overflow

  00024	e8 00 00 00 00	 call	 ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
$LN2@Get_size_o:

; 66   :         }
; 67   :     }
; 68   : 
; 69   :     return _Count * _Ty_size;

  00029	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  0002c	c1 e0 03	 shl	 eax, 3
$LN3@Get_size_o:

; 70   : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??$_Get_size_of_n@$07@std@@YAII@Z ENDP			; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv66 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end, COMDAT
; _this$ = ecx

; 1534 :     _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_end() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1535 :         return _Mypair._Myval2._Mylast;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Unchecked_
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Unchecked_
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Unchecked_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1536 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv66 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ PROC ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin, COMDAT
; _this$ = ecx

; 1526 :     _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1527 :         return _Mypair._Myval2._Myfirst;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv66[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv66[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Unchecked_
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Unchecked_
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Unchecked_:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv66[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 1528 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ENDP ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
_TEXT	SEGMENT
tv75 = -48						; size = 4
_elem$1 = -44						; size = 4
tv79 = -40						; size = 4
_<end>$L0$2 = -36					; size = 4
_this$ = -32						; size = 4
$T3 = -28						; size = 4
_<range>$L0$4 = -24					; size = 4
tv64 = -20						; size = 4
tv82 = -16						; size = 4
tv92 = -12						; size = 4
_<begin>$L0$5 = -8					; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
??1Terrain@@QAE@XZ PROC					; Terrain::~Terrain
; _this$ = ecx

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H
  00006	89 4d e0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 17   : 	for (auto elem : *terrain) {

  00013	8b 45 e0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv92[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv92[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv95[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  00032	74 1a		 je	 SHORT $LN9@Terrain
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv92[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv95[ebp]
  00040	7c 0c		 jl	 SHORT $LN9@Terrain
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv92[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN9@Terrain:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	89 4d e8	 mov	 DWORD PTR _<range>$L0$4[ebp], ecx
  00056	8b 4d e8	 mov	 ecx, DWORD PTR _<range>$L0$4[ebp]
  00059	e8 00 00 00 00	 call	 ?_Unchecked_begin@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_begin
  0005e	89 45 f8	 mov	 DWORD PTR _<begin>$L0$5[ebp], eax
  00061	8b 4d e8	 mov	 ecx, DWORD PTR _<range>$L0$4[ebp]
  00064	e8 00 00 00 00	 call	 ?_Unchecked_end@?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@QAEPAPAVBlock@@XZ ; std::vector<Block *,std::allocator<Block *> >::_Unchecked_end
  00069	89 45 dc	 mov	 DWORD PTR _<end>$L0$2[ebp], eax
  0006c	eb 09		 jmp	 SHORT $LN4@Terrain
$LN2@Terrain:
  0006e	8b 55 f8	 mov	 edx, DWORD PTR _<begin>$L0$5[ebp]
  00071	83 c2 04	 add	 edx, 4
  00074	89 55 f8	 mov	 DWORD PTR _<begin>$L0$5[ebp], edx
$LN4@Terrain:
  00077	8b 45 f8	 mov	 eax, DWORD PTR _<begin>$L0$5[ebp]
  0007a	3b 45 dc	 cmp	 eax, DWORD PTR _<end>$L0$2[ebp]
  0007d	74 67		 je	 SHORT $LN5@Terrain
  0007f	8b 4d f8	 mov	 ecx, DWORD PTR _<begin>$L0$5[ebp]
  00082	89 4d d8	 mov	 DWORD PTR tv79[ebp], ecx
  00085	8b 55 d8	 mov	 edx, DWORD PTR tv79[ebp]
  00088	89 55 f0	 mov	 DWORD PTR tv82[ebp], edx
  0008b	8b 45 f0	 mov	 eax, DWORD PTR tv82[ebp]
  0008e	c1 e8 03	 shr	 eax, 3
  00091	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00097	88 4d fe	 mov	 BYTE PTR tv85[ebp], cl
  0009a	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  0009e	74 1a		 je	 SHORT $LN8@Terrain
  000a0	8a 55 f0	 mov	 dl, BYTE PTR tv82[ebp]
  000a3	80 e2 07	 and	 dl, 7
  000a6	80 c2 03	 add	 dl, 3
  000a9	3a 55 fe	 cmp	 dl, BYTE PTR tv85[ebp]
  000ac	7c 0c		 jl	 SHORT $LN8@Terrain
  000ae	8b 45 f0	 mov	 eax, DWORD PTR tv82[ebp]
  000b1	50		 push	 eax
  000b2	e8 00 00 00 00	 call	 ___asan_report_load4
  000b7	83 c4 04	 add	 esp, 4
$LN8@Terrain:
  000ba	8b 4d f8	 mov	 ecx, DWORD PTR _<begin>$L0$5[ebp]
  000bd	8b 11		 mov	 edx, DWORD PTR [ecx]
  000bf	89 55 d4	 mov	 DWORD PTR _elem$1[ebp], edx

; 18   : 			delete(elem);

  000c2	8b 45 d4	 mov	 eax, DWORD PTR _elem$1[ebp]
  000c5	89 45 e4	 mov	 DWORD PTR $T3[ebp], eax
  000c8	83 7d e4 00	 cmp	 DWORD PTR $T3[ebp], 0
  000cc	74 0f		 je	 SHORT $LN6@Terrain
  000ce	6a 01		 push	 1
  000d0	8b 4d e4	 mov	 ecx, DWORD PTR $T3[ebp]
  000d3	e8 00 00 00 00	 call	 ??_GBlock@@QAEPAXI@Z
  000d8	89 45 d0	 mov	 DWORD PTR tv75[ebp], eax
  000db	eb 07		 jmp	 SHORT $LN7@Terrain
$LN6@Terrain:
  000dd	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR tv75[ebp], 0
$LN7@Terrain:

; 19   : 		
; 20   : 	}

  000e4	eb 88		 jmp	 SHORT $LN2@Terrain
$LN5@Terrain:

; 21   : }

  000e6	8b e5		 mov	 esp, ebp
  000e8	5d		 pop	 ebp
  000e9	c3		 ret	 0
??1Terrain@@QAE@XZ ENDP					; Terrain::~Terrain
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
_TEXT	SEGMENT
tv67 = -40						; size = 4
tv72 = -36						; size = 4
tv64 = -32						; size = 4
tv68 = -28						; size = 4
tv65 = -24						; size = 4
tv80 = -20						; size = 4
_this$ = -16						; size = 4
tv90 = -12						; size = 4
tv132 = -8						; size = 4
tv83 = -3						; size = 1
tv93 = -2						; size = 1
tv135 = -1						; size = 1
_level$ = 8						; size = 4
?loadTerrain@Terrain@@QAEXH@Z PROC			; Terrain::loadTerrain
; _this$ = ecx

; 11   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 12   : 	terrain = TC->ConstructTerrainFromLevelFile(level, *RP);

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 e8	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv132[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv132[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv135[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv135[ebp], 0
  00035	74 1a		 je	 SHORT $LN5@loadTerrai
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv132[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv135[ebp]
  00043	7c 0c		 jl	 SHORT $LN5@loadTerrai
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv132[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN5@loadTerrai:
  00051	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	89 4d dc	 mov	 DWORD PTR tv72[ebp], ecx
  00059	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  0005c	83 c2 04	 add	 edx, 4
  0005f	89 55 e4	 mov	 DWORD PTR tv68[ebp], edx
  00062	8b 45 e4	 mov	 eax, DWORD PTR tv68[ebp]
  00065	89 45 f4	 mov	 DWORD PTR tv90[ebp], eax
  00068	8b 4d f4	 mov	 ecx, DWORD PTR tv90[ebp]
  0006b	c1 e9 03	 shr	 ecx, 3
  0006e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00074	88 55 fe	 mov	 BYTE PTR tv93[ebp], dl
  00077	80 7d fe 00	 cmp	 BYTE PTR tv93[ebp], 0
  0007b	74 18		 je	 SHORT $LN4@loadTerrai
  0007d	8a 45 f4	 mov	 al, BYTE PTR tv90[ebp]
  00080	24 07		 and	 al, 7
  00082	04 03		 add	 al, 3
  00084	3a 45 fe	 cmp	 al, BYTE PTR tv93[ebp]
  00087	7c 0c		 jl	 SHORT $LN4@loadTerrai
  00089	8b 4d f4	 mov	 ecx, DWORD PTR tv90[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 ___asan_report_load4
  00092	83 c4 04	 add	 esp, 4
$LN4@loadTerrai:
  00095	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  00098	8b 02		 mov	 eax, DWORD PTR [edx]
  0009a	50		 push	 eax
  0009b	8b 4d 08	 mov	 ecx, DWORD PTR _level$[ebp]
  0009e	51		 push	 ecx
  0009f	8b 4d dc	 mov	 ecx, DWORD PTR tv72[ebp]
  000a2	e8 00 00 00 00	 call	 ?ConstructTerrainFromLevelFile@TerrainConstructor@@QAEPAV?$vector@PAVBlock@@V?$allocator@PAVBlock@@@std@@@std@@HAAVRessourcePack@@@Z ; TerrainConstructor::ConstructTerrainFromLevelFile
  000a7	89 45 d8	 mov	 DWORD PTR tv67[ebp], eax
  000aa	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  000ad	89 55 e0	 mov	 DWORD PTR tv64[ebp], edx
  000b0	8b 45 e0	 mov	 eax, DWORD PTR tv64[ebp]
  000b3	89 45 ec	 mov	 DWORD PTR tv80[ebp], eax
  000b6	8b 4d ec	 mov	 ecx, DWORD PTR tv80[ebp]
  000b9	c1 e9 03	 shr	 ecx, 3
  000bc	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c2	88 55 fd	 mov	 BYTE PTR tv83[ebp], dl
  000c5	80 7d fd 00	 cmp	 BYTE PTR tv83[ebp], 0
  000c9	74 18		 je	 SHORT $LN3@loadTerrai
  000cb	8a 45 ec	 mov	 al, BYTE PTR tv80[ebp]
  000ce	24 07		 and	 al, 7
  000d0	04 03		 add	 al, 3
  000d2	3a 45 fd	 cmp	 al, BYTE PTR tv83[ebp]
  000d5	7c 0c		 jl	 SHORT $LN3@loadTerrai
  000d7	8b 4d ec	 mov	 ecx, DWORD PTR tv80[ebp]
  000da	51		 push	 ecx
  000db	e8 00 00 00 00	 call	 ___asan_report_store4
  000e0	83 c4 04	 add	 esp, 4
$LN3@loadTerrai:
  000e3	8b 55 e0	 mov	 edx, DWORD PTR tv64[ebp]
  000e6	8b 45 d8	 mov	 eax, DWORD PTR tv67[ebp]
  000e9	89 02		 mov	 DWORD PTR [edx], eax

; 13   : }

  000eb	8b e5		 mov	 esp, ebp
  000ed	5d		 pop	 ebp
  000ee	c2 04 00	 ret	 4
?loadTerrain@Terrain@@QAEXH@Z ENDP			; Terrain::loadTerrain
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
_TEXT	SEGMENT
$T2 = -64						; size = 4
tv74 = -60						; size = 4
tv66 = -56						; size = 4
tv80 = -52						; size = 4
tv65 = -48						; size = 4
tv64 = -44						; size = 4
tv92 = -40						; size = 4
tv134 = -36						; size = 4
$T3 = -32						; size = 4
tv144 = -28						; size = 4
tv154 = -24						; size = 4
_this$ = -20						; size = 4
tv95 = -16						; size = 1
tv137 = -15						; size = 1
tv147 = -14						; size = 1
tv157 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_rp$ = 8						; size = 4
??0Terrain@@QAE@PAVRessourcePack@@@Z PROC		; Terrain::Terrain
; _this$ = ecx

; 4    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0Terrain@@QAE@PAVRessourcePack@@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 34	 sub	 esp, 52			; 00000034H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.h

; 10   : 	std::vector<Block*>* terrain = nullptr;

  00032	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  00038	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  0003b	89 4d e8	 mov	 DWORD PTR tv154[ebp], ecx
  0003e	8b 55 e8	 mov	 edx, DWORD PTR tv154[ebp]
  00041	c1 ea 03	 shr	 edx, 3
  00044	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0004a	88 45 f3	 mov	 BYTE PTR tv157[ebp], al
  0004d	80 7d f3 00	 cmp	 BYTE PTR tv157[ebp], 0
  00051	74 1a		 je	 SHORT $LN9@Terrain
  00053	8a 4d e8	 mov	 cl, BYTE PTR tv154[ebp]
  00056	80 e1 07	 and	 cl, 7
  00059	80 c1 03	 add	 cl, 3
  0005c	3a 4d f3	 cmp	 cl, BYTE PTR tv157[ebp]
  0005f	7c 0c		 jl	 SHORT $LN9@Terrain
  00061	8b 55 e8	 mov	 edx, DWORD PTR tv154[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 ___asan_report_store4
  0006a	83 c4 04	 add	 esp, 4
$LN9@Terrain:
  0006d	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00070	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 11   : 	RessourcePack* RP = nullptr;

  00076	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00079	83 c1 04	 add	 ecx, 4
  0007c	89 4d d0	 mov	 DWORD PTR tv65[ebp], ecx
  0007f	8b 55 d0	 mov	 edx, DWORD PTR tv65[ebp]
  00082	89 55 e4	 mov	 DWORD PTR tv144[ebp], edx
  00085	8b 45 e4	 mov	 eax, DWORD PTR tv144[ebp]
  00088	c1 e8 03	 shr	 eax, 3
  0008b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00091	88 4d f2	 mov	 BYTE PTR tv147[ebp], cl
  00094	80 7d f2 00	 cmp	 BYTE PTR tv147[ebp], 0
  00098	74 1a		 je	 SHORT $LN8@Terrain
  0009a	8a 55 e4	 mov	 dl, BYTE PTR tv144[ebp]
  0009d	80 e2 07	 and	 dl, 7
  000a0	80 c2 03	 add	 dl, 3
  000a3	3a 55 f2	 cmp	 dl, BYTE PTR tv147[ebp]
  000a6	7c 0c		 jl	 SHORT $LN8@Terrain
  000a8	8b 45 e4	 mov	 eax, DWORD PTR tv144[ebp]
  000ab	50		 push	 eax
  000ac	e8 00 00 00 00	 call	 ___asan_report_store4
  000b1	83 c4 04	 add	 esp, 4
$LN8@Terrain:
  000b4	8b 4d d0	 mov	 ecx, DWORD PTR tv65[ebp]
  000b7	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 12   : 	TerrainConstructor *TC = new TerrainConstructor();

  000bd	6a 10		 push	 16			; 00000010H
  000bf	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  000c4	83 c4 04	 add	 esp, 4
  000c7	89 45 e0	 mov	 DWORD PTR $T3[ebp], eax
  000ca	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  000d1	83 7d e0 00	 cmp	 DWORD PTR $T3[ebp], 0
  000d5	74 17		 je	 SHORT $LN3@Terrain
  000d7	6a 10		 push	 16			; 00000010H
  000d9	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  000dc	e8 00 00 00 00	 call	 ?__autoclassinit2@TerrainConstructor@@QAEXI@Z
  000e1	8b 4d e0	 mov	 ecx, DWORD PTR $T3[ebp]
  000e4	e8 00 00 00 00	 call	 ??0TerrainConstructor@@QAE@XZ ; TerrainConstructor::TerrainConstructor
  000e9	89 45 cc	 mov	 DWORD PTR tv80[ebp], eax
  000ec	eb 07		 jmp	 SHORT $LN4@Terrain
$LN3@Terrain:
  000ee	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR tv80[ebp], 0
$LN4@Terrain:
  000f5	8b 55 cc	 mov	 edx, DWORD PTR tv80[ebp]
  000f8	89 55 c0	 mov	 DWORD PTR $T2[ebp], edx
  000fb	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00102	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00105	83 c0 08	 add	 eax, 8
  00108	89 45 c8	 mov	 DWORD PTR tv66[ebp], eax
  0010b	8b 4d c8	 mov	 ecx, DWORD PTR tv66[ebp]
  0010e	89 4d dc	 mov	 DWORD PTR tv134[ebp], ecx
  00111	8b 55 dc	 mov	 edx, DWORD PTR tv134[ebp]
  00114	c1 ea 03	 shr	 edx, 3
  00117	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0011d	88 45 f1	 mov	 BYTE PTR tv137[ebp], al
  00120	80 7d f1 00	 cmp	 BYTE PTR tv137[ebp], 0
  00124	74 1a		 je	 SHORT $LN7@Terrain
  00126	8a 4d dc	 mov	 cl, BYTE PTR tv134[ebp]
  00129	80 e1 07	 and	 cl, 7
  0012c	80 c1 03	 add	 cl, 3
  0012f	3a 4d f1	 cmp	 cl, BYTE PTR tv137[ebp]
  00132	7c 0c		 jl	 SHORT $LN7@Terrain
  00134	8b 55 dc	 mov	 edx, DWORD PTR tv134[ebp]
  00137	52		 push	 edx
  00138	e8 00 00 00 00	 call	 ___asan_report_store4
  0013d	83 c4 04	 add	 esp, 4
$LN7@Terrain:
  00140	8b 45 c8	 mov	 eax, DWORD PTR tv66[ebp]
  00143	8b 4d c0	 mov	 ecx, DWORD PTR $T2[ebp]
  00146	89 08		 mov	 DWORD PTR [eax], ecx
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp

; 5    : 	RP = rp;

  00148	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  0014b	83 c2 04	 add	 edx, 4
  0014e	89 55 c4	 mov	 DWORD PTR tv74[ebp], edx
  00151	8b 45 c4	 mov	 eax, DWORD PTR tv74[ebp]
  00154	89 45 d8	 mov	 DWORD PTR tv92[ebp], eax
  00157	8b 4d d8	 mov	 ecx, DWORD PTR tv92[ebp]
  0015a	c1 e9 03	 shr	 ecx, 3
  0015d	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00163	88 55 f0	 mov	 BYTE PTR tv95[ebp], dl
  00166	80 7d f0 00	 cmp	 BYTE PTR tv95[ebp], 0
  0016a	74 18		 je	 SHORT $LN6@Terrain
  0016c	8a 45 d8	 mov	 al, BYTE PTR tv92[ebp]
  0016f	24 07		 and	 al, 7
  00171	04 03		 add	 al, 3
  00173	3a 45 f0	 cmp	 al, BYTE PTR tv95[ebp]
  00176	7c 0c		 jl	 SHORT $LN6@Terrain
  00178	8b 4d d8	 mov	 ecx, DWORD PTR tv92[ebp]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 ___asan_report_store4
  00181	83 c4 04	 add	 esp, 4
$LN6@Terrain:
  00184	8b 55 c4	 mov	 edx, DWORD PTR tv74[ebp]
  00187	8b 45 08	 mov	 eax, DWORD PTR _rp$[ebp]
  0018a	89 02		 mov	 DWORD PTR [edx], eax

; 6    : 
; 7    : 	
; 8    : }

  0018c	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0018f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00192	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00199	59		 pop	 ecx
  0019a	8b e5		 mov	 esp, ebp
  0019c	5d		 pop	 ebp
  0019d	c2 04 00	 ret	 4
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$??0Terrain@@QAE@PAVRessourcePack@@@Z$0:
  00000	6a 10		 push	 16			; 00000010H
  00002	8b 45 e0	 mov	 eax, DWORD PTR $T3[ebp]
  00005	50		 push	 eax
  00006	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0000b	83 c4 08	 add	 esp, 8
  0000e	c3		 ret	 0
  0000f	cc		 int	 3
  00010	cc		 int	 3
  00011	cc		 int	 3
  00012	cc		 int	 3
  00013	cc		 int	 3
__ehhandler$??0Terrain@@QAE@PAVRessourcePack@@@Z:
  00014	90		 npad	 1
  00015	90		 npad	 1
  00016	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0001a	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0001d	8b 4a c8	 mov	 ecx, DWORD PTR [edx-56]
  00020	33 c8		 xor	 ecx, eax
  00022	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00027	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0Terrain@@QAE@PAVRessourcePack@@@Z
  0002c	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0Terrain@@QAE@PAVRessourcePack@@@Z ENDP		; Terrain::Terrain
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@TerrainConstructor@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@TerrainConstructor@@QAEXI@Z PROC	; TerrainConstructor::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@TerrainConstructor@@QAEXI@Z ENDP	; TerrainConstructor::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_GBlock@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GBlock@@QAEPAXI@Z PROC				; Block::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1Block@@QAE@XZ	; Block::~Block
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 1c		 push	 28			; 0000001cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_GBlock@@QAEPAXI@Z ENDP				; Block::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??__Flevel1@@YAXXZ
text$yd	SEGMENT
??__Flevel1@@YAXXZ PROC					; `dynamic atexit destructor for 'level1'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  00008	e8 00 00 00 00	 call	 ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??__Flevel1@@YAXXZ ENDP					; `dynamic atexit destructor for 'level1''
text$yd	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Levels.h
;	COMDAT ??__Elevel1@@YAXXZ
text$di	SEGMENT
__asan_gen_0$ = -2248					; size = 4
__asan_gen_1$ = -2244					; size = 4
__asan_gen_2$ = -2240					; size = 4
$T3 = -2232						; size = 224
$T4 = -1976						; size = 36
$T5 = -1904						; size = 36
$T6 = -1832						; size = 36
$T7 = -1760						; size = 36
$T8 = -1688						; size = 36
$T9 = -1616						; size = 36
$T10 = -1544						; size = 36
$T11 = -1472						; size = 36
$T12 = -1400						; size = 36
$T13 = -1328						; size = 36
$T14 = -1256						; size = 36
$T15 = -1184						; size = 36
$T16 = -1112						; size = 36
$T17 = -1040						; size = 36
$T18 = -968						; size = 1
$T19 = -952						; size = 1
$T20 = -936						; size = 8
$T21 = -920						; size = 1
$T22 = -904						; size = 8
$T23 = -888						; size = 1
$T24 = -872						; size = 8
$T25 = -856						; size = 1
$T26 = -840						; size = 8
$T27 = -824						; size = 1
$T28 = -808						; size = 8
$T29 = -792						; size = 1
$T30 = -776						; size = 8
$T31 = -760						; size = 1
$T32 = -744						; size = 8
$T33 = -728						; size = 1
$T34 = -712						; size = 8
$T35 = -696						; size = 1
$T36 = -680						; size = 8
$T37 = -664						; size = 1
$T38 = -648						; size = 8
$T39 = -632						; size = 1
$T40 = -616						; size = 8
$T41 = -600						; size = 1
$T42 = -584						; size = 8
$T43 = -568						; size = 1
$T44 = -552						; size = 8
$T45 = -536						; size = 1
$T46 = -520						; size = 8
$T47 = -504						; size = 8
tv1007 = -460						; size = 4
tv918 = -456						; size = 4
tv924 = -452						; size = 4
tv930 = -448						; size = 4
tv936 = -444						; size = 4
tv942 = -440						; size = 4
tv948 = -436						; size = 4
tv954 = -432						; size = 4
tv960 = -428						; size = 4
tv966 = -424						; size = 4
tv972 = -420						; size = 4
tv978 = -416						; size = 4
tv984 = -412						; size = 4
tv990 = -408						; size = 4
tv996 = -404						; size = 4
tv1002 = -400						; size = 4
tv919 = -396						; size = 4
tv1185 = -392						; size = 4
tv1172 = -388						; size = 4
tv1159 = -384						; size = 4
tv1146 = -380						; size = 4
tv1133 = -376						; size = 4
tv1120 = -372						; size = 4
tv1107 = -368						; size = 4
tv1094 = -364						; size = 4
tv1081 = -360						; size = 4
tv1068 = -356						; size = 4
tv1055 = -352						; size = 4
tv1042 = -348						; size = 4
tv1029 = -344						; size = 4
tv1016 = -340						; size = 4
tv916 = -336						; size = 4
tv923 = -332						; size = 4
tv928 = -328						; size = 4
tv929 = -324						; size = 4
tv934 = -320						; size = 4
tv935 = -316						; size = 4
tv940 = -312						; size = 4
tv941 = -308						; size = 4
tv946 = -304						; size = 4
tv947 = -300						; size = 4
tv952 = -296						; size = 4
tv953 = -292						; size = 4
tv958 = -288						; size = 4
tv959 = -284						; size = 4
tv964 = -280						; size = 4
tv965 = -276						; size = 4
tv970 = -272						; size = 4
tv971 = -268						; size = 4
tv976 = -264						; size = 4
tv977 = -260						; size = 4
tv982 = -256						; size = 4
tv983 = -252						; size = 4
tv988 = -248						; size = 4
tv989 = -244						; size = 4
tv994 = -240						; size = 4
tv995 = -236						; size = 4
tv1000 = -232						; size = 4
tv1001 = -228						; size = 4
tv1006 = -224						; size = 4
tv84 = -220						; size = 4
tv164 = -216						; size = 4
tv179 = -212						; size = 4
tv226 = -208						; size = 4
tv241 = -204						; size = 4
tv320 = -200						; size = 4
tv335 = -196						; size = 4
tv350 = -192						; size = 4
tv397 = -188						; size = 4
tv412 = -184						; size = 4
tv459 = -180						; size = 4
tv474 = -176						; size = 4
tv553 = -172						; size = 4
tv568 = -168						; size = 4
tv612 = -164						; size = 4
tv1195 = -160						; size = 4
tv1204 = -156						; size = 4
$T48 = -152						; size = 8
$T49 = -144						; size = 8
$T50 = -136						; size = 8
$T51 = -128						; size = 8
$T52 = -120						; size = 8
$T53 = -112						; size = 8
$T54 = -104						; size = 8
$T55 = -96						; size = 8
$T56 = -88						; size = 8
$T57 = -80						; size = 8
$T58 = -72						; size = 8
$T59 = -64						; size = 8
$T60 = -56						; size = 8
$T61 = -48						; size = 8
$T62 = -40						; size = 8
__$EHRec$ = -12						; size = 12
??__Elevel1@@YAXXZ PROC					; `dynamic initializer for 'level1'', COMDAT

; 19   : };

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??__Elevel1@@YAXXZ
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 30 f7 ff
	ff		 add	 esp, -2256		; fffff730H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 85 38 f7 ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00046	c7 85 3c f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??__Elevel1@@YAXXZ
  00050	c7 85 40 f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??__Elevel1@@YAXXZ ; `dynamic initializer for 'level1''
  0005a	8d 85 38 f7 ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv916[ebp], eax
  00066	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv916[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 8d 38 fe ff
	ff		 mov	 DWORD PTR tv918[ebp], ecx
  0007b	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  00080	8b 85 38 fe ff
	ff		 mov	 eax, DWORD PTR tv918[ebp]
  00086	66 89 10	 mov	 WORD PTR [eax], dx
  00089	8b 8d 38 fe ff
	ff		 mov	 ecx, DWORD PTR tv918[ebp]
  0008f	83 c1 02	 add	 ecx, 2
  00092	89 8d 74 fe ff
	ff		 mov	 DWORD PTR tv919[ebp], ecx
  00098	6a 1c		 push	 28			; 0000001cH
  0009a	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR tv919[ebp]
  000a0	52		 push	 edx
  000a1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000a6	83 c4 08	 add	 esp, 8
  000a9	8b 85 74 fe ff
	ff		 mov	 eax, DWORD PTR tv919[ebp]
  000af	83 c0 1c	 add	 eax, 28			; 0000001cH
  000b2	89 85 b4 fe ff
	ff		 mov	 DWORD PTR tv923[ebp], eax
  000b8	8b 8d b4 fe ff
	ff		 mov	 ecx, DWORD PTR tv923[ebp]
  000be	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  000c4	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  000ca	83 c2 22	 add	 edx, 34			; 00000022H
  000cd	89 95 3c fe ff
	ff		 mov	 DWORD PTR tv924[ebp], edx
  000d3	6a 04		 push	 4
  000d5	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR tv924[ebp]
  000db	50		 push	 eax
  000dc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000e1	83 c4 08	 add	 esp, 8
  000e4	8b 8d 3c fe ff
	ff		 mov	 ecx, DWORD PTR tv924[ebp]
  000ea	83 c1 04	 add	 ecx, 4
  000ed	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv928[ebp], ecx
  000f3	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv928[ebp]
  000f9	c6 02 04	 mov	 BYTE PTR [edx], 4
  000fc	8b 85 3c fe ff
	ff		 mov	 eax, DWORD PTR tv924[ebp]
  00102	83 c0 05	 add	 eax, 5
  00105	89 85 bc fe ff
	ff		 mov	 DWORD PTR tv929[ebp], eax
  0010b	8b 8d bc fe ff
	ff		 mov	 ecx, DWORD PTR tv929[ebp]
  00111	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00117	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0011d	83 c2 2b	 add	 edx, 43			; 0000002bH
  00120	89 95 40 fe ff
	ff		 mov	 DWORD PTR tv930[ebp], edx
  00126	6a 04		 push	 4
  00128	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  0012e	50		 push	 eax
  0012f	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00134	83 c4 08	 add	 esp, 8
  00137	8b 8d 40 fe ff
	ff		 mov	 ecx, DWORD PTR tv930[ebp]
  0013d	83 c1 04	 add	 ecx, 4
  00140	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv934[ebp], ecx
  00146	8b 95 c0 fe ff
	ff		 mov	 edx, DWORD PTR tv934[ebp]
  0014c	c6 02 04	 mov	 BYTE PTR [edx], 4
  0014f	8b 85 40 fe ff
	ff		 mov	 eax, DWORD PTR tv930[ebp]
  00155	83 c0 05	 add	 eax, 5
  00158	89 85 c4 fe ff
	ff		 mov	 DWORD PTR tv935[ebp], eax
  0015e	8b 8d c4 fe ff
	ff		 mov	 ecx, DWORD PTR tv935[ebp]
  00164	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  0016a	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00170	83 c2 34	 add	 edx, 52			; 00000034H
  00173	89 95 44 fe ff
	ff		 mov	 DWORD PTR tv936[ebp], edx
  00179	6a 04		 push	 4
  0017b	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv936[ebp]
  00181	50		 push	 eax
  00182	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00187	83 c4 08	 add	 esp, 8
  0018a	8b 8d 44 fe ff
	ff		 mov	 ecx, DWORD PTR tv936[ebp]
  00190	83 c1 04	 add	 ecx, 4
  00193	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv940[ebp], ecx
  00199	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv940[ebp]
  0019f	c6 02 04	 mov	 BYTE PTR [edx], 4
  001a2	8b 85 44 fe ff
	ff		 mov	 eax, DWORD PTR tv936[ebp]
  001a8	83 c0 05	 add	 eax, 5
  001ab	89 85 cc fe ff
	ff		 mov	 DWORD PTR tv941[ebp], eax
  001b1	8b 8d cc fe ff
	ff		 mov	 ecx, DWORD PTR tv941[ebp]
  001b7	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  001bd	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  001c3	83 c2 3d	 add	 edx, 61			; 0000003dH
  001c6	89 95 48 fe ff
	ff		 mov	 DWORD PTR tv942[ebp], edx
  001cc	6a 04		 push	 4
  001ce	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  001d4	50		 push	 eax
  001d5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001da	83 c4 08	 add	 esp, 8
  001dd	8b 8d 48 fe ff
	ff		 mov	 ecx, DWORD PTR tv942[ebp]
  001e3	83 c1 04	 add	 ecx, 4
  001e6	89 8d d0 fe ff
	ff		 mov	 DWORD PTR tv946[ebp], ecx
  001ec	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv946[ebp]
  001f2	c6 02 04	 mov	 BYTE PTR [edx], 4
  001f5	8b 85 48 fe ff
	ff		 mov	 eax, DWORD PTR tv942[ebp]
  001fb	83 c0 05	 add	 eax, 5
  001fe	89 85 d4 fe ff
	ff		 mov	 DWORD PTR tv947[ebp], eax
  00204	8b 8d d4 fe ff
	ff		 mov	 ecx, DWORD PTR tv947[ebp]
  0020a	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00210	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00216	83 c2 46	 add	 edx, 70			; 00000046H
  00219	89 95 4c fe ff
	ff		 mov	 DWORD PTR tv948[ebp], edx
  0021f	6a 04		 push	 4
  00221	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv948[ebp]
  00227	50		 push	 eax
  00228	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022d	83 c4 08	 add	 esp, 8
  00230	8b 8d 4c fe ff
	ff		 mov	 ecx, DWORD PTR tv948[ebp]
  00236	83 c1 04	 add	 ecx, 4
  00239	89 8d d8 fe ff
	ff		 mov	 DWORD PTR tv952[ebp], ecx
  0023f	8b 95 d8 fe ff
	ff		 mov	 edx, DWORD PTR tv952[ebp]
  00245	c6 02 04	 mov	 BYTE PTR [edx], 4
  00248	8b 85 4c fe ff
	ff		 mov	 eax, DWORD PTR tv948[ebp]
  0024e	83 c0 05	 add	 eax, 5
  00251	89 85 dc fe ff
	ff		 mov	 DWORD PTR tv953[ebp], eax
  00257	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv953[ebp]
  0025d	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00263	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00269	83 c2 4f	 add	 edx, 79			; 0000004fH
  0026c	89 95 50 fe ff
	ff		 mov	 DWORD PTR tv954[ebp], edx
  00272	6a 04		 push	 4
  00274	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv954[ebp]
  0027a	50		 push	 eax
  0027b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00280	83 c4 08	 add	 esp, 8
  00283	8b 8d 50 fe ff
	ff		 mov	 ecx, DWORD PTR tv954[ebp]
  00289	83 c1 04	 add	 ecx, 4
  0028c	89 8d e0 fe ff
	ff		 mov	 DWORD PTR tv958[ebp], ecx
  00292	8b 95 e0 fe ff
	ff		 mov	 edx, DWORD PTR tv958[ebp]
  00298	c6 02 04	 mov	 BYTE PTR [edx], 4
  0029b	8b 85 50 fe ff
	ff		 mov	 eax, DWORD PTR tv954[ebp]
  002a1	83 c0 05	 add	 eax, 5
  002a4	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv959[ebp], eax
  002aa	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv959[ebp]
  002b0	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  002b6	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  002bc	83 c2 58	 add	 edx, 88			; 00000058H
  002bf	89 95 54 fe ff
	ff		 mov	 DWORD PTR tv960[ebp], edx
  002c5	6a 04		 push	 4
  002c7	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv960[ebp]
  002cd	50		 push	 eax
  002ce	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  002d3	83 c4 08	 add	 esp, 8
  002d6	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR tv960[ebp]
  002dc	83 c1 04	 add	 ecx, 4
  002df	89 8d e8 fe ff
	ff		 mov	 DWORD PTR tv964[ebp], ecx
  002e5	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv964[ebp]
  002eb	c6 02 04	 mov	 BYTE PTR [edx], 4
  002ee	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR tv960[ebp]
  002f4	83 c0 05	 add	 eax, 5
  002f7	89 85 ec fe ff
	ff		 mov	 DWORD PTR tv965[ebp], eax
  002fd	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv965[ebp]
  00303	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00309	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0030f	83 c2 61	 add	 edx, 97			; 00000061H
  00312	89 95 58 fe ff
	ff		 mov	 DWORD PTR tv966[ebp], edx
  00318	6a 04		 push	 4
  0031a	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv966[ebp]
  00320	50		 push	 eax
  00321	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00326	83 c4 08	 add	 esp, 8
  00329	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv966[ebp]
  0032f	83 c1 04	 add	 ecx, 4
  00332	89 8d f0 fe ff
	ff		 mov	 DWORD PTR tv970[ebp], ecx
  00338	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv970[ebp]
  0033e	c6 02 04	 mov	 BYTE PTR [edx], 4
  00341	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv966[ebp]
  00347	83 c0 05	 add	 eax, 5
  0034a	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv971[ebp], eax
  00350	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv971[ebp]
  00356	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  0035c	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00362	83 c2 6a	 add	 edx, 106		; 0000006aH
  00365	89 95 5c fe ff
	ff		 mov	 DWORD PTR tv972[ebp], edx
  0036b	6a 04		 push	 4
  0036d	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv972[ebp]
  00373	50		 push	 eax
  00374	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00379	83 c4 08	 add	 esp, 8
  0037c	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR tv972[ebp]
  00382	83 c1 04	 add	 ecx, 4
  00385	89 8d f8 fe ff
	ff		 mov	 DWORD PTR tv976[ebp], ecx
  0038b	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv976[ebp]
  00391	c6 02 04	 mov	 BYTE PTR [edx], 4
  00394	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR tv972[ebp]
  0039a	83 c0 05	 add	 eax, 5
  0039d	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv977[ebp], eax
  003a3	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR tv977[ebp]
  003a9	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  003af	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  003b5	83 c2 73	 add	 edx, 115		; 00000073H
  003b8	89 95 60 fe ff
	ff		 mov	 DWORD PTR tv978[ebp], edx
  003be	6a 04		 push	 4
  003c0	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  003c6	50		 push	 eax
  003c7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003cc	83 c4 08	 add	 esp, 8
  003cf	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR tv978[ebp]
  003d5	83 c1 04	 add	 ecx, 4
  003d8	89 8d 00 ff ff
	ff		 mov	 DWORD PTR tv982[ebp], ecx
  003de	8b 95 00 ff ff
	ff		 mov	 edx, DWORD PTR tv982[ebp]
  003e4	c6 02 04	 mov	 BYTE PTR [edx], 4
  003e7	8b 85 60 fe ff
	ff		 mov	 eax, DWORD PTR tv978[ebp]
  003ed	83 c0 05	 add	 eax, 5
  003f0	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv983[ebp], eax
  003f6	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv983[ebp]
  003fc	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00402	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00408	83 c2 7c	 add	 edx, 124		; 0000007cH
  0040b	89 95 64 fe ff
	ff		 mov	 DWORD PTR tv984[ebp], edx
  00411	6a 04		 push	 4
  00413	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv984[ebp]
  00419	50		 push	 eax
  0041a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0041f	83 c4 08	 add	 esp, 8
  00422	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR tv984[ebp]
  00428	83 c1 04	 add	 ecx, 4
  0042b	89 8d 08 ff ff
	ff		 mov	 DWORD PTR tv988[ebp], ecx
  00431	8b 95 08 ff ff
	ff		 mov	 edx, DWORD PTR tv988[ebp]
  00437	c6 02 04	 mov	 BYTE PTR [edx], 4
  0043a	8b 85 64 fe ff
	ff		 mov	 eax, DWORD PTR tv984[ebp]
  00440	83 c0 05	 add	 eax, 5
  00443	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv989[ebp], eax
  00449	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv989[ebp]
  0044f	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00455	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  0045b	81 c2 85 00 00
	00		 add	 edx, 133		; 00000085H
  00461	89 95 68 fe ff
	ff		 mov	 DWORD PTR tv990[ebp], edx
  00467	6a 04		 push	 4
  00469	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  0046f	50		 push	 eax
  00470	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00475	83 c4 08	 add	 esp, 8
  00478	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv990[ebp]
  0047e	83 c1 04	 add	 ecx, 4
  00481	89 8d 10 ff ff
	ff		 mov	 DWORD PTR tv994[ebp], ecx
  00487	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv994[ebp]
  0048d	c6 02 04	 mov	 BYTE PTR [edx], 4
  00490	8b 85 68 fe ff
	ff		 mov	 eax, DWORD PTR tv990[ebp]
  00496	83 c0 05	 add	 eax, 5
  00499	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv995[ebp], eax
  0049f	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv995[ebp]
  004a5	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  004ab	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  004b1	81 c2 8e 00 00
	00		 add	 edx, 142		; 0000008eH
  004b7	89 95 6c fe ff
	ff		 mov	 DWORD PTR tv996[ebp], edx
  004bd	6a 04		 push	 4
  004bf	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv996[ebp]
  004c5	50		 push	 eax
  004c6	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  004cb	83 c4 08	 add	 esp, 8
  004ce	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv996[ebp]
  004d4	83 c1 04	 add	 ecx, 4
  004d7	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv1000[ebp], ecx
  004dd	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv1000[ebp]
  004e3	c6 02 04	 mov	 BYTE PTR [edx], 4
  004e6	8b 85 6c fe ff
	ff		 mov	 eax, DWORD PTR tv996[ebp]
  004ec	83 c0 05	 add	 eax, 5
  004ef	89 85 1c ff ff
	ff		 mov	 DWORD PTR tv1001[ebp], eax
  004f5	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv1001[ebp]
  004fb	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00501	8b 95 38 fe ff
	ff		 mov	 edx, DWORD PTR tv918[ebp]
  00507	81 c2 97 00 00
	00		 add	 edx, 151		; 00000097H
  0050d	89 95 70 fe ff
	ff		 mov	 DWORD PTR tv1002[ebp], edx
  00513	6a 04		 push	 4
  00515	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv1002[ebp]
  0051b	50		 push	 eax
  0051c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00521	83 c4 08	 add	 esp, 8
  00524	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv1002[ebp]
  0052a	83 c1 04	 add	 ecx, 4
  0052d	89 8d 20 ff ff
	ff		 mov	 DWORD PTR tv1006[ebp], ecx
  00533	8b 95 20 ff ff
	ff		 mov	 edx, DWORD PTR tv1006[ebp]
  00539	c6 02 04	 mov	 BYTE PTR [edx], 4
  0053c	8b 85 70 fe ff
	ff		 mov	 eax, DWORD PTR tv1002[ebp]
  00542	83 c0 05	 add	 eax, 5
  00545	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv1007[ebp], eax
  0054b	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00551	c7 01 f2 f2 f2
	f2		 mov	 DWORD PTR [ecx], -218959118 ; f2f2f2f2H
  00557	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0055e	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  00564	c7 02 01 f2 01
	f2		 mov	 DWORD PTR [edx], -234753535 ; f201f201H
  0056a	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00571	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00577	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  0057d	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00584	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  0058a	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  00590	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00597	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  0059d	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  005a3	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005aa	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  005b0	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  005b6	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005bd	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  005c3	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  005c9	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005d0	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  005d6	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  005dc	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005e3	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  005e9	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  005ef	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  005f6	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  005fc	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  00602	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00609	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  0060f	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  00615	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0061c	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00622	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  00628	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0062f	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00635	c7 01 00 f2 01
	f2		 mov	 DWORD PTR [ecx], -234753536 ; f201f200H
  0063b	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00642	8b 95 34 fe ff
	ff		 mov	 edx, DWORD PTR tv1007[ebp]
  00648	c7 02 00 f2 01
	f2		 mov	 DWORD PTR [edx], -234753536 ; f201f200H
  0064e	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00655	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  0065b	c7 00 00 f2 01
	f2		 mov	 DWORD PTR [eax], -234753536 ; f201f200H
  00661	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  00668	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  0066e	c7 01 00 f2 00
	f3		 mov	 DWORD PTR [ecx], -218041856 ; f300f200H
  00674	83 85 34 fe ff
	ff 04		 add	 DWORD PTR tv1007[ebp], 4
  0067b	ba f3 f3 00 00	 mov	 edx, 62451		; 0000f3f3H
  00680	8b 85 34 fe ff
	ff		 mov	 eax, DWORD PTR tv1007[ebp]
  00686	66 89 10	 mov	 WORD PTR [eax], dx
  00689	83 85 34 fe ff
	ff 02		 add	 DWORD PTR tv1007[ebp], 2
  00690	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv1007[ebp]
  00696	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00699	b9 00 00 00 00	 mov	 ecx, OFFSET __218DFE2C_Levels@h
  0069e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4    : inline std::vector<std::vector<int>> level1 = {

  006a3	6a 10		 push	 16			; 00000010H
  006a5	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  006aa	e8 00 00 00 00	 call	 ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
  006af	8d 8d 38 fc ff
	ff		 lea	 ecx, DWORD PTR $T18[ebp]
  006b5	e8 00 00 00 00	 call	 ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
  006ba	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv612[ebp], eax
  006c0	8d 8d 48 fc ff
	ff		 lea	 ecx, DWORD PTR $T19[ebp]
  006c6	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  006cb	89 85 24 ff ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  006d1	c7 85 48 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp], 0
  006db	c7 85 4c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+4], 0
  006e5	c7 85 50 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+8], 0
  006ef	c7 85 54 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+12], 0
  006f9	c7 85 58 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+16], 0
  00703	c7 85 5c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+20], 0
  0070d	c7 85 60 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+24], 0
  00717	c7 85 64 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+28], 0
  00721	c7 85 68 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T4[ebp+32], 0
  0072b	8d 95 48 f8 ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  00731	83 c2 24	 add	 edx, 36			; 00000024H
  00734	52		 push	 edx
  00735	8d 85 48 f8 ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  0073b	50		 push	 eax
  0073c	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  00742	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00747	6a 08		 push	 8
  00749	50		 push	 eax
  0074a	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR $T48[ebp]
  00750	51		 push	 ecx
  00751	e8 00 00 00 00	 call	 ___asan_memcpy
  00756	83 c4 0c	 add	 esp, 12			; 0000000cH
  00759	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  0075f	52		 push	 edx
  00760	8b 85 6c ff ff
	ff		 mov	 eax, DWORD PTR $T48[ebp+4]
  00766	50		 push	 eax
  00767	8b 8d 68 ff ff
	ff		 mov	 ecx, DWORD PTR $T48[ebp]
  0076d	51		 push	 ecx
  0076e	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00774	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00779	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00780	8d 8d 68 fc ff
	ff		 lea	 ecx, DWORD PTR $T21[ebp]
  00786	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0078b	89 85 28 ff ff
	ff		 mov	 DWORD PTR tv164[ebp], eax
  00791	c7 85 90 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp], 0
  0079b	c7 85 94 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+4], 0
  007a5	c7 85 98 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+8], 0
  007af	c7 85 9c f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+12], 0
  007b9	c7 85 a0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+16], 0
  007c3	c7 85 a4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+20], 0
  007cd	c7 85 a8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+24], 0
  007d7	c7 85 ac f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+28], 0
  007e1	c7 85 b0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T5[ebp+32], 0
  007eb	8d 95 90 f8 ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  007f1	83 c2 24	 add	 edx, 36			; 00000024H
  007f4	52		 push	 edx
  007f5	8d 85 90 f8 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  007fb	50		 push	 eax
  007fc	8d 8d 78 fc ff
	ff		 lea	 ecx, DWORD PTR $T22[ebp]
  00802	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00807	6a 08		 push	 8
  00809	50		 push	 eax
  0080a	8d 8d 70 ff ff
	ff		 lea	 ecx, DWORD PTR $T49[ebp]
  00810	51		 push	 ecx
  00811	e8 00 00 00 00	 call	 ___asan_memcpy
  00816	83 c4 0c	 add	 esp, 12			; 0000000cH
  00819	8b 95 28 ff ff
	ff		 mov	 edx, DWORD PTR tv164[ebp]
  0081f	52		 push	 edx
  00820	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR $T49[ebp+4]
  00826	50		 push	 eax
  00827	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR $T49[ebp]
  0082d	51		 push	 ecx
  0082e	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+16]
  00834	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00839	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1
  0083d	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  00843	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00848	89 85 2c ff ff
	ff		 mov	 DWORD PTR tv179[ebp], eax
  0084e	c7 85 d8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp], 0
  00858	c7 85 dc f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+4], 0
  00862	c7 85 e0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+8], 0
  0086c	c7 85 e4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+12], 0
  00876	c7 85 e8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+16], 0
  00880	c7 85 ec f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+20], 0
  0088a	c7 85 f0 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+24], 0
  00894	c7 85 f4 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+28], 0
  0089e	c7 85 f8 f8 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T6[ebp+32], 0
  008a8	8d 95 d8 f8 ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  008ae	83 c2 24	 add	 edx, 36			; 00000024H
  008b1	52		 push	 edx
  008b2	8d 85 d8 f8 ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  008b8	50		 push	 eax
  008b9	8d 8d 98 fc ff
	ff		 lea	 ecx, DWORD PTR $T24[ebp]
  008bf	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  008c4	6a 08		 push	 8
  008c6	50		 push	 eax
  008c7	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR $T50[ebp]
  008cd	51		 push	 ecx
  008ce	e8 00 00 00 00	 call	 ___asan_memcpy
  008d3	83 c4 0c	 add	 esp, 12			; 0000000cH
  008d6	8b 95 2c ff ff
	ff		 mov	 edx, DWORD PTR tv179[ebp]
  008dc	52		 push	 edx
  008dd	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR $T50[ebp+4]
  008e3	50		 push	 eax
  008e4	8b 8d 78 ff ff
	ff		 mov	 ecx, DWORD PTR $T50[ebp]
  008ea	51		 push	 ecx
  008eb	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+32]
  008f1	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  008f6	c6 45 fc 02	 mov	 BYTE PTR __$EHRec$[ebp+8], 2
  008fa	8d 8d a8 fc ff
	ff		 lea	 ecx, DWORD PTR $T25[ebp]
  00900	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00905	89 85 30 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], eax
  0090b	c7 85 20 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp], 0
  00915	c7 85 24 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+4], 0
  0091f	c7 85 28 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+8], 0
  00929	c7 85 2c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+12], 0
  00933	c7 85 30 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+16], 0
  0093d	c7 85 34 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+20], 0
  00947	c7 85 38 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+24], 0
  00951	c7 85 3c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+28], 0
  0095b	c7 85 40 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T7[ebp+32], 0
  00965	8d 95 20 f9 ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  0096b	83 c2 24	 add	 edx, 36			; 00000024H
  0096e	52		 push	 edx
  0096f	8d 85 20 f9 ff
	ff		 lea	 eax, DWORD PTR $T7[ebp]
  00975	50		 push	 eax
  00976	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  0097c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00981	6a 08		 push	 8
  00983	50		 push	 eax
  00984	8d 4d 80	 lea	 ecx, DWORD PTR $T51[ebp]
  00987	51		 push	 ecx
  00988	e8 00 00 00 00	 call	 ___asan_memcpy
  0098d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00990	8b 95 30 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  00996	52		 push	 edx
  00997	8b 45 84	 mov	 eax, DWORD PTR $T51[ebp+4]
  0099a	50		 push	 eax
  0099b	8b 4d 80	 mov	 ecx, DWORD PTR $T51[ebp]
  0099e	51		 push	 ecx
  0099f	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+48]
  009a5	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  009aa	c6 45 fc 03	 mov	 BYTE PTR __$EHRec$[ebp+8], 3
  009ae	8d 8d c8 fc ff
	ff		 lea	 ecx, DWORD PTR $T27[ebp]
  009b4	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  009b9	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv241[ebp], eax
  009bf	c7 85 68 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp], 0
  009c9	c7 85 6c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+4], 0
  009d3	c7 85 70 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+8], 0
  009dd	c7 85 74 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+12], 0
  009e7	c7 85 78 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+16], 0
  009f1	c7 85 7c f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+20], 0
  009fb	c7 85 80 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+24], 0
  00a05	c7 85 84 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+28], 0
  00a0f	c7 85 88 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T8[ebp+32], 0
  00a19	8d 95 68 f9 ff
	ff		 lea	 edx, DWORD PTR $T8[ebp]
  00a1f	83 c2 24	 add	 edx, 36			; 00000024H
  00a22	52		 push	 edx
  00a23	8d 85 68 f9 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00a29	50		 push	 eax
  00a2a	8d 8d d8 fc ff
	ff		 lea	 ecx, DWORD PTR $T28[ebp]
  00a30	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00a35	6a 08		 push	 8
  00a37	50		 push	 eax
  00a38	8d 4d 88	 lea	 ecx, DWORD PTR $T52[ebp]
  00a3b	51		 push	 ecx
  00a3c	e8 00 00 00 00	 call	 ___asan_memcpy
  00a41	83 c4 0c	 add	 esp, 12			; 0000000cH
  00a44	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv241[ebp]
  00a4a	52		 push	 edx
  00a4b	8b 45 8c	 mov	 eax, DWORD PTR $T52[ebp+4]
  00a4e	50		 push	 eax
  00a4f	8b 4d 88	 mov	 ecx, DWORD PTR $T52[ebp]
  00a52	51		 push	 ecx
  00a53	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+64]
  00a59	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00a5e	c6 45 fc 04	 mov	 BYTE PTR __$EHRec$[ebp+8], 4
  00a62	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  00a68	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00a6d	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv320[ebp], eax
  00a73	c7 85 b0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp], 0
  00a7d	c7 85 b4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+4], 0
  00a87	c7 85 b8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+8], 0
  00a91	c7 85 bc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+12], 0
  00a9b	c7 85 c0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+16], 0
  00aa5	c7 85 c4 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+20], 0
  00aaf	c7 85 c8 f9 ff
	ff 03 00 00 00	 mov	 DWORD PTR $T9[ebp+24], 3
  00ab9	c7 85 cc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+28], 0
  00ac3	c7 85 d0 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T9[ebp+32], 0
  00acd	8d 95 b0 f9 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  00ad3	83 c2 24	 add	 edx, 36			; 00000024H
  00ad6	52		 push	 edx
  00ad7	8d 85 b0 f9 ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00add	50		 push	 eax
  00ade	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR $T30[ebp]
  00ae4	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00ae9	6a 08		 push	 8
  00aeb	50		 push	 eax
  00aec	8d 4d 90	 lea	 ecx, DWORD PTR $T53[ebp]
  00aef	51		 push	 ecx
  00af0	e8 00 00 00 00	 call	 ___asan_memcpy
  00af5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00af8	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv320[ebp]
  00afe	52		 push	 edx
  00aff	8b 45 94	 mov	 eax, DWORD PTR $T53[ebp+4]
  00b02	50		 push	 eax
  00b03	8b 4d 90	 mov	 ecx, DWORD PTR $T53[ebp]
  00b06	51		 push	 ecx
  00b07	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+80]
  00b0d	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00b12	c6 45 fc 05	 mov	 BYTE PTR __$EHRec$[ebp+8], 5
  00b16	8d 8d 08 fd ff
	ff		 lea	 ecx, DWORD PTR $T31[ebp]
  00b1c	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00b21	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv335[ebp], eax
  00b27	c7 85 f8 f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp], 0
  00b31	c7 85 fc f9 ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+4], 0
  00b3b	c7 85 00 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+8], 0
  00b45	c7 85 04 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+12], 0
  00b4f	c7 85 08 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+16], 0
  00b59	c7 85 0c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+20], 0
  00b63	c7 85 10 fa ff
	ff 05 00 00 00	 mov	 DWORD PTR $T10[ebp+24], 5
  00b6d	c7 85 14 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+28], 0
  00b77	c7 85 18 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T10[ebp+32], 0
  00b81	8d 95 f8 f9 ff
	ff		 lea	 edx, DWORD PTR $T10[ebp]
  00b87	83 c2 24	 add	 edx, 36			; 00000024H
  00b8a	52		 push	 edx
  00b8b	8d 85 f8 f9 ff
	ff		 lea	 eax, DWORD PTR $T10[ebp]
  00b91	50		 push	 eax
  00b92	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  00b98	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00b9d	6a 08		 push	 8
  00b9f	50		 push	 eax
  00ba0	8d 4d 98	 lea	 ecx, DWORD PTR $T54[ebp]
  00ba3	51		 push	 ecx
  00ba4	e8 00 00 00 00	 call	 ___asan_memcpy
  00ba9	83 c4 0c	 add	 esp, 12			; 0000000cH
  00bac	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv335[ebp]
  00bb2	52		 push	 edx
  00bb3	8b 45 9c	 mov	 eax, DWORD PTR $T54[ebp+4]
  00bb6	50		 push	 eax
  00bb7	8b 4d 98	 mov	 ecx, DWORD PTR $T54[ebp]
  00bba	51		 push	 ecx
  00bbb	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+96]
  00bc1	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00bc6	c6 45 fc 06	 mov	 BYTE PTR __$EHRec$[ebp+8], 6
  00bca	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR $T33[ebp]
  00bd0	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00bd5	89 85 40 ff ff
	ff		 mov	 DWORD PTR tv350[ebp], eax
  00bdb	c7 85 40 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp], 0
  00be5	c7 85 44 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+4], 0
  00bef	c7 85 48 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+8], 0
  00bf9	c7 85 4c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+12], 0
  00c03	c7 85 50 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+16], 0
  00c0d	c7 85 54 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+20], 0
  00c17	c7 85 58 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T11[ebp+24], 3
  00c21	c7 85 5c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+28], 0
  00c2b	c7 85 60 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T11[ebp+32], 0
  00c35	8d 95 40 fa ff
	ff		 lea	 edx, DWORD PTR $T11[ebp]
  00c3b	83 c2 24	 add	 edx, 36			; 00000024H
  00c3e	52		 push	 edx
  00c3f	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  00c45	50		 push	 eax
  00c46	8d 8d 38 fd ff
	ff		 lea	 ecx, DWORD PTR $T34[ebp]
  00c4c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00c51	6a 08		 push	 8
  00c53	50		 push	 eax
  00c54	8d 4d a0	 lea	 ecx, DWORD PTR $T55[ebp]
  00c57	51		 push	 ecx
  00c58	e8 00 00 00 00	 call	 ___asan_memcpy
  00c5d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00c60	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv350[ebp]
  00c66	52		 push	 edx
  00c67	8b 45 a4	 mov	 eax, DWORD PTR $T55[ebp+4]
  00c6a	50		 push	 eax
  00c6b	8b 4d a0	 mov	 ecx, DWORD PTR $T55[ebp]
  00c6e	51		 push	 ecx
  00c6f	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+112]
  00c75	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00c7a	c6 45 fc 07	 mov	 BYTE PTR __$EHRec$[ebp+8], 7
  00c7e	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  00c84	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00c89	89 85 44 ff ff
	ff		 mov	 DWORD PTR tv397[ebp], eax
  00c8f	c7 85 88 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp], 2
  00c99	c7 85 8c fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+4], 0
  00ca3	c7 85 90 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+8], 0
  00cad	c7 85 94 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+12], 2
  00cb7	c7 85 98 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T12[ebp+16], 0
  00cc1	c7 85 9c fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+20], 2
  00ccb	c7 85 a0 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+24], 2
  00cd5	c7 85 a4 fa ff
	ff 06 00 00 00	 mov	 DWORD PTR $T12[ebp+28], 6
  00cdf	c7 85 a8 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T12[ebp+32], 2
  00ce9	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  00cef	83 c2 24	 add	 edx, 36			; 00000024H
  00cf2	52		 push	 edx
  00cf3	8d 85 88 fa ff
	ff		 lea	 eax, DWORD PTR $T12[ebp]
  00cf9	50		 push	 eax
  00cfa	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T36[ebp]
  00d00	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00d05	6a 08		 push	 8
  00d07	50		 push	 eax
  00d08	8d 4d a8	 lea	 ecx, DWORD PTR $T56[ebp]
  00d0b	51		 push	 ecx
  00d0c	e8 00 00 00 00	 call	 ___asan_memcpy
  00d11	83 c4 0c	 add	 esp, 12			; 0000000cH
  00d14	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv397[ebp]
  00d1a	52		 push	 edx
  00d1b	8b 45 ac	 mov	 eax, DWORD PTR $T56[ebp+4]
  00d1e	50		 push	 eax
  00d1f	8b 4d a8	 mov	 ecx, DWORD PTR $T56[ebp]
  00d22	51		 push	 ecx
  00d23	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+128]
  00d29	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00d2e	c6 45 fc 08	 mov	 BYTE PTR __$EHRec$[ebp+8], 8
  00d32	8d 8d 68 fd ff
	ff		 lea	 ecx, DWORD PTR $T37[ebp]
  00d38	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00d3d	89 85 48 ff ff
	ff		 mov	 DWORD PTR tv412[ebp], eax
  00d43	c7 85 d0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp], 0
  00d4d	c7 85 d4 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+4], 2
  00d57	c7 85 d8 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+8], 0
  00d61	c7 85 dc fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+12], 0
  00d6b	c7 85 e0 fa ff
	ff 00 00 00 00	 mov	 DWORD PTR $T13[ebp+16], 0
  00d75	c7 85 e4 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp+20], 3
  00d7f	c7 85 e8 fa ff
	ff 03 00 00 00	 mov	 DWORD PTR $T13[ebp+24], 3
  00d89	c7 85 ec fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+28], 2
  00d93	c7 85 f0 fa ff
	ff 02 00 00 00	 mov	 DWORD PTR $T13[ebp+32], 2
  00d9d	8d 95 d0 fa ff
	ff		 lea	 edx, DWORD PTR $T13[ebp]
  00da3	83 c2 24	 add	 edx, 36			; 00000024H
  00da6	52		 push	 edx
  00da7	8d 85 d0 fa ff
	ff		 lea	 eax, DWORD PTR $T13[ebp]
  00dad	50		 push	 eax
  00dae	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  00db4	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00db9	6a 08		 push	 8
  00dbb	50		 push	 eax
  00dbc	8d 4d b0	 lea	 ecx, DWORD PTR $T57[ebp]
  00dbf	51		 push	 ecx
  00dc0	e8 00 00 00 00	 call	 ___asan_memcpy
  00dc5	83 c4 0c	 add	 esp, 12			; 0000000cH
  00dc8	8b 95 48 ff ff
	ff		 mov	 edx, DWORD PTR tv412[ebp]
  00dce	52		 push	 edx
  00dcf	8b 45 b4	 mov	 eax, DWORD PTR $T57[ebp+4]
  00dd2	50		 push	 eax
  00dd3	8b 4d b0	 mov	 ecx, DWORD PTR $T57[ebp]
  00dd6	51		 push	 ecx
  00dd7	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+144]
  00ddd	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00de2	c6 45 fc 09	 mov	 BYTE PTR __$EHRec$[ebp+8], 9
  00de6	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T39[ebp]
  00dec	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00df1	89 85 4c ff ff
	ff		 mov	 DWORD PTR tv459[ebp], eax
  00df7	c7 85 18 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp], 0
  00e01	c7 85 1c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+4], 0
  00e0b	c7 85 20 fb ff
	ff 05 00 00 00	 mov	 DWORD PTR $T14[ebp+8], 5
  00e15	c7 85 24 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+12], 0
  00e1f	c7 85 28 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+16], 0
  00e29	c7 85 2c fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+20], 0
  00e33	c7 85 30 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T14[ebp+24], 4
  00e3d	c7 85 34 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T14[ebp+28], 3
  00e47	c7 85 38 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T14[ebp+32], 0
  00e51	8d 95 18 fb ff
	ff		 lea	 edx, DWORD PTR $T14[ebp]
  00e57	83 c2 24	 add	 edx, 36			; 00000024H
  00e5a	52		 push	 edx
  00e5b	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  00e61	50		 push	 eax
  00e62	8d 8d 98 fd ff
	ff		 lea	 ecx, DWORD PTR $T40[ebp]
  00e68	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00e6d	6a 08		 push	 8
  00e6f	50		 push	 eax
  00e70	8d 4d b8	 lea	 ecx, DWORD PTR $T58[ebp]
  00e73	51		 push	 ecx
  00e74	e8 00 00 00 00	 call	 ___asan_memcpy
  00e79	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e7c	8b 95 4c ff ff
	ff		 mov	 edx, DWORD PTR tv459[ebp]
  00e82	52		 push	 edx
  00e83	8b 45 bc	 mov	 eax, DWORD PTR $T58[ebp+4]
  00e86	50		 push	 eax
  00e87	8b 4d b8	 mov	 ecx, DWORD PTR $T58[ebp]
  00e8a	51		 push	 ecx
  00e8b	8d 8d e8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+160]
  00e91	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00e96	c6 45 fc 0a	 mov	 BYTE PTR __$EHRec$[ebp+8], 10 ; 0000000aH
  00e9a	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  00ea0	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00ea5	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv474[ebp], eax
  00eab	c7 85 60 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp], 0
  00eb5	c7 85 64 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+4], 0
  00ebf	c7 85 68 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T15[ebp+8], 3
  00ec9	c7 85 6c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp+12], 2
  00ed3	c7 85 70 fb ff
	ff ff ff ff ff	 mov	 DWORD PTR $T15[ebp+16], -1
  00edd	c7 85 74 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+20], 0
  00ee7	c7 85 78 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+24], 0
  00ef1	c7 85 7c fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T15[ebp+28], 2
  00efb	c7 85 80 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T15[ebp+32], 0
  00f05	8d 95 60 fb ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  00f0b	83 c2 24	 add	 edx, 36			; 00000024H
  00f0e	52		 push	 edx
  00f0f	8d 85 60 fb ff
	ff		 lea	 eax, DWORD PTR $T15[ebp]
  00f15	50		 push	 eax
  00f16	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR $T42[ebp]
  00f1c	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00f21	6a 08		 push	 8
  00f23	50		 push	 eax
  00f24	8d 4d c0	 lea	 ecx, DWORD PTR $T59[ebp]
  00f27	51		 push	 ecx
  00f28	e8 00 00 00 00	 call	 ___asan_memcpy
  00f2d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00f30	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv474[ebp]
  00f36	52		 push	 edx
  00f37	8b 45 c4	 mov	 eax, DWORD PTR $T59[ebp+4]
  00f3a	50		 push	 eax
  00f3b	8b 4d c0	 mov	 ecx, DWORD PTR $T59[ebp]
  00f3e	51		 push	 ecx
  00f3f	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+176]
  00f45	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00f4a	c6 45 fc 0b	 mov	 BYTE PTR __$EHRec$[ebp+8], 11 ; 0000000bH
  00f4e	8d 8d c8 fd ff
	ff		 lea	 ecx, DWORD PTR $T43[ebp]
  00f54	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  00f59	89 85 54 ff ff
	ff		 mov	 DWORD PTR tv553[ebp], eax
  00f5f	c7 85 a8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp], 0
  00f69	c7 85 ac fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+4], 0
  00f73	c7 85 b0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T16[ebp+8], 2
  00f7d	c7 85 b4 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp+12], 4
  00f87	c7 85 b8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T16[ebp+16], 3
  00f91	c7 85 bc fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+20], 0
  00f9b	c7 85 c0 fb ff
	ff 64 00 00 00	 mov	 DWORD PTR $T16[ebp+24], 100 ; 00000064H
  00fa5	c7 85 c4 fb ff
	ff 04 00 00 00	 mov	 DWORD PTR $T16[ebp+28], 4
  00faf	c7 85 c8 fb ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp+32], 0
  00fb9	8d 95 a8 fb ff
	ff		 lea	 edx, DWORD PTR $T16[ebp]
  00fbf	83 c2 24	 add	 edx, 36			; 00000024H
  00fc2	52		 push	 edx
  00fc3	8d 85 a8 fb ff
	ff		 lea	 eax, DWORD PTR $T16[ebp]
  00fc9	50		 push	 eax
  00fca	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  00fd0	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  00fd5	6a 08		 push	 8
  00fd7	50		 push	 eax
  00fd8	8d 4d c8	 lea	 ecx, DWORD PTR $T60[ebp]
  00fdb	51		 push	 ecx
  00fdc	e8 00 00 00 00	 call	 ___asan_memcpy
  00fe1	83 c4 0c	 add	 esp, 12			; 0000000cH
  00fe4	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv553[ebp]
  00fea	52		 push	 edx
  00feb	8b 45 cc	 mov	 eax, DWORD PTR $T60[ebp+4]
  00fee	50		 push	 eax
  00fef	8b 4d c8	 mov	 ecx, DWORD PTR $T60[ebp]
  00ff2	51		 push	 ecx
  00ff3	8d 8d 08 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+192]
  00ff9	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00ffe	c6 45 fc 0c	 mov	 BYTE PTR __$EHRec$[ebp+8], 12 ; 0000000cH
  01002	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T45[ebp]
  01008	e8 00 00 00 00	 call	 ??0?$allocator@H@std@@QAE@XZ ; std::allocator<int>::allocator<int>
  0100d	89 85 58 ff ff
	ff		 mov	 DWORD PTR tv568[ebp], eax
  01013	c7 85 f0 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp], 2
  0101d	c7 85 f4 fb ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+4], 2
  01027	c7 85 f8 fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+8], 3
  01031	c7 85 fc fb ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+12], 3
  0103b	c7 85 00 fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+16], 2
  01045	c7 85 04 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+20], 3
  0104f	c7 85 08 fc ff
	ff 03 00 00 00	 mov	 DWORD PTR $T17[ebp+24], 3
  01059	c7 85 0c fc ff
	ff 02 00 00 00	 mov	 DWORD PTR $T17[ebp+28], 2
  01063	c7 85 10 fc ff
	ff 04 00 00 00	 mov	 DWORD PTR $T17[ebp+32], 4
  0106d	8d 95 f0 fb ff
	ff		 lea	 edx, DWORD PTR $T17[ebp]
  01073	83 c2 24	 add	 edx, 36			; 00000024H
  01076	52		 push	 edx
  01077	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  0107d	50		 push	 eax
  0107e	8d 8d f8 fd ff
	ff		 lea	 ecx, DWORD PTR $T46[ebp]
  01084	e8 00 00 00 00	 call	 ??0?$initializer_list@H@std@@QAE@PBH0@Z ; std::initializer_list<int>::initializer_list<int>
  01089	6a 08		 push	 8
  0108b	50		 push	 eax
  0108c	8d 4d d0	 lea	 ecx, DWORD PTR $T61[ebp]
  0108f	51		 push	 ecx
  01090	e8 00 00 00 00	 call	 ___asan_memcpy
  01095	83 c4 0c	 add	 esp, 12			; 0000000cH
  01098	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv568[ebp]
  0109e	52		 push	 edx
  0109f	8b 45 d4	 mov	 eax, DWORD PTR $T61[ebp+4]
  010a2	50		 push	 eax
  010a3	8b 4d d0	 mov	 ecx, DWORD PTR $T61[ebp]
  010a6	51		 push	 ecx
  010a7	8d 8d 18 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+208]
  010ad	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  010b2	c7 45 fc 0d 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 13 ; 0000000dH
  010b9	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  010bf	81 c2 e0 00 00
	00		 add	 edx, 224		; 000000e0H
  010c5	52		 push	 edx
  010c6	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  010cc	50		 push	 eax
  010cd	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  010d3	e8 00 00 00 00	 call	 ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
  010d8	6a 08		 push	 8
  010da	50		 push	 eax
  010db	8d 4d d8	 lea	 ecx, DWORD PTR $T62[ebp]
  010de	51		 push	 ecx
  010df	e8 00 00 00 00	 call	 ___asan_memcpy
  010e4	83 c4 0c	 add	 esp, 12			; 0000000cH
  010e7	8b 95 5c ff ff
	ff		 mov	 edx, DWORD PTR tv612[ebp]
  010ed	52		 push	 edx
  010ee	8b 45 dc	 mov	 eax, DWORD PTR $T62[ebp+4]
  010f1	50		 push	 eax
  010f2	8b 4d d8	 mov	 ecx, DWORD PTR $T62[ebp]
  010f5	51		 push	 ecx
  010f6	b9 00 00 00 00	 mov	 ecx, OFFSET ?level1@@3V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@A ; level1
  010fb	e8 00 00 00 00	 call	 ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  01100	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  01107	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0110c	6a 0e		 push	 14			; 0000000eH
  0110e	6a 10		 push	 16			; 00000010H
  01110	8d 95 48 f7 ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  01116	52		 push	 edx
  01117	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  0111c	8d 85 38 fc ff
	ff		 lea	 eax, DWORD PTR $T18[ebp]
  01122	c1 e8 03	 shr	 eax, 3
  01125	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0112c	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  01132	c1 e9 03	 shr	 ecx, 3
  01135	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0113b	89 8d 60 ff ff
	ff		 mov	 DWORD PTR tv1195[ebp], ecx
  01141	6a 1c		 push	 28			; 0000001cH
  01143	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR tv1195[ebp]
  01149	52		 push	 edx
  0114a	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  0114f	83 c4 08	 add	 esp, 8
  01152	8d 85 48 fc ff
	ff		 lea	 eax, DWORD PTR $T19[ebp]
  01158	c1 e8 03	 shr	 eax, 3
  0115b	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01162	8d 8d 48 f8 ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  01168	c1 e9 03	 shr	 ecx, 3
  0116b	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  01171	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv1185[ebp], ecx
  01177	6a 04		 push	 4
  01179	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR tv1185[ebp]
  0117f	52		 push	 edx
  01180	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01185	83 c4 08	 add	 esp, 8
  01188	8b 85 78 fe ff
	ff		 mov	 eax, DWORD PTR tv1185[ebp]
  0118e	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01192	8d 8d 58 fc ff
	ff		 lea	 ecx, DWORD PTR $T20[ebp]
  01198	c1 e9 03	 shr	 ecx, 3
  0119b	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  011a2	8d 95 68 fc ff
	ff		 lea	 edx, DWORD PTR $T21[ebp]
  011a8	c1 ea 03	 shr	 edx, 3
  011ab	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  011b2	8d 85 90 f8 ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  011b8	c1 e8 03	 shr	 eax, 3
  011bb	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  011c0	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv1172[ebp], eax
  011c6	6a 04		 push	 4
  011c8	8b 8d 7c fe ff
	ff		 mov	 ecx, DWORD PTR tv1172[ebp]
  011ce	51		 push	 ecx
  011cf	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  011d4	83 c4 08	 add	 esp, 8
  011d7	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR tv1172[ebp]
  011dd	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  011e1	8d 85 78 fc ff
	ff		 lea	 eax, DWORD PTR $T22[ebp]
  011e7	c1 e8 03	 shr	 eax, 3
  011ea	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  011f1	8d 8d 88 fc ff
	ff		 lea	 ecx, DWORD PTR $T23[ebp]
  011f7	c1 e9 03	 shr	 ecx, 3
  011fa	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01201	8d 95 d8 f8 ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  01207	c1 ea 03	 shr	 edx, 3
  0120a	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  01210	89 95 80 fe ff
	ff		 mov	 DWORD PTR tv1159[ebp], edx
  01216	6a 04		 push	 4
  01218	8b 85 80 fe ff
	ff		 mov	 eax, DWORD PTR tv1159[ebp]
  0121e	50		 push	 eax
  0121f	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01224	83 c4 08	 add	 esp, 8
  01227	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR tv1159[ebp]
  0122d	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  01231	8d 95 98 fc ff
	ff		 lea	 edx, DWORD PTR $T24[ebp]
  01237	c1 ea 03	 shr	 edx, 3
  0123a	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01241	8d 85 a8 fc ff
	ff		 lea	 eax, DWORD PTR $T25[ebp]
  01247	c1 e8 03	 shr	 eax, 3
  0124a	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01251	8d 8d 20 f9 ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  01257	c1 e9 03	 shr	 ecx, 3
  0125a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  01260	89 8d 84 fe ff
	ff		 mov	 DWORD PTR tv1146[ebp], ecx
  01266	6a 04		 push	 4
  01268	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv1146[ebp]
  0126e	52		 push	 edx
  0126f	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01274	83 c4 08	 add	 esp, 8
  01277	8b 85 84 fe ff
	ff		 mov	 eax, DWORD PTR tv1146[ebp]
  0127d	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01281	8d 8d b8 fc ff
	ff		 lea	 ecx, DWORD PTR $T26[ebp]
  01287	c1 e9 03	 shr	 ecx, 3
  0128a	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01291	8d 95 c8 fc ff
	ff		 lea	 edx, DWORD PTR $T27[ebp]
  01297	c1 ea 03	 shr	 edx, 3
  0129a	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  012a1	8d 85 68 f9 ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  012a7	c1 e8 03	 shr	 eax, 3
  012aa	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  012af	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv1133[ebp], eax
  012b5	6a 04		 push	 4
  012b7	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv1133[ebp]
  012bd	51		 push	 ecx
  012be	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  012c3	83 c4 08	 add	 esp, 8
  012c6	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv1133[ebp]
  012cc	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  012d0	8d 85 d8 fc ff
	ff		 lea	 eax, DWORD PTR $T28[ebp]
  012d6	c1 e8 03	 shr	 eax, 3
  012d9	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  012e0	8d 8d e8 fc ff
	ff		 lea	 ecx, DWORD PTR $T29[ebp]
  012e6	c1 e9 03	 shr	 ecx, 3
  012e9	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  012f0	8d 95 b0 f9 ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  012f6	c1 ea 03	 shr	 edx, 3
  012f9	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  012ff	89 95 8c fe ff
	ff		 mov	 DWORD PTR tv1120[ebp], edx
  01305	6a 04		 push	 4
  01307	8b 85 8c fe ff
	ff		 mov	 eax, DWORD PTR tv1120[ebp]
  0130d	50		 push	 eax
  0130e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01313	83 c4 08	 add	 esp, 8
  01316	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR tv1120[ebp]
  0131c	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  01320	8d 95 f8 fc ff
	ff		 lea	 edx, DWORD PTR $T30[ebp]
  01326	c1 ea 03	 shr	 edx, 3
  01329	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01330	8d 85 08 fd ff
	ff		 lea	 eax, DWORD PTR $T31[ebp]
  01336	c1 e8 03	 shr	 eax, 3
  01339	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  01340	8d 8d f8 f9 ff
	ff		 lea	 ecx, DWORD PTR $T10[ebp]
  01346	c1 e9 03	 shr	 ecx, 3
  01349	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0134f	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv1107[ebp], ecx
  01355	6a 04		 push	 4
  01357	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR tv1107[ebp]
  0135d	52		 push	 edx
  0135e	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01363	83 c4 08	 add	 esp, 8
  01366	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv1107[ebp]
  0136c	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  01370	8d 8d 18 fd ff
	ff		 lea	 ecx, DWORD PTR $T32[ebp]
  01376	c1 e9 03	 shr	 ecx, 3
  01379	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  01380	8d 95 28 fd ff
	ff		 lea	 edx, DWORD PTR $T33[ebp]
  01386	c1 ea 03	 shr	 edx, 3
  01389	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  01390	8d 85 40 fa ff
	ff		 lea	 eax, DWORD PTR $T11[ebp]
  01396	c1 e8 03	 shr	 eax, 3
  01399	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0139e	89 85 94 fe ff
	ff		 mov	 DWORD PTR tv1094[ebp], eax
  013a4	6a 04		 push	 4
  013a6	8b 8d 94 fe ff
	ff		 mov	 ecx, DWORD PTR tv1094[ebp]
  013ac	51		 push	 ecx
  013ad	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  013b2	83 c4 08	 add	 esp, 8
  013b5	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv1094[ebp]
  013bb	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  013bf	8d 85 38 fd ff
	ff		 lea	 eax, DWORD PTR $T34[ebp]
  013c5	c1 e8 03	 shr	 eax, 3
  013c8	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  013cf	8d 8d 48 fd ff
	ff		 lea	 ecx, DWORD PTR $T35[ebp]
  013d5	c1 e9 03	 shr	 ecx, 3
  013d8	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  013df	8d 95 88 fa ff
	ff		 lea	 edx, DWORD PTR $T12[ebp]
  013e5	c1 ea 03	 shr	 edx, 3
  013e8	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  013ee	89 95 98 fe ff
	ff		 mov	 DWORD PTR tv1081[ebp], edx
  013f4	6a 04		 push	 4
  013f6	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv1081[ebp]
  013fc	50		 push	 eax
  013fd	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01402	83 c4 08	 add	 esp, 8
  01405	8b 8d 98 fe ff
	ff		 mov	 ecx, DWORD PTR tv1081[ebp]
  0140b	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  0140f	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR $T36[ebp]
  01415	c1 ea 03	 shr	 edx, 3
  01418	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0141f	8d 85 68 fd ff
	ff		 lea	 eax, DWORD PTR $T37[ebp]
  01425	c1 e8 03	 shr	 eax, 3
  01428	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0142f	8d 8d d0 fa ff
	ff		 lea	 ecx, DWORD PTR $T13[ebp]
  01435	c1 e9 03	 shr	 ecx, 3
  01438	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0143e	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv1068[ebp], ecx
  01444	6a 04		 push	 4
  01446	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv1068[ebp]
  0144c	52		 push	 edx
  0144d	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01452	83 c4 08	 add	 esp, 8
  01455	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv1068[ebp]
  0145b	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  0145f	8d 8d 78 fd ff
	ff		 lea	 ecx, DWORD PTR $T38[ebp]
  01465	c1 e9 03	 shr	 ecx, 3
  01468	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  0146f	8d 95 88 fd ff
	ff		 lea	 edx, DWORD PTR $T39[ebp]
  01475	c1 ea 03	 shr	 edx, 3
  01478	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0147f	8d 85 18 fb ff
	ff		 lea	 eax, DWORD PTR $T14[ebp]
  01485	c1 e8 03	 shr	 eax, 3
  01488	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0148d	89 85 a0 fe ff
	ff		 mov	 DWORD PTR tv1055[ebp], eax
  01493	6a 04		 push	 4
  01495	8b 8d a0 fe ff
	ff		 mov	 ecx, DWORD PTR tv1055[ebp]
  0149b	51		 push	 ecx
  0149c	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  014a1	83 c4 08	 add	 esp, 8
  014a4	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR tv1055[ebp]
  014aa	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  014ae	8d 85 98 fd ff
	ff		 lea	 eax, DWORD PTR $T40[ebp]
  014b4	c1 e8 03	 shr	 eax, 3
  014b7	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  014be	8d 8d a8 fd ff
	ff		 lea	 ecx, DWORD PTR $T41[ebp]
  014c4	c1 e9 03	 shr	 ecx, 3
  014c7	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  014ce	8d 95 60 fb ff
	ff		 lea	 edx, DWORD PTR $T15[ebp]
  014d4	c1 ea 03	 shr	 edx, 3
  014d7	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  014dd	89 95 a4 fe ff
	ff		 mov	 DWORD PTR tv1042[ebp], edx
  014e3	6a 04		 push	 4
  014e5	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv1042[ebp]
  014eb	50		 push	 eax
  014ec	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  014f1	83 c4 08	 add	 esp, 8
  014f4	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv1042[ebp]
  014fa	c6 41 04 f8	 mov	 BYTE PTR [ecx+4], 248	; 000000f8H
  014fe	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR $T42[ebp]
  01504	c1 ea 03	 shr	 edx, 3
  01507	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0150e	8d 85 c8 fd ff
	ff		 lea	 eax, DWORD PTR $T43[ebp]
  01514	c1 e8 03	 shr	 eax, 3
  01517	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  0151e	8d 8d a8 fb ff
	ff		 lea	 ecx, DWORD PTR $T16[ebp]
  01524	c1 e9 03	 shr	 ecx, 3
  01527	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0152d	89 8d a8 fe ff
	ff		 mov	 DWORD PTR tv1029[ebp], ecx
  01533	6a 04		 push	 4
  01535	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR tv1029[ebp]
  0153b	52		 push	 edx
  0153c	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01541	83 c4 08	 add	 esp, 8
  01544	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv1029[ebp]
  0154a	c6 40 04 f8	 mov	 BYTE PTR [eax+4], 248	; 000000f8H
  0154e	8d 8d d8 fd ff
	ff		 lea	 ecx, DWORD PTR $T44[ebp]
  01554	c1 e9 03	 shr	 ecx, 3
  01557	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  0155e	8d 95 e8 fd ff
	ff		 lea	 edx, DWORD PTR $T45[ebp]
  01564	c1 ea 03	 shr	 edx, 3
  01567	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
  0156e	8d 85 f0 fb ff
	ff		 lea	 eax, DWORD PTR $T17[ebp]
  01574	c1 e8 03	 shr	 eax, 3
  01577	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  0157c	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv1016[ebp], eax
  01582	6a 04		 push	 4
  01584	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv1016[ebp]
  0158a	51		 push	 ecx
  0158b	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  01590	83 c4 08	 add	 esp, 8
  01593	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv1016[ebp]
  01599	c6 42 04 f8	 mov	 BYTE PTR [edx+4], 248	; 000000f8H
  0159d	8d 85 f8 fd ff
	ff		 lea	 eax, DWORD PTR $T46[ebp]
  015a3	c1 e8 03	 shr	 eax, 3
  015a6	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H
  015ad	8d 8d 08 fe ff
	ff		 lea	 ecx, DWORD PTR $T47[ebp]
  015b3	c1 e9 03	 shr	 ecx, 3
  015b6	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
  015bd	68 00 00 00 00	 push	 OFFSET ??__Flevel1@@YAXXZ ; `dynamic atexit destructor for 'level1''
  015c2	e8 00 00 00 00	 call	 _atexit
  015c7	83 c4 04	 add	 esp, 4
  015ca	c7 85 38 f7 ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  015d4	8d 95 38 f7 ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  015da	c1 ea 03	 shr	 edx, 3
  015dd	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  015e3	89 95 64 ff ff
	ff		 mov	 DWORD PTR tv1204[ebp], edx
  015e9	68 df 00 00 00	 push	 223			; 000000dfH
  015ee	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv1204[ebp]
  015f4	50		 push	 eax
  015f5	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  015fa	83 c4 08	 add	 esp, 8
  015fd	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  01600	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  01607	59		 pop	 ecx
  01608	8b e5		 mov	 esp, ebp
  0160a	5d		 pop	 ebp
  0160b	8b e3		 mov	 esp, ebx
  0160d	5b		 pop	 ebx
  0160e	c3		 ret	 0
text$di	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Elevel1@@YAXXZ$0:
  00000	8d 8d 48 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$1:
  0000b	8d 8d 58 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+16]
  00011	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$2:
  00016	8d 8d 68 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+32]
  0001c	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$3:
  00021	8d 8d 78 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+48]
  00027	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$4:
  0002c	8d 8d 88 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+64]
  00032	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$5:
  00037	8d 8d 98 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+80]
  0003d	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$6:
  00042	8d 8d a8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+96]
  00048	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$7:
  0004d	8d 8d b8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+112]
  00053	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$8:
  00058	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+128]
  0005e	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$9:
  00063	8d 8d d8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+144]
  00069	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$10:
  0006e	8d 8d e8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+160]
  00074	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$11:
  00079	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+176]
  0007f	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$12:
  00084	8d 8d 08 f8 ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp+192]
  0008a	e9 00 00 00 00	 jmp	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
__unwindfunclet$??__Elevel1@@YAXXZ$14:
  0008f	68 00 00 00 00	 push	 OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  00094	6a 0e		 push	 14			; 0000000eH
  00096	6a 10		 push	 16			; 00000010H
  00098	8d 85 48 f7 ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  0009e	50		 push	 eax
  0009f	e8 00 00 00 00	 call	 ??_M@YGXPAXIIP6EX0@Z@Z
  000a4	c3		 ret	 0
  000a5	cc		 int	 3
  000a6	cc		 int	 3
  000a7	cc		 int	 3
  000a8	cc		 int	 3
  000a9	cc		 int	 3
__ehhandler$??__Elevel1@@YAXXZ:
  000aa	90		 npad	 1
  000ab	90		 npad	 1
  000ac	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  000b0	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  000b3	8b 8a 28 f7 ff
	ff		 mov	 ecx, DWORD PTR [edx-2264]
  000b9	33 c8		 xor	 ecx, eax
  000bb	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c0	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??__Elevel1@@YAXXZ
  000c5	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??__Elevel1@@YAXXZ ENDP					; `dynamic initializer for 'level1''
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >, COMDAT

; 719  :     static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&, _Uty* const _Ptr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 720  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 721  :         _STD destroy_at(_Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??$destroy_at@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAXQAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::destroy_at<std::vector<int,std::allocator<int> > >
  00016	83 c4 04	 add	 esp, 4

; 722  : #else // __cpp_lib_constexpr_dynamic_alloc
; 723  :         _Ptr->~_Uty();
; 724  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 725  :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {

  0002c	eb 09		 jmp	 SHORT $LN4@Destroy_ra
$LN2@Destroy_ra:
  0002e	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00031	83 c0 10	 add	 eax, 16			; 00000010H
  00034	89 45 08	 mov	 DWORD PTR __First$[ebp], eax
$LN4@Destroy_ra:
  00037	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  0003a	3b 4d 0c	 cmp	 ecx, DWORD PTR __Last$[ebp]
  0003d	74 1b		 je	 SHORT $LN5@Destroy_ra

; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));

  0003f	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  00048	83 c4 04	 add	 esp, 4
  0004b	50		 push	 eax
  0004c	8b 45 10	 mov	 eax, DWORD PTR __Al$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 ??$destroy@V?$vector@HV?$allocator@H@std@@@std@@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::destroy<std::vector<int,std::allocator<int> > >
  00055	83 c4 08	 add	 esp, 8

; 951  :         }

  00058	eb d4		 jmp	 SHORT $LN2@Destroy_ra
$LN5@Destroy_ra:

; 952  :     }
; 953  : }

  0005a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0005d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00064	59		 pop	 ecx
  00065	8b e5		 mov	 esp, ebp
  00067	5d		 pop	 ebp
  00068	c3		 ret	 0
  00069	cc		 int	 3
  0006a	cc		 int	 3
  0006b	cc		 int	 3
  0006c	cc		 int	 3
  0006d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z PROC		; std::construct_at<int,int &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ENDP		; std::construct_at<int,int &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@HAAHX@std@@YAPAHQAHAAH@Z ; std::construct_at<int,int &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@AAH@std@@YAAAHAAH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAH@std@@YAAAHAAH@Z PROC			; std::forward<int &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@AAH@std@@YAAAHAAH@Z ENDP			; std::forward<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@AAH@std@@YAAAHAAH@Z ; std::forward<int &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@HAAH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHAAH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z PROC		; std::_Copy_memmove<int *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ENDP		; std::_Copy_memmove<int *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z PROC		; std::_Get_unwrapped<int * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ENDP		; std::_Get_unwrapped<int * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQAH@std@@YA?A_TABQAH@Z ; std::_Get_unwrapped<int * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PAHPAH@std@@YAPAHPAH00@Z ; std::_Copy_memmove<int *,int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@AAH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXAAH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int *,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z PROC ; std::forward<std::allocator<int> >, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ENDP ; std::forward<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PAHV?$allocator@H@std@@@std@@YAPAHQAH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int *,std::allocator<int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@V?$allocator@H@std@@@std@@YA$$QAV?$allocator@H@0@AAV10@@Z ; std::forward<std::allocator<int> >
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv78 = -4						; size = 4
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z PROC ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 10		 push	 16			; 00000010H
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 fc	 mov	 DWORD PTR tv78[ebp], eax
  00039	8b 55 fc	 mov	 edx, DWORD PTR tv78[ebp]
  0003c	52		 push	 edx
  0003d	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00040	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >

; 145  : }

  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ENDP ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
tv85 = -4						; size = 4
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1b		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@V?$vector@HV?$allocator@H@std@@@std@@ABV12@X@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QAV10@ABV10@@Z ; std::construct_at<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	eb 35		 jmp	 SHORT $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00037	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003a	50		 push	 eax
  0003b	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAV?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAXPAV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Voidify_iter<std::vector<int,std::allocator<int> > *>
  00040	83 c4 04	 add	 esp, 4
  00043	50		 push	 eax
  00044	6a 10		 push	 16			; 00000010H
  00046	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004b	83 c4 08	 add	 esp, 8
  0004e	89 45 f8	 mov	 DWORD PTR $T1[ebp], eax
  00051	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 fc	 mov	 DWORD PTR tv85[ebp], eax
  00060	8b 55 fc	 mov	 edx, DWORD PTR tv85[ebp]
  00063	52		 push	 edx
  00064	8b 4d f8	 mov	 ecx, DWORD PTR $T1[ebp]
  00067	e8 00 00 00 00	 call	 ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z PROC ; std::forward<std::vector<int,std::allocator<int> > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ENDP ; std::forward<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z PROC ; std::_Unfancy<std::vector<int,std::allocator<int> > >, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ENDP ; std::_Unfancy<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABV?$vector@HV?$allocator@H@std@@@std@@@std@@YAABV?$vector@HV?$allocator@H@std@@@0@ABV10@@Z ; std::forward<std::vector<int,std::allocator<int> > const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@V?$vector@HV?$allocator@H@std@@@std@@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@PAV10@@Z ; std::_Unfancy<std::vector<int,std::allocator<int> > >
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@V?$vector@HV?$allocator@H@std@@@std@@ABV12@@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAXAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@QAV?$vector@HV?$allocator@H@std@@@1@ABV31@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::construct<std::vector<int,std::allocator<int> >,std::vector<int,std::allocator<int> > const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 10	 add	 eax, 16			; 00000010H
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z PROC ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ENDP ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
__Backout$ = -112					; size = 12
tv86 = -64						; size = 4
__UFirst$ = -60						; size = 4
tv84 = -56						; size = 4
__ULast$ = -52						; size = 4
$T3 = -48						; size = 4
tv89 = -44						; size = 4
tv71 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	83 c4 90	 add	 esp, -112		; ffffff90H
  00028	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002d	33 c5		 xor	 eax, ebp
  0002f	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00043	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0004a	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  00051	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00054	89 45 c8	 mov	 DWORD PTR tv84[ebp], eax
  00057	8b 4d c8	 mov	 ecx, DWORD PTR tv84[ebp]
  0005a	c1 e9 03	 shr	 ecx, 3
  0005d	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00063	89 4d c0	 mov	 DWORD PTR tv86[ebp], ecx
  00066	8b 55 c0	 mov	 edx, DWORD PTR tv86[ebp]
  00069	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0006f	83 45 c0 04	 add	 DWORD PTR tv86[ebp], 4
  00073	8b 45 c0	 mov	 eax, DWORD PTR tv86[ebp]
  00076	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  0007c	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00081	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00086	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0008f	83 c4 04	 add	 esp, 4
  00092	89 45 c4	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  00095	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  00098	52		 push	 edx
  00099	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBV?$vector@HV?$allocator@H@std@@@std@@@std@@YA?A_TABQBV?$vector@HV?$allocator@H@std@@@0@@Z ; std::_Get_unwrapped<std::vector<int,std::allocator<int> > const * const &>
  0009e	83 c4 04	 add	 esp, 4
  000a1	89 45 cc	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())
; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
; 1664 :             _Dest += _ULast - _UFirst;
; 1665 :             return _Dest;
; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  000a4	6a 0c		 push	 12			; 0000000cH
  000a6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000a9	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXI@Z
  000ae	8b 43 14	 mov	 eax, DWORD PTR __Al$[ebx]
  000b1	50		 push	 eax
  000b2	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000b5	51		 push	 ecx
  000b6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000b9	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@PAV?$vector@HV?$allocator@H@std@@@1@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  000be	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  000c5	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  000c7	8b 55 c4	 mov	 edx, DWORD PTR __UFirst$[ebp]
  000ca	83 c2 10	 add	 edx, 16			; 00000010H
  000cd	89 55 c4	 mov	 DWORD PTR __UFirst$[ebp], edx
$LN4@Uninitiali:
  000d0	8b 45 c4	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d3	3b 45 cc	 cmp	 eax, DWORD PTR __ULast$[ebp]
  000d6	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  000d8	8b 4d c4	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  000db	51		 push	 ecx
  000dc	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000df	e8 00 00 00 00	 call	 ??$_Emplace_back@ABV?$vector@HV?$allocator@H@std@@@std@@@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEXABV?$vector@HV?$allocator@H@std@@@1@@Z ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Emplace_back<std::vector<int,std::allocator<int> > const &>

; 1672 :     }

  000e4	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  000e6	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000e9	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::_Release
  000ee	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  000f1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f8	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  000fb	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00100	8b 55 d0	 mov	 edx, DWORD PTR $T3[ebp]
  00103	89 55 d8	 mov	 DWORD PTR tv71[ebp], edx
  00106	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0010d	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00110	c1 e8 03	 shr	 eax, 3
  00113	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00118	89 45 d4	 mov	 DWORD PTR tv89[ebp], eax
  0011b	6a 08		 push	 8
  0011d	8b 4d d4	 mov	 ecx, DWORD PTR tv89[ebp]
  00120	51		 push	 ecx
  00121	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00126	83 c4 08	 add	 esp, 8
  00129	8b 45 d8	 mov	 eax, DWORD PTR tv71[ebp]

; 1675 : }

  0012c	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0012f	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00136	59		 pop	 ecx
  00137	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0013a	33 cd		 xor	 ecx, ebp
  0013c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00141	8b e5		 mov	 esp, ebp
  00143	5d		 pop	 ebp
  00144	8b e3		 mov	 esp, ebx
  00146	5b		 pop	 ebx
  00147	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z$0:
  00000	8d 4d 90	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >::~_Uninitialized_backout_al<std::allocator<std::vector<int,std::allocator<int> > > >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 4a 88	 mov	 ecx, DWORD PTR [edx-120]
  00019	33 c8		 xor	 ecx, eax
  0001b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00020	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00023	33 c8		 xor	 ecx, eax
  00025	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002a	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z
  0002f	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBV?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@YAPAV?$vector@HV?$allocator@H@std@@@0@QBV10@0PAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Uninitialized_copy<std::vector<int,std::allocator<int> > const *,std::allocator<std::vector<int,std::allocator<int> > > >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z PROC ; std::distance<std::vector<int,std::allocator<int> > const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 04	 sar	 eax, 4

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ENDP ; std::distance<std::vector<int,std::allocator<int> > const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z PROC ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ENDP ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Guard$3 = -136					; size = 4
tv172 = -92						; size = 1
tv162 = -91						; size = 1
tv152 = -90						; size = 1
tv142 = -89						; size = 1
tv94 = -88						; size = 4
_this$ = -84						; size = 4
tv169 = -80						; size = 4
tv159 = -76						; size = 4
tv149 = -72						; size = 4
tv139 = -68						; size = 4
__Count$ = -64						; size = 4
tv78 = -60						; size = 4
__My_data$4 = -56					; size = 4
tv75 = -52						; size = 4
tv92 = -48						; size = 4
tv77 = -44						; size = 4
tv135 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  00056	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
  00060	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  00069	8b 4d d0	 mov	 ecx, DWORD PTR tv92[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d a8	 mov	 DWORD PTR tv94[ebp], ecx
  00078	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  0007b	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00081	83 45 a8 04	 add	 DWORD PTR tv94[ebp], 4
  00085	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0008a	8b 4d a8	 mov	 ecx, DWORD PTR tv94[ebp]
  0008d	66 89 01	 mov	 WORD PTR [ecx], ax
  00090	83 45 a8 02	 add	 DWORD PTR tv94[ebp], 2
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  00097	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0009f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  000a4	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000a7	50		 push	 eax
  000a8	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$distance@PBV?$vector@HV?$allocator@H@std@@@std@@@std@@YAHPBV?$vector@HV?$allocator@H@std@@@0@0@Z ; std::distance<std::vector<int,std::allocator<int> > const *>
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 c0	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  000c0	83 7d c0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000c4	0f 84 69 01 00
	00		 je	 $LN1@Range_cons
  000ca	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 527  :             _Buy_nonzero(_Count);

  000da	8b 45 c0	 mov	 eax, DWORD PTR __Count$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  000e6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ec	89 4d b0	 mov	 DWORD PTR tv169[ebp], ecx
  000ef	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 a4	 mov	 BYTE PTR tv172[ebp], al
  000fe	80 7d a4 00	 cmp	 BYTE PTR tv172[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@Range_cons
  00104	8a 4d b0	 mov	 cl, BYTE PTR tv169[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d a4	 cmp	 cl, BYTE PTR tv172[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@Range_cons
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN8@Range_cons:
  0011e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Guard$3[ebp], eax
  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0012e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	89 4d c8	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00134	8b 55 c8	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00137	83 c2 04	 add	 edx, 4
  0013a	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00140	89 45 b4	 mov	 DWORD PTR tv159[ebp], eax
  00143	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	c1 e9 03	 shr	 ecx, 3
  00149	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0014f	88 55 a5	 mov	 BYTE PTR tv162[ebp], dl
  00152	80 7d a5 00	 cmp	 BYTE PTR tv162[ebp], 0
  00156	74 18		 je	 SHORT $LN7@Range_cons
  00158	8a 45 b4	 mov	 al, BYTE PTR tv159[ebp]
  0015b	24 07		 and	 al, 7
  0015d	04 03		 add	 al, 3
  0015f	3a 45 a5	 cmp	 al, BYTE PTR tv162[ebp]
  00162	7c 0c		 jl	 SHORT $LN7@Range_cons
  00164	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ___asan_report_load4
  0016d	83 c4 04	 add	 esp, 4
$LN7@Range_cons:
  00170	8b 55 c4	 mov	 edx, DWORD PTR tv78[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	50		 push	 eax
  00176	8b 4b 0c	 mov	 ecx, DWORD PTR __Last$[ebx]
  00179	51		 push	 ecx
  0017a	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  0017d	52		 push	 edx
  0017e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??$_Ucopy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEPAV?$vector@HV?$allocator@H@std@@@1@PBV21@0PAV21@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Ucopy<std::vector<int,std::allocator<int> > const *>
  00186	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00189	8b 45 c8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	89 45 cc	 mov	 DWORD PTR tv75[ebp], eax
  00192	8b 4d cc	 mov	 ecx, DWORD PTR tv75[ebp]
  00195	89 4d b8	 mov	 DWORD PTR tv149[ebp], ecx
  00198	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  0019b	c1 ea 03	 shr	 edx, 3
  0019e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001a4	88 45 a6	 mov	 BYTE PTR tv152[ebp], al
  001a7	80 7d a6 00	 cmp	 BYTE PTR tv152[ebp], 0
  001ab	74 1a		 je	 SHORT $LN6@Range_cons
  001ad	8a 4d b8	 mov	 cl, BYTE PTR tv149[ebp]
  001b0	80 e1 07	 and	 cl, 7
  001b3	80 c1 03	 add	 cl, 3
  001b6	3a 4d a6	 cmp	 cl, BYTE PTR tv152[ebp]
  001b9	7c 0c		 jl	 SHORT $LN6@Range_cons
  001bb	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 ___asan_report_store4
  001c4	83 c4 04	 add	 esp, 4
$LN6@Range_cons:
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv75[ebp]
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  001cd	89 08		 mov	 DWORD PTR [eax], ecx

; 531  :             _Guard._Target   = nullptr;

  001cf	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  001d5	89 55 bc	 mov	 DWORD PTR tv139[ebp], edx
  001d8	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d a7	 mov	 BYTE PTR tv142[ebp], cl
  001e7	80 7d a7 00	 cmp	 BYTE PTR tv142[ebp], 0
  001eb	74 1a		 je	 SHORT $LN5@Range_cons
  001ed	8a 55 bc	 mov	 dl, BYTE PTR tv139[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 a7	 cmp	 dl, BYTE PTR tv142[ebp]
  001f9	7c 0c		 jl	 SHORT $LN5@Range_cons
  001fb	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN5@Range_cons:
  00207	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  00211	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00218	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0021e	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN1@Range_cons:

; 533  :     }

  00233	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0023d	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00243	c1 ea 03	 shr	 edx, 3
  00246	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0024c	89 55 d8	 mov	 DWORD PTR tv135[ebp], edx
  0024f	6a 07		 push	 7
  00251	8b 45 d8	 mov	 eax, DWORD PTR tv135[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025a	83 c4 08	 add	 esp, 8
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	59		 pop	 ecx
  00268	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	8b e3		 mov	 esp, ebx
  00277	5b		 pop	 ebx
  00278	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >::~_Tidy_guard<std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@ABV10@@Z ; std::forward<std::allocator<std::vector<int,std::allocator<int> > > const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : _CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 999  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1000 :     using _Ty = typename _Alloc::value_type;
; 1001 :     _Ptr->~_Ty();
; 1002 :     _Deallocate_plain(_Al, _Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0001a	83 c4 08	 add	 esp, 8

; 1003 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z PROC ; std::_Destroy_range<std::allocator<int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ENDP ; std::_Destroy_range<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z PROC		; std::_Voidify_iter<int *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ENDP		; std::_Voidify_iter<int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@HABHX@std@@YAPAHQAHABH@Z
_TEXT	SEGMENT
tv77 = -24						; size = 4
tv72 = -20						; size = 4
$T1 = -16						; size = 4
tv80 = -12						; size = 4
tv90 = -8						; size = 4
tv83 = -2						; size = 1
tv93 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@HABHX@std@@YAPAHQAHABH@Z PROC		; std::construct_at<int,int const &,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 04		 push	 4
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 ec	 mov	 DWORD PTR tv72[ebp], eax
  00039	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv90[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv93[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv93[ebp], 0
  00052	74 1a		 je	 SHORT $LN4@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv90[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv93[ebp]
  00060	7c 0c		 jl	 SHORT $LN4@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv90[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN4@construct_:
  0006e	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  00071	89 4d e8	 mov	 DWORD PTR tv77[ebp], ecx
  00074	8b 55 e8	 mov	 edx, DWORD PTR tv77[ebp]
  00077	89 55 f4	 mov	 DWORD PTR tv80[ebp], edx
  0007a	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  0007d	c1 e8 03	 shr	 eax, 3
  00080	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00086	88 4d fe	 mov	 BYTE PTR tv83[ebp], cl
  00089	80 7d fe 00	 cmp	 BYTE PTR tv83[ebp], 0
  0008d	74 1a		 je	 SHORT $LN3@construct_
  0008f	8a 55 f4	 mov	 dl, BYTE PTR tv80[ebp]
  00092	80 e2 07	 and	 dl, 7
  00095	80 c2 03	 add	 dl, 3
  00098	3a 55 fe	 cmp	 dl, BYTE PTR tv83[ebp]
  0009b	7c 0c		 jl	 SHORT $LN3@construct_
  0009d	8b 45 f4	 mov	 eax, DWORD PTR tv80[ebp]
  000a0	50		 push	 eax
  000a1	e8 00 00 00 00	 call	 ___asan_report_store4
  000a6	83 c4 04	 add	 esp, 4
$LN3@construct_:
  000a9	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000ac	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  000af	8b 02		 mov	 eax, DWORD PTR [edx]
  000b1	89 01		 mov	 DWORD PTR [ecx], eax
  000b3	8b 45 f0	 mov	 eax, DWORD PTR $T1[ebp]

; 145  : }

  000b6	8b e5		 mov	 esp, ebp
  000b8	5d		 pop	 ebp
  000b9	c3		 ret	 0
??$construct_at@HABHX@std@@YAPAHQAHABH@Z ENDP		; std::construct_at<int,int const &,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z
_TEXT	SEGMENT
tv84 = -24						; size = 4
tv79 = -20						; size = 4
$T1 = -16						; size = 4
tv87 = -12						; size = 4
tv129 = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
___formal$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>, COMDAT

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 708  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 709  :         if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 1e		 je	 SHORT $LN2@construct

; 710  :             _STD construct_at(_Ptr, _STD forward<_Types>(_Args)...);

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  00025	83 c4 04	 add	 esp, 4
  00028	50		 push	 eax
  00029	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  0002c	52		 push	 edx
  0002d	e8 00 00 00 00	 call	 ??$construct_at@HABHX@std@@YAPAHQAHABH@Z ; std::construct_at<int,int const &,void>
  00032	83 c4 08	 add	 esp, 8

; 711  :         } else

  00035	e9 a3 00 00 00	 jmp	 $LN1@construct
$LN2@construct:

; 707  :     static _CONSTEXPR20_DYNALLOC void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) {

  0003a	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  0003d	50		 push	 eax
  0003e	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAH@std@@YAPAXPAH@Z ; std::_Voidify_iter<int *>
  00043	83 c4 04	 add	 esp, 4
  00046	50		 push	 eax
  00047	6a 04		 push	 4
  00049	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  0004e	83 c4 08	 add	 esp, 8
  00051	89 45 f0	 mov	 DWORD PTR $T1[ebp], eax
  00054	8b 4d 10	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  00057	51		 push	 ecx
  00058	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0005d	83 c4 04	 add	 esp, 4
  00060	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  00063	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  00066	89 55 f8	 mov	 DWORD PTR tv129[ebp], edx
  00069	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0006c	c1 e8 03	 shr	 eax, 3
  0006f	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00075	88 4d ff	 mov	 BYTE PTR tv132[ebp], cl
  00078	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0007c	74 1a		 je	 SHORT $LN6@construct
  0007e	8a 55 f8	 mov	 dl, BYTE PTR tv129[ebp]
  00081	80 e2 07	 and	 dl, 7
  00084	80 c2 03	 add	 dl, 3
  00087	3a 55 ff	 cmp	 dl, BYTE PTR tv132[ebp]
  0008a	7c 0c		 jl	 SHORT $LN6@construct
  0008c	8b 45 f8	 mov	 eax, DWORD PTR tv129[ebp]
  0008f	50		 push	 eax
  00090	e8 00 00 00 00	 call	 ___asan_report_load4
  00095	83 c4 04	 add	 esp, 4
$LN6@construct:
  00098	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  0009b	89 4d e8	 mov	 DWORD PTR tv84[ebp], ecx
  0009e	8b 55 e8	 mov	 edx, DWORD PTR tv84[ebp]
  000a1	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  000a4	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000a7	c1 e8 03	 shr	 eax, 3
  000aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b0	88 4d fe	 mov	 BYTE PTR tv90[ebp], cl
  000b3	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  000b7	74 1a		 je	 SHORT $LN5@construct
  000b9	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  000bc	80 e2 07	 and	 dl, 7
  000bf	80 c2 03	 add	 dl, 3
  000c2	3a 55 fe	 cmp	 dl, BYTE PTR tv90[ebp]
  000c5	7c 0c		 jl	 SHORT $LN5@construct
  000c7	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  000ca	50		 push	 eax
  000cb	e8 00 00 00 00	 call	 ___asan_report_store4
  000d0	83 c4 04	 add	 esp, 4
$LN5@construct:
  000d3	8b 4d f0	 mov	 ecx, DWORD PTR $T1[ebp]
  000d6	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000d9	8b 02		 mov	 eax, DWORD PTR [edx]
  000db	89 01		 mov	 DWORD PTR [ecx], eax
$LN1@construct:

; 712  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 713  :         {
; 714  :             ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward<_Types>(_Args)...);
; 715  :         }
; 716  :     }

  000dd	8b e5		 mov	 esp, ebp
  000df	5d		 pop	 ebp
  000e0	c3		 ret	 0
??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABH@std@@YAABHABH@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABH@std@@YAABHABH@Z PROC			; std::forward<int const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABH@std@@YAABHABH@Z ENDP			; std::forward<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z
_TEXT	SEGMENT
tv81 = -56						; size = 4
tv74 = -52						; size = 4
tv76 = -48						; size = 4
tv78 = -44						; size = 4
tv80 = -40						; size = 4
tv79 = -36						; size = 4
tv71 = -32						; size = 4
tv68 = -28						; size = 4
tv91 = -24						; size = 4
tv133 = -20						; size = 4
tv143 = -16						; size = 4
tv153 = -12						; size = 4
_this$ = -8						; size = 4
tv94 = -4						; size = 1
tv136 = -3						; size = 1
tv146 = -2						; size = 1
tv156 = -1						; size = 1
_<_Vals_0>$ = 8						; size = 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>, COMDAT
; _this$ = ecx

; 1630 :     _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&&... _Vals) { // construct a new element at *_Last and increment

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 38	 sub	 esp, 56			; 00000038H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1631 :         allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), _STD forward<_Types>(_Vals)...);

  00013	8b 45 08	 mov	 eax, DWORD PTR _<_Vals_0>$[ebp]
  00016	50		 push	 eax
  00017	e8 00 00 00 00	 call	 ??$forward@ABH@std@@YAABHABH@Z ; std::forward<int const &>
  0001c	83 c4 04	 add	 esp, 4
  0001f	89 45 d4	 mov	 DWORD PTR tv78[ebp], eax
  00022	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00025	83 c1 04	 add	 ecx, 4
  00028	89 4d e4	 mov	 DWORD PTR tv68[ebp], ecx
  0002b	8b 55 e4	 mov	 edx, DWORD PTR tv68[ebp]
  0002e	89 55 f4	 mov	 DWORD PTR tv153[ebp], edx
  00031	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00034	c1 e8 03	 shr	 eax, 3
  00037	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0003d	88 4d ff	 mov	 BYTE PTR tv156[ebp], cl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv156[ebp], 0
  00044	74 1a		 je	 SHORT $LN6@Emplace_ba
  00046	8a 55 f4	 mov	 dl, BYTE PTR tv153[ebp]
  00049	80 e2 07	 and	 dl, 7
  0004c	80 c2 03	 add	 dl, 3
  0004f	3a 55 ff	 cmp	 dl, BYTE PTR tv156[ebp]
  00052	7c 0c		 jl	 SHORT $LN6@Emplace_ba
  00054	8b 45 f4	 mov	 eax, DWORD PTR tv153[ebp]
  00057	50		 push	 eax
  00058	e8 00 00 00 00	 call	 ___asan_report_load4
  0005d	83 c4 04	 add	 esp, 4
$LN6@Emplace_ba:
  00060	8b 4d e4	 mov	 ecx, DWORD PTR tv68[ebp]
  00063	8b 11		 mov	 edx, DWORD PTR [ecx]
  00065	52		 push	 edx
  00066	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  0006b	83 c4 04	 add	 esp, 4
  0006e	89 45 d0	 mov	 DWORD PTR tv76[ebp], eax
  00071	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00074	83 c0 08	 add	 eax, 8
  00077	89 45 e0	 mov	 DWORD PTR tv71[ebp], eax
  0007a	8b 4d e0	 mov	 ecx, DWORD PTR tv71[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv143[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 fe	 mov	 BYTE PTR tv146[ebp], al
  0008f	80 7d fe 00	 cmp	 BYTE PTR tv146[ebp], 0
  00093	74 1a		 je	 SHORT $LN5@Emplace_ba
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv143[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	80 c1 03	 add	 cl, 3
  0009e	3a 4d fe	 cmp	 cl, BYTE PTR tv146[ebp]
  000a1	7c 0c		 jl	 SHORT $LN5@Emplace_ba
  000a3	8b 55 f0	 mov	 edx, DWORD PTR tv143[ebp]
  000a6	52		 push	 edx
  000a7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ac	83 c4 04	 add	 esp, 4
$LN5@Emplace_ba:
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b4	89 4d cc	 mov	 DWORD PTR tv74[ebp], ecx
  000b7	8b 55 d4	 mov	 edx, DWORD PTR tv78[ebp]
  000ba	52		 push	 edx
  000bb	8b 45 d0	 mov	 eax, DWORD PTR tv76[ebp]
  000be	50		 push	 eax
  000bf	8b 4d cc	 mov	 ecx, DWORD PTR tv74[ebp]
  000c2	51		 push	 ecx
  000c3	e8 00 00 00 00	 call	 ??$construct@HABH@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAXAAV?$allocator@H@1@QAHABH@Z ; std::_Default_allocator_traits<std::allocator<int> >::construct<int,int const &>
  000c8	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1632 :         ++_Last;

  000cb	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ce	83 c2 04	 add	 edx, 4
  000d1	89 55 dc	 mov	 DWORD PTR tv79[ebp], edx
  000d4	8b 45 dc	 mov	 eax, DWORD PTR tv79[ebp]
  000d7	89 45 ec	 mov	 DWORD PTR tv133[ebp], eax
  000da	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000dd	c1 e9 03	 shr	 ecx, 3
  000e0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000e6	88 55 fd	 mov	 BYTE PTR tv136[ebp], dl
  000e9	80 7d fd 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ed	74 18		 je	 SHORT $LN4@Emplace_ba
  000ef	8a 45 ec	 mov	 al, BYTE PTR tv133[ebp]
  000f2	24 07		 and	 al, 7
  000f4	04 03		 add	 al, 3
  000f6	3a 45 fd	 cmp	 al, BYTE PTR tv136[ebp]
  000f9	7c 0c		 jl	 SHORT $LN4@Emplace_ba
  000fb	8b 4d ec	 mov	 ecx, DWORD PTR tv133[ebp]
  000fe	51		 push	 ecx
  000ff	e8 00 00 00 00	 call	 ___asan_report_load4
  00104	83 c4 04	 add	 esp, 4
$LN4@Emplace_ba:
  00107	8b 55 dc	 mov	 edx, DWORD PTR tv79[ebp]
  0010a	8b 02		 mov	 eax, DWORD PTR [edx]
  0010c	83 c0 04	 add	 eax, 4
  0010f	89 45 c8	 mov	 DWORD PTR tv81[ebp], eax
  00112	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00115	83 c1 04	 add	 ecx, 4
  00118	89 4d d8	 mov	 DWORD PTR tv80[ebp], ecx
  0011b	8b 55 d8	 mov	 edx, DWORD PTR tv80[ebp]
  0011e	89 55 e8	 mov	 DWORD PTR tv91[ebp], edx
  00121	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00124	c1 e8 03	 shr	 eax, 3
  00127	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0012d	88 4d fc	 mov	 BYTE PTR tv94[ebp], cl
  00130	80 7d fc 00	 cmp	 BYTE PTR tv94[ebp], 0
  00134	74 1a		 je	 SHORT $LN3@Emplace_ba
  00136	8a 55 e8	 mov	 dl, BYTE PTR tv91[ebp]
  00139	80 e2 07	 and	 dl, 7
  0013c	80 c2 03	 add	 dl, 3
  0013f	3a 55 fc	 cmp	 dl, BYTE PTR tv94[ebp]
  00142	7c 0c		 jl	 SHORT $LN3@Emplace_ba
  00144	8b 45 e8	 mov	 eax, DWORD PTR tv91[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 ___asan_report_store4
  0014d	83 c4 04	 add	 esp, 4
$LN3@Emplace_ba:
  00150	8b 4d d8	 mov	 ecx, DWORD PTR tv80[ebp]
  00153	8b 55 c8	 mov	 edx, DWORD PTR tv81[ebp]
  00156	89 11		 mov	 DWORD PTR [ecx], edx

; 1633 :     }

  00158	8b e5		 mov	 esp, ebp
  0015a	5d		 pop	 ebp
  0015b	c2 04 00	 ret	 4
??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
_this$ = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release, COMDAT
; _this$ = ecx

; 1635 :     constexpr pointer _Release() { // suppress any exception handling backout and return _Last

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1636 :         _First = _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 e4	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0001f	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  00022	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00025	89 55 f8	 mov	 DWORD PTR tv94[ebp], edx
  00028	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0002b	c1 e8 03	 shr	 eax, 3
  0002e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00034	88 4d ff	 mov	 BYTE PTR tv129[ebp], cl
  00037	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0003b	74 1a		 je	 SHORT $LN5@Release
  0003d	8a 55 f8	 mov	 dl, BYTE PTR tv94[ebp]
  00040	80 e2 07	 and	 dl, 7
  00043	80 c2 03	 add	 dl, 3
  00046	3a 55 ff	 cmp	 dl, BYTE PTR tv129[ebp]
  00049	7c 0c		 jl	 SHORT $LN5@Release
  0004b	8b 45 f8	 mov	 eax, DWORD PTR tv94[ebp]
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ___asan_report_load4
  00054	83 c4 04	 add	 esp, 4
$LN5@Release:
  00057	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0005a	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0005d	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00060	c1 ea 03	 shr	 edx, 3
  00063	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00069	88 45 fe	 mov	 BYTE PTR tv87[ebp], al
  0006c	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00070	74 1a		 je	 SHORT $LN4@Release
  00072	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00075	80 e1 07	 and	 cl, 7
  00078	80 c1 03	 add	 cl, 3
  0007b	3a 4d fe	 cmp	 cl, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@Release
  00080	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00083	52		 push	 edx
  00084	e8 00 00 00 00	 call	 ___asan_report_store4
  00089	83 c4 04	 add	 esp, 4
$LN4@Release:
  0008c	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  0008f	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00092	8b 11		 mov	 edx, DWORD PTR [ecx]
  00094	89 10		 mov	 DWORD PTR [eax], edx

; 1637 :         return _Last;

  00096	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00099	83 c0 04	 add	 eax, 4
  0009c	89 45 e0	 mov	 DWORD PTR tv66[ebp], eax
  0009f	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000a2	89 4d ec	 mov	 DWORD PTR tv74[ebp], ecx
  000a5	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000a8	c1 ea 03	 shr	 edx, 3
  000ab	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b1	88 45 fd	 mov	 BYTE PTR tv77[ebp], al
  000b4	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000b8	74 1a		 je	 SHORT $LN3@Release
  000ba	8a 4d ec	 mov	 cl, BYTE PTR tv74[ebp]
  000bd	80 e1 07	 and	 cl, 7
  000c0	80 c1 03	 add	 cl, 3
  000c3	3a 4d fd	 cmp	 cl, BYTE PTR tv77[ebp]
  000c6	7c 0c		 jl	 SHORT $LN3@Release
  000c8	8b 55 ec	 mov	 edx, DWORD PTR tv74[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_report_load4
  000d1	83 c4 04	 add	 esp, 4
$LN3@Release:
  000d4	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000d7	8b 00		 mov	 eax, DWORD PTR [eax]

; 1638 :     }

  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv64 = -16						; size = 4
_this$ = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1625 :     _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1626 :         _Destroy_range(_First, _Last, _Al);

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Uninitiali
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Uninitiali
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0005d	50		 push	 eax
  0005e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00061	8b 11		 mov	 edx, DWORD PTR [ecx]
  00063	52		 push	 edx
  00064	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1627 :     }

  0006c	8b e5		 mov	 esp, ebp
  0006e	5d		 pop	 ebp
  0006f	c3		 ret	 0
??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z
_TEXT	SEGMENT
tv66 = -32						; size = 4
tv65 = -28						; size = 4
tv64 = -24						; size = 4
tv74 = -20						; size = 4
tv84 = -16						; size = 4
tv94 = -12						; size = 4
_this$ = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Dest$ = 8						; size = 4
__Al_$ = 12						; size = 4
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z PROC ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >, COMDAT
; _this$ = ecx

; 1620 :         : _First(_Dest), _Last(_Dest), _Al(_Al_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 e8	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv94[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Uninitiali
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv94[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Uninitiali
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv94[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Uninitiali:
  0004e	8b 45 e8	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Dest$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e4	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e4	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00065	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00078	74 18		 je	 SHORT $LN4@Uninitiali
  0007a	8a 45 f0	 mov	 al, BYTE PTR tv84[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  00084	7c 0c		 jl	 SHORT $LN4@Uninitiali
  00086	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN4@Uninitiali:
  00092	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 08	 mov	 eax, DWORD PTR __Dest$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0009d	83 c1 08	 add	 ecx, 8
  000a0	89 4d e0	 mov	 DWORD PTR tv66[ebp], ecx
  000a3	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000a6	89 55 ec	 mov	 DWORD PTR tv74[ebp], edx
  000a9	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000ac	c1 e8 03	 shr	 eax, 3
  000af	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000b5	88 4d fd	 mov	 BYTE PTR tv77[ebp], cl
  000b8	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000bc	74 1a		 je	 SHORT $LN3@Uninitiali
  000be	8a 55 ec	 mov	 dl, BYTE PTR tv74[ebp]
  000c1	80 e2 07	 and	 dl, 7
  000c4	80 c2 03	 add	 dl, 3
  000c7	3a 55 fd	 cmp	 dl, BYTE PTR tv77[ebp]
  000ca	7c 0c		 jl	 SHORT $LN3@Uninitiali
  000cc	8b 45 ec	 mov	 eax, DWORD PTR tv74[ebp]
  000cf	50		 push	 eax
  000d0	e8 00 00 00 00	 call	 ___asan_report_store4
  000d5	83 c4 04	 add	 esp, 4
$LN3@Uninitiali:
  000d8	8b 4d e0	 mov	 ecx, DWORD PTR tv66[ebp]
  000db	8b 55 0c	 mov	 edx, DWORD PTR __Al_$[ebp]
  000de	89 11		 mov	 DWORD PTR [ecx], edx
  000e0	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 08 00	 ret	 8
??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ENDP ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z
_TEXT	SEGMENT
__Last_ch$ = -28					; size = 4
__DestPtr$ = -24					; size = 4
__LastPtr$ = -20					; size = 4
__FirstPtr$ = -16					; size = 4
__Count$ = -12						; size = 4
__Dest_ch$ = -8						; size = 4
__First_ch$ = -4					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z PROC	; std::_Copy_memmove<int const *,int *>, COMDAT

; 4159 : _OutCtgIt _Copy_memmove(_CtgIt _First, _CtgIt _Last, _OutCtgIt _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4160 :     auto _FirstPtr              = _To_address(_First);

  00010	8d 45 08	 lea	 eax, DWORD PTR __First$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 f0	 mov	 DWORD PTR __FirstPtr$[ebp], eax

; 4161 :     auto _LastPtr               = _To_address(_Last);

  0001f	8d 4d 0c	 lea	 ecx, DWORD PTR __Last$[ebp]
  00022	51		 push	 ecx
  00023	e8 00 00 00 00	 call	 ??$_To_address@PBH@std@@YA?A_PABQBH@Z ; std::_To_address<int const *>
  00028	83 c4 04	 add	 esp, 4
  0002b	89 45 ec	 mov	 DWORD PTR __LastPtr$[ebp], eax

; 4162 :     auto _DestPtr               = _To_address(_Dest);

  0002e	8d 55 10	 lea	 edx, DWORD PTR __Dest$[ebp]
  00031	52		 push	 edx
  00032	e8 00 00 00 00	 call	 ??$_To_address@PAH@std@@YA?A_PABQAH@Z ; std::_To_address<int *>
  00037	83 c4 04	 add	 esp, 4
  0003a	89 45 e8	 mov	 DWORD PTR __DestPtr$[ebp], eax

; 4163 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_FirstPtr));

  0003d	8b 45 f0	 mov	 eax, DWORD PTR __FirstPtr$[ebp]
  00040	89 45 fc	 mov	 DWORD PTR __First_ch$[ebp], eax

; 4164 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_LastPtr));

  00043	8b 4d ec	 mov	 ecx, DWORD PTR __LastPtr$[ebp]
  00046	89 4d e4	 mov	 DWORD PTR __Last_ch$[ebp], ecx

; 4165 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<const volatile char*>(_DestPtr));

  00049	8b 55 e8	 mov	 edx, DWORD PTR __DestPtr$[ebp]
  0004c	89 55 f8	 mov	 DWORD PTR __Dest_ch$[ebp], edx

; 4166 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

  0004f	8b 45 e4	 mov	 eax, DWORD PTR __Last_ch$[ebp]
  00052	2b 45 fc	 sub	 eax, DWORD PTR __First_ch$[ebp]
  00055	89 45 f4	 mov	 DWORD PTR __Count$[ebp], eax

; 4167 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

  00058	8b 4d f4	 mov	 ecx, DWORD PTR __Count$[ebp]
  0005b	51		 push	 ecx
  0005c	8b 55 fc	 mov	 edx, DWORD PTR __First_ch$[ebp]
  0005f	52		 push	 edx
  00060	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  00063	50		 push	 eax
  00064	e8 00 00 00 00	 call	 _memmove
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH

; 4168 :     if constexpr (is_pointer_v<_OutCtgIt>) {
; 4169 :         return reinterpret_cast<_OutCtgIt>(_Dest_ch + _Count);

  0006c	8b 45 f8	 mov	 eax, DWORD PTR __Dest_ch$[ebp]
  0006f	03 45 f4	 add	 eax, DWORD PTR __Count$[ebp]

; 4170 :     } else {
; 4171 :         return _Dest + (_LastPtr - _FirstPtr);
; 4172 :     }
; 4173 : }

  00072	8b e5		 mov	 esp, ebp
  00074	5d		 pop	 ebp
  00075	c3		 ret	 0
??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ENDP	; std::_Copy_memmove<int const *,int *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@H@std@@YAPAHPAH@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@H@std@@YAPAHPAH@Z PROC			; std::_Unfancy<int>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@H@std@@YAPAHPAH@Z ENDP			; std::_Unfancy<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@H@std@@YAPAHQAH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@H@std@@YAPAHQAH@Z PROC			; std::to_address<int>, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@H@std@@YAPAHQAH@Z ENDP			; std::to_address<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$to_address@$$CBH@std@@YAPBHQBH@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$to_address@$$CBH@std@@YAPBHQBH@Z PROC		; std::to_address<int const >, COMDAT

; 211  : _NODISCARD constexpr _Ty* to_address(_Ty* const _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 212  :     static_assert(!is_function_v<_Ty>,
; 213  :         "N4810 20.10.4 [pointer.conversion]/2: The program is ill-formed if T is a function type.");
; 214  :     return _Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 215  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$to_address@$$CBH@std@@YAPBHQBH@Z ENDP		; std::to_address<int const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z
_TEXT	SEGMENT
tv65 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
__It$ = 8						; size = 4
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z PROC		; std::_Get_unwrapped<int const * const &>, COMDAT

; 1324 : _NODISCARD constexpr decltype(auto) _Get_unwrapped(_Iter&& _It) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1325 :     // unwrap an iterator previously subjected to _Adl_verify_range or otherwise validated
; 1326 :     if constexpr (is_pointer_v<decay_t<_Iter>>) { // special-case pointers and arrays
; 1327 :         return _It + 0;

  00010	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  00013	89 45 f4	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d f4	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  0002f	74 1a		 je	 SHORT $LN3@Get_unwrap
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  0003d	7c 0c		 jl	 SHORT $LN3@Get_unwrap
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN3@Get_unwrap:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]
  0004e	8b 00		 mov	 eax, DWORD PTR [eax]

; 1328 :     } else if constexpr (_Unwrappable_v<_Iter>) {
; 1329 :         return static_cast<_Iter&&>(_It)._Unwrapped();
; 1330 :     } else {
; 1331 :         return static_cast<_Iter&&>(_It);
; 1332 :     }
; 1333 : }

  00050	8b e5		 mov	 esp, ebp
  00052	5d		 pop	 ebp
  00053	c3		 ret	 0
??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ENDP		; std::_Get_unwrapped<int const * const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -136					; size = 4
__asan_gen_1$ = -132					; size = 4
__asan_gen_2$ = -128					; size = 4
__Backout$ = -120					; size = 12
__UFirst$ = -72						; size = 4
tv131 = -68						; size = 4
__ULast$ = -64						; size = 4
tv129 = -60						; size = 4
tv134 = -56						; size = 4
tv83 = -52						; size = 4
$T3 = -48						; size = 4
tv140 = -44						; size = 4
tv128 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z PROC ; std::_Uninitialized_copy<int const *,std::allocator<int> >, COMDAT

; 1649 :     const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	c7 85 78 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00049	c7 85 7c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  00053	c7 45 80 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  0005a	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00060	89 45 c4	 mov	 DWORD PTR tv129[ebp], eax
  00063	8b 4d c4	 mov	 ecx, DWORD PTR tv129[ebp]
  00066	c1 e9 03	 shr	 ecx, 3
  00069	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0006f	89 4d bc	 mov	 DWORD PTR tv131[ebp], ecx
  00072	8b 55 bc	 mov	 edx, DWORD PTR tv131[ebp]
  00075	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0007b	83 45 bc 04	 add	 DWORD PTR tv131[ebp], 4
  0007f	8b 45 bc	 mov	 eax, DWORD PTR tv131[ebp]
  00082	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00088	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0008d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1650 :     // copy [_First, _Last) to raw _Dest, using _Al
; 1651 :     // note: only called internally from elsewhere in the STL
; 1652 :     using _Ptrval = typename _Alloc::value_type*;
; 1653 : 
; 1654 :     auto _UFirst      = _Get_unwrapped(_First);

  00092	8d 4b 08	 lea	 ecx, DWORD PTR __First$[ebx]
  00095	51		 push	 ecx
  00096	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  0009b	83 c4 04	 add	 esp, 4
  0009e	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax

; 1655 :     const auto _ULast = _Get_unwrapped(_Last);

  000a1	8d 53 0c	 lea	 edx, DWORD PTR __Last$[ebx]
  000a4	52		 push	 edx
  000a5	e8 00 00 00 00	 call	 ??$_Get_unwrapped@ABQBH@std@@YA?A_TABQBH@Z ; std::_Get_unwrapped<int const * const &>
  000aa	83 c4 04	 add	 esp, 4
  000ad	89 45 c0	 mov	 DWORD PTR __ULast$[ebp], eax

; 1656 : 
; 1657 :     if constexpr (conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
; 1658 :                       _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>) {
; 1659 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1660 :         if (!_STD is_constant_evaluated())

  000b0	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  000b5	0f b6 c0	 movzx	 eax, al
  000b8	85 c0		 test	 eax, eax
  000ba	75 67		 jne	 SHORT $LN5@Uninitiali

; 1661 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1662 :         {
; 1663 :             _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));

  000bc	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 ??$_Unfancy@H@std@@YAPAHPAH@Z ; std::_Unfancy<int>
  000c5	83 c4 04	 add	 esp, 4
  000c8	50		 push	 eax
  000c9	8b 55 c0	 mov	 edx, DWORD PTR __ULast$[ebp]
  000cc	52		 push	 edx
  000cd	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  000d0	50		 push	 eax
  000d1	e8 00 00 00 00	 call	 ??$_Copy_memmove@PBHPAH@std@@YAPAHPBH0PAH@Z ; std::_Copy_memmove<int const *,int *>
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1664 :             _Dest += _ULast - _UFirst;

  000d9	8b 4d c0	 mov	 ecx, DWORD PTR __ULast$[ebp]
  000dc	2b 4d b8	 sub	 ecx, DWORD PTR __UFirst$[ebp]
  000df	c1 f9 02	 sar	 ecx, 2
  000e2	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  000e5	8d 04 8a	 lea	 eax, DWORD PTR [edx+ecx*4]
  000e8	89 43 10	 mov	 DWORD PTR __Dest$[ebx], eax

; 1665 :             return _Dest;

  000eb	8b 4b 10	 mov	 ecx, DWORD PTR __Dest$[ebx]
  000ee	89 4d cc	 mov	 DWORD PTR tv83[ebp], ecx
  000f1	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000fb	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00101	c1 ea 03	 shr	 edx, 3
  00104	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0010a	89 55 c8	 mov	 DWORD PTR tv134[ebp], edx
  0010d	6a 08		 push	 8
  0010f	8b 45 c8	 mov	 eax, DWORD PTR tv134[ebp]
  00112	50		 push	 eax
  00113	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00118	83 c4 08	 add	 esp, 8
  0011b	8b 45 cc	 mov	 eax, DWORD PTR tv83[ebp]
  0011e	e9 8f 00 00 00	 jmp	 $LN1@Uninitiali
$LN5@Uninitiali:

; 1666 :         }
; 1667 :     }
; 1668 : 
; 1669 :     _Uninitialized_backout_al<_Alloc> _Backout{_Dest, _Al};

  00123	6a 0c		 push	 12			; 0000000cH
  00125	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00128	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXI@Z
  0012d	8b 4b 14	 mov	 ecx, DWORD PTR __Al$[ebx]
  00130	51		 push	 ecx
  00131	8b 53 10	 mov	 edx, DWORD PTR __Dest$[ebx]
  00134	52		 push	 edx
  00135	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00138	e8 00 00 00 00	 call	 ??0?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@PAHAAV?$allocator@H@1@@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Uninitialized_backout_al<std::allocator<int> >
  0013d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 1670 :     for (; _UFirst != _ULast; ++_UFirst) {

  00144	eb 09		 jmp	 SHORT $LN4@Uninitiali
$LN2@Uninitiali:
  00146	8b 45 b8	 mov	 eax, DWORD PTR __UFirst$[ebp]
  00149	83 c0 04	 add	 eax, 4
  0014c	89 45 b8	 mov	 DWORD PTR __UFirst$[ebp], eax
$LN4@Uninitiali:
  0014f	8b 4d b8	 mov	 ecx, DWORD PTR __UFirst$[ebp]
  00152	3b 4d c0	 cmp	 ecx, DWORD PTR __ULast$[ebp]
  00155	74 0e		 je	 SHORT $LN3@Uninitiali

; 1671 :         _Backout._Emplace_back(*_UFirst);

  00157	8b 55 b8	 mov	 edx, DWORD PTR __UFirst$[ebp]
  0015a	52		 push	 edx
  0015b	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0015e	e8 00 00 00 00	 call	 ??$_Emplace_back@ABH@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEXABH@Z ; std::_Uninitialized_backout_al<std::allocator<int> >::_Emplace_back<int const &>

; 1672 :     }

  00163	eb e1		 jmp	 SHORT $LN2@Uninitiali
$LN3@Uninitiali:

; 1673 : 
; 1674 :     return _Backout._Release();

  00165	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00168	e8 00 00 00 00	 call	 ?_Release@?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAEPAHXZ ; std::_Uninitialized_backout_al<std::allocator<int> >::_Release
  0016d	89 45 d0	 mov	 DWORD PTR $T3[ebp], eax
  00170	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00177	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  0017a	e8 00 00 00 00	 call	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  0017f	8b 45 d0	 mov	 eax, DWORD PTR $T3[ebp]
  00182	89 45 d8	 mov	 DWORD PTR tv128[ebp], eax
  00185	c7 85 78 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0018f	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00195	c1 e9 03	 shr	 ecx, 3
  00198	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0019e	89 4d d4	 mov	 DWORD PTR tv140[ebp], ecx
  001a1	6a 08		 push	 8
  001a3	8b 55 d4	 mov	 edx, DWORD PTR tv140[ebp]
  001a6	52		 push	 edx
  001a7	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001ac	83 c4 08	 add	 esp, 8
  001af	8b 45 d8	 mov	 eax, DWORD PTR tv128[ebp]
$LN1@Uninitiali:

; 1675 : }

  001b2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001b5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001bc	59		 pop	 ecx
  001bd	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001c0	33 cd		 xor	 ecx, ebp
  001c2	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001c7	8b e5		 mov	 esp, ebp
  001c9	5d		 pop	 ebp
  001ca	8b e3		 mov	 esp, ebx
  001cc	5b		 pop	 ebx
  001cd	c3		 ret	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z$0:
  00000	8d 4d 88	 lea	 ecx, DWORD PTR __Backout$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$_Uninitialized_backout_al@V?$allocator@H@std@@@std@@QAE@XZ ; std::_Uninitialized_backout_al<std::allocator<int> >::~_Uninitialized_backout_al<std::allocator<int> >
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ENDP ; std::_Uninitialized_copy<int const *,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$min@I@std@@YAABIABI0@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv70 = -24						; size = 4
tv67 = -20						; size = 4
tv65 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$min@I@std@@YAABIABI0@Z PROC				; std::min<unsigned int>, COMDAT

; 66   :     const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left)) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 67   :     // return smaller of _Left and _Right
; 68   :     return _Right < _Left ? _Right : _Left;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv67[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv67[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  0002f	74 1a		 je	 SHORT $LN6@min
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  0003d	7c 0c		 jl	 SHORT $LN6@min
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN6@min:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  0004e	89 45 e8	 mov	 DWORD PTR tv70[ebp], eax
  00051	8b 4d e8	 mov	 ecx, DWORD PTR tv70[ebp]
  00054	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
  00057	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0005a	c1 ea 03	 shr	 edx, 3
  0005d	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00063	88 45 fe	 mov	 BYTE PTR tv76[ebp], al
  00066	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  0006a	74 1a		 je	 SHORT $LN5@min
  0006c	8a 4d f4	 mov	 cl, BYTE PTR tv73[ebp]
  0006f	80 e1 07	 and	 cl, 7
  00072	80 c1 03	 add	 cl, 3
  00075	3a 4d fe	 cmp	 cl, BYTE PTR tv76[ebp]
  00078	7c 0c		 jl	 SHORT $LN5@min
  0007a	8b 55 f4	 mov	 edx, DWORD PTR tv73[ebp]
  0007d	52		 push	 edx
  0007e	e8 00 00 00 00	 call	 ___asan_report_load4
  00083	83 c4 04	 add	 esp, 4
$LN5@min:
  00086	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00089	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0008c	8b 10		 mov	 edx, DWORD PTR [eax]
  0008e	3b 11		 cmp	 edx, DWORD PTR [ecx]
  00090	73 08		 jae	 SHORT $LN3@min
  00092	8b 45 0c	 mov	 eax, DWORD PTR __Right$[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00098	eb 06		 jmp	 SHORT $LN4@min
$LN3@min:
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR __Left$[ebp]
  0009d	89 4d f0	 mov	 DWORD PTR tv65[ebp], ecx
$LN4@min:
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  000a3	89 55 e4	 mov	 DWORD PTR $T1[ebp], edx
  000a6	8b 45 e4	 mov	 eax, DWORD PTR $T1[ebp]

; 69   : }

  000a9	8b e5		 mov	 esp, ebp
  000ab	5d		 pop	 ebp
  000ac	c3		 ret	 0
??$min@I@std@@YAABIABI0@Z ENDP				; std::min<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z PROC ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>, COMDAT
; _this$ = ecx

; 1652 :     _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1653 :         // copy [_First, _Last) to raw _Dest, using allocator
; 1654 :         return _Uninitialized_copy(_First, _Last, _Dest, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 10	 mov	 eax, DWORD PTR __Dest$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 0c	 mov	 ecx, DWORD PTR __Last$[ebp]
  00021	51		 push	 ecx
  00022	8b 55 08	 mov	 edx, DWORD PTR __First$[ebp]
  00025	52		 push	 edx
  00026	e8 00 00 00 00	 call	 ??$_Uninitialized_copy@PBHV?$allocator@H@std@@@std@@YAPAHQBH0PAHAAV?$allocator@H@0@@Z ; std::_Uninitialized_copy<int const *,std::allocator<int> >
  0002b	83 c4 10	 add	 esp, 16			; 00000010H

; 1655 :     }

  0002e	8b e5		 mov	 esp, ebp
  00030	5d		 pop	 ebp
  00031	c2 0c 00	 ret	 12			; 0000000cH
??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ENDP ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv66 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv73 = -12						; size = 4
tv83 = -8						; size = 4
tv76 = -2						; size = 1
tv86 = -1						; size = 1
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 34   :     _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 35   :         if (_Target) {

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv83[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv86[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv86[ebp], 0
  00032	74 1a		 je	 SHORT $LN5@Tidy_guard
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv83[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv86[ebp]
  00040	7c 0c		 jl	 SHORT $LN5@Tidy_guard
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv83[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN5@Tidy_guard:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 45		 je	 SHORT $LN3@Tidy_guard

; 36   :             _Target->_Tidy();

  00056	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 e8	 mov	 edx, DWORD PTR tv66[ebp]
  0005f	89 55 f4	 mov	 DWORD PTR tv73[ebp], edx
  00062	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00065	c1 e8 03	 shr	 eax, 3
  00068	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0006e	88 4d fe	 mov	 BYTE PTR tv76[ebp], cl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv76[ebp], 0
  00075	74 1a		 je	 SHORT $LN4@Tidy_guard
  00077	8a 55 f4	 mov	 dl, BYTE PTR tv73[ebp]
  0007a	80 e2 07	 and	 dl, 7
  0007d	80 c2 03	 add	 dl, 3
  00080	3a 55 fe	 cmp	 dl, BYTE PTR tv76[ebp]
  00083	7c 0c		 jl	 SHORT $LN4@Tidy_guard
  00085	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
  00088	50		 push	 eax
  00089	e8 00 00 00 00	 call	 ___asan_report_load4
  0008e	83 c4 04	 add	 esp, 4
$LN4@Tidy_guard:
  00091	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00094	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00096	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy
$LN3@Tidy_guard:

; 37   :         }
; 38   :     }

  0009b	8b e5		 mov	 esp, ebp
  0009d	5d		 pop	 ebp
  0009e	c3		 ret	 0
??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$distance@PBH@std@@YAHPBH0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$distance@PBH@std@@YAHPBH0@Z PROC			; std::distance<int const *>, COMDAT

; 1588 : _NODISCARD _CONSTEXPR17 _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1589 :     if constexpr (_Is_random_iter_v<_InIt>) {
; 1590 :         return _Last - _First; // assume the iterator will do debug checking

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  00010	2b 45 08	 sub	 eax, DWORD PTR __First$[ebp]
  00013	c1 f8 02	 sar	 eax, 2

; 1591 :     } else {
; 1592 :         _Adl_verify_range(_First, _Last);
; 1593 :         auto _UFirst             = _Get_unwrapped(_First);
; 1594 :         const auto _ULast        = _Get_unwrapped(_Last);
; 1595 :         _Iter_diff_t<_InIt> _Off = 0;
; 1596 :         for (; _UFirst != _ULast; ++_UFirst) {
; 1597 :             ++_Off;
; 1598 :         }
; 1599 : 
; 1600 :         return _Off;
; 1601 :     }
; 1602 : }

  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??$distance@PBH@std@@YAHPBH0@Z ENDP			; std::distance<int const *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z PROC ; std::_Voidify_iter<std::_Container_proxy *>, COMDAT

; 130  : _NODISCARD constexpr void* _Voidify_iter(_Iter _It) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 131  :     if constexpr (is_pointer_v<_Iter>) {
; 132  :         return const_cast<void*>(static_cast<const volatile void*>(_It));

  0000d	8b 45 08	 mov	 eax, DWORD PTR __It$[ebp]

; 133  :     } else {
; 134  :         return const_cast<void*>(static_cast<const volatile void*>(_STD addressof(*_It)));
; 135  :     }
; 136  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ENDP ; std::_Voidify_iter<std::_Container_proxy *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -20						; size = 4
tv78 = -16						; size = 4
tv74 = -12						; size = 4
tv82 = -8						; size = 4
tv85 = -1						; size = 1
__Location$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z PROC ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>, COMDAT

; 143  :     noexcept(::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...))) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 144  :     return ::new (_Voidify_iter(_Location)) _Ty(_STD forward<_Types>(_Args)...);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Location$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  00019	83 c4 04	 add	 esp, 4
  0001c	50		 push	 eax
  0001d	6a 08		 push	 8
  0001f	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00024	83 c4 08	 add	 esp, 8
  00027	89 45 ec	 mov	 DWORD PTR $T1[ebp], eax
  0002a	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0002d	51		 push	 ecx
  0002e	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00033	83 c4 04	 add	 esp, 4
  00036	89 45 f4	 mov	 DWORD PTR tv74[ebp], eax
  00039	8b 55 f4	 mov	 edx, DWORD PTR tv74[ebp]
  0003c	89 55 f8	 mov	 DWORD PTR tv82[ebp], edx
  0003f	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00042	c1 e8 03	 shr	 eax, 3
  00045	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0004b	88 4d ff	 mov	 BYTE PTR tv85[ebp], cl
  0004e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00052	74 1a		 je	 SHORT $LN3@construct_
  00054	8a 55 f8	 mov	 dl, BYTE PTR tv82[ebp]
  00057	80 e2 07	 and	 dl, 7
  0005a	80 c2 03	 add	 dl, 3
  0005d	3a 55 ff	 cmp	 dl, BYTE PTR tv85[ebp]
  00060	7c 0c		 jl	 SHORT $LN3@construct_
  00062	8b 45 f8	 mov	 eax, DWORD PTR tv82[ebp]
  00065	50		 push	 eax
  00066	e8 00 00 00 00	 call	 ___asan_report_load4
  0006b	83 c4 04	 add	 esp, 4
$LN3@construct_:
  0006e	8b 4d f4	 mov	 ecx, DWORD PTR tv74[ebp]
  00071	8b 11		 mov	 edx, DWORD PTR [ecx]
  00073	89 55 f0	 mov	 DWORD PTR tv78[ebp], edx
  00076	8b 45 f0	 mov	 eax, DWORD PTR tv78[ebp]
  00079	50		 push	 eax
  0007a	8b 4d ec	 mov	 ecx, DWORD PTR $T1[ebp]
  0007d	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy

; 145  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ENDP ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z PROC ; std::forward<std::_Container_base12 *>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ENDP ; std::forward<std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 288  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 289  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 290  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z PROC ; std::forward<std::allocator<int> const &>, COMDAT

; 1443 :     remove_reference_t<_Ty>& _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __589FA321_type_traits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1444 :     return static_cast<_Ty&&>(_Arg);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Arg$[ebp]

; 1445 : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ENDP ; std::forward<std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Guard$3 = -136					; size = 4
tv172 = -92						; size = 1
tv162 = -91						; size = 1
tv152 = -90						; size = 1
tv142 = -89						; size = 1
tv94 = -88						; size = 4
_this$ = -84						; size = 4
tv169 = -80						; size = 4
tv159 = -76						; size = 4
tv149 = -72						; size = 4
tv139 = -68						; size = 4
__Count$ = -64						; size = 4
tv78 = -60						; size = 4
__My_data$4 = -56					; size = 4
tv75 = -52						; size = 4
tv92 = -48						; size = 4
tv77 = -44						; size = 4
tv135 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z PROC ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>, COMDAT
; _this$ = ecx

; 524  :     _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 70 ff ff
	ff		 add	 esp, -144		; ffffff70H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ac	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  00056	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
  00060	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 d0	 mov	 DWORD PTR tv92[ebp], eax
  00069	8b 4d d0	 mov	 ecx, DWORD PTR tv92[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d a8	 mov	 DWORD PTR tv94[ebp], ecx
  00078	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  0007b	c7 02 f1 f1 f8
	f3		 mov	 DWORD PTR [edx], -201788943 ; f3f8f1f1H
  00081	83 45 a8 04	 add	 DWORD PTR tv94[ebp], 4
  00085	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0008a	8b 4d a8	 mov	 ecx, DWORD PTR tv94[ebp]
  0008d	66 89 01	 mov	 WORD PTR [ecx], ax
  00090	83 45 a8 02	 add	 DWORD PTR tv94[ebp], 2
  00094	8b 55 a8	 mov	 edx, DWORD PTR tv94[ebp]
  00097	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0009a	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0009f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 525  :         const auto _Count = _Convert_size<size_type>(static_cast<size_t>(_STD distance(_First, _Last)));

  000a4	8b 43 0c	 mov	 eax, DWORD PTR __Last$[ebx]
  000a7	50		 push	 eax
  000a8	8b 4b 08	 mov	 ecx, DWORD PTR __First$[ebx]
  000ab	51		 push	 ecx
  000ac	e8 00 00 00 00	 call	 ??$distance@PBH@std@@YAHPBH0@Z ; std::distance<int const *>
  000b1	83 c4 08	 add	 esp, 8
  000b4	50		 push	 eax
  000b5	e8 00 00 00 00	 call	 ??$_Convert_size@I@std@@YAII@Z ; std::_Convert_size<unsigned int>
  000ba	83 c4 04	 add	 esp, 4
  000bd	89 45 c0	 mov	 DWORD PTR __Count$[ebp], eax

; 526  :         if (_Count != 0) {

  000c0	83 7d c0 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000c4	0f 84 69 01 00
	00		 je	 $LN1@Range_cons
  000ca	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4

; 527  :             _Buy_nonzero(_Count);

  000da	8b 45 c0	 mov	 eax, DWORD PTR __Count$[ebp]
  000dd	50		 push	 eax
  000de	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  000e1	e8 00 00 00 00	 call	 ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_nonzero

; 528  :             _Tidy_guard<vector> _Guard{this};

  000e6	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  000ec	89 4d b0	 mov	 DWORD PTR tv169[ebp], ecx
  000ef	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  000f2	c1 ea 03	 shr	 edx, 3
  000f5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000fb	88 45 a4	 mov	 BYTE PTR tv172[ebp], al
  000fe	80 7d a4 00	 cmp	 BYTE PTR tv172[ebp], 0
  00102	74 1a		 je	 SHORT $LN8@Range_cons
  00104	8a 4d b0	 mov	 cl, BYTE PTR tv169[ebp]
  00107	80 e1 07	 and	 cl, 7
  0010a	80 c1 03	 add	 cl, 3
  0010d	3a 4d a4	 cmp	 cl, BYTE PTR tv172[ebp]
  00110	7c 0c		 jl	 SHORT $LN8@Range_cons
  00112	8b 55 b0	 mov	 edx, DWORD PTR tv169[ebp]
  00115	52		 push	 edx
  00116	e8 00 00 00 00	 call	 ___asan_report_store4
  0011b	83 c4 04	 add	 esp, 4
$LN8@Range_cons:
  0011e	8b 45 ac	 mov	 eax, DWORD PTR _this$[ebp]
  00121	89 85 78 ff ff
	ff		 mov	 DWORD PTR __Guard$3[ebp], eax
  00127	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 529  :             auto& _My_data   = _Mypair._Myval2;

  0012e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00131	89 4d c8	 mov	 DWORD PTR __My_data$4[ebp], ecx

; 530  :             _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);

  00134	8b 55 c8	 mov	 edx, DWORD PTR __My_data$4[ebp]
  00137	83 c2 04	 add	 edx, 4
  0013a	89 55 c4	 mov	 DWORD PTR tv78[ebp], edx
  0013d	8b 45 c4	 mov	 eax, DWORD PTR tv78[ebp]
  00140	89 45 b4	 mov	 DWORD PTR tv159[ebp], eax
  00143	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00146	c1 e9 03	 shr	 ecx, 3
  00149	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0014f	88 55 a5	 mov	 BYTE PTR tv162[ebp], dl
  00152	80 7d a5 00	 cmp	 BYTE PTR tv162[ebp], 0
  00156	74 18		 je	 SHORT $LN7@Range_cons
  00158	8a 45 b4	 mov	 al, BYTE PTR tv159[ebp]
  0015b	24 07		 and	 al, 7
  0015d	04 03		 add	 al, 3
  0015f	3a 45 a5	 cmp	 al, BYTE PTR tv162[ebp]
  00162	7c 0c		 jl	 SHORT $LN7@Range_cons
  00164	8b 4d b4	 mov	 ecx, DWORD PTR tv159[ebp]
  00167	51		 push	 ecx
  00168	e8 00 00 00 00	 call	 ___asan_report_load4
  0016d	83 c4 04	 add	 esp, 4
$LN7@Range_cons:
  00170	8b 55 c4	 mov	 edx, DWORD PTR tv78[ebp]
  00173	8b 02		 mov	 eax, DWORD PTR [edx]
  00175	50		 push	 eax
  00176	8b 4b 0c	 mov	 ecx, DWORD PTR __Last$[ebx]
  00179	51		 push	 ecx
  0017a	8b 53 08	 mov	 edx, DWORD PTR __First$[ebx]
  0017d	52		 push	 edx
  0017e	8b 4d ac	 mov	 ecx, DWORD PTR _this$[ebp]
  00181	e8 00 00 00 00	 call	 ??$_Ucopy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPBH0PAH@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int const *>
  00186	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  00189	8b 45 c8	 mov	 eax, DWORD PTR __My_data$4[ebp]
  0018c	83 c0 08	 add	 eax, 8
  0018f	89 45 cc	 mov	 DWORD PTR tv75[ebp], eax
  00192	8b 4d cc	 mov	 ecx, DWORD PTR tv75[ebp]
  00195	89 4d b8	 mov	 DWORD PTR tv149[ebp], ecx
  00198	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  0019b	c1 ea 03	 shr	 edx, 3
  0019e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001a4	88 45 a6	 mov	 BYTE PTR tv152[ebp], al
  001a7	80 7d a6 00	 cmp	 BYTE PTR tv152[ebp], 0
  001ab	74 1a		 je	 SHORT $LN6@Range_cons
  001ad	8a 4d b8	 mov	 cl, BYTE PTR tv149[ebp]
  001b0	80 e1 07	 and	 cl, 7
  001b3	80 c1 03	 add	 cl, 3
  001b6	3a 4d a6	 cmp	 cl, BYTE PTR tv152[ebp]
  001b9	7c 0c		 jl	 SHORT $LN6@Range_cons
  001bb	8b 55 b8	 mov	 edx, DWORD PTR tv149[ebp]
  001be	52		 push	 edx
  001bf	e8 00 00 00 00	 call	 ___asan_report_store4
  001c4	83 c4 04	 add	 esp, 4
$LN6@Range_cons:
  001c7	8b 45 cc	 mov	 eax, DWORD PTR tv75[ebp]
  001ca	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  001cd	89 08		 mov	 DWORD PTR [eax], ecx

; 531  :             _Guard._Target   = nullptr;

  001cf	8d 95 78 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$3[ebp]
  001d5	89 55 bc	 mov	 DWORD PTR tv139[ebp], edx
  001d8	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001db	c1 e8 03	 shr	 eax, 3
  001de	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e4	88 4d a7	 mov	 BYTE PTR tv142[ebp], cl
  001e7	80 7d a7 00	 cmp	 BYTE PTR tv142[ebp], 0
  001eb	74 1a		 je	 SHORT $LN5@Range_cons
  001ed	8a 55 bc	 mov	 dl, BYTE PTR tv139[ebp]
  001f0	80 e2 07	 and	 dl, 7
  001f3	80 c2 03	 add	 dl, 3
  001f6	3a 55 a7	 cmp	 dl, BYTE PTR tv142[ebp]
  001f9	7c 0c		 jl	 SHORT $LN5@Range_cons
  001fb	8b 45 bc	 mov	 eax, DWORD PTR tv139[ebp]
  001fe	50		 push	 eax
  001ff	e8 00 00 00 00	 call	 ___asan_report_store4
  00204	83 c4 04	 add	 esp, 4
$LN5@Range_cons:
  00207	c7 85 78 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$3[ebp], 0

; 532  :         }

  00211	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00218	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  0021e	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00223	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00229	c1 e9 03	 shr	 ecx, 3
  0022c	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H
$LN1@Range_cons:

; 533  :     }

  00233	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0023d	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00243	c1 ea 03	 shr	 edx, 3
  00246	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0024c	89 55 d8	 mov	 DWORD PTR tv135[ebp], edx
  0024f	6a 07		 push	 7
  00251	8b 45 d8	 mov	 eax, DWORD PTR tv135[ebp]
  00254	50		 push	 eax
  00255	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0025a	83 c4 08	 add	 esp, 8
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00260	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00267	59		 pop	 ecx
  00268	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0026b	33 cd		 xor	 ecx, ebp
  0026d	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00272	8b e5		 mov	 esp, ebp
  00274	5d		 pop	 ebp
  00275	8b e3		 mov	 esp, ebx
  00277	5b		 pop	 ebx
  00278	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$3[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 68 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-152]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ENDP ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv79 = -16						; size = 4
tv82 = -12						; size = 4
_this$ = -8						; size = 4
tv85 = -1						; size = 1
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1353 :     _CONSTEXPR20_CONTAINER ~_Container_proxy_ptr12() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1354 :         if (_Ptr) {

  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv79[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv79[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv82[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv85[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv85[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv82[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv85[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv82[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	74 15		 je	 SHORT $LN3@Container_

; 1355 :             _Delete_plain_internal(_Al, _Ptr);

  00056	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00059	8b 11		 mov	 edx, DWORD PTR [ecx]
  0005b	52		 push	 edx
  0005c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005f	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00062	51		 push	 ecx
  00063	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00068	83 c4 08	 add	 esp, 8
$LN3@Container_:

; 1356 :         }
; 1357 :     }

  0006b	8b e5		 mov	 esp, ebp
  0006d	5d		 pop	 ebp
  0006e	c3		 ret	 0
??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -128					; size = 4
__asan_gen_1$ = -124					; size = 4
__asan_gen_2$ = -120					; size = 4
$T2 = -112						; size = 4
tv199 = -69						; size = 1
tv189 = -68						; size = 1
tv179 = -67						; size = 1
tv169 = -66						; size = 1
tv159 = -65						; size = 1
_this$ = -64						; size = 4
tv146 = -60						; size = 4
tv196 = -56						; size = 4
tv186 = -52						; size = 4
tv176 = -48						; size = 4
tv166 = -44						; size = 4
tv156 = -40						; size = 4
tv69 = -36						; size = 4
tv92 = -32						; size = 4
tv144 = -28						; size = 4
tv134 = -24						; size = 4
tv75 = -20						; size = 4
tv83 = -16						; size = 4
tv139 = -12						; size = 4
tv152 = -8						; size = 4
tv131 = -4						; size = 4
__Al_$ = 8						; size = 4
__Mycont$ = 12						; size = 4
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z PROC ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >, COMDAT
; _this$ = ecx

; 1339 :     _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d c0	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 80 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 84 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z
  0002d	c7 45 88 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00034	8d 45 80	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e4	 mov	 DWORD PTR tv144[ebp], eax
  0003a	8b 4d e4	 mov	 ecx, DWORD PTR tv144[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d c4	 mov	 DWORD PTR tv146[ebp], ecx
  00049	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  0004c	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00052	83 45 c4 04	 add	 DWORD PTR tv146[ebp], 4
  00056	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  0005b	8b 4d c4	 mov	 ecx, DWORD PTR tv146[ebp]
  0005e	66 89 01	 mov	 WORD PTR [ecx], ax
  00061	83 45 c4 02	 add	 DWORD PTR tv146[ebp], 2
  00065	8b 55 c4	 mov	 edx, DWORD PTR tv146[ebp]
  00068	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  0006b	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00070	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00075	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  00078	e8 00 00 00 00	 call	 ??0_Basic_container_proxy_ptr12@std@@IAE@XZ ; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
  0007d	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00080	83 c0 04	 add	 eax, 4
  00083	89 45 dc	 mov	 DWORD PTR tv69[ebp], eax
  00086	8b 4d dc	 mov	 ecx, DWORD PTR tv69[ebp]
  00089	89 4d c8	 mov	 DWORD PTR tv196[ebp], ecx
  0008c	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  0008f	c1 ea 03	 shr	 edx, 3
  00092	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00098	88 45 bb	 mov	 BYTE PTR tv199[ebp], al
  0009b	80 7d bb 00	 cmp	 BYTE PTR tv199[ebp], 0
  0009f	74 1a		 je	 SHORT $LN7@Container_
  000a1	8a 4d c8	 mov	 cl, BYTE PTR tv196[ebp]
  000a4	80 e1 07	 and	 cl, 7
  000a7	80 c1 03	 add	 cl, 3
  000aa	3a 4d bb	 cmp	 cl, BYTE PTR tv199[ebp]
  000ad	7c 0c		 jl	 SHORT $LN7@Container_
  000af	8b 55 c8	 mov	 edx, DWORD PTR tv196[ebp]
  000b2	52		 push	 edx
  000b3	e8 00 00 00 00	 call	 ___asan_report_store4
  000b8	83 c4 04	 add	 esp, 4
$LN7@Container_:
  000bb	8b 45 dc	 mov	 eax, DWORD PTR tv69[ebp]
  000be	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c1	89 08		 mov	 DWORD PTR [eax], ecx

; 1340 :         // create a new _Container_proxy pointing at _Mycont
; 1341 :         _Ptr = _Unfancy(_Al_.allocate(1));

  000c3	6a 01		 push	 1
  000c5	8b 4b 08	 mov	 ecx, DWORD PTR __Al_$[ebx]
  000c8	e8 00 00 00 00	 call	 ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
  000cd	50		 push	 eax
  000ce	e8 00 00 00 00	 call	 ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
  000d3	83 c4 04	 add	 esp, 4
  000d6	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  000d9	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  000dc	89 55 e8	 mov	 DWORD PTR tv134[ebp], edx
  000df	8b 45 e8	 mov	 eax, DWORD PTR tv134[ebp]
  000e2	89 45 cc	 mov	 DWORD PTR tv186[ebp], eax
  000e5	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  000e8	c1 e9 03	 shr	 ecx, 3
  000eb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f1	88 55 bc	 mov	 BYTE PTR tv189[ebp], dl
  000f4	80 7d bc 00	 cmp	 BYTE PTR tv189[ebp], 0
  000f8	74 18		 je	 SHORT $LN6@Container_
  000fa	8a 45 cc	 mov	 al, BYTE PTR tv186[ebp]
  000fd	24 07		 and	 al, 7
  000ff	04 03		 add	 al, 3
  00101	3a 45 bc	 cmp	 al, BYTE PTR tv189[ebp]
  00104	7c 0c		 jl	 SHORT $LN6@Container_
  00106	8b 4d cc	 mov	 ecx, DWORD PTR tv186[ebp]
  00109	51		 push	 ecx
  0010a	e8 00 00 00 00	 call	 ___asan_report_store4
  0010f	83 c4 04	 add	 esp, 4
$LN6@Container_:
  00112	8b 55 c0	 mov	 edx, DWORD PTR _this$[ebp]
  00115	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  00118	89 02		 mov	 DWORD PTR [edx], eax

; 1342 :         _Construct_in_place(*_Ptr, _STD addressof(_Mycont));

  0011a	8b 4b 0c	 mov	 ecx, DWORD PTR __Mycont$[ebx]
  0011d	51		 push	 ecx
  0011e	e8 00 00 00 00	 call	 ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ; std::addressof<std::_Container_base12>
  00123	83 c4 04	 add	 esp, 4
  00126	89 45 f0	 mov	 DWORD PTR tv83[ebp], eax
  00129	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  0012c	89 55 d0	 mov	 DWORD PTR tv176[ebp], edx
  0012f	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00132	c1 e8 03	 shr	 eax, 3
  00135	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0013b	88 4d bd	 mov	 BYTE PTR tv179[ebp], cl
  0013e	80 7d bd 00	 cmp	 BYTE PTR tv179[ebp], 0
  00142	74 1a		 je	 SHORT $LN5@Container_
  00144	8a 55 d0	 mov	 dl, BYTE PTR tv176[ebp]
  00147	80 e2 07	 and	 dl, 7
  0014a	80 c2 03	 add	 dl, 3
  0014d	3a 55 bd	 cmp	 dl, BYTE PTR tv179[ebp]
  00150	7c 0c		 jl	 SHORT $LN5@Container_
  00152	8b 45 d0	 mov	 eax, DWORD PTR tv176[ebp]
  00155	50		 push	 eax
  00156	e8 00 00 00 00	 call	 ___asan_report_store4
  0015b	83 c4 04	 add	 esp, 4
$LN5@Container_:
  0015e	8b 4d f0	 mov	 ecx, DWORD PTR tv83[ebp]
  00161	89 4d 90	 mov	 DWORD PTR $T2[ebp], ecx
  00164	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00167	52		 push	 edx
  00168	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	51		 push	 ecx
  0016e	e8 00 00 00 00	 call	 ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
  00173	83 c4 08	 add	 esp, 8
  00176	8d 55 90	 lea	 edx, DWORD PTR $T2[ebp]
  00179	c1 ea 03	 shr	 edx, 3
  0017c	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 1343 :         _Mycont._Myproxy = _Ptr;

  00183	8b 43 0c	 mov	 eax, DWORD PTR __Mycont$[ebx]
  00186	89 45 e0	 mov	 DWORD PTR tv92[ebp], eax
  00189	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  0018c	89 4d f4	 mov	 DWORD PTR tv139[ebp], ecx
  0018f	8b 55 f4	 mov	 edx, DWORD PTR tv139[ebp]
  00192	89 55 d4	 mov	 DWORD PTR tv166[ebp], edx
  00195	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  00198	c1 e8 03	 shr	 eax, 3
  0019b	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001a1	88 4d be	 mov	 BYTE PTR tv169[ebp], cl
  001a4	80 7d be 00	 cmp	 BYTE PTR tv169[ebp], 0
  001a8	74 1a		 je	 SHORT $LN4@Container_
  001aa	8a 55 d4	 mov	 dl, BYTE PTR tv166[ebp]
  001ad	80 e2 07	 and	 dl, 7
  001b0	80 c2 03	 add	 dl, 3
  001b3	3a 55 be	 cmp	 dl, BYTE PTR tv169[ebp]
  001b6	7c 0c		 jl	 SHORT $LN4@Container_
  001b8	8b 45 d4	 mov	 eax, DWORD PTR tv166[ebp]
  001bb	50		 push	 eax
  001bc	e8 00 00 00 00	 call	 ___asan_report_load4
  001c1	83 c4 04	 add	 esp, 4
$LN4@Container_:
  001c4	8b 4d e0	 mov	 ecx, DWORD PTR tv92[ebp]
  001c7	89 4d d8	 mov	 DWORD PTR tv156[ebp], ecx
  001ca	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001cd	c1 ea 03	 shr	 edx, 3
  001d0	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  001d6	88 45 bf	 mov	 BYTE PTR tv159[ebp], al
  001d9	80 7d bf 00	 cmp	 BYTE PTR tv159[ebp], 0
  001dd	74 1a		 je	 SHORT $LN3@Container_
  001df	8a 4d d8	 mov	 cl, BYTE PTR tv156[ebp]
  001e2	80 e1 07	 and	 cl, 7
  001e5	80 c1 03	 add	 cl, 3
  001e8	3a 4d bf	 cmp	 cl, BYTE PTR tv159[ebp]
  001eb	7c 0c		 jl	 SHORT $LN3@Container_
  001ed	8b 55 d8	 mov	 edx, DWORD PTR tv156[ebp]
  001f0	52		 push	 edx
  001f1	e8 00 00 00 00	 call	 ___asan_report_store4
  001f6	83 c4 04	 add	 esp, 4
$LN3@Container_:
  001f9	8b 45 e0	 mov	 eax, DWORD PTR tv92[ebp]
  001fc	8b 4d c0	 mov	 ecx, DWORD PTR _this$[ebp]
  001ff	8b 11		 mov	 edx, DWORD PTR [ecx]
  00201	89 10		 mov	 DWORD PTR [eax], edx

; 1344 :     }

  00203	8b 45 c0	 mov	 eax, DWORD PTR _this$[ebp]
  00206	89 45 fc	 mov	 DWORD PTR tv131[ebp], eax
  00209	c7 45 80 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00210	8d 4d 80	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00213	c1 e9 03	 shr	 ecx, 3
  00216	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0021c	89 4d f8	 mov	 DWORD PTR tv152[ebp], ecx
  0021f	6a 07		 push	 7
  00221	8b 55 f8	 mov	 edx, DWORD PTR tv152[ebp]
  00224	52		 push	 edx
  00225	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0022a	83 c4 08	 add	 esp, 8
  0022d	8b 45 fc	 mov	 eax, DWORD PTR tv131[ebp]
  00230	8b e5		 mov	 esp, ebp
  00232	5d		 pop	 ebp
  00233	8b e3		 mov	 esp, ebx
  00235	5b		 pop	 ebx
  00236	c2 08 00	 ret	 8
??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ENDP ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$07@std@@YAII@Z ; std::_Get_size_of_n<8>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 03	 shl	 eax, 3
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>, COMDAT
; _this$ = ecx

; 1395 :         : _Ty1(_STD forward<_Other1>(_Val1)), _Myval2(_STD forward<_Other2>(_Val2)...) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 0c	 mov	 eax, DWORD PTR __Val1$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$forward@ABV?$allocator@H@std@@@std@@YAABV?$allocator@H@0@ABV10@@Z ; std::forward<std::allocator<int> const &>
  0001a	83 c4 04	 add	 esp, 4
  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 08 00	 ret	 8
??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@end
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@end
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@end:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 44   :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@begin
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@begin
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@begin:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z PROC ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@initialize
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@initialize
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@initialize:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@initialize
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@initialize
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@initialize:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@PBV?$vector@HV?$allocator@H@std@@@1@0@Z ENDP ; std::initializer_list<std::vector<int,std::allocator<int> > >::initializer_list<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QBEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 04	 sar	 edx, 4
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@CAXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 04	 shl	 eax, 4
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXI@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@YAXPAV?$vector@HV?$allocator@H@std@@@0@QAV10@AAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<std::vector<int,std::allocator<int> > > >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPAV?$vector@HV?$allocator@H@std@@@2@0@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@ABEABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QBEIXZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S10$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXXZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S10$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S10$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@XZ ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::~vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
_$S8$ = -152						; size = 1
__Proxy$ = -136						; size = 8
$T3 = -120						; size = 1
$T4 = -76						; size = 1
$T5 = -75						; size = 1
$T6 = -74						; size = 1
$T7 = -73						; size = 1
tv153 = -72						; size = 4
_this$ = -68						; size = 4
tv151 = -64						; size = 4
tv70 = -60						; size = 4
__Alproxy$ = -56					; size = 4
tv135 = -52						; size = 4
tv133 = -48						; size = 4
tv162 = -44						; size = 4
tv150 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z PROC ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  00056	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
  00060	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv151[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv151[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b8	 mov	 DWORD PTR tv153[ebp], ecx
  00078	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00085	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b8 02	 add	 DWORD PTR tv153[ebp], 2
  000a1	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	c1 e9 03	 shr	 ecx, 3
  000ad	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	89 55 c4	 mov	 DWORD PTR tv70[ebp], edx
  000c4	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  000c7	50		 push	 eax
  000c8	0f b6 4d b6	 movzx	 ecx, BYTE PTR $T6[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  000d0	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@$$V@?$_Compressed_pair@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@V?$vector@HV?$allocator@H@std@@@std@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1>::_Compressed_pair<std::allocator<std::vector<int,std::allocator<int> > >,std::_Vector_val<std::_Simple_types<std::vector<int,std::allocator<int> > > >,1><std::allocator<std::vector<int,std::allocator<int> > > const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEAAV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@XZ ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Getal
  000dd	50		 push	 eax
  000de	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _$S8$[ebp]
  000e4	e8 00 00 00 00	 call	 ??$?0V?$vector@HV?$allocator@H@std@@@std@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><std::vector<int,std::allocator<int> > >
  000e9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _$S8$[ebp]
  000ef	89 55 c8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000f9	51		 push	 ecx
  000fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0010c	6a 01		 push	 1
  0010e	6a 00		 push	 0
  00110	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_memset
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	6a 01		 push	 1
  0011e	8d 45 b7	 lea	 eax, DWORD PTR $T7[ebp]
  00121	50		 push	 eax
  00122	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ___asan_memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	6a 01		 push	 1
  00130	8d 55 b4	 lea	 edx, DWORD PTR $T4[ebp]
  00133	52		 push	 edx
  00134	8d 45 b5	 lea	 eax, DWORD PTR $T5[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ___asan_memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  00143	e8 00 00 00 00	 call	 ?end@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::end
  00148	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  0014b	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  0014e	e8 00 00 00 00	 call	 ?begin@?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@std@@QBEPBV?$vector@HV?$allocator@H@std@@@2@XZ ; std::initializer_list<std::vector<int,std::allocator<int> > >::begin
  00153	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  00156	0f b6 4d b5	 movzx	 ecx, BYTE PTR $T5[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00162	50		 push	 eax
  00163	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBV?$vector@HV?$allocator@H@std@@@std@@@?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@AAEXPBV?$vector@HV?$allocator@H@std@@@1@0Uforward_iterator_tag@1@@Z ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::_Range_construct_or_tidy<std::vector<int,std::allocator<int> > const *>
  0016b	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	c1 e9 03	 shr	 ecx, 3
  00171	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 551  :         _Proxy._Release();

  00178	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00190	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00195	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	89 55 d8	 mov	 DWORD PTR tv150[ebp], edx
  0019b	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  001ab	c1 e8 03	 shr	 eax, 3
  001ae	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001b3	89 45 d4	 mov	 DWORD PTR tv162[ebp], eax
  001b6	6a 0b		 push	 11			; 0000000bH
  001b8	8b 4d d4	 mov	 ecx, DWORD PTR tv162[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 45 d8	 mov	 eax, DWORD PTR tv150[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	8b e3		 mov	 esp, ebx
  001e1	5b		 pop	 ebx
  001e2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@V?$vector@HV?$allocator@H@std@@@std@@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@std@@QAE@V?$initializer_list@V?$vector@HV?$allocator@H@std@@@std@@@1@ABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@1@@Z ENDP ; std::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >::vector<std::vector<int,std::allocator<int> >,std::allocator<std::vector<int,std::allocator<int> > > >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 0f	 mov	 eax, 268435455		; 0fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@@std@@SAIABV?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::vector<int,std::allocator<int> > > >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$0BA@@std@@YAII@Z ; std::_Get_size_of_n<16>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEPAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z PROC ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 04	 shl	 eax, 4
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAEXQAV?$vector@HV?$allocator@H@std@@@2@I@Z ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ PROC ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ENDP ; std::allocator<std::vector<int,std::allocator<int> > >::allocator<std::vector<int,std::allocator<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?end@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?end@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::end, COMDAT
; _this$ = ecx

; 42   :     _NODISCARD constexpr const _Elem* end() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 43   :         return _Last;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@end
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@end
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@end:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 44   :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?end@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::end
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ?begin@?$initializer_list@H@std@@QBEPBHXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?begin@?$initializer_list@H@std@@QBEPBHXZ PROC		; std::initializer_list<int>::begin, COMDAT
; _this$ = ecx

; 38   :     _NODISCARD constexpr const _Elem* begin() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 39   :         return _First;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@begin
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@begin
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN3@begin:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 00		 mov	 eax, DWORD PTR [eax]

; 40   :     }

  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
?begin@?$initializer_list@H@std@@QBEPBHXZ ENDP		; std::initializer_list<int>::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\initializer_list
;	COMDAT ??0?$initializer_list@H@std@@QAE@PBH0@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__First_arg$ = 8					; size = 4
__Last_arg$ = 12					; size = 4
??0?$initializer_list@H@std@@QAE@PBH0@Z PROC		; std::initializer_list<int>::initializer_list<int>, COMDAT
; _this$ = ecx

; 36   :         : _First(_First_arg), _Last(_Last_arg) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __372D2D08_initializer_list
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@initialize
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@initialize
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@initialize:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __First_arg$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx
  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@initialize
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@initialize
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@initialize:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	8b 45 0c	 mov	 eax, DWORD PTR __Last_arg$[ebp]
  00098	89 02		 mov	 DWORD PTR [edx], eax
  0009a	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	c2 08 00	 ret	 8
??0?$initializer_list@H@std@@QAE@PBH0@Z ENDP		; std::initializer_list<int>::initializer_list<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z PROC	; std::vector<int,std::allocator<int> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 10		 push	 16			; 00000010H
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_G?$vector@HV?$allocator@H@std@@@std@@QAEPAXI@Z ENDP	; std::vector<int,std::allocator<int> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1401 :     constexpr const _Ty1& _Get_first() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1402 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1403 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ PROC ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ENDP ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv71 = -32						; size = 4
tv70 = -28						; size = 4
tv69 = -24						; size = 4
tv79 = -20						; size = 4
tv89 = -16						; size = 4
tv131 = -12						; size = 4
_this$ = -8						; size = 4
tv82 = -3						; size = 1
tv92 = -2						; size = 1
tv134 = -1						; size = 1
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >, COMDAT
; _this$ = ecx

; 401  :     _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Container_base12@std@@QAE@XZ ; std::_Container_base12::_Container_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 04	 add	 eax, 4
  00021	89 45 e8	 mov	 DWORD PTR tv69[ebp], eax
  00024	8b 4d e8	 mov	 ecx, DWORD PTR tv69[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv131[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv134[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv134[ebp], 0
  0003d	74 1a		 je	 SHORT $LN5@Vector_val
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv131[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv134[ebp]
  0004b	7c 0c		 jl	 SHORT $LN5@Vector_val
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv131[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN5@Vector_val:
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv69[ebp]
  0005c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  00062	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00065	83 c1 08	 add	 ecx, 8
  00068	89 4d e4	 mov	 DWORD PTR tv70[ebp], ecx
  0006b	8b 55 e4	 mov	 edx, DWORD PTR tv70[ebp]
  0006e	89 55 f0	 mov	 DWORD PTR tv89[ebp], edx
  00071	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00074	c1 e8 03	 shr	 eax, 3
  00077	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0007d	88 4d fe	 mov	 BYTE PTR tv92[ebp], cl
  00080	80 7d fe 00	 cmp	 BYTE PTR tv92[ebp], 0
  00084	74 1a		 je	 SHORT $LN4@Vector_val
  00086	8a 55 f0	 mov	 dl, BYTE PTR tv89[ebp]
  00089	80 e2 07	 and	 dl, 7
  0008c	80 c2 03	 add	 dl, 3
  0008f	3a 55 fe	 cmp	 dl, BYTE PTR tv92[ebp]
  00092	7c 0c		 jl	 SHORT $LN4@Vector_val
  00094	8b 45 f0	 mov	 eax, DWORD PTR tv89[ebp]
  00097	50		 push	 eax
  00098	e8 00 00 00 00	 call	 ___asan_report_store4
  0009d	83 c4 04	 add	 esp, 4
$LN4@Vector_val:
  000a0	8b 4d e4	 mov	 ecx, DWORD PTR tv70[ebp]
  000a3	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
  000a9	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  000ac	83 c2 0c	 add	 edx, 12			; 0000000cH
  000af	89 55 e0	 mov	 DWORD PTR tv71[ebp], edx
  000b2	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000b5	89 45 ec	 mov	 DWORD PTR tv79[ebp], eax
  000b8	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000c4	88 55 fd	 mov	 BYTE PTR tv82[ebp], dl
  000c7	80 7d fd 00	 cmp	 BYTE PTR tv82[ebp], 0
  000cb	74 18		 je	 SHORT $LN3@Vector_val
  000cd	8a 45 ec	 mov	 al, BYTE PTR tv79[ebp]
  000d0	24 07		 and	 al, 7
  000d2	04 03		 add	 al, 3
  000d4	3a 45 fd	 cmp	 al, BYTE PTR tv82[ebp]
  000d7	7c 0c		 jl	 SHORT $LN3@Vector_val
  000d9	8b 4d ec	 mov	 ecx, DWORD PTR tv79[ebp]
  000dc	51		 push	 ecx
  000dd	e8 00 00 00 00	 call	 ___asan_report_store4
  000e2	83 c4 04	 add	 esp, 4
$LN3@Vector_val:
  000e5	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000e8	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
  000ee	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000f1	8b e5		 mov	 esp, ebp
  000f3	5d		 pop	 ebp
  000f4	c3		 ret	 0
??0?$_Vector_val@U?$_Simple_types@H@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<int> >::_Vector_val<std::_Simple_types<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1821 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Alty& _Getal() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1822 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QBEABV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1823 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ PROC ; std::vector<int,std::allocator<int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$allocator@H@2@XZ ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ENDP ; std::vector<int,std::allocator<int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ PROC ; std::vector<int,std::allocator<int> >::_Xlength, COMDAT

; 1773 :     [[noreturn]] static void _Xlength() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1774 :         _Xlength_error("vector too long");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BA@FOIKENOD@vector?5too?5long@
  00012	e8 00 00 00 00	 call	 ?_Xlength_error@std@@YAXPBD@Z ; std::_Xlength_error
$LN2@Xlength:

; 1775 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ENDP ; std::vector<int,std::allocator<int> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ PROC	; std::vector<int,std::allocator<int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ; std::vector<int,std::allocator<int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@H@std@@QAEXQAHI@Z ; std::allocator<int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ENDP	; std::vector<int,std::allocator<int> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Newcapacity$ = 8					; size = 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_nonzero, COMDAT
; _this$ = ecx

; 1717 :     _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1718 :         // allocate array with _Newcapacity elements
; 1719 : #ifdef _ENABLE_STL_INTERNAL_CHECK
; 1720 :         auto& _My_data    = _Mypair._Myval2;
; 1721 :         pointer& _Myfirst = _My_data._Myfirst;
; 1722 :         pointer& _Mylast  = _My_data._Mylast;
; 1723 :         pointer& _Myend   = _My_data._Myend;
; 1724 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1725 :         _STL_INTERNAL_CHECK(0 < _Newcapacity);
; 1726 : #endif // _ENABLE_STL_INTERNAL_CHECK
; 1727 : 
; 1728 :         if (_Newcapacity > max_size()) {

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00019	39 45 08	 cmp	 DWORD PTR __Newcapacity$[ebp], eax
  0001c	76 05		 jbe	 SHORT $LN2@Buy_nonzer

; 1729 :             _Xlength();

  0001e	e8 00 00 00 00	 call	 ?_Xlength@?$vector@HV?$allocator@H@std@@@std@@CAXXZ ; std::vector<int,std::allocator<int> >::_Xlength
$LN2@Buy_nonzer:

; 1730 :         }
; 1731 : 
; 1732 :         _Buy_raw(_Newcapacity);

  00023	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  00026	50		 push	 eax
  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw
$LN3@Buy_nonzer:

; 1733 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c2 04 00	 ret	 4
?_Buy_nonzero@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z
_TEXT	SEGMENT
tv80 = -60						; size = 4
tv88 = -56						; size = 4
tv85 = -52						; size = 4
tv82 = -48						; size = 4
tv77 = -44						; size = 4
__Myend$ = -40						; size = 4
__Mylast$ = -36						; size = 4
__Myfirst$ = -32					; size = 4
_this$ = -28						; size = 4
tv91 = -24						; size = 4
__Newvec$ = -20						; size = 4
tv133 = -16						; size = 4
tv143 = -12						; size = 4
__My_data$ = -8						; size = 4
tv94 = -3						; size = 1
tv136 = -2						; size = 1
tv146 = -1						; size = 1
__Newcapacity$ = 8					; size = 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z PROC ; std::vector<int,std::allocator<int> >::_Buy_raw, COMDAT
; _this$ = ecx

; 1701 :     _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 3c	 sub	 esp, 60			; 0000003cH
  00006	89 4d e4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1702 :         // allocate array with _Newcapacity elements
; 1703 :         auto& _My_data    = _Mypair._Myval2;

  00013	8b 45 e4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f8	 mov	 DWORD PTR __My_data$[ebp], eax

; 1704 :         pointer& _Myfirst = _My_data._Myfirst;

  00019	8b 4d f8	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 04	 add	 ecx, 4
  0001f	89 4d e0	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1705 :         pointer& _Mylast  = _My_data._Mylast;

  00022	8b 55 f8	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 08	 add	 edx, 8
  00028	89 55 dc	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1706 :         pointer& _Myend   = _My_data._Myend;

  0002b	8b 45 f8	 mov	 eax, DWORD PTR __My_data$[ebp]
  0002e	83 c0 0c	 add	 eax, 12			; 0000000cH
  00031	89 45 d8	 mov	 DWORD PTR __Myend$[ebp], eax

; 1707 : 
; 1708 :         _STL_INTERNAL_CHECK(!_Myfirst && !_Mylast && !_Myend); // check that *this is tidy
; 1709 :         _STL_INTERNAL_CHECK(0 < _Newcapacity && _Newcapacity <= max_size());
; 1710 : 
; 1711 :         const auto _Newvec = _Getal().allocate(_Newcapacity);

  00034	8b 4d e4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0003c	89 45 d4	 mov	 DWORD PTR tv77[ebp], eax
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR __Newcapacity$[ebp]
  00042	51		 push	 ecx
  00043	8b 4d d4	 mov	 ecx, DWORD PTR tv77[ebp]
  00046	e8 00 00 00 00	 call	 ?allocate@?$allocator@H@std@@QAEPAHI@Z ; std::allocator<int>::allocate
  0004b	89 45 ec	 mov	 DWORD PTR __Newvec$[ebp], eax

; 1712 :         _Myfirst           = _Newvec;

  0004e	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  00051	89 55 d0	 mov	 DWORD PTR tv82[ebp], edx
  00054	8b 45 d0	 mov	 eax, DWORD PTR tv82[ebp]
  00057	89 45 f4	 mov	 DWORD PTR tv143[ebp], eax
  0005a	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0005d	c1 e9 03	 shr	 ecx, 3
  00060	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00066	88 55 ff	 mov	 BYTE PTR tv146[ebp], dl
  00069	80 7d ff 00	 cmp	 BYTE PTR tv146[ebp], 0
  0006d	74 18		 je	 SHORT $LN5@Buy_raw
  0006f	8a 45 f4	 mov	 al, BYTE PTR tv143[ebp]
  00072	24 07		 and	 al, 7
  00074	04 03		 add	 al, 3
  00076	3a 45 ff	 cmp	 al, BYTE PTR tv146[ebp]
  00079	7c 0c		 jl	 SHORT $LN5@Buy_raw
  0007b	8b 4d f4	 mov	 ecx, DWORD PTR tv143[ebp]
  0007e	51		 push	 ecx
  0007f	e8 00 00 00 00	 call	 ___asan_report_store4
  00084	83 c4 04	 add	 esp, 4
$LN5@Buy_raw:
  00087	8b 55 e0	 mov	 edx, DWORD PTR __Myfirst$[ebp]
  0008a	8b 45 ec	 mov	 eax, DWORD PTR __Newvec$[ebp]
  0008d	89 02		 mov	 DWORD PTR [edx], eax

; 1713 :         _Mylast            = _Newvec;

  0008f	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  00092	89 4d cc	 mov	 DWORD PTR tv85[ebp], ecx
  00095	8b 55 cc	 mov	 edx, DWORD PTR tv85[ebp]
  00098	89 55 f0	 mov	 DWORD PTR tv133[ebp], edx
  0009b	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  0009e	c1 e8 03	 shr	 eax, 3
  000a1	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000a7	88 4d fe	 mov	 BYTE PTR tv136[ebp], cl
  000aa	80 7d fe 00	 cmp	 BYTE PTR tv136[ebp], 0
  000ae	74 1a		 je	 SHORT $LN4@Buy_raw
  000b0	8a 55 f0	 mov	 dl, BYTE PTR tv133[ebp]
  000b3	80 e2 07	 and	 dl, 7
  000b6	80 c2 03	 add	 dl, 3
  000b9	3a 55 fe	 cmp	 dl, BYTE PTR tv136[ebp]
  000bc	7c 0c		 jl	 SHORT $LN4@Buy_raw
  000be	8b 45 f0	 mov	 eax, DWORD PTR tv133[ebp]
  000c1	50		 push	 eax
  000c2	e8 00 00 00 00	 call	 ___asan_report_store4
  000c7	83 c4 04	 add	 esp, 4
$LN4@Buy_raw:
  000ca	8b 4d dc	 mov	 ecx, DWORD PTR __Mylast$[ebp]
  000cd	8b 55 ec	 mov	 edx, DWORD PTR __Newvec$[ebp]
  000d0	89 11		 mov	 DWORD PTR [ecx], edx

; 1714 :         _Myend             = _Newvec + _Newcapacity;

  000d2	8b 45 08	 mov	 eax, DWORD PTR __Newcapacity$[ebp]
  000d5	c1 e0 02	 shl	 eax, 2
  000d8	8b 4d ec	 mov	 ecx, DWORD PTR __Newvec$[ebp]
  000db	03 c8		 add	 ecx, eax
  000dd	89 4d c4	 mov	 DWORD PTR tv80[ebp], ecx
  000e0	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  000e3	89 55 c8	 mov	 DWORD PTR tv88[ebp], edx
  000e6	8b 45 c8	 mov	 eax, DWORD PTR tv88[ebp]
  000e9	89 45 e8	 mov	 DWORD PTR tv91[ebp], eax
  000ec	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  000ef	c1 e9 03	 shr	 ecx, 3
  000f2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000f8	88 55 fd	 mov	 BYTE PTR tv94[ebp], dl
  000fb	80 7d fd 00	 cmp	 BYTE PTR tv94[ebp], 0
  000ff	74 18		 je	 SHORT $LN3@Buy_raw
  00101	8a 45 e8	 mov	 al, BYTE PTR tv91[ebp]
  00104	24 07		 and	 al, 7
  00106	04 03		 add	 al, 3
  00108	3a 45 fd	 cmp	 al, BYTE PTR tv94[ebp]
  0010b	7c 0c		 jl	 SHORT $LN3@Buy_raw
  0010d	8b 4d e8	 mov	 ecx, DWORD PTR tv91[ebp]
  00110	51		 push	 ecx
  00111	e8 00 00 00 00	 call	 ___asan_report_store4
  00116	83 c4 04	 add	 esp, 4
$LN3@Buy_raw:
  00119	8b 55 d8	 mov	 edx, DWORD PTR __Myend$[ebp]
  0011c	8b 45 c4	 mov	 eax, DWORD PTR tv80[ebp]
  0011f	89 02		 mov	 DWORD PTR [edx], eax

; 1715 :     }

  00121	8b e5		 mov	 esp, ebp
  00123	5d		 pop	 ebp
  00124	c2 04 00	 ret	 4
?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ENDP ; std::vector<int,std::allocator<int> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z PROC ; std::vector<int,std::allocator<int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@H@std@@@std@@YAXPAHQAHAAV?$allocator@H@0@@Z ; std::_Destroy_range<std::allocator<int> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@HV?$allocator@H@std@@@std@@AAEXPAH0@Z ENDP ; std::vector<int,std::allocator<int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
_TEXT	SEGMENT
__asan_gen_0$ = -120					; size = 4
__asan_gen_1$ = -116					; size = 4
__asan_gen_2$ = -112					; size = 4
$T2 = -104						; size = 4
$T3 = -88						; size = 4
tv144 = -47						; size = 1
tv134 = -46						; size = 1
tv92 = -45						; size = 1
tv82 = -44						; size = 4
tv141 = -40						; size = 4
tv131 = -36						; size = 4
tv89 = -32						; size = 4
tv64 = -28						; size = 4
tv80 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv70 = -12						; size = 4
tv85 = -8						; size = 4
tv73 = -4						; size = 4
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ PROC ; std::vector<int,std::allocator<int> >::max_size, COMDAT
; _this$ = ecx

; 1552 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0001f	c7 45 88 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00026	c7 45 8c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ
  0002d	c7 45 90 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ; std::vector<int,std::allocator<int> >::max_size
  00034	8d 45 88	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00037	89 45 e8	 mov	 DWORD PTR tv80[ebp], eax
  0003a	8b 4d e8	 mov	 ecx, DWORD PTR tv80[ebp]
  0003d	c1 e9 03	 shr	 ecx, 3
  00040	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00046	89 4d d4	 mov	 DWORD PTR tv82[ebp], ecx
  00049	8b 55 d4	 mov	 edx, DWORD PTR tv82[ebp]
  0004c	c7 02 f1 f1 04
	f2		 mov	 DWORD PTR [edx], -234556943 ; f204f1f1H
  00052	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00056	8b 45 d4	 mov	 eax, DWORD PTR tv82[ebp]
  00059	c7 00 04 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116348 ; f3f3f304H
  0005f	83 45 d4 04	 add	 DWORD PTR tv82[ebp], 4
  00063	8b 4d d4	 mov	 ecx, DWORD PTR tv82[ebp]
  00066	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1553 :         return (_STD min)(

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ; std::_Default_allocator_traits<std::allocator<int> >::max_size
  00081	83 c4 04	 add	 esp, 4
  00084	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00087	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  0008a	89 55 d8	 mov	 DWORD PTR tv141[ebp], edx
  0008d	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  00090	c1 e8 03	 shr	 eax, 3
  00093	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00099	88 4d d1	 mov	 BYTE PTR tv144[ebp], cl
  0009c	80 7d d1 00	 cmp	 BYTE PTR tv144[ebp], 0
  000a0	74 1a		 je	 SHORT $LN5@max_size
  000a2	8a 55 d8	 mov	 dl, BYTE PTR tv141[ebp]
  000a5	80 e2 07	 and	 dl, 7
  000a8	80 c2 03	 add	 dl, 3
  000ab	3a 55 d1	 cmp	 dl, BYTE PTR tv144[ebp]
  000ae	7c 0c		 jl	 SHORT $LN5@max_size
  000b0	8b 45 d8	 mov	 eax, DWORD PTR tv141[ebp]
  000b3	50		 push	 eax
  000b4	e8 00 00 00 00	 call	 ___asan_report_store4
  000b9	83 c4 04	 add	 esp, 4
$LN5@max_size:
  000bc	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  000bf	89 4d 98	 mov	 DWORD PTR $T2[ebp], ecx
  000c2	e8 00 00 00 00	 call	 ?max@?$numeric_limits@H@std@@SAHXZ ; std::numeric_limits<int>::max
  000c7	89 45 f4	 mov	 DWORD PTR tv70[ebp], eax
  000ca	8d 55 a8	 lea	 edx, DWORD PTR $T3[ebp]
  000cd	89 55 dc	 mov	 DWORD PTR tv131[ebp], edx
  000d0	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000d3	c1 e8 03	 shr	 eax, 3
  000d6	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000dc	88 4d d2	 mov	 BYTE PTR tv134[ebp], cl
  000df	80 7d d2 00	 cmp	 BYTE PTR tv134[ebp], 0
  000e3	74 1a		 je	 SHORT $LN4@max_size
  000e5	8a 55 dc	 mov	 dl, BYTE PTR tv131[ebp]
  000e8	80 e2 07	 and	 dl, 7
  000eb	80 c2 03	 add	 dl, 3
  000ee	3a 55 d2	 cmp	 dl, BYTE PTR tv134[ebp]
  000f1	7c 0c		 jl	 SHORT $LN4@max_size
  000f3	8b 45 dc	 mov	 eax, DWORD PTR tv131[ebp]
  000f6	50		 push	 eax
  000f7	e8 00 00 00 00	 call	 ___asan_report_store4
  000fc	83 c4 04	 add	 esp, 4
$LN4@max_size:
  000ff	8b 4d f4	 mov	 ecx, DWORD PTR tv70[ebp]
  00102	89 4d a8	 mov	 DWORD PTR $T3[ebp], ecx
  00105	8d 55 98	 lea	 edx, DWORD PTR $T2[ebp]
  00108	52		 push	 edx
  00109	8d 45 a8	 lea	 eax, DWORD PTR $T3[ebp]
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 ??$min@I@std@@YAABIABI0@Z ; std::min<unsigned int>
  00112	83 c4 08	 add	 esp, 8
  00115	89 45 e4	 mov	 DWORD PTR tv64[ebp], eax
  00118	8b 4d e4	 mov	 ecx, DWORD PTR tv64[ebp]
  0011b	89 4d e0	 mov	 DWORD PTR tv89[ebp], ecx
  0011e	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00121	c1 ea 03	 shr	 edx, 3
  00124	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0012a	88 45 d3	 mov	 BYTE PTR tv92[ebp], al
  0012d	80 7d d3 00	 cmp	 BYTE PTR tv92[ebp], 0
  00131	74 1a		 je	 SHORT $LN3@max_size
  00133	8a 4d e0	 mov	 cl, BYTE PTR tv89[ebp]
  00136	80 e1 07	 and	 cl, 7
  00139	80 c1 03	 add	 cl, 3
  0013c	3a 4d d3	 cmp	 cl, BYTE PTR tv92[ebp]
  0013f	7c 0c		 jl	 SHORT $LN3@max_size
  00141	8b 55 e0	 mov	 edx, DWORD PTR tv89[ebp]
  00144	52		 push	 edx
  00145	e8 00 00 00 00	 call	 ___asan_report_load4
  0014a	83 c4 04	 add	 esp, 4
$LN3@max_size:
  0014d	8b 45 e4	 mov	 eax, DWORD PTR tv64[ebp]
  00150	8b 08		 mov	 ecx, DWORD PTR [eax]
  00152	89 4d fc	 mov	 DWORD PTR tv73[ebp], ecx
  00155	c7 45 88 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0015c	8d 55 88	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  0015f	c1 ea 03	 shr	 edx, 3
  00162	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00168	89 55 f8	 mov	 DWORD PTR tv85[ebp], edx
  0016b	6a 09		 push	 9
  0016d	8b 45 f8	 mov	 eax, DWORD PTR tv85[ebp]
  00170	50		 push	 eax
  00171	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00176	83 c4 08	 add	 esp, 8
  00179	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]

; 1554 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1555 :     }

  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c3		 ret	 0
?max_size@?$vector@HV?$allocator@H@std@@@std@@QBEIXZ ENDP ; std::vector<int,std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S13$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ PROC	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@HV?$allocator@H@std@@@std@@AAEXXZ ; std::vector<int,std::allocator<int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S13$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S13$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@HV?$allocator@H@std@@@std@@QAE@XZ ENDP	; std::vector<int,std::allocator<int> >::~vector<int,std::allocator<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -240					; size = 4
__asan_gen_1$ = -236					; size = 4
__asan_gen_2$ = -232					; size = 4
$T3 = -224						; size = 1
_$S9$ = -208						; size = 1
__Proxy$ = -192						; size = 8
__Guard$4 = -176					; size = 4
tv242 = -136						; size = 1
tv232 = -135						; size = 1
tv222 = -134						; size = 1
tv212 = -133						; size = 1
tv202 = -132						; size = 1
tv192 = -131						; size = 1
$T5 = -130						; size = 1
$T6 = -129						; size = 1
tv167 = -128						; size = 4
_this$ = -124						; size = 4
tv239 = -120						; size = 4
tv229 = -116						; size = 4
tv219 = -112						; size = 4
tv209 = -108						; size = 4
__Rightlast$ = -104					; size = 4
__Rightfirst$ = -100					; size = 4
__My_data$ = -96					; size = 4
tv199 = -92						; size = 4
tv189 = -88						; size = 4
tv86 = -84						; size = 4
__Right_data$ = -80					; size = 4
tv87 = -76						; size = 4
tv138 = -72						; size = 4
tv135 = -68						; size = 4
tv165 = -64						; size = 4
tv76 = -60						; size = 4
tv78 = -56						; size = 4
__Alproxy$ = -52					; size = 4
tv137 = -48						; size = 4
tv185 = -44						; size = 4
tv152 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 555  :         : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 10 ff ff
	ff		 add	 esp, -240		; ffffff10H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d 84	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 10 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 14 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00056	c7 85 18 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00060	8d 85 10 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv165[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv165[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d 80	 mov	 DWORD PTR tv167[ebp], ecx
  00078	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00085	8b 45 80	 mov	 eax, DWORD PTR tv167[ebp]
  00088	c7 00 f8 f2 f8
	f2		 mov	 DWORD PTR [eax], -218565896 ; f2f8f2f8H
  0008e	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  00092	8b 4d 80	 mov	 ecx, DWORD PTR tv167[ebp]
  00095	c7 01 f8 f3 f3
	f3		 mov	 DWORD PTR [ecx], -202116104 ; f3f3f3f8H
  0009b	83 45 80 04	 add	 DWORD PTR tv167[ebp], 4
  0009f	8b 55 80	 mov	 edx, DWORD PTR tv167[ebp]
  000a2	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  000a5	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S9$[ebp]
  000ab	c1 e8 03	 shr	 eax, 3
  000ae	c6 80 00 00 00
	30 01		 mov	 BYTE PTR [eax+805306368], 1
  000b5	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  000bb	c1 e9 03	 shr	 ecx, 3
  000be	c6 81 00 00 00
	30 00		 mov	 BYTE PTR [ecx+805306368], 0
  000c5	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000ca	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000cf	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  000d2	89 55 c8	 mov	 DWORD PTR tv78[ebp], edx
  000d5	8b 4b 08	 mov	 ecx, DWORD PTR __Right$[ebx]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@ABEABV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  000e4	50		 push	 eax
  000e5	e8 00 00 00 00	 call	 ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
  000ea	83 c4 08	 add	 esp, 8
  000ed	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000f0	6a 01		 push	 1
  000f2	8d 8d 7f ff ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  000f8	51		 push	 ecx
  000f9	8d 95 7e ff ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  000ff	52		 push	 edx
  00100	e8 00 00 00 00	 call	 ___asan_memcpy
  00105	83 c4 0c	 add	 esp, 12			; 0000000cH
  00108	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  0010b	50		 push	 eax
  0010c	0f b6 8d 7e ff
	ff ff		 movzx	 ecx, BYTE PTR $T5[ebp]
  00113	51		 push	 ecx
  00114	8b 4d c8	 mov	 ecx, DWORD PTR tv78[ebp]
  00117	e8 00 00 00 00	 call	 ??$?0V?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> >
  0011c	8d 95 20 ff ff
	ff		 lea	 edx, DWORD PTR $T3[ebp]
  00122	c1 ea 03	 shr	 edx, 3
  00125	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H

; 556  :         auto&& _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0012c	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0012f	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  00134	50		 push	 eax
  00135	8d 8d 30 ff ff
	ff		 lea	 ecx, DWORD PTR _$S9$[ebp]
  0013b	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  00140	8d 85 30 ff ff
	ff		 lea	 eax, DWORD PTR _$S9$[ebp]
  00146	89 45 cc	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 557  :         auto& _My_data            = _Mypair._Myval2;

  00149	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	89 4d a0	 mov	 DWORD PTR __My_data$[ebp], ecx

; 558  :         const auto& _Right_data   = _Right._Mypair._Myval2;

  0014f	8b 53 08	 mov	 edx, DWORD PTR __Right$[ebx]
  00152	89 55 b0	 mov	 DWORD PTR __Right_data$[ebp], edx

; 559  :         const pointer _Rightfirst = _Right_data._Myfirst;

  00155	8b 45 b0	 mov	 eax, DWORD PTR __Right_data$[ebp]
  00158	83 c0 04	 add	 eax, 4
  0015b	89 45 ac	 mov	 DWORD PTR tv86[ebp], eax
  0015e	8b 4d ac	 mov	 ecx, DWORD PTR tv86[ebp]
  00161	89 4d 88	 mov	 DWORD PTR tv239[ebp], ecx
  00164	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00167	c1 ea 03	 shr	 edx, 3
  0016a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00170	88 85 78 ff ff
	ff		 mov	 BYTE PTR tv242[ebp], al
  00176	80 bd 78 ff ff
	ff 00		 cmp	 BYTE PTR tv242[ebp], 0
  0017d	74 1d		 je	 SHORT $LN11@vector
  0017f	8a 4d 88	 mov	 cl, BYTE PTR tv239[ebp]
  00182	80 e1 07	 and	 cl, 7
  00185	80 c1 03	 add	 cl, 3
  00188	3a 8d 78 ff ff
	ff		 cmp	 cl, BYTE PTR tv242[ebp]
  0018e	7c 0c		 jl	 SHORT $LN11@vector
  00190	8b 55 88	 mov	 edx, DWORD PTR tv239[ebp]
  00193	52		 push	 edx
  00194	e8 00 00 00 00	 call	 ___asan_report_load4
  00199	83 c4 04	 add	 esp, 4
$LN11@vector:
  0019c	8b 45 ac	 mov	 eax, DWORD PTR tv86[ebp]
  0019f	8b 08		 mov	 ecx, DWORD PTR [eax]
  001a1	89 4d 9c	 mov	 DWORD PTR __Rightfirst$[ebp], ecx

; 560  :         const pointer _Rightlast  = _Right_data._Mylast;

  001a4	8b 55 b0	 mov	 edx, DWORD PTR __Right_data$[ebp]
  001a7	83 c2 08	 add	 edx, 8
  001aa	89 55 b4	 mov	 DWORD PTR tv87[ebp], edx
  001ad	8b 45 b4	 mov	 eax, DWORD PTR tv87[ebp]
  001b0	89 45 8c	 mov	 DWORD PTR tv229[ebp], eax
  001b3	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001b6	c1 e9 03	 shr	 ecx, 3
  001b9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001bf	88 95 79 ff ff
	ff		 mov	 BYTE PTR tv232[ebp], dl
  001c5	80 bd 79 ff ff
	ff 00		 cmp	 BYTE PTR tv232[ebp], 0
  001cc	74 1b		 je	 SHORT $LN10@vector
  001ce	8a 45 8c	 mov	 al, BYTE PTR tv229[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 85 79 ff ff
	ff		 cmp	 al, BYTE PTR tv232[ebp]
  001db	7c 0c		 jl	 SHORT $LN10@vector
  001dd	8b 4d 8c	 mov	 ecx, DWORD PTR tv229[ebp]
  001e0	51		 push	 ecx
  001e1	e8 00 00 00 00	 call	 ___asan_report_load4
  001e6	83 c4 04	 add	 esp, 4
$LN10@vector:
  001e9	8b 55 b4	 mov	 edx, DWORD PTR tv87[ebp]
  001ec	8b 02		 mov	 eax, DWORD PTR [edx]
  001ee	89 45 98	 mov	 DWORD PTR __Rightlast$[ebp], eax

; 561  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);

  001f1	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  001f4	51		 push	 ecx
  001f5	8b 55 cc	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  001f8	52		 push	 edx
  001f9	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  001ff	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00204	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 562  :         if (_Rightfirst != _Rightlast) {

  0020b	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  0020e	3b 45 98	 cmp	 eax, DWORD PTR __Rightlast$[ebp]
  00211	0f 84 85 01 00
	00		 je	 $LN2@vector
  00217	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  0021d	c1 e9 03	 shr	 ecx, 3
  00220	c6 81 00 00 00
	30 04		 mov	 BYTE PTR [ecx+805306368], 4

; 563  :             _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));

  00227	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  0022a	2b 55 9c	 sub	 edx, DWORD PTR __Rightfirst$[ebp]
  0022d	c1 fa 02	 sar	 edx, 2
  00230	52		 push	 edx
  00231	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	e8 00 00 00 00	 call	 ?_Buy_raw@?$vector@HV?$allocator@H@std@@@std@@AAEXI@Z ; std::vector<int,std::allocator<int> >::_Buy_raw

; 564  :             _Tidy_guard<vector> _Guard{this};

  00239	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0023f	89 45 90	 mov	 DWORD PTR tv219[ebp], eax
  00242	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  00245	c1 e9 03	 shr	 ecx, 3
  00248	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0024e	88 95 7a ff ff
	ff		 mov	 BYTE PTR tv222[ebp], dl
  00254	80 bd 7a ff ff
	ff 00		 cmp	 BYTE PTR tv222[ebp], 0
  0025b	74 1b		 je	 SHORT $LN9@vector
  0025d	8a 45 90	 mov	 al, BYTE PTR tv219[ebp]
  00260	24 07		 and	 al, 7
  00262	04 03		 add	 al, 3
  00264	3a 85 7a ff ff
	ff		 cmp	 al, BYTE PTR tv222[ebp]
  0026a	7c 0c		 jl	 SHORT $LN9@vector
  0026c	8b 4d 90	 mov	 ecx, DWORD PTR tv219[ebp]
  0026f	51		 push	 ecx
  00270	e8 00 00 00 00	 call	 ___asan_report_store4
  00275	83 c4 04	 add	 esp, 4
$LN9@vector:
  00278	8b 55 84	 mov	 edx, DWORD PTR _this$[ebp]
  0027b	89 95 50 ff ff
	ff		 mov	 DWORD PTR __Guard$4[ebp], edx
  00281	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 565  :             _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);

  00285	8b 45 a0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00288	83 c0 04	 add	 eax, 4
  0028b	89 45 b8	 mov	 DWORD PTR tv138[ebp], eax
  0028e	8b 4d b8	 mov	 ecx, DWORD PTR tv138[ebp]
  00291	89 4d 94	 mov	 DWORD PTR tv209[ebp], ecx
  00294	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  00297	c1 ea 03	 shr	 edx, 3
  0029a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  002a0	88 85 7b ff ff
	ff		 mov	 BYTE PTR tv212[ebp], al
  002a6	80 bd 7b ff ff
	ff 00		 cmp	 BYTE PTR tv212[ebp], 0
  002ad	74 1d		 je	 SHORT $LN8@vector
  002af	8a 4d 94	 mov	 cl, BYTE PTR tv209[ebp]
  002b2	80 e1 07	 and	 cl, 7
  002b5	80 c1 03	 add	 cl, 3
  002b8	3a 8d 7b ff ff
	ff		 cmp	 cl, BYTE PTR tv212[ebp]
  002be	7c 0c		 jl	 SHORT $LN8@vector
  002c0	8b 55 94	 mov	 edx, DWORD PTR tv209[ebp]
  002c3	52		 push	 edx
  002c4	e8 00 00 00 00	 call	 ___asan_report_load4
  002c9	83 c4 04	 add	 esp, 4
$LN8@vector:
  002cc	8b 45 b8	 mov	 eax, DWORD PTR tv138[ebp]
  002cf	8b 08		 mov	 ecx, DWORD PTR [eax]
  002d1	51		 push	 ecx
  002d2	8b 55 98	 mov	 edx, DWORD PTR __Rightlast$[ebp]
  002d5	52		 push	 edx
  002d6	8b 45 9c	 mov	 eax, DWORD PTR __Rightfirst$[ebp]
  002d9	50		 push	 eax
  002da	8b 4d 84	 mov	 ecx, DWORD PTR _this$[ebp]
  002dd	e8 00 00 00 00	 call	 ??$_Ucopy@PAH@?$vector@HV?$allocator@H@std@@@std@@AAEPAHPAH00@Z ; std::vector<int,std::allocator<int> >::_Ucopy<int *>
  002e2	89 45 d0	 mov	 DWORD PTR tv137[ebp], eax
  002e5	8b 4d a0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  002e8	83 c1 08	 add	 ecx, 8
  002eb	89 4d bc	 mov	 DWORD PTR tv135[ebp], ecx
  002ee	8b 55 bc	 mov	 edx, DWORD PTR tv135[ebp]
  002f1	89 55 a4	 mov	 DWORD PTR tv199[ebp], edx
  002f4	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  002f7	c1 e8 03	 shr	 eax, 3
  002fa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00300	88 8d 7c ff ff
	ff		 mov	 BYTE PTR tv202[ebp], cl
  00306	80 bd 7c ff ff
	ff 00		 cmp	 BYTE PTR tv202[ebp], 0
  0030d	74 1d		 je	 SHORT $LN7@vector
  0030f	8a 55 a4	 mov	 dl, BYTE PTR tv199[ebp]
  00312	80 e2 07	 and	 dl, 7
  00315	80 c2 03	 add	 dl, 3
  00318	3a 95 7c ff ff
	ff		 cmp	 dl, BYTE PTR tv202[ebp]
  0031e	7c 0c		 jl	 SHORT $LN7@vector
  00320	8b 45 a4	 mov	 eax, DWORD PTR tv199[ebp]
  00323	50		 push	 eax
  00324	e8 00 00 00 00	 call	 ___asan_report_store4
  00329	83 c4 04	 add	 esp, 4
$LN7@vector:
  0032c	8b 4d bc	 mov	 ecx, DWORD PTR tv135[ebp]
  0032f	8b 55 d0	 mov	 edx, DWORD PTR tv137[ebp]
  00332	89 11		 mov	 DWORD PTR [ecx], edx

; 566  :             _Guard._Target   = nullptr;

  00334	8d 85 50 ff ff
	ff		 lea	 eax, DWORD PTR __Guard$4[ebp]
  0033a	89 45 a8	 mov	 DWORD PTR tv189[ebp], eax
  0033d	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  00340	c1 e9 03	 shr	 ecx, 3
  00343	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00349	88 95 7d ff ff
	ff		 mov	 BYTE PTR tv192[ebp], dl
  0034f	80 bd 7d ff ff
	ff 00		 cmp	 BYTE PTR tv192[ebp], 0
  00356	74 1b		 je	 SHORT $LN6@vector
  00358	8a 45 a8	 mov	 al, BYTE PTR tv189[ebp]
  0035b	24 07		 and	 al, 7
  0035d	04 03		 add	 al, 3
  0035f	3a 85 7d ff ff
	ff		 cmp	 al, BYTE PTR tv192[ebp]
  00365	7c 0c		 jl	 SHORT $LN6@vector
  00367	8b 4d a8	 mov	 ecx, DWORD PTR tv189[ebp]
  0036a	51		 push	 ecx
  0036b	e8 00 00 00 00	 call	 ___asan_report_store4
  00370	83 c4 04	 add	 esp, 4
$LN6@vector:
  00373	c7 85 50 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __Guard$4[ebp], 0

; 567  :         }

  0037d	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  00381	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00387	e8 00 00 00 00	 call	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  0038c	8d 95 50 ff ff
	ff		 lea	 edx, DWORD PTR __Guard$4[ebp]
  00392	c1 ea 03	 shr	 edx, 3
  00395	c6 82 00 00 00
	30 f8		 mov	 BYTE PTR [edx+805306368], 248 ; 000000f8H
$LN2@vector:

; 568  : 
; 569  :         _Proxy._Release();

  0039c	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003a2	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 570  :     }

  003a7	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  003ae	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  003b4	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  003b9	8b 45 84	 mov	 eax, DWORD PTR _this$[ebp]
  003bc	89 45 d8	 mov	 DWORD PTR tv152[ebp], eax
  003bf	c7 85 10 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  003c9	8d 8d 10 ff ff
	ff		 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  003cf	c1 e9 03	 shr	 ecx, 3
  003d2	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  003d8	89 4d d4	 mov	 DWORD PTR tv185[ebp], ecx
  003db	6a 0d		 push	 13			; 0000000dH
  003dd	8b 55 d4	 mov	 edx, DWORD PTR tv185[ebp]
  003e0	52		 push	 edx
  003e1	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003e6	83 c4 08	 add	 esp, 8
  003e9	8b 45 d8	 mov	 eax, DWORD PTR tv152[ebp]
  003ec	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  003ef	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  003f6	59		 pop	 ecx
  003f7	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  003fa	33 cd		 xor	 ecx, ebp
  003fc	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00401	8b e5		 mov	 esp, ebp
  00403	5d		 pop	 ebp
  00404	8b e3		 mov	 esp, ebx
  00406	5b		 pop	 ebx
  00407	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$0:
  00000	8d 8d 40 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z$1:
  0000b	8d 8d 50 ff ff
	ff		 lea	 ecx, DWORD PTR __Guard$4[ebp]
  00011	e9 00 00 00 00	 jmp	 ??1?$_Tidy_guard@V?$vector@HV?$allocator@H@std@@@std@@@std@@QAE@XZ ; std::_Tidy_guard<std::vector<int,std::allocator<int> > >::~_Tidy_guard<std::vector<int,std::allocator<int> > >
  00016	cc		 int	 3
  00017	cc		 int	 3
  00018	cc		 int	 3
  00019	cc		 int	 3
  0001a	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z:
  0001b	90		 npad	 1
  0001c	90		 npad	 1
  0001d	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00021	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00024	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  0002a	33 c8		 xor	 ecx, eax
  0002c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00031	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00034	33 c8		 xor	 ecx, eax
  00036	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0003b	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z
  00040	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -168					; size = 4
__asan_gen_1$ = -164					; size = 4
__asan_gen_2$ = -160					; size = 4
_$S7$ = -152						; size = 1
__Proxy$ = -136						; size = 8
$T3 = -120						; size = 1
$T4 = -76						; size = 1
$T5 = -75						; size = 1
$T6 = -74						; size = 1
$T7 = -73						; size = 1
tv153 = -72						; size = 4
_this$ = -68						; size = 4
tv151 = -64						; size = 4
tv70 = -60						; size = 4
__Alproxy$ = -56					; size = 4
tv135 = -52						; size = 4
tv133 = -48						; size = 4
tv162 = -44						; size = 4
tv150 = -40						; size = 4
__$ArrayPad$ = -36					; size = 4
__$EHRec$ = -12						; size = 12
__Ilist$ = 8						; size = 8
__Al$ = 16						; size = 4
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z PROC ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >, COMDAT
; _this$ = ecx

; 547  :         : _Mypair(_One_then_variadic_args_t{}, _Al) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 50 ff ff
	ff		 add	 esp, -176		; ffffff50H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	89 45 dc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d bc	 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 58 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 5c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  00056	c7 85 60 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
  00060	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 45 c0	 mov	 DWORD PTR tv151[ebp], eax
  00069	8b 4d c0	 mov	 ecx, DWORD PTR tv151[ebp]
  0006c	c1 e9 03	 shr	 ecx, 3
  0006f	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00075	89 4d b8	 mov	 DWORD PTR tv153[ebp], ecx
  00078	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0007b	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  00081	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00085	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  00088	c7 00 00 f2 f8
	f3		 mov	 DWORD PTR [eax], -201788928 ; f3f8f200H
  0008e	83 45 b8 04	 add	 DWORD PTR tv153[ebp], 4
  00092	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  00097	8b 55 b8	 mov	 edx, DWORD PTR tv153[ebp]
  0009a	66 89 0a	 mov	 WORD PTR [edx], cx
  0009d	83 45 b8 02	 add	 DWORD PTR tv153[ebp], 2
  000a1	8b 45 b8	 mov	 eax, DWORD PTR tv153[ebp]
  000a4	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  000a7	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  000aa	c1 e9 03	 shr	 ecx, 3
  000ad	c6 81 00 00 00
	30 01		 mov	 BYTE PTR [ecx+805306368], 1
  000b4	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  000b9	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  000be	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  000c1	89 55 c4	 mov	 DWORD PTR tv70[ebp], edx
  000c4	8b 43 10	 mov	 eax, DWORD PTR __Al$[ebx]
  000c7	50		 push	 eax
  000c8	0f b6 4d b6	 movzx	 ecx, BYTE PTR $T6[ebp]
  000cc	51		 push	 ecx
  000cd	8b 4d c4	 mov	 ecx, DWORD PTR tv70[ebp]
  000d0	e8 00 00 00 00	 call	 ??$?0ABV?$allocator@H@std@@$$V@?$_Compressed_pair@V?$allocator@H@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@H@1@@Z ; std::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1>::_Compressed_pair<std::allocator<int>,std::_Vector_val<std::_Simple_types<int> >,1><std::allocator<int> const &>

; 548  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  000d5	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  000d8	e8 00 00 00 00	 call	 ?_Getal@?$vector@HV?$allocator@H@std@@@std@@AAEAAV?$allocator@H@2@XZ ; std::vector<int,std::allocator<int> >::_Getal
  000dd	50		 push	 eax
  000de	8d 8d 68 ff ff
	ff		 lea	 ecx, DWORD PTR _$S7$[ebp]
  000e4	e8 00 00 00 00	 call	 ??$?0H@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@H@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><int>
  000e9	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR _$S7$[ebp]
  000ef	89 55 c8	 mov	 DWORD PTR __Alproxy$[ebp], edx

; 549  :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);

  000f2	8b 45 bc	 mov	 eax, DWORD PTR _this$[ebp]
  000f5	50		 push	 eax
  000f6	8b 4d c8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  000f9	51		 push	 ecx
  000fa	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00100	e8 00 00 00 00	 call	 ??0?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAV?$allocator@U_Container_proxy@std@@@1@AAU_Container_base12@1@@Z ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00105	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 550  :         _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});

  0010c	6a 01		 push	 1
  0010e	6a 00		 push	 0
  00110	8d 55 88	 lea	 edx, DWORD PTR $T3[ebp]
  00113	52		 push	 edx
  00114	e8 00 00 00 00	 call	 ___asan_memset
  00119	83 c4 0c	 add	 esp, 12			; 0000000cH
  0011c	6a 01		 push	 1
  0011e	8d 45 b7	 lea	 eax, DWORD PTR $T7[ebp]
  00121	50		 push	 eax
  00122	8d 4d b4	 lea	 ecx, DWORD PTR $T4[ebp]
  00125	51		 push	 ecx
  00126	e8 00 00 00 00	 call	 ___asan_memcpy
  0012b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0012e	6a 01		 push	 1
  00130	8d 55 b4	 lea	 edx, DWORD PTR $T4[ebp]
  00133	52		 push	 edx
  00134	8d 45 b5	 lea	 eax, DWORD PTR $T5[ebp]
  00137	50		 push	 eax
  00138	e8 00 00 00 00	 call	 ___asan_memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00140	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  00143	e8 00 00 00 00	 call	 ?end@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::end
  00148	89 45 cc	 mov	 DWORD PTR tv135[ebp], eax
  0014b	8d 4b 08	 lea	 ecx, DWORD PTR __Ilist$[ebx]
  0014e	e8 00 00 00 00	 call	 ?begin@?$initializer_list@H@std@@QBEPBHXZ ; std::initializer_list<int>::begin
  00153	89 45 d0	 mov	 DWORD PTR tv133[ebp], eax
  00156	0f b6 4d b5	 movzx	 ecx, BYTE PTR $T5[ebp]
  0015a	51		 push	 ecx
  0015b	8b 55 cc	 mov	 edx, DWORD PTR tv135[ebp]
  0015e	52		 push	 edx
  0015f	8b 45 d0	 mov	 eax, DWORD PTR tv133[ebp]
  00162	50		 push	 eax
  00163	8b 4d bc	 mov	 ecx, DWORD PTR _this$[ebp]
  00166	e8 00 00 00 00	 call	 ??$_Range_construct_or_tidy@PBH@?$vector@HV?$allocator@H@std@@@std@@AAEXPBH0Uforward_iterator_tag@1@@Z ; std::vector<int,std::allocator<int> >::_Range_construct_or_tidy<int const *>
  0016b	8d 4d 88	 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	c1 e9 03	 shr	 ecx, 3
  00171	c6 81 00 00 00
	30 f8		 mov	 BYTE PTR [ecx+805306368], 248 ; 000000f8H

; 551  :         _Proxy._Release();

  00178	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  0017e	e8 00 00 00 00	 call	 ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ; std::_Basic_container_proxy_ptr12::_Release

; 552  :     }

  00183	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0018a	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00190	e8 00 00 00 00	 call	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  00195	8b 55 bc	 mov	 edx, DWORD PTR _this$[ebp]
  00198	89 55 d8	 mov	 DWORD PTR tv150[ebp], edx
  0019b	c7 85 58 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  001a5	8d 85 58 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  001ab	c1 e8 03	 shr	 eax, 3
  001ae	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  001b3	89 45 d4	 mov	 DWORD PTR tv162[ebp], eax
  001b6	6a 0b		 push	 11			; 0000000bH
  001b8	8b 4d d4	 mov	 ecx, DWORD PTR tv162[ebp]
  001bb	51		 push	 ecx
  001bc	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  001c1	83 c4 08	 add	 esp, 8
  001c4	8b 45 d8	 mov	 eax, DWORD PTR tv150[ebp]
  001c7	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  001ca	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  001d1	59		 pop	 ecx
  001d2	8b 4d dc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  001d5	33 cd		 xor	 ecx, ebp
  001d7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  001dc	8b e5		 mov	 esp, ebp
  001de	5d		 pop	 ebp
  001df	8b e3		 mov	 esp, ebx
  001e1	5b		 pop	 ebx
  001e2	c2 0c 00	 ret	 12			; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z$0:
  00000	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Proxy$[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$_Container_proxy_ptr12@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@XZ ; std::_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >::~_Container_proxy_ptr12<std::allocator<std::_Container_proxy> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 48 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-184]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a e8	 mov	 ecx, DWORD PTR [edx-24]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0?$vector@HV?$allocator@H@std@@@std@@QAE@V?$initializer_list@H@1@ABV?$allocator@H@1@@Z ENDP ; std::vector<int,std::allocator<int> >::vector<int,std::allocator<int> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction, COMDAT

; 731  :     _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc& _Al) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 732  :         return _Al;

  0000d	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 733  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SA?AV?$allocator@H@2@ABV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<int> >::max_size, COMDAT

; 727  :     _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 728  :         return static_cast<size_t>(-1) / sizeof(value_type);

  0000d	b8 ff ff ff 3f	 mov	 eax, 1073741823		; 3fffffffH

; 729  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@H@std@@@std@@SAIABV?$allocator@H@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<int> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?allocate@?$allocator@H@std@@QAEPAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@H@std@@QAEPAHI@Z PROC		; std::allocator<int>::allocate, COMDAT
; _this$ = ecx

; 838  :     _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 839  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));

  00011	8b 45 08	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 ??$_Get_size_of_n@$03@std@@YAII@Z ; std::_Get_size_of_n<4>
  0001a	83 c4 04	 add	 esp, 4
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 ??$_Allocate@$07U_Default_allocate_traits@std@@$0A@@std@@YAPAXI@Z ; std::_Allocate<8,std::_Default_allocate_traits,0>
  00023	83 c4 04	 add	 esp, 4

; 840  :     }

  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 04 00	 ret	 4
?allocate@?$allocator@H@std@@QAEPAHI@Z ENDP		; std::allocator<int>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@H@std@@QAEXQAHI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@H@std@@QAEXQAHI@Z PROC		; std::allocator<int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@H@std@@QAEXQAHI@Z ENDP		; std::allocator<int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0?$allocator@H@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@H@std@@QAE@XZ PROC			; std::allocator<int>::allocator<int>, COMDAT
; _this$ = ecx

; 825  :     constexpr allocator() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
??0?$allocator@H@std@@QAE@XZ ENDP			; std::allocator<int>::allocator<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv85 = -32						; size = 4
tv82 = -28						; size = 4
__Ptrdest$ = -24					; size = 4
tv88 = -20						; size = 4
tv130 = -16						; size = 4
__Ptrnext$1 = -12					; size = 4
__Count$ = -8						; size = 4
tv91 = -2						; size = 1
tv133 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00022	68 0e 02 00 00	 push	 526			; 0000020eH
  00027	68 00 00 00 00	 push	 OFFSET $SG253969
  0002c	6a 02		 push	 2
  0002e	6a 01		 push	 1
  00030	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	89 45 e8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 527  : 
; 528  :     if (!_Ptrdest) {

  00040	83 7d e8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00044	75 05		 jne	 SHORT $LN5@Maklocstr

; 529  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0004b	8b 55 e8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  00051	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00053	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	83 e8 01	 sub	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f4	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00068	83 c2 01	 add	 edx, 1
  0006b	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0006e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00072	76 7f		 jbe	 SHORT $LN3@Maklocstr

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00074	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00077	89 45 e4	 mov	 DWORD PTR tv82[ebp], eax
  0007a	8b 4d e4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv130[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 ff	 mov	 BYTE PTR tv133[ebp], al
  0008f	80 7d ff 00	 cmp	 BYTE PTR tv133[ebp], 0
  00093	74 17		 je	 SHORT $LN8@Maklocstr
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv130[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	3a 4d ff	 cmp	 cl, BYTE PTR tv133[ebp]
  0009e	7c 0c		 jl	 SHORT $LN8@Maklocstr
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load1
  000a9	83 c4 04	 add	 esp, 4
$LN8@Maklocstr:
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000af	89 45 e0	 mov	 DWORD PTR tv85[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR tv85[ebp]
  000b5	89 4d ec	 mov	 DWORD PTR tv88[ebp], ecx
  000b8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000bb	c1 ea 03	 shr	 edx, 3
  000be	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c4	88 45 fe	 mov	 BYTE PTR tv91[ebp], al
  000c7	80 7d fe 00	 cmp	 BYTE PTR tv91[ebp], 0
  000cb	74 17		 je	 SHORT $LN7@Maklocstr
  000cd	8a 4d ec	 mov	 cl, BYTE PTR tv88[ebp]
  000d0	80 e1 07	 and	 cl, 7
  000d3	3a 4d fe	 cmp	 cl, BYTE PTR tv91[ebp]
  000d6	7c 0c		 jl	 SHORT $LN7@Maklocstr
  000d8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ___asan_report_store1
  000e1	83 c4 04	 add	 esp, 4
$LN7@Maklocstr:
  000e4	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ea	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ec	88 10		 mov	 BYTE PTR [eax], dl

; 534  :     }

  000ee	e9 60 ff ff ff	 jmp	 $LN2@Maklocstr
$LN3@Maklocstr:

; 535  : 
; 536  :     return _Ptrdest;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 537  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__Ptrdest$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __4CB88277_xlocnum
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0001a	83 c4 04	 add	 esp, 4
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00023	6a 5d		 push	 93			; 0000005dH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0002a	6a 02		 push	 2
  0002c	6a 02		 push	 2
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 94   : 
; 95   :     if (!_Ptrdest) {

  0003e	83 7d fc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00042	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  00044	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00049	8b 55 f8	 mov	 edx, DWORD PTR __Count$[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _wmemcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :     return _Ptrdest;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 101  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Mbst1$ = -136						; size = 8
__Wc$ = -120						; size = 2
__Mbst2$ = -104						; size = 8
tv156 = -57						; size = 1
tv146 = -56						; size = 4
__Wchars$ = -52						; size = 4
__Bytes$ = -48						; size = 4
__Count$ = -44						; size = 4
__Ptrnext$ = -40					; size = 4
__Ptr1$ = -36						; size = 4
tv153 = -32						; size = 4
__Ptrdest$ = -28					; size = 4
__Count1$ = -24						; size = 4
tv144 = -20						; size = 4
tv141 = -16						; size = 4
tv149 = -12						; size = 4
tv140 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 540  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
  0003a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00044	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR tv144[ebp], eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c8	 mov	 DWORD PTR tv146[ebp], ecx
  0005c	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0005f	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00065	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00069	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  0006c	c7 00 02 f2 00
	f3		 mov	 DWORD PTR [eax], -218041854 ; f300f202H
  00072	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00076	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  0007b	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0007e	66 89 0a	 mov	 WORD PTR [edx], cx
  00081	83 45 c8 02	 add	 DWORD PTR tv146[ebp], 2
  00085	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  00088	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 541  :     // convert C string to wchar_t sequence using _Cvtvec
; 542  :     size_t _Count;
; 543  :     size_t _Count1;
; 544  :     size_t _Wchars;
; 545  :     const char* _Ptr1;
; 546  :     int _Bytes;
; 547  :     wchar_t _Wc;
; 548  :     mbstate_t _Mbst1 = {};

  00095	6a 08		 push	 8
  00097	6a 00		 push	 0
  00099	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ___asan_memset
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 549  : 
; 550  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  000a8	8b 53 08	 mov	 edx, DWORD PTR __Ptr$[ebx]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _strlen
  000b1	83 c4 04	 add	 esp, 4
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 e8	 mov	 DWORD PTR __Count1$[ebp], eax

; 551  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  000ba	8b 45 e8	 mov	 eax, DWORD PTR __Count1$[ebp]
  000bd	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  000c0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  000c7	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000ca	89 4d dc	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  000cd	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  000cf	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  000d2	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  000d5	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  000d8	8b 45 dc	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  000db	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  000de	89 45 dc	 mov	 DWORD PTR __Ptr1$[ebp], eax
  000e1	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
$LN4@Maklocstr:
  000ea	83 7d d4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000ee	76 2c		 jbe	 SHORT $LN3@Maklocstr

; 552  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  000f0	8b 53 10	 mov	 edx, DWORD PTR __Cvt$[ebx]
  000f3	52		 push	 edx
  000f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __Mbst1$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 dc	 mov	 edx, DWORD PTR __Ptr1$[ebp]
  00102	52		 push	 edx
  00103	8d 45 88	 lea	 eax, DWORD PTR __Wc$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __Mbrtowc
  0010c	83 c4 14	 add	 esp, 20			; 00000014H
  0010f	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00112	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00116	7f 02		 jg	 SHORT $LN8@Maklocstr

; 553  :             break;

  00118	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 554  :         }
; 555  :     }

  0011a	eb b3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 556  : 
; 557  :     ++_Wchars; // count terminating nul

  0011c	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx

; 558  : 
; 559  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00125	68 2f 02 00 00	 push	 559			; 0000022fH
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0012f	6a 02		 push	 2
  00131	6a 02		 push	 2
  00133	8b 55 cc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  00136	52		 push	 edx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0013d	83 c4 14	 add	 esp, 20			; 00000014H
  00140	89 45 e4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 560  : 
; 561  :     if (!_Ptrdest) {

  00143	83 7d e4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00147	75 05		 jne	 SHORT $LN9@Maklocstr

; 562  :         _Xbad_alloc();

  00149	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 563  :     }
; 564  : 
; 565  :     wchar_t* _Ptrnext = _Ptrdest;

  0014e	8b 45 e4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00151	89 45 d8	 mov	 DWORD PTR __Ptrnext$[ebp], eax

; 566  :     mbstate_t _Mbst2  = {};

  00154	6a 08		 push	 8
  00156	6a 00		 push	 0
  00158	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ___asan_memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 
; 568  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00164	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  00166	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  00169	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  0016c	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  0016f	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00172	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00175	89 43 08	 mov	 DWORD PTR __Ptr$[ebx], eax
  00178	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0017b	83 e9 01	 sub	 ecx, 1
  0017e	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
  00181	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  00184	83 c2 02	 add	 edx, 2
  00187	89 55 d8	 mov	 DWORD PTR __Ptrnext$[ebp], edx
$LN7@Maklocstr:
  0018a	83 7d cc 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0018e	76 29		 jbe	 SHORT $LN6@Maklocstr

; 569  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00190	8b 43 10	 mov	 eax, DWORD PTR __Cvt$[ebx]
  00193	50		 push	 eax
  00194	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 e8	 mov	 edx, DWORD PTR __Count1$[ebp]
  0019b	52		 push	 edx
  0019c	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  0019f	50		 push	 eax
  001a0	8b 4d d8	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 __Mbrtowc
  001a9	83 c4 14	 add	 esp, 20			; 00000014H
  001ac	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  001af	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  001b3	7f 02		 jg	 SHORT $LN10@Maklocstr

; 570  :             break;

  001b5	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 571  :         }
; 572  :     }

  001b7	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 573  : 
; 574  :     *_Ptrnext = L'\0';

  001b9	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  001bc	89 55 f0	 mov	 DWORD PTR tv141[ebp], edx
  001bf	8b 45 f0	 mov	 eax, DWORD PTR tv141[ebp]
  001c2	89 45 e0	 mov	 DWORD PTR tv153[ebp], eax
  001c5	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001c8	c1 e9 03	 shr	 ecx, 3
  001cb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001d1	88 55 c7	 mov	 BYTE PTR tv156[ebp], dl
  001d4	80 7d c7 00	 cmp	 BYTE PTR tv156[ebp], 0
  001d8	74 18		 je	 SHORT $LN12@Maklocstr
  001da	8a 45 e0	 mov	 al, BYTE PTR tv153[ebp]
  001dd	24 07		 and	 al, 7
  001df	04 01		 add	 al, 1
  001e1	3a 45 c7	 cmp	 al, BYTE PTR tv156[ebp]
  001e4	7c 0c		 jl	 SHORT $LN12@Maklocstr
  001e6	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 ___asan_report_store2
  001ef	83 c4 04	 add	 esp, 4
$LN12@Maklocstr:
  001f2	33 d2		 xor	 edx, edx
  001f4	8b 45 d8	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  001f7	66 89 10	 mov	 WORD PTR [eax], dx

; 575  : 
; 576  :     return _Ptrdest;

  001fa	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  001fd	89 4d f8	 mov	 DWORD PTR tv140[ebp], ecx
  00200	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0020a	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00210	c1 ea 03	 shr	 edx, 3
  00213	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00219	89 55 f4	 mov	 DWORD PTR tv149[ebp], edx
  0021c	6a 0b		 push	 11			; 0000000bH
  0021e	8b 45 f4	 mov	 eax, DWORD PTR tv149[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00227	83 c4 08	 add	 esp, 8
  0022a	8b 45 f8	 mov	 eax, DWORD PTR tv140[ebp]
$LN11@Maklocstr:

; 577  : }

  0022d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00230	33 cd		 xor	 ecx, ebp
  00232	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	8b e3		 mov	 esp, ebx
  0023c	5b		 pop	 ebx
  0023d	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xutility
;	COMDAT ??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z
_TEXT	SEGMENT
$T1 = -28						; size = 4
tv93 = -24						; size = 4
tv75 = -20						; size = 4
tv77 = -16						; size = 4
tv89 = -12						; size = 4
tv128 = -8						; size = 4
tv131 = -1						; size = 1
__Obj$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z PROC ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>, COMDAT

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __12269DE6_xutility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 152  : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 153  :     if (_STD is_constant_evaluated()) {

  00010	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00015	0f b6 c0	 movzx	 eax, al
  00018	85 c0		 test	 eax, eax
  0001a	74 30		 je	 SHORT $LN2@Construct_

; 154  :         _STD construct_at(_STD addressof(_Obj), _STD forward<_Types>(_Args)...);

  0001c	8b 4d 0c	 mov	 ecx, DWORD PTR _<_Args_0>$[ebp]
  0001f	51		 push	 ecx
  00020	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00025	83 c4 04	 add	 esp, 4
  00028	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  0002b	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0002e	52		 push	 edx
  0002f	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  0003a	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0003d	50		 push	 eax
  0003e	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00041	51		 push	 ecx
  00042	e8 00 00 00 00	 call	 ??$construct_at@U_Container_proxy@std@@PAU_Container_base12@2@X@std@@YAPAU_Container_proxy@0@QAU10@$$QAPAU_Container_base12@0@@Z ; std::construct_at<std::_Container_proxy,std::_Container_base12 *,void>
  00047	83 c4 08	 add	 esp, 8

; 155  :     } else

  0004a	eb 7b		 jmp	 SHORT $LN4@Construct_
$LN2@Construct_:

; 151  :     is_nothrow_constructible_v<_Ty, _Types...>) {

  0004c	8b 55 08	 mov	 edx, DWORD PTR __Obj$[ebp]
  0004f	52		 push	 edx
  00050	e8 00 00 00 00	 call	 ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
  00055	83 c4 04	 add	 esp, 4
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ??$_Voidify_iter@PAU_Container_proxy@std@@@std@@YAPAXPAU_Container_proxy@0@@Z ; std::_Voidify_iter<std::_Container_proxy *>
  0005e	83 c4 04	 add	 esp, 4
  00061	50		 push	 eax
  00062	6a 08		 push	 8
  00064	e8 00 00 00 00	 call	 ??2@YAPAXIPAX@Z		; operator new
  00069	83 c4 08	 add	 esp, 8
  0006c	89 45 e4	 mov	 DWORD PTR $T1[ebp], eax
  0006f	8b 45 0c	 mov	 eax, DWORD PTR _<_Args_0>$[ebp]
  00072	50		 push	 eax
  00073	e8 00 00 00 00	 call	 ??$forward@PAU_Container_base12@std@@@std@@YA$$QAPAU_Container_base12@0@AAPAU10@@Z ; std::forward<std::_Container_base12 *>
  00078	83 c4 04	 add	 esp, 4
  0007b	89 45 f4	 mov	 DWORD PTR tv89[ebp], eax
  0007e	8b 4d f4	 mov	 ecx, DWORD PTR tv89[ebp]
  00081	89 4d f8	 mov	 DWORD PTR tv128[ebp], ecx
  00084	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00087	c1 ea 03	 shr	 edx, 3
  0008a	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00090	88 45 ff	 mov	 BYTE PTR tv131[ebp], al
  00093	80 7d ff 00	 cmp	 BYTE PTR tv131[ebp], 0
  00097	74 1a		 je	 SHORT $LN5@Construct_
  00099	8a 4d f8	 mov	 cl, BYTE PTR tv128[ebp]
  0009c	80 e1 07	 and	 cl, 7
  0009f	80 c1 03	 add	 cl, 3
  000a2	3a 4d ff	 cmp	 cl, BYTE PTR tv131[ebp]
  000a5	7c 0c		 jl	 SHORT $LN5@Construct_
  000a7	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  000aa	52		 push	 edx
  000ab	e8 00 00 00 00	 call	 ___asan_report_load4
  000b0	83 c4 04	 add	 esp, 4
$LN5@Construct_:
  000b3	8b 45 f4	 mov	 eax, DWORD PTR tv89[ebp]
  000b6	8b 08		 mov	 ecx, DWORD PTR [eax]
  000b8	89 4d e8	 mov	 DWORD PTR tv93[ebp], ecx
  000bb	8b 55 e8	 mov	 edx, DWORD PTR tv93[ebp]
  000be	52		 push	 edx
  000bf	8b 4d e4	 mov	 ecx, DWORD PTR $T1[ebp]
  000c2	e8 00 00 00 00	 call	 ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ; std::_Container_proxy::_Container_proxy
$LN4@Construct_:

; 156  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 157  :     {
; 158  :         ::new (_Voidify_iter(_STD addressof(_Obj))) _Ty(_STD forward<_Types>(_Args)...);
; 159  :     }
; 160  : }

  000c7	8b e5		 mov	 esp, ebp
  000c9	5d		 pop	 ebp
  000ca	c3		 ret	 0
??$_Construct_in_place@U_Container_proxy@std@@PAU_Container_base12@2@@std@@YAXAAU_Container_proxy@0@$$QAPAU_Container_base12@0@@Z ENDP ; std::_Construct_in_place<std::_Container_proxy,std::_Container_base12 *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xstddef
;	COMDAT ??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z PROC ; std::addressof<std::_Container_base12>, COMDAT

; 274  : _NODISCARD constexpr _Ty* addressof(_Ty& _Val) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __E458E21C_xstddef
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 275  :     return __builtin_addressof(_Val);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]

; 276  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$addressof@U_Container_base12@std@@@std@@YAPAU_Container_base12@0@AAU10@@Z ENDP ; std::addressof<std::_Container_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Basic_container_proxy_ptr12@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Basic_container_proxy_ptr12@std@@IAE@XZ PROC	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12, COMDAT
; _this$ = ecx

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1316 :     _Container_proxy* _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Basic_cont
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Basic_cont
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Basic_cont:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1323 :     _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Basic_container_proxy_ptr12@std@@IAE@XZ ENDP	; std::_Basic_container_proxy_ptr12::_Basic_container_proxy_ptr12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ PROC	; std::_Basic_container_proxy_ptr12::_Release, COMDAT
; _this$ = ecx

; 1318 :     constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1319 :         _Ptr = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Release
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Release
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Release:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1320 :     }

  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
?_Release@_Basic_container_proxy_ptr12@std@@QAEXXZ ENDP	; std::_Basic_container_proxy_ptr12::_Release
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1095 :     void _Orphan_all_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1096 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1097 :         _Orphan_all_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1098 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv89 = -100						; size = 4
tv86 = -96						; size = 4
tv83 = -92						; size = 4
tv78 = -88						; size = 4
tv72 = -84						; size = 4
tv71 = -80						; size = 4
tv70 = -76						; size = 4
tv68 = -72						; size = 4
tv66 = -68						; size = 4
tv64 = -64						; size = 4
tv130 = -60						; size = 4
tv140 = -56						; size = 4
_this$ = -52						; size = 4
tv150 = -48						; size = 4
tv160 = -44						; size = 4
tv170 = -40						; size = 4
tv180 = -36						; size = 4
tv190 = -32						; size = 4
tv200 = -28						; size = 4
tv210 = -24						; size = 4
tv220 = -20						; size = 4
__Pnext$1 = -16						; size = 4
tv133 = -10						; size = 1
tv143 = -9						; size = 1
tv153 = -8						; size = 1
tv163 = -7						; size = 1
tv173 = -6						; size = 1
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 :     if (!_Myproxy) { // no proxy, already done

  00013	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv220[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_all
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv220[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_all
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_all:
  0004e	8b 45 c0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN5@Orphan_all

; 1239 :         return;

  00056	e9 58 02 00 00	 jmp	 $LN6@Orphan_all
$LN5@Orphan_all:

; 1240 :     }
; 1241 : 
; 1242 :     // proxy allocated, drain it
; 1243 :     for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { // TRANSITION, VSO-1269037

  0005b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e8	 mov	 DWORD PTR tv210[ebp], edx
  00067	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv213[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  0007a	74 1a		 je	 SHORT $LN15@Orphan_all
  0007c	8a 55 e8	 mov	 dl, BYTE PTR tv210[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv213[ebp]
  00088	7c 0c		 jl	 SHORT $LN15@Orphan_all
  0008a	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN15@Orphan_all:
  00096	8b 4d bc	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$1[ebp], edx
  000a1	e9 c0 00 00 00	 jmp	 $LN4@Orphan_all
$LN2@Orphan_all:
  000a6	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000a9	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  000ac	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  000af	89 4d e4	 mov	 DWORD PTR tv200[ebp], ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000b5	c1 ea 03	 shr	 edx, 3
  000b8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000be	88 45 fd	 mov	 BYTE PTR tv203[ebp], al
  000c1	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  000c5	74 1a		 je	 SHORT $LN14@Orphan_all
  000c7	8a 4d e4	 mov	 cl, BYTE PTR tv200[ebp]
  000ca	80 e1 07	 and	 cl, 7
  000cd	80 c1 03	 add	 cl, 3
  000d0	3a 4d fd	 cmp	 cl, BYTE PTR tv203[ebp]
  000d3	7c 0c		 jl	 SHORT $LN14@Orphan_all
  000d5	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ___asan_report_load4
  000de	83 c4 04	 add	 esp, 4
$LN14@Orphan_all:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	83 c1 04	 add	 ecx, 4
  000e9	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  000ec	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  000ef	89 55 e0	 mov	 DWORD PTR tv190[ebp], edx
  000f2	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  000f5	c1 e8 03	 shr	 eax, 3
  000f8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000fe	88 4d fc	 mov	 BYTE PTR tv193[ebp], cl
  00101	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  00105	74 1a		 je	 SHORT $LN13@Orphan_all
  00107	8a 55 e0	 mov	 dl, BYTE PTR tv190[ebp]
  0010a	80 e2 07	 and	 dl, 7
  0010d	80 c2 03	 add	 dl, 3
  00110	3a 55 fc	 cmp	 dl, BYTE PTR tv193[ebp]
  00113	7c 0c		 jl	 SHORT $LN13@Orphan_all
  00115	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ___asan_report_load4
  0011e	83 c4 04	 add	 esp, 4
$LN13@Orphan_all:
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00124	89 4d a4	 mov	 DWORD PTR tv83[ebp], ecx
  00127	8b 55 a4	 mov	 edx, DWORD PTR tv83[ebp]
  0012a	89 55 dc	 mov	 DWORD PTR tv180[ebp], edx
  0012d	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00130	c1 e8 03	 shr	 eax, 3
  00133	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00139	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  0013c	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00140	74 1a		 je	 SHORT $LN12@Orphan_all
  00142	8a 55 dc	 mov	 dl, BYTE PTR tv180[ebp]
  00145	80 e2 07	 and	 dl, 7
  00148	80 c2 03	 add	 dl, 3
  0014b	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  0014e	7c 0c		 jl	 SHORT $LN12@Orphan_all
  00150	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ___asan_report_store4
  00159	83 c4 04	 add	 esp, 4
$LN12@Orphan_all:
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  0015f	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  00162	8b 02		 mov	 eax, DWORD PTR [edx]
  00164	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Orphan_all:
  00166	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00169	89 4d a0	 mov	 DWORD PTR tv86[ebp], ecx
  0016c	8b 55 a0	 mov	 edx, DWORD PTR tv86[ebp]
  0016f	89 55 d8	 mov	 DWORD PTR tv170[ebp], edx
  00172	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00175	c1 e8 03	 shr	 eax, 3
  00178	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0017e	88 4d fa	 mov	 BYTE PTR tv173[ebp], cl
  00181	80 7d fa 00	 cmp	 BYTE PTR tv173[ebp], 0
  00185	74 1a		 je	 SHORT $LN11@Orphan_all
  00187	8a 55 d8	 mov	 dl, BYTE PTR tv170[ebp]
  0018a	80 e2 07	 and	 dl, 7
  0018d	80 c2 03	 add	 dl, 3
  00190	3a 55 fa	 cmp	 dl, BYTE PTR tv173[ebp]
  00193	7c 0c		 jl	 SHORT $LN11@Orphan_all
  00195	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ___asan_report_load4
  0019e	83 c4 04	 add	 esp, 4
$LN11@Orphan_all:
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  001a4	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001a7	0f 84 84 00 00
	00		 je	 $LN3@Orphan_all

; 1244 :         _Pnext->_Myproxy = nullptr;

  001ad	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001b0	89 55 9c	 mov	 DWORD PTR tv89[ebp], edx
  001b3	8b 45 9c	 mov	 eax, DWORD PTR tv89[ebp]
  001b6	89 45 d4	 mov	 DWORD PTR tv160[ebp], eax
  001b9	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001bc	c1 e9 03	 shr	 ecx, 3
  001bf	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001c5	88 55 f9	 mov	 BYTE PTR tv163[ebp], dl
  001c8	80 7d f9 00	 cmp	 BYTE PTR tv163[ebp], 0
  001cc	74 18		 je	 SHORT $LN10@Orphan_all
  001ce	8a 45 d4	 mov	 al, BYTE PTR tv160[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 45 f9	 cmp	 al, BYTE PTR tv163[ebp]
  001d8	7c 0c		 jl	 SHORT $LN10@Orphan_all
  001da	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ___asan_report_load4
  001e3	83 c4 04	 add	 esp, 4
$LN10@Orphan_all:
  001e6	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001e9	8b 02		 mov	 eax, DWORD PTR [edx]
  001eb	89 45 b4	 mov	 DWORD PTR tv70[ebp], eax
  001ee	8b 4d b4	 mov	 ecx, DWORD PTR tv70[ebp]
  001f1	89 4d d0	 mov	 DWORD PTR tv150[ebp], ecx
  001f4	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  001f7	c1 ea 03	 shr	 edx, 3
  001fa	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00200	88 45 f8	 mov	 BYTE PTR tv153[ebp], al
  00203	80 7d f8 00	 cmp	 BYTE PTR tv153[ebp], 0
  00207	74 1a		 je	 SHORT $LN9@Orphan_all
  00209	8a 4d d0	 mov	 cl, BYTE PTR tv150[ebp]
  0020c	80 e1 07	 and	 cl, 7
  0020f	80 c1 03	 add	 cl, 3
  00212	3a 4d f8	 cmp	 cl, BYTE PTR tv153[ebp]
  00215	7c 0c		 jl	 SHORT $LN9@Orphan_all
  00217	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ___asan_report_store4
  00220	83 c4 04	 add	 esp, 4
$LN9@Orphan_all:
  00223	8b 45 b4	 mov	 eax, DWORD PTR tv70[ebp]
  00226	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1245 :     }

  0022c	e9 75 fe ff ff	 jmp	 $LN2@Orphan_all
$LN3@Orphan_all:

; 1246 :     _Myproxy->_Myfirstiter = nullptr;

  00231	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	89 4d b0	 mov	 DWORD PTR tv71[ebp], ecx
  00237	8b 55 b0	 mov	 edx, DWORD PTR tv71[ebp]
  0023a	89 55 c8	 mov	 DWORD PTR tv140[ebp], edx
  0023d	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00240	c1 e8 03	 shr	 eax, 3
  00243	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00249	88 4d f7	 mov	 BYTE PTR tv143[ebp], cl
  0024c	80 7d f7 00	 cmp	 BYTE PTR tv143[ebp], 0
  00250	74 1a		 je	 SHORT $LN8@Orphan_all
  00252	8a 55 c8	 mov	 dl, BYTE PTR tv140[ebp]
  00255	80 e2 07	 and	 dl, 7
  00258	80 c2 03	 add	 dl, 3
  0025b	3a 55 f7	 cmp	 dl, BYTE PTR tv143[ebp]
  0025e	7c 0c		 jl	 SHORT $LN8@Orphan_all
  00260	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ___asan_report_load4
  00269	83 c4 04	 add	 esp, 4
$LN8@Orphan_all:
  0026c	8b 4d b0	 mov	 ecx, DWORD PTR tv71[ebp]
  0026f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00271	83 c2 04	 add	 edx, 4
  00274	89 55 ac	 mov	 DWORD PTR tv72[ebp], edx
  00277	8b 45 ac	 mov	 eax, DWORD PTR tv72[ebp]
  0027a	89 45 c4	 mov	 DWORD PTR tv130[ebp], eax
  0027d	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  00280	c1 e9 03	 shr	 ecx, 3
  00283	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00289	88 55 f6	 mov	 BYTE PTR tv133[ebp], dl
  0028c	80 7d f6 00	 cmp	 BYTE PTR tv133[ebp], 0
  00290	74 18		 je	 SHORT $LN7@Orphan_all
  00292	8a 45 c4	 mov	 al, BYTE PTR tv130[ebp]
  00295	24 07		 and	 al, 7
  00297	04 03		 add	 al, 3
  00299	3a 45 f6	 cmp	 al, BYTE PTR tv133[ebp]
  0029c	7c 0c		 jl	 SHORT $LN7@Orphan_all
  0029e	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 ___asan_report_store4
  002a7	83 c4 04	 add	 esp, 4
$LN7@Orphan_all:
  002aa	8b 55 ac	 mov	 edx, DWORD PTR tv72[ebp]
  002ad	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Orphan_all:

; 1247 : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1250 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1251 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1252 :     if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Orphan_all

; 1253 :         _Orphan_all_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1254 :     } else

  00025	eb 08		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 1255 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1256 :     {
; 1257 :         _Orphan_all_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN4@Orphan_all:

; 1258 :     }
; 1259 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1260 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv68 = -8						; size = 4
tv71 = -1						; size = 1
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1065 : 
; 1066 :     _Container_base12(const _Container_base12&) = delete;
; 1067 :     _Container_base12& operator=(const _Container_base12&) = delete;
; 1068 : 
; 1069 :     _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept;
; 1070 :     _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base12&) noexcept;
; 1071 : 
; 1072 :     template <class _Alloc>
; 1073 :     _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&& _Al) {
; 1074 :         _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
; 1075 :         _Construct_in_place(*_New_proxy, this);
; 1076 :         _Myproxy            = _New_proxy;
; 1077 :         _New_proxy->_Mycont = this;
; 1078 :     }
; 1079 : 
; 1080 :     template <class _Alloc>
; 1081 :     _CONSTEXPR20_CONTAINER void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc) {
; 1082 :         // pre: no iterators refer to the existing proxy
; 1083 :         _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
; 1084 :         _Construct_in_place(*_New_proxy, this);
; 1085 :         _New_proxy->_Mycont = this;
; 1086 :         _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
; 1087 :     }
; 1088 : 
; 1089 :     _Container_proxy* _Myproxy = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv68[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv71[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv71[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv68[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv71[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv68[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@Container_:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1064 :     _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;

  00057	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
__Mycont_$ = 8						; size = 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z PROC ; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Container_
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Container_
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Container_:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	8b 4d 08	 mov	 ecx, DWORD PTR __Mycont_$[ebp]
  00054	89 08		 mov	 DWORD PTR [eax], ecx

; 1057 : 
; 1058 :     const _Container_base12* _Mycont       = nullptr;
; 1059 :     mutable _Iterator_base12* _Myfirstiter = nullptr;

  00056	8b 55 f0	 mov	 edx, DWORD PTR _this$[ebp]
  00059	83 c2 04	 add	 edx, 4
  0005c	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  0005f	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00062	89 45 f4	 mov	 DWORD PTR tv71[ebp], eax
  00065	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00068	c1 e9 03	 shr	 ecx, 3
  0006b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00071	88 55 fe	 mov	 BYTE PTR tv74[ebp], dl
  00074	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00078	74 18		 je	 SHORT $LN3@Container_
  0007a	8a 45 f4	 mov	 al, BYTE PTR tv71[ebp]
  0007d	24 07		 and	 al, 7
  0007f	04 03		 add	 al, 3
  00081	3a 45 fe	 cmp	 al, BYTE PTR tv74[ebp]
  00084	7c 0c		 jl	 SHORT $LN3@Container_
  00086	8b 4d f4	 mov	 ecx, DWORD PTR tv71[ebp]
  00089	51		 push	 ecx
  0008a	e8 00 00 00 00	 call	 ___asan_report_store4
  0008f	83 c4 04	 add	 esp, 4
$LN3@Container_:
  00092	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00095	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1056 :     _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}

  0009b	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  0009e	8b e5		 mov	 esp, ebp
  000a0	5d		 pop	 ebp
  000a1	c2 04 00	 ret	 4
??0_Container_proxy@std@@QAE@PAU_Container_base12@1@@Z ENDP ; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Convert_size@I@std@@YAII@Z
_TEXT	SEGMENT
__Len$ = 8						; size = 4
??$_Convert_size@I@std@@YAII@Z PROC			; std::_Convert_size<unsigned int>, COMDAT

; 978  : _NODISCARD constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 979  :     // convert size_t to size_t, unchanged
; 980  :     return _Len;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Len$[ebp]

; 981  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Convert_size@I@std@@YAII@Z ENDP			; std::_Convert_size<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -84					; size = 4
tv154 = -80						; size = 4
tv151 = -76						; size = 4
tv144 = -72						; size = 4
tv64 = -68						; size = 4
tv141 = -64						; size = 4
tv138 = -60						; size = 4
__Ptr_container$ = -56					; size = 4
__Back_shift$ = -52					; size = 4
tv68 = -48						; size = 4
__Ptr_user$ = -44					; size = 4
tv66 = -40						; size = 4
tv157 = -36						; size = 4
tv167 = -32						; size = 4
tv177 = -28						; size = 4
tv187 = -24						; size = 4
tv197 = -20						; size = 4
tv207 = -16						; size = 4
tv217 = -12						; size = 4
tv160 = -7						; size = 1
tv170 = -6						; size = 1
tv180 = -5						; size = 1
tv190 = -4						; size = 1
tv200 = -3						; size = 1
tv210 = -2						; size = 1
tv220 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 153  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 154  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 155  :     _Bytes += _Non_user_size;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	89 45 c4	 mov	 DWORD PTR tv138[ebp], eax
  00016	8b 4d c4	 mov	 ecx, DWORD PTR tv138[ebp]
  00019	89 4d f4	 mov	 DWORD PTR tv217[ebp], ecx
  0001c	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv220[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv220[ebp], 0
  0002f	74 1a		 je	 SHORT $LN27@Adjust_man
  00031	8a 4d f4	 mov	 cl, BYTE PTR tv217[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv220[ebp]
  0003d	7c 0c		 jl	 SHORT $LN27@Adjust_man
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN27@Adjust_man:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	83 c1 27	 add	 ecx, 39			; 00000027H
  00053	89 4d bc	 mov	 DWORD PTR tv64[ebp], ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00059	89 55 c0	 mov	 DWORD PTR tv141[ebp], edx
  0005c	8b 45 c0	 mov	 eax, DWORD PTR tv141[ebp]
  0005f	89 45 f0	 mov	 DWORD PTR tv207[ebp], eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006e	88 55 fe	 mov	 BYTE PTR tv210[ebp], dl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv210[ebp], 0
  00075	74 18		 je	 SHORT $LN26@Adjust_man
  00077	8a 45 f0	 mov	 al, BYTE PTR tv207[ebp]
  0007a	24 07		 and	 al, 7
  0007c	04 03		 add	 al, 3
  0007e	3a 45 fe	 cmp	 al, BYTE PTR tv210[ebp]
  00081	7c 0c		 jl	 SHORT $LN26@Adjust_man
  00083	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN26@Adjust_man:
  0008f	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00092	8b 45 bc	 mov	 eax, DWORD PTR tv64[ebp]
  00095	89 02		 mov	 DWORD PTR [edx], eax

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009a	89 4d b8	 mov	 DWORD PTR tv144[ebp], ecx
  0009d	8b 55 b8	 mov	 edx, DWORD PTR tv144[ebp]
  000a0	89 55 ec	 mov	 DWORD PTR tv197[ebp], edx
  000a3	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000a6	c1 e8 03	 shr	 eax, 3
  000a9	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000af	88 4d fd	 mov	 BYTE PTR tv200[ebp], cl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv200[ebp], 0
  000b6	74 1a		 je	 SHORT $LN25@Adjust_man
  000b8	8a 55 ec	 mov	 dl, BYTE PTR tv197[ebp]
  000bb	80 e2 07	 and	 dl, 7
  000be	80 c2 03	 add	 dl, 3
  000c1	3a 55 fd	 cmp	 dl, BYTE PTR tv200[ebp]
  000c4	7c 0c		 jl	 SHORT $LN25@Adjust_man
  000c6	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ___asan_report_load4
  000cf	83 c4 04	 add	 esp, 4
$LN25@Adjust_man:
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d7	89 55 d4	 mov	 DWORD PTR __Ptr_user$[ebp], edx

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000da	b8 04 00 00 00	 mov	 eax, 4
  000df	6b c8 ff	 imul	 ecx, eax, -1
  000e2	8b 55 d4	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  000e5	03 d1		 add	 edx, ecx
  000e7	89 55 d8	 mov	 DWORD PTR tv66[ebp], edx
  000ea	8b 45 d8	 mov	 eax, DWORD PTR tv66[ebp]
  000ed	89 45 e8	 mov	 DWORD PTR tv187[ebp], eax
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  000f3	c1 e9 03	 shr	 ecx, 3
  000f6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000fc	88 55 fc	 mov	 BYTE PTR tv190[ebp], dl
  000ff	80 7d fc 00	 cmp	 BYTE PTR tv190[ebp], 0
  00103	74 18		 je	 SHORT $LN24@Adjust_man
  00105	8a 45 e8	 mov	 al, BYTE PTR tv187[ebp]
  00108	24 07		 and	 al, 7
  0010a	04 03		 add	 al, 3
  0010c	3a 45 fc	 cmp	 al, BYTE PTR tv190[ebp]
  0010f	7c 0c		 jl	 SHORT $LN24@Adjust_man
  00111	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ___asan_report_load4
  0011a	83 c4 04	 add	 esp, 4
$LN24@Adjust_man:
  0011d	8b 55 d8	 mov	 edx, DWORD PTR tv66[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	89 45 c8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00125	b9 04 00 00 00	 mov	 ecx, 4
  0012a	6b d1 fe	 imul	 edx, ecx, -2
  0012d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_user$[ebp]
  00130	03 c2		 add	 eax, edx
  00132	89 45 d0	 mov	 DWORD PTR tv68[ebp], eax
  00135	8b 4d d0	 mov	 ecx, DWORD PTR tv68[ebp]
  00138	89 4d e4	 mov	 DWORD PTR tv177[ebp], ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  0013e	c1 ea 03	 shr	 edx, 3
  00141	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00147	88 45 fb	 mov	 BYTE PTR tv180[ebp], al
  0014a	80 7d fb 00	 cmp	 BYTE PTR tv180[ebp], 0
  0014e	74 1a		 je	 SHORT $LN23@Adjust_man
  00150	8a 4d e4	 mov	 cl, BYTE PTR tv177[ebp]
  00153	80 e1 07	 and	 cl, 7
  00156	80 c1 03	 add	 cl, 3
  00159	3a 4d fb	 cmp	 cl, BYTE PTR tv180[ebp]
  0015c	7c 0c		 jl	 SHORT $LN23@Adjust_man
  0015e	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN23@Adjust_man:
  0016a	8b 45 d0	 mov	 eax, DWORD PTR tv68[ebp]
  0016d	81 38 fa fa fa
	fa		 cmp	 DWORD PTR [eax], -84215046 ; fafafafaH
  00173	75 02		 jne	 SHORT $LN7@Adjust_man
  00175	eb 4a		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00181	6a 00		 push	 0
  00183	68 a2 00 00 00	 push	 162			; 000000a2H
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0018d	6a 02		 push	 2
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00195	83 c4 18	 add	 esp, 24			; 00000018H
  00198	83 f8 01	 cmp	 eax, 1
  0019b	75 01		 jne	 SHORT $LN19@Adjust_man
  0019d	cc		 int	 3
$LN19@Adjust_man:
  0019e	6a 00		 push	 0
  001a0	68 a2 00 00 00	 push	 162			; 000000a2H
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001ba	83 c4 14	 add	 esp, 20			; 00000014H
  001bd	33 d2		 xor	 edx, edx
  001bf	75 b6		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  001c1	33 c0		 xor	 eax, eax
  001c3	0f 85 5c ff ff
	ff		 jne	 $LN4@Adjust_man

; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  001c9	c7 45 ac 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  001d3	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  001d6	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  001d9	89 55 e0	 mov	 DWORD PTR tv167[ebp], edx
  001dc	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  001df	c1 e8 03	 shr	 eax, 3
  001e2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e8	88 4d fa	 mov	 BYTE PTR tv170[ebp], cl
  001eb	80 7d fa 00	 cmp	 BYTE PTR tv170[ebp], 0
  001ef	74 1a		 je	 SHORT $LN22@Adjust_man
  001f1	8a 55 e0	 mov	 dl, BYTE PTR tv167[ebp]
  001f4	80 e2 07	 and	 dl, 7
  001f7	80 c2 03	 add	 dl, 3
  001fa	3a 55 fa	 cmp	 dl, BYTE PTR tv170[ebp]
  001fd	7c 0c		 jl	 SHORT $LN22@Adjust_man
  001ff	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ___asan_report_load4
  00208	83 c4 04	 add	 esp, 4
$LN22@Adjust_man:
  0020b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	2b 55 c8	 sub	 edx, DWORD PTR __Ptr_container$[ebp]
  00213	89 55 cc	 mov	 DWORD PTR __Back_shift$[ebp], edx
$LN10@Adjust_man:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00216	83 7d cc 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  0021a	72 08		 jb	 SHORT $LN13@Adjust_man
  0021c	83 7d cc 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  00220	77 02		 ja	 SHORT $LN13@Adjust_man
  00222	eb 4a		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0022e	6a 00		 push	 0
  00230	68 ac 00 00 00	 push	 172			; 000000acH
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0023a	6a 02		 push	 2
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00242	83 c4 18	 add	 esp, 24			; 00000018H
  00245	83 f8 01	 cmp	 eax, 1
  00248	75 01		 jne	 SHORT $LN20@Adjust_man
  0024a	cc		 int	 3
$LN20@Adjust_man:
  0024b	6a 00		 push	 0
  0024d	68 ac 00 00 00	 push	 172			; 000000acH
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00267	83 c4 14	 add	 esp, 20			; 00000014H
  0026a	33 c9		 xor	 ecx, ecx
  0026c	75 b6		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0026e	33 d2		 xor	 edx, edx
  00270	75 a4		 jne	 SHORT $LN10@Adjust_man

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00272	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00275	89 45 b0	 mov	 DWORD PTR tv154[ebp], eax
  00278	8b 4d b0	 mov	 ecx, DWORD PTR tv154[ebp]
  0027b	89 4d dc	 mov	 DWORD PTR tv157[ebp], ecx
  0027e	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  00281	c1 ea 03	 shr	 edx, 3
  00284	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0028a	88 45 f9	 mov	 BYTE PTR tv160[ebp], al
  0028d	80 7d f9 00	 cmp	 BYTE PTR tv160[ebp], 0
  00291	74 1a		 je	 SHORT $LN21@Adjust_man
  00293	8a 4d dc	 mov	 cl, BYTE PTR tv157[ebp]
  00296	80 e1 07	 and	 cl, 7
  00299	80 c1 03	 add	 cl, 3
  0029c	3a 4d f9	 cmp	 cl, BYTE PTR tv160[ebp]
  0029f	7c 0c		 jl	 SHORT $LN21@Adjust_man
  002a1	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 ___asan_report_store4
  002aa	83 c4 04	 add	 esp, 4
$LN21@Adjust_man:
  002ad	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  002b0	8b 4d c8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  002b3	89 08		 mov	 DWORD PTR [eax], ecx

; 174  : }

  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z
_TEXT	SEGMENT
__Bytes$ = 8						; size = 4
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z PROC	; std::_Default_allocate_traits::_Allocate, COMDAT

; 84   :         void* _Allocate(const size_t _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 85   :         return ::operator new(_Bytes);

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00010	50		 push	 eax
  00011	e8 00 00 00 00	 call	 ??2@YAPAXI@Z		; operator new
  00016	83 c4 04	 add	 esp, 4

; 86   :     }

  00019	5d		 pop	 ebp
  0001a	c3		 ret	 0
?_Allocate@_Default_allocate_traits@std@@SAPAXI@Z ENDP	; std::_Default_allocate_traits::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\exception
;	COMDAT ?_Throw_bad_array_new_length@std@@YAXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
$T2 = -64						; size = 12
tv70 = -12						; size = 4
tv68 = -8						; size = 4
tv73 = -4						; size = 4
?_Throw_bad_array_new_length@std@@YAXXZ PROC		; std::_Throw_bad_array_new_length, COMDAT

; 320  : [[noreturn]] inline void _Throw_bad_array_new_length() {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00020	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Throw_bad_array_new_length@std@@YAXXZ
  00027	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Throw_bad_array_new_length@std@@YAXXZ ; std::_Throw_bad_array_new_length
  0002e	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00031	89 45 f8	 mov	 DWORD PTR tv68[ebp], eax
  00034	8b 4d f8	 mov	 ecx, DWORD PTR tv68[ebp]
  00037	c1 e9 03	 shr	 ecx, 3
  0003a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00040	89 4d f4	 mov	 DWORD PTR tv70[ebp], ecx
  00043	8b 55 f4	 mov	 edx, DWORD PTR tv70[ebp]
  00046	c7 02 f1 f1 00
	04		 mov	 DWORD PTR [edx], 67170801 ; 0400f1f1H
  0004c	83 45 f4 04	 add	 DWORD PTR tv70[ebp], 4
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv70[ebp]
  00053	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00059	b9 00 00 00 00	 mov	 ecx, OFFSET __FF458F76_exception
  0005e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 321  :     _THROW(bad_array_new_length{});

  00063	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00066	e8 00 00 00 00	 call	 ??0bad_array_new_length@std@@QAE@XZ ; std::bad_array_new_length::bad_array_new_length
  0006b	68 00 00 00 00	 push	 OFFSET __TI3?AVbad_array_new_length@std@@
  00070	8d 4d c0	 lea	 ecx, DWORD PTR $T2[ebp]
  00073	51		 push	 ecx
  00074	e8 00 00 00 00	 call	 __CxxThrowException@8
$LN2@Throw_bad_:

; 322  : }

  00079	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00080	8d 55 b0	 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  0008c	89 55 fc	 mov	 DWORD PTR tv73[ebp], edx
  0008f	6a 08		 push	 8
  00091	8b 45 fc	 mov	 eax, DWORD PTR tv73[ebp]
  00094	50		 push	 eax
  00095	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0009a	83 c4 08	 add	 esp, 8
  0009d	8b e5		 mov	 esp, ebp
  0009f	5d		 pop	 ebp
  000a0	8b e3		 mov	 esp, ebx
  000a2	5b		 pop	 ebx
  000a3	c3		 ret	 0
?_Throw_bad_array_new_length@std@@YAXXZ ENDP		; std::_Throw_bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_array_new_length@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_array_new_length@std@@UAEPAXI@Z PROC		; std::bad_array_new_length::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_array_new_length@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_array_new_length@std@@UAEPAXI@Z ENDP		; std::bad_array_new_length::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_array_new_length@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_array_new_length@std@@QAE@ABV01@@Z PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0bad_alloc@std@@QAE@ABV01@@Z
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_array_
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_array_
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_array_new_length@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_array_new_length@std@@QAE@ABV01@@Z ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_array_new_length@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_array_new_length@std@@UAE@XZ PROC		; std::bad_array_new_length::~bad_array_new_length, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_array_new_length@std@@UAE@XZ ENDP		; std::bad_array_new_length::~bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_array_new_length@std@@QAE@XZ
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv84 = -12						; size = 4
_this$ = -8						; size = 4
tv87 = -1						; size = 1
??0bad_array_new_length@std@@QAE@XZ PROC		; std::bad_array_new_length::bad_array_new_length, COMDAT
; _this$ = ecx

; 141  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 140  :         : bad_alloc("bad array new length")

  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@KINCDENJ@bad?5array?5new?5length@
  00018	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001b	e8 00 00 00 00	 call	 ??0bad_alloc@std@@AAE@QBD@Z ; std::bad_alloc::bad_alloc

; 141  :     {

  00020	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00023	89 45 f0	 mov	 DWORD PTR tv69[ebp], eax
  00026	8b 4d f0	 mov	 ecx, DWORD PTR tv69[ebp]
  00029	89 4d f4	 mov	 DWORD PTR tv84[ebp], ecx
  0002c	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  0002f	c1 ea 03	 shr	 edx, 3
  00032	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00038	88 45 ff	 mov	 BYTE PTR tv87[ebp], al
  0003b	80 7d ff 00	 cmp	 BYTE PTR tv87[ebp], 0
  0003f	74 1a		 je	 SHORT $LN3@bad_array_
  00041	8a 4d f4	 mov	 cl, BYTE PTR tv84[ebp]
  00044	80 e1 07	 and	 cl, 7
  00047	80 c1 03	 add	 cl, 3
  0004a	3a 4d ff	 cmp	 cl, BYTE PTR tv87[ebp]
  0004d	7c 0c		 jl	 SHORT $LN3@bad_array_
  0004f	8b 55 f4	 mov	 edx, DWORD PTR tv84[ebp]
  00052	52		 push	 edx
  00053	e8 00 00 00 00	 call	 ___asan_report_store4
  00058	83 c4 04	 add	 esp, 4
$LN3@bad_array_:
  0005b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7bad_array_new_length@std@@6B@

; 142  :     }

  00064	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
??0bad_array_new_length@std@@QAE@XZ ENDP		; std::bad_array_new_length::bad_array_new_length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1bad_alloc@std@@UAE@XZ
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv87 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -1						; size = 1
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	8b 45 08	 mov	 eax, DWORD PTR ___that$[ebp]
  0000c	50		 push	 eax
  0000d	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	e8 00 00 00 00	 call	 ??0exception@std@@QAE@ABV01@@Z ; std::exception::exception
  00015	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  0001b	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0001e	89 55 f4	 mov	 DWORD PTR tv87[ebp], edx
  00021	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00024	c1 e8 03	 shr	 eax, 3
  00027	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0002d	88 4d ff	 mov	 BYTE PTR tv90[ebp], cl
  00030	80 7d ff 00	 cmp	 BYTE PTR tv90[ebp], 0
  00034	74 1a		 je	 SHORT $LN3@bad_alloc
  00036	8a 55 f4	 mov	 dl, BYTE PTR tv87[ebp]
  00039	80 e2 07	 and	 dl, 7
  0003c	80 c2 03	 add	 dl, 3
  0003f	3a 55 ff	 cmp	 dl, BYTE PTR tv90[ebp]
  00042	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00044	8b 45 f4	 mov	 eax, DWORD PTR tv87[ebp]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 ___asan_report_store4
  0004d	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  00050	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00053	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
  00059	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0005c	8b e5		 mov	 esp, ebp
  0005e	5d		 pop	 ebp
  0005f	c2 04 00	 ret	 4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0bad_alloc@std@@AAE@QBD@Z
_TEXT	SEGMENT
tv69 = -16						; size = 4
tv85 = -12						; size = 4
_this$ = -8						; size = 4
tv88 = -1						; size = 1
__Message$ = 8						; size = 4
??0bad_alloc@std@@AAE@QBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 130  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 129  :         : exception(_Message, 1)

  00013	6a 01		 push	 1
  00015	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  00018	50		 push	 eax
  00019	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ??0exception@std@@QAE@QBDH@Z ; std::exception::exception

; 130  :     {

  00021	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	89 4d f0	 mov	 DWORD PTR tv69[ebp], ecx
  00027	8b 55 f0	 mov	 edx, DWORD PTR tv69[ebp]
  0002a	89 55 f4	 mov	 DWORD PTR tv85[ebp], edx
  0002d	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00030	c1 e8 03	 shr	 eax, 3
  00033	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00039	88 4d ff	 mov	 BYTE PTR tv88[ebp], cl
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00040	74 1a		 je	 SHORT $LN3@bad_alloc
  00042	8a 55 f4	 mov	 dl, BYTE PTR tv85[ebp]
  00045	80 e2 07	 and	 dl, 7
  00048	80 c2 03	 add	 dl, 3
  0004b	3a 55 ff	 cmp	 dl, BYTE PTR tv88[ebp]
  0004e	7c 0c		 jl	 SHORT $LN3@bad_alloc
  00050	8b 45 f4	 mov	 eax, DWORD PTR tv85[ebp]
  00053	50		 push	 eax
  00054	e8 00 00 00 00	 call	 ___asan_report_store4
  00059	83 c4 04	 add	 esp, 4
$LN3@bad_alloc:
  0005c	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005f	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 131  :     }

  00065	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00068	8b e5		 mov	 esp, ebp
  0006a	5d		 pop	 ebp
  0006b	c2 04 00	 ret	 4
??0bad_alloc@std@@AAE@QBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1exception@std@@UAE@XZ ; std::exception::~exception
  0000f	8b 45 08	 mov	 eax, DWORD PTR ___flags$[ebp]
  00012	83 e0 01	 and	 eax, 1
  00015	74 0e		 je	 SHORT $LN2@scalar
  00017	6a 0c		 push	 12			; 0000000cH
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	51		 push	 ecx
  0001d	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00022	83 c4 08	 add	 esp, 8
$LN2@scalar:
  00025	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c2 04 00	 ret	 4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
tv69 = -28						; size = 4
tv67 = -24						; size = 4
_this$ = -20						; size = 4
tv65 = -16						; size = 4
tv75 = -12						; size = 4
tv85 = -8						; size = 4
tv78 = -2						; size = 1
tv88 = -1						; size = 1
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 94   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 1c	 sub	 esp, 28			; 0000001cH
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 95   :         return _Data._What ? _Data._What : "Unknown exception";

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  0001c	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv85[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv88[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv88[ebp], 0
  00035	74 1a		 je	 SHORT $LN6@what
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv85[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv88[ebp]
  00043	7c 0c		 jl	 SHORT $LN6@what
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv85[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN6@what:
  00051	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  00054	83 38 00	 cmp	 DWORD PTR [eax], 0
  00057	74 48		 je	 SHORT $LN3@what
  00059	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005c	83 c1 04	 add	 ecx, 4
  0005f	89 4d e8	 mov	 DWORD PTR tv67[ebp], ecx
  00062	8b 55 e8	 mov	 edx, DWORD PTR tv67[ebp]
  00065	89 55 f4	 mov	 DWORD PTR tv75[ebp], edx
  00068	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0006b	c1 e8 03	 shr	 eax, 3
  0006e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00074	88 4d fe	 mov	 BYTE PTR tv78[ebp], cl
  00077	80 7d fe 00	 cmp	 BYTE PTR tv78[ebp], 0
  0007b	74 1a		 je	 SHORT $LN5@what
  0007d	8a 55 f4	 mov	 dl, BYTE PTR tv75[ebp]
  00080	80 e2 07	 and	 dl, 7
  00083	80 c2 03	 add	 dl, 3
  00086	3a 55 fe	 cmp	 dl, BYTE PTR tv78[ebp]
  00089	7c 0c		 jl	 SHORT $LN5@what
  0008b	8b 45 f4	 mov	 eax, DWORD PTR tv75[ebp]
  0008e	50		 push	 eax
  0008f	e8 00 00 00 00	 call	 ___asan_report_load4
  00094	83 c4 04	 add	 esp, 4
$LN5@what:
  00097	8b 4d e8	 mov	 ecx, DWORD PTR tv67[ebp]
  0009a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009c	89 55 e4	 mov	 DWORD PTR tv69[ebp], edx
  0009f	eb 07		 jmp	 SHORT $LN4@what
$LN3@what:
  000a1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR tv69[ebp], OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception@
$LN4@what:
  000a8	8b 45 e4	 mov	 eax, DWORD PTR tv69[ebp]

; 96   :     }

  000ab	8b e5		 mov	 esp, ebp
  000ad	5d		 pop	 ebp
  000ae	c3		 ret	 0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv70 = -8						; size = 4
tv73 = -1						; size = 1
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 89   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv70[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv73[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv73[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv70[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv73[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv70[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 90   :         __std_exception_destroy(&_Data);

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	51		 push	 ecx
  0005e	e8 00 00 00 00	 call	 ___std_exception_destroy
  00063	83 c4 04	 add	 esp, 4

; 91   :     }

  00066	8b e5		 mov	 esp, ebp
  00068	5d		 pop	 ebp
  00069	c3		 ret	 0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv64 = -16						; size = 4
tv76 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -1						; size = 1
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 72   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv76[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv79[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv79[ebp], 0
  00032	74 1a		 je	 SHORT $LN3@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv76[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv79[ebp]
  00040	7c 0c		 jl	 SHORT $LN3@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv76[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN3@exception:
  0004e	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 71   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 73   :         __std_exception_copy(&_Other._Data, &_Data);

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	52		 push	 edx
  00071	8b 45 08	 mov	 eax, DWORD PTR __Other$[ebp]
  00074	83 c0 04	 add	 eax, 4
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 ___std_exception_copy
  0007d	83 c4 08	 add	 esp, 8

; 74   :     }

  00080	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c2 04 00	 ret	 4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBDH@Z
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
tv76 = -16						; size = 4
tv86 = -12						; size = 4
_this$ = -8						; size = 4
tv79 = -2						; size = 1
tv89 = -1						; size = 1
__Message$ = 8						; size = 4
___formal$ = 12						; size = 4
??0exception@std@@QAE@QBDH@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __B0A13A33_vcruntime_exception@h
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f4	 mov	 DWORD PTR tv86[ebp], ecx
  0001f	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv89[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv89[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@exception
  00034	8a 4d f4	 mov	 cl, BYTE PTR tv86[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv89[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@exception
  00042	8b 55 f4	 mov	 edx, DWORD PTR tv86[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@exception:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], OFFSET ??_7exception@std@@6B@

; 65   :         : _Data()

  00057	6a 08		 push	 8
  00059	6a 00		 push	 0
  0005b	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	83 c1 04	 add	 ecx, 4
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ___asan_memset
  00067	83 c4 0c	 add	 esp, 12			; 0000000cH

; 67   :         _Data._What = _Message;

  0006a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0006d	83 c2 04	 add	 edx, 4
  00070	89 55 e8	 mov	 DWORD PTR tv65[ebp], edx
  00073	8b 45 e8	 mov	 eax, DWORD PTR tv65[ebp]
  00076	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  00079	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0007c	c1 e9 03	 shr	 ecx, 3
  0007f	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00085	88 55 fe	 mov	 BYTE PTR tv79[ebp], dl
  00088	80 7d fe 00	 cmp	 BYTE PTR tv79[ebp], 0
  0008c	74 18		 je	 SHORT $LN3@exception
  0008e	8a 45 f0	 mov	 al, BYTE PTR tv76[ebp]
  00091	24 07		 and	 al, 7
  00093	04 03		 add	 al, 3
  00095	3a 45 fe	 cmp	 al, BYTE PTR tv79[ebp]
  00098	7c 0c		 jl	 SHORT $LN3@exception
  0009a	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  0009d	51		 push	 ecx
  0009e	e8 00 00 00 00	 call	 ___asan_report_store4
  000a3	83 c4 04	 add	 esp, 4
$LN3@exception:
  000a6	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  000a9	8b 45 08	 mov	 eax, DWORD PTR __Message$[ebp]
  000ac	89 02		 mov	 DWORD PTR [edx], eax

; 68   :     }

  000ae	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b1	8b e5		 mov	 esp, ebp
  000b3	5d		 pop	 ebp
  000b4	c2 08 00	 ret	 8
??0exception@std@@QAE@QBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 167  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __97D3638F_vcruntime_new@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 168  :         (void)_Size;
; 169  :         return _Where;

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Where$[ebp]

; 170  :     }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\limits
;	COMDAT ?max@?$numeric_limits@H@std@@SAHXZ
_TEXT	SEGMENT
?max@?$numeric_limits@H@std@@SAHXZ PROC			; std::numeric_limits<int>::max, COMDAT

; 556  :     _NODISCARD static constexpr int(max)() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __7FE5F402_limits
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 557  :         return INT_MAX;

  0000d	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH

; 558  :     }

  00012	5d		 pop	 ebp
  00013	c3		 ret	 0
?max@?$numeric_limits@H@std@@SAHXZ ENDP			; std::numeric_limits<int>::max
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 180  : _NODISCARD constexpr bool is_constant_evaluated() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __47F37C5A_xtr1common
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 181  :     return __builtin_is_constant_evaluated();

  0000d	32 c0		 xor	 al, al

; 182  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __93DC0B45_wchar@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00010	d1 e0		 shl	 eax, 1
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Terrain.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __077BA29D_Terrain@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
