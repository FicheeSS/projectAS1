; Listing generated by Microsoft (R) Optimizing Compiler Version 19.29.30137.0 

	TITLE	C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Debug\Character.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
$SG90797 DB	'invalid argument', 00H
___asan_rrz_$SG90797 DD 0f9H
	ORG $+43
$SG90798 DB	'%s', 00H
___asan_rrz_$SG90798 DD 0f9H
	ORG $+57
$SG90799 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xmemory', 00H
___asan_rrz_$SG90799 DD 0f9H
	ORG $+52
$SG90800 DB	'C', 00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H
	DB	'g', 00H, 'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H
	DB	'8', 00H, '6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c'
	DB	00H, 'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H
	DB	' ', 00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l'
	DB	00H, ' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H
	DB	'o', 00H, '\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\'
	DB	00H, 'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H
	DB	'i', 00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\'
	DB	00H, 'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H
	DB	'M', 00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4'
	DB	00H, '.', 00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H
	DB	'1', 00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c'
	DB	00H, 'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H
	DB	'm', 00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H
	DB	00H
___asan_rrz_$SG90800 DD 0f9H
	ORG $+44
$SG90801 DB	's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H
	DB	'A', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't'
	DB	00H, 'e', 00H, '_', 00H, 'm', 00H, 'a', 00H, 'n', 00H, 'u', 00H
	DB	'a', 00H, 'l', 00H, 'l', 00H, 'y', 00H, '_', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'a', 00H
	DB	'l', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, 00H
	DB	00H
___asan_rrz_$SG90801 DD 0f9H
	ORG $+46
$SG90802 DB	'"', 00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u'
	DB	00H, 'm', 00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H
___asan_rrz_$SG90802 DD 0f9H
	ORG $+54
$SG88167 DB	'C:\Program Files (x86)\Microsoft Visual Studio\2019\Comm'
	DB	'unity\VC\Tools\MSVC\14.29.30133\include\xlocale', 00H
___asan_rrz_$SG88167 DD 0f9H
CONST	ENDS
ASAN$GL	SEGMENT
_L___asan_global_$SG88167 DD FLAT:$SG88167
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.14
	DD	FLAT:_L___asan_gen_.13
	DD	00H
	DD	FLAT:_L___asan_gen_.15
	DD	00H
_L___asan_global_$SG90802 DD FLAT:$SG90802
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.11
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.12
	DD	00H
_L___asan_global_$SG90801 DD FLAT:$SG90801
	DD	04eH
	DD	080H
	DD	FLAT:_L___asan_gen_.9
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.10
	DD	00H
_L___asan_global_$SG90800 DD FLAT:$SG90800
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.7
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.8
	DD	00H
_L___asan_global_$SG90799 DD FLAT:$SG90799
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.5
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.6
	DD	00H
_L___asan_global_$SG90798 DD FLAT:$SG90798
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
_L___asan_global_$SG90797 DD FLAT:$SG90797
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
CONST	SEGMENT
	ORG $+52
_L___asan_gen_.0 DB 'xmemory', 00H
_L___asan_gen_.1 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.3 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.5 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.6 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.7 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.8 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.9 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.10 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.11 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.12 DD FLAT:_L___asan_gen_.0
	DD	08eH
	DD	04H
_L___asan_gen_.13 DB 'xlocale', 00H
_L___asan_gen_.14 DB '<C++ string literal>', 00H
	ORG $+3
_L___asan_gen_.15 DD FLAT:_L___asan_gen_.13
	DD	020eH
	DD	059H
CONST	ENDS
msvcjmc	SEGMENT
__A2143F22_corecrt_stdio_config@h DB 01H
__829E1958_corecrt_wstdio@h DB 01H
__6DFAE8B8_stdio@h DB 01H
__1FEB9909_corecrt_memcpy_s@h DB 01H
__C6E16F6F_corecrt_wconio@h DB 01H
__6D390390_corecrt_wio@h DB 01H
__9200769A_corecrt_wstring@h DB 01H
__1157D6BA_corecrt_wtime@h DB 01H
__1DC1E279_stat@h DB 01H
__93DC0B45_wchar@h DB 01H
__47F37C5A_xtr1common DB 01H
__81812A28_cstddef DB 01H
__741AE07E_corecrt_math@h DB 01H
__B49664B7_stdlib@h DB 01H
__244AF085_cstdlib DB 01H
__7FE5F402_limits DB 01H
__589FA321_type_traits DB 01H
__97D3638F_vcruntime_new@h DB 01H
__DD5FCA34_compare DB 01H
__A751F051_corecrt_memory@h DB 01H
__32E5F013_string@h DB 01H
__12269DE6_xutility DB 01H
__C69F69CF_tuple DB 01H
__20BB4341_malloc@h DB 01H
__B0A13A33_vcruntime_exception@h DB 01H
__FF458F76_exception DB 01H
__79D216CD_xmemory DB 01H
__374A57BA_xpolymorphic_allocator@h DB 01H
__60BC708E_cmath DB 01H
__0D019051_xstring DB 01H
__760BB52B_stdexcept DB 01H
__A4685E82_xcall_once@h DB 01H
__A0B61CF9_time@h DB 01H
__DDB379A0_xthreads@h DB 01H
__14D0A8C0_atomic DB 01H
__1B354CA2_system_error DB 01H
__65ADBEC9_vcruntime_typeinfo@h DB 01H
__62F96EFF_typeinfo DB 01H
__C34BF88C_memory DB 01H
__EF0EAF83_xfacet DB 01H
__B2D2BA86_ctype@h DB 01H
__7D708D37_xlocinfo DB 01H
__D23FE460_xlocale DB 01H
__4495FA24_xiosbase DB 01H
__4CB88277_xlocnum DB 01H
__845859A3_ios DB 01H
__B2A9EE53_InputStream@hpp DB 01H
__62DD75E3_NonCopyable@hpp DB 01H
__B7987E10_string DB 01H
__1589CDA2_algorithm DB 01H
__FE33131C_xlocmes DB 01H
__67DA974F_xlocmon DB 01H
__D96D2425_xloctime DB 01H
__FC4CDF9C_Thread@inl DB 01H
__3C1C7D88_ContextSettings@hpp DB 01H
__8D991C03_Drawable@hpp DB 01H
__896EE8A8_Glyph@hpp DB 01H
__69958C8C_xtree DB 01H
__E3A1A8C3_Font@hpp DB 01H
__0D6BD463_Character@h DB 01H
__324884E2_vector DB 01H
__BC01C4E9_Character@cpp DB 01H
__68A60A21_locale DB 01H
__C12F3EA4_ostream DB 01H
__74AB0D97_streambuf DB 01H
__038A2AA6_iterator DB 01H
__B30C2184_iosfwd DB 01H
__1347750E_utility DB 01H
__E458E21C_xstddef DB 01H
__C23CD225_Rect@inl DB 01H
__03BEDB82_Rect@hpp DB 01H
__F54903A0_xatomic@h DB 01H
__B3577796_RenderStates@hpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ; __empty_global_delete
PUBLIC	_wmemcpy
PUBLIC	?is_constant_evaluated@std@@YA_NXZ		; std::is_constant_evaluated
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked
PUBLIC	?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
PUBLIC	?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
PUBLIC	?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
PUBLIC	??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
PUBLIC	?_Maklocwcs@std@@YAPA_WPB_W@Z			; std::_Maklocwcs
PUBLIC	??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z	; std::_Maklocstr<char>
PUBLIC	??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
PUBLIC	??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
PUBLIC	?deallocate@?$allocator@I@std@@QAEXQAII@Z	; std::allocator<unsigned int>::deallocate
PUBLIC	?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z ; Character::move
PUBLIC	?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
PUBLIC	?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
PUBLIC	??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
PUBLIC	?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
PUBLIC	??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
PUBLIC	?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
PUBLIC	?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
PUBLIC	?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
PUBLIC	?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
PUBLIC	?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
PUBLIC	??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
PUBLIC	?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin
PUBLIC	?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
PUBLIC	?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
PUBLIC	??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
PUBLIC	?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xran
PUBLIC	??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
PUBLIC	?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
PUBLIC	??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
PUBLIC	?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
PUBLIC	?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
PUBLIC	??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
PUBLIC	??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
PUBLIC	??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
PUBLIC	??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2
PUBLIC	??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
PUBLIC	??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
PUBLIC	??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z	; std::_Unfancy_maybe_null<unsigned int>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ ; `string'
PUBLIC	??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ ; `string'
PUBLIC	??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ ; `string'
PUBLIC	??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ ; `string'
PUBLIC	??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ ; `string'
PUBLIC	??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ ; `string'
PUBLIC	??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ ; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ ; `string'
PUBLIC	??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ ; `string'
PUBLIC	??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ ; `string'
PUBLIC	??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ ; `string'
PUBLIC	??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ ; `string'
PUBLIC	??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ ; `string'
PUBLIC	??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@	; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	__real@00000000
PUBLIC	__real@3dcccccd
PUBLIC	__real@3e4ccccd
PUBLIC	__real@3f800000
PUBLIC	__real@40a00000
PUBLIC	__real@42480000
PUBLIC	__real@bf800000
PUBLIC	__real@c0a00000
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	_memcpy:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp___calloc_dbg:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ:PROC
EXTRN	__imp_?setPosition@Transformable@sf@@QAEXMM@Z:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	___asan_load1:PROC
EXTRN	___asan_load4:PROC
EXTRN	___asan_loadN:PROC
EXTRN	___asan_memset:PROC
EXTRN	___asan_report_load1:PROC
EXTRN	___asan_report_load4:PROC
EXTRN	___asan_report_store1:PROC
EXTRN	___asan_report_store2:PROC
EXTRN	___asan_report_store4:PROC
EXTRN	___asan_set_shadow_00:PROC
EXTRN	___asan_set_shadow_f8:PROC
EXTRN	___asan_store1:PROC
EXTRN	___asan_store4:PROC
EXTRN	___asan_storeN:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
___asan_rrz_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
___asan_rrz_??_C@_02DKCKIIND@?$CFs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xmemory', 00H	; `string'
___asan_rrz_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H
	DB	'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
CONST	SEGMENT
??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'd', 00H, 'j', 00H, 'u', 00H, 's', 00H, 't', 00H, '_', 00H, 'm'
	DB	00H, 'a', 00H, 'n', 00H, 'u', 00H, 'a', 00H, 'l', 00H, 'l', 00H
	DB	'y', 00H, '_', 00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'g', 00H
	DB	'n', 00H, 'e', 00H, 'd', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
CONST	SEGMENT
??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DB 'ITERATOR LIST CORRU'
	DB	'PTED!', 00H					; `string'
___asan_rrz_??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
CONST	SEGMENT
??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'I', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '_', 00H, 'b', 00H, 'a', 00H, 's', 00H, 'e', 00H, '1', 00H
	DB	'2', 00H, ':', 00H, ':', 00H, '_', 00H, 'O', 00H, 'r', 00H, 'p'
	DB	00H, 'h', 00H, 'a', 00H, 'n', 00H, '_', 00H, 'm', 00H, 'e', 00H
	DB	'_', 00H, 'u', 00H, 'n', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'k'
	DB	00H, 'e', 00H, 'd', 00H, '_', 00H, 'v', 00H, '3', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
CONST	SEGMENT
??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DB '"'
	DB	00H, 'I', 00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H
	DB	'O', 00H, 'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T'
	DB	00H, ' ', 00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H
	DB	'P', 00H, 'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, '"', 00H, 00H
	DB	00H						; `string'
___asan_rrz_??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocale', 00H	; `string'
___asan_rrz_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\xlocnum', 00H	; `string'
___asan_rrz_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
CONST	SEGMENT
??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DB 'vector<'
	DB	'bool> subscript out of range', 00H		; `string'
___asan_rrz_??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
CONST	SEGMENT
??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DB 'C:\Pro'
	DB	'gram Files (x86)\Microsoft Visual Studio\2019\Community\VC\To'
	DB	'ols\MSVC\14.29.30133\include\vector', 00H	; `string'
___asan_rrz_??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	'\', 00H, '2', 00H, '0', 00H, '1', 00H, '9', 00H, '\', 00H, 'C'
	DB	00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H, 'T'
	DB	00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M', 00H
	DB	'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H, '.'
	DB	00H, '2', 00H, '9', 00H, '.', 00H, '3', 00H, '0', 00H, '1', 00H
	DB	'3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
CONST	SEGMENT
??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, 'v', 00H, 'e', 00H
	DB	'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, ',', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H, 'o'
	DB	00H, 'o', 00H, 'l', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H
	DB	':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, '[', 00H, ']', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
CONST	SEGMENT
??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' '
	DB	00H, 's', 00H, 'u', 00H, 'b', 00H, 's', 00H, 'c', 00H, 'r', 00H
	DB	'i', 00H, 'p', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'r', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
___asan_rrz_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
CONST	SEGMENT
??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DB 'cannot derefer'
	DB	'ence value-initialized vector<bool> iterator', 00H ; `string'
___asan_rrz_??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
CONST	SEGMENT
??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'b', 00H, '_', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 's', 00H, 't', 00H
	DB	'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H, 't'
	DB	00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'W', 00H, 'r', 00H
	DB	'a', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o'
	DB	00H, 'c', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H
	DB	's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':'
	DB	00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H
	DB	't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n', 00H, 's'
	DB	00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*'
	DB	00H, 00H, 00H				; `string'
___asan_rrz_??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DB '"'
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e'
	DB	00H, 'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, ' ', 00H
	DB	'v', 00H, 'a', 00H, 'l', 00H, 'u', 00H, 'e', 00H, '-', 00H, 'i'
	DB	00H, 'n', 00H, 'i', 00H, 't', 00H, 'i', 00H, 'a', 00H, 'l', 00H
	DB	'i', 00H, 'z', 00H, 'e', 00H, 'd', 00H, ' ', 00H, 'v', 00H, 'e'
	DB	00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'b', 00H
	DB	'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' ', 00H, 'i', 00H, 't'
	DB	00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'"', 00H, 00H, 00H				; `string'
___asan_rrz_??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
CONST	SEGMENT
??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DB 'vector<b'
	DB	'ool> iterator not dereferenceable', 00H	; `string'
___asan_rrz_??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
CONST	SEGMENT
??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DB '"'
	DB	00H, 'v', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'<', 00H, 'b', 00H, 'o', 00H, 'o', 00H, 'l', 00H, '>', 00H, ' '
	DB	00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H
	DB	'o', 00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' '
	DB	00H, 'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H
	DB	'r', 00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, 'a', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, '"', 00H, 00H, 00H	; `string'
___asan_rrz_??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
CONST	SEGMENT
??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'b', 00H, '_', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'e', 00H, '<', 00H, 's', 00H
	DB	't', 00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'W', 00H
	DB	'r', 00H, 'a', 00H, 'p', 00H, '_', 00H, 'a', 00H, 'l', 00H, 'l'
	DB	00H, 'o', 00H, 'c', 00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H
	DB	's', 00H, 's', 00H, ' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':'
	DB	00H, ':', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, '<', 00H, 'u', 00H, 'n'
	DB	00H, 's', 00H, 'i', 00H, 'g', 00H, 'n', 00H, 'e', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 'n', 00H, 't', 00H, '>', 00H, ' ', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'G', 00H
	DB	'e', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
CONST	SEGMENT
??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DB 'invalid ve'
	DB	'ctor<bool> subscript', 00H			; `string'
___asan_rrz_??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
CONST	SEGMENT
??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DB 'invalid vector subscri'
	DB	'pt', 00H					; `string'
___asan_rrz_??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DD 0f9H
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
___asan_rrz_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD 0f9H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DD FLAT:??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
	DD	01aH
	DD	040H
	DD	FLAT:_L___asan_gen_.55
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.56
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.56 DD FLAT:_L___asan_gen_.36
	DD	0b4H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.55 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@ DD FLAT:??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
	DD	019H
	DD	040H
	DD	FLAT:_L___asan_gen_.53
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.54
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.54 DD FLAT:_L___asan_gen_.25
	DD	06f2H
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.53 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@ DD FLAT:??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
	DD	01fH
	DD	040H
	DD	FLAT:_L___asan_gen_.51
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.52
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.52 DD FLAT:_L___asan_gen_.25
	DD	0c19H
	DD	017H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.51 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@ DD FLAT:??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
	DD	0b6H
	DD	0e0H
	DD	FLAT:_L___asan_gen_.49
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.50
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.50 DD FLAT:_L___asan_gen_.25
	DD	0823H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.49 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@ DD FLAT:??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
	DD	058H
	DD	080H
	DD	FLAT:_L___asan_gen_.47
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.48
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.48 DD FLAT:_L___asan_gen_.25
	DD	091dH
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.47 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@ DD FLAT:??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
	DD	02aH
	DD	060H
	DD	FLAT:_L___asan_gen_.45
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.46
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.46 DD FLAT:_L___asan_gen_.25
	DD	091dH
	DD	00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.45 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@ DD FLAT:??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
	DD	07aH
	DD	0a0H
	DD	FLAT:_L___asan_gen_.43
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.44
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.44 DD FLAT:_L___asan_gen_.25
	DD	091cH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.43 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@ DD FLAT:??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
	DD	0baH
	DD	0e0H
	DD	FLAT:_L___asan_gen_.41
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.42
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.42 DD FLAT:_L___asan_gen_.25
	DD	091cH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.41 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@ DD FLAT:??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
	DD	03bH
	DD	060H
	DD	FLAT:_L___asan_gen_.39
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.40
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.40 DD FLAT:_L___asan_gen_.25
	DD	091cH
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.39 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DD FLAT:??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
	DD	0dH
	DD	040H
	DD	FLAT:_L___asan_gen_.37
	DD	FLAT:_L___asan_gen_.36
	DD	00H
	DD	FLAT:_L___asan_gen_.38
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.38 DD FLAT:_L___asan_gen_.36
	DD	01b7H
	DD	030H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.37 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.36 DB 'xloctime', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@ DD FLAT:??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
	DD	04cH
	DD	080H
	DD	FLAT:_L___asan_gen_.34
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.35
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.35 DD FLAT:_L___asan_gen_.25
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.34 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@ DD FLAT:??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
	DD	076H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.32
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.33
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.33 DD FLAT:_L___asan_gen_.25
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.32 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0ceH
	DD	0100H
	DD	FLAT:_L___asan_gen_.30
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.31
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.31 DD FLAT:_L___asan_gen_.25
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.30 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	067H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.28
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.29
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.29 DD FLAT:_L___asan_gen_.25
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.28 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@ DD FLAT:??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
	DD	024H
	DD	060H
	DD	FLAT:_L___asan_gen_.26
	DD	FLAT:_L___asan_gen_.25
	DD	00H
	DD	FLAT:_L___asan_gen_.27
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.27 DD FLAT:_L___asan_gen_.25
	DD	0b14H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.26 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.25 DB 'vector', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.23
	DD	FLAT:_L___asan_gen_.22
	DD	00H
	DD	FLAT:_L___asan_gen_.24
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.24 DD FLAT:_L___asan_gen_.22
	DD	05dH
	DD	05fH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.23 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.22 DB 'xlocnum', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.20
	DD	FLAT:_L___asan_gen_.19
	DD	00H
	DD	FLAT:_L___asan_gen_.21
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.21 DD FLAT:_L___asan_gen_.19
	DD	049H
	DD	03eH
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.20 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.19 DB 'xlocale', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@ DD FLAT:??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
	DD	036H
	DD	060H
	DD	FLAT:_L___asan_gen_.17
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.18
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.18 DD FLAT:_L___asan_gen_.0
	DD	04c8H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.17 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@ DD FLAT:??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
	DD	05cH
	DD	080H
	DD	FLAT:_L___asan_gen_.15
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.16
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.16 DD FLAT:_L___asan_gen_.0
	DD	04c8H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.15 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@ DD FLAT:??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
	DD	019H
	DD	040H
	DD	FLAT:_L___asan_gen_.13
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.14
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.14 DD FLAT:_L___asan_gen_.0
	DD	04c8H
	DD	08H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.13 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DD FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
	DD	026H
	DD	060H
	DD	FLAT:_L___asan_gen_.11
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.12
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.12 DD FLAT:_L___asan_gen_.0
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.11 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@ DD FLAT:??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
	DD	04aH
	DD	080H
	DD	FLAT:_L___asan_gen_.9
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.10
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.10 DD FLAT:_L___asan_gen_.0
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.9 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DD FLAT:??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
	DD	0d0H
	DD	0100H
	DD	FLAT:_L___asan_gen_.7
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.8
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.8 DD FLAT:_L___asan_gen_.0
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.7 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@ DD FLAT:??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
	DD	068H
	DD	0a0H
	DD	FLAT:_L___asan_gen_.5
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.6
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.6 DD FLAT:_L___asan_gen_.0
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.5 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_02DKCKIIND@?$CFs@ DD FLAT:??_C@_02DKCKIIND@?$CFs@
	DD	03H
	DD	040H
	DD	FLAT:_L___asan_gen_.3
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.4
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.4 DD FLAT:_L___asan_gen_.0
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.3 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT ASAN$GL
ASAN$GL	SEGMENT
_L___asan_global_??_C@_0BB@FCMFBGOM@invalid?5argument@ DD FLAT:??_C@_0BB@FCMFBGOM@invalid?5argument@
	DD	011H
	DD	040H
	DD	FLAT:_L___asan_gen_.1
	DD	FLAT:_L___asan_gen_.0
	DD	00H
	DD	FLAT:_L___asan_gen_.2
	DD	00H
ASAN$GL	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.2 DD FLAT:_L___asan_gen_.0
	DD	0a2H
	DD	04H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.1 DB '<C++ string literal>', 00H
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
_L___asan_gen_.0 DB 'xmemory', 00H
CONST	ENDS
;	COMDAT __real@c0a00000
CONST	SEGMENT
__real@c0a00000 DD 0c0a00000r			; -5
CONST	ENDS
;	COMDAT __real@bf800000
CONST	SEGMENT
__real@bf800000 DD 0bf800000r			; -1
CONST	ENDS
;	COMDAT __real@42480000
CONST	SEGMENT
__real@42480000 DD 042480000r			; 50
CONST	ENDS
;	COMDAT __real@40a00000
CONST	SEGMENT
__real@40a00000 DD 040a00000r			; 5
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3e4ccccd
CONST	SEGMENT
__real@3e4ccccd DD 03e4ccccdr			; 0.2
CONST	ENDS
;	COMDAT __real@3dcccccd
CONST	SEGMENT
__real@3dcccccd DD 03dcccccdr			; 0.1
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0172H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z DB '1'
	DB	' 16 16 3 _It'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0133H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ DB '2 16 1 4'
	DB	' $S18 32 4 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	013eH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ DB '2 16 1 '
	DB	'4 $S15 32 4 18 compiler temporary'
CONST	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:__unwindfunclet$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z$0
	DD	019H
voltbl	ENDS
xdata$x	SEGMENT
__unwindtable$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z$0
__ehfuncinfo$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CONST	SEGMENT
	ORG $+4
__L__asan_gen_.?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z DB '7'
	DB	' 16 16 18 compiler temporary 32 16 18 compiler temporary 48 1'
	DB	'6 18 compiler temporary 64 16 18 compiler temporary 80 16 18 '
	DB	'compiler temporary 96 16 18 compiler temporary 112 16 18 comp'
	DB	'iler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z DB '1'
	DB	' 16 44 18 compiler temporary'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	022dH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z DB '3 16'
	DB	' 8 6 _Mbst1 32 2 3 _Wc 48 8 6 _Mbst2'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ DB '1 1'
	DB	'6 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0c0H
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	020H
	DB	0bbH
voltbl	ENDS
;	COMDAT CONST
CONST	SEGMENT
__L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ DB '1'
	DB	' 16 4 5 _Lock'
CONST	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 693  :     static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 694  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 695  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 696  :         if (_STD is_constant_evaluated()) {

  0000d	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00012	0f b6 c0	 movzx	 eax, al
  00015	85 c0		 test	 eax, eax
  00017	74 12		 je	 SHORT $LN2@deallocate

; 697  :             _Al.deallocate(_Ptr, _Count);

  00019	8b 4d 10	 mov	 ecx, DWORD PTR __Count$[ebp]
  0001c	51		 push	 ecx
  0001d	8b 55 0c	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00020	52		 push	 edx
  00021	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00024	e8 00 00 00 00	 call	 ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 698  :         } else

  00029	eb 13		 jmp	 SHORT $LN1@deallocate
$LN2@deallocate:

; 699  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 700  :         {
; 701  :             (void) _Al;
; 702  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  0002b	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  0002e	c1 e0 03	 shl	 eax, 3
  00031	50		 push	 eax
  00032	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  0003b	83 c4 08	 add	 esp, 8
$LN1@deallocate:

; 703  :         }
; 704  :     }

  0003e	5d		 pop	 ebp
  0003f	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 985  : _CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 986  :     // deallocate a plain pointer using an allocator
; 987  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 988  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 989  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  0002c	6a 01		 push	 1
  0002e	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00031	50		 push	 eax
  00032	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00035	51		 push	 ecx
  00036	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  0003b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 990  :     } else {
; 991  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 992  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 993  :     }
; 994  : }

  0003e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00041	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00048	59		 pop	 ecx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
  0004d	cc		 int	 3
  0004e	cc		 int	 3
  0004f	cc		 int	 3
  00050	cc		 int	 3
  00051	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z PROC ; std::_Destroy_range<std::allocator<unsigned int> >, COMDAT

; 945  :     _Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 946  :     // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
; 947  :     using _Ty = typename _Alloc::value_type;
; 948  :     if constexpr (!conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>) {
; 949  :         for (; _First != _Last; ++_First) {
; 950  :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 951  :         }
; 952  :     }
; 953  : }

  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ENDP ; std::_Destroy_range<std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 251  : _CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00016	33 c5		 xor	 eax, ebp
  00018	50		 push	 eax
  00019	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001c	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00022	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00027	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 252  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 253  : #ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
; 254  :     if (_STD is_constant_evaluated()) {

  0002c	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00031	0f b6 c0	 movzx	 eax, al
  00034	85 c0		 test	 eax, eax
  00036	74 0e		 je	 SHORT $LN2@Deallocate

; 255  :         ::operator delete(_Ptr);

  00038	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0003b	51		 push	 ecx
  0003c	e8 00 00 00 00	 call	 ??3@YAXPAX@Z		; operator delete
  00041	83 c4 04	 add	 esp, 4

; 256  :     } else

  00044	eb 29		 jmp	 SHORT $LN5@Deallocate
$LN2@Deallocate:

; 257  : #endif // __cpp_lib_constexpr_dynamic_alloc
; 258  :     {
; 259  : #if defined(_M_IX86) || defined(_M_X64)
; 260  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00046	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  0004d	72 10		 jb	 SHORT $LN4@Deallocate

; 261  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004f	8d 55 0c	 lea	 edx, DWORD PTR __Bytes$[ebp]
  00052	52		 push	 edx
  00053	8d 45 08	 lea	 eax, DWORD PTR __Ptr$[ebp]
  00056	50		 push	 eax
  00057	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  0005c	83 c4 08	 add	 esp, 8
$LN4@Deallocate:

; 262  :         }
; 263  : #endif // defined(_M_IX86) || defined(_M_X64)
; 264  :         ::operator delete(_Ptr, _Bytes);

  0005f	8b 4d 0c	 mov	 ecx, DWORD PTR __Bytes$[ebp]
  00062	51		 push	 ecx
  00063	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00066	52		 push	 edx
  00067	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  0006c	83 c4 08	 add	 esp, 8
$LN5@Deallocate:

; 265  :     }
; 266  : }

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00072	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00079	59		 pop	 ecx
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
  0007e	cc		 int	 3
  0007f	cc		 int	 3
  00080	cc		 int	 3
  00081	cc		 int	 3
  00082	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z PROC		; std::_Unfancy_maybe_null<unsigned int>, COMDAT

; 437  : constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 438  :     return _Ptr;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 439  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ENDP		; std::_Unfancy_maybe_null<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\utility
;	COMDAT ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -32					; size = 4
tv71 = -28						; size = 4
tv68 = -24						; size = 4
tv65 = -20						; size = 4
tv74 = -16						; size = 4
tv84 = -12						; size = 4
tv94 = -8						; size = 4
tv77 = -3						; size = 1
tv87 = -2						; size = 1
tv129 = -1						; size = 1
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Container_proxy *,std::nullptr_t>, COMDAT

; 614  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __1347750E_utility
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 615  :     // assign _New_val to _Val, return previous _Val
; 616  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00010	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00013	89 45 ec	 mov	 DWORD PTR tv65[ebp], eax
  00016	8b 4d ec	 mov	 ecx, DWORD PTR tv65[ebp]
  00019	89 4d f8	 mov	 DWORD PTR tv94[ebp], ecx
  0001c	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv129[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv129[ebp], 0
  0002f	74 1a		 je	 SHORT $LN5@exchange
  00031	8a 4d f8	 mov	 cl, BYTE PTR tv94[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv129[ebp]
  0003d	7c 0c		 jl	 SHORT $LN5@exchange
  0003f	8b 55 f8	 mov	 edx, DWORD PTR tv94[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN5@exchange:
  0004b	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	89 4d e0	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 617  :     _Val         = static_cast<_Other&&>(_New_val);

  00053	8b 55 0c	 mov	 edx, DWORD PTR __New_val$[ebp]
  00056	89 55 e8	 mov	 DWORD PTR tv68[ebp], edx
  00059	8b 45 e8	 mov	 eax, DWORD PTR tv68[ebp]
  0005c	89 45 f4	 mov	 DWORD PTR tv84[ebp], eax
  0005f	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00062	c1 e9 03	 shr	 ecx, 3
  00065	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006b	88 55 fe	 mov	 BYTE PTR tv87[ebp], dl
  0006e	80 7d fe 00	 cmp	 BYTE PTR tv87[ebp], 0
  00072	74 18		 je	 SHORT $LN4@exchange
  00074	8a 45 f4	 mov	 al, BYTE PTR tv84[ebp]
  00077	24 07		 and	 al, 7
  00079	04 03		 add	 al, 3
  0007b	3a 45 fe	 cmp	 al, BYTE PTR tv87[ebp]
  0007e	7c 0c		 jl	 SHORT $LN4@exchange
  00080	8b 4d f4	 mov	 ecx, DWORD PTR tv84[ebp]
  00083	51		 push	 ecx
  00084	e8 00 00 00 00	 call	 ___asan_report_load4
  00089	83 c4 04	 add	 esp, 4
$LN4@exchange:
  0008c	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  0008f	89 55 e4	 mov	 DWORD PTR tv71[ebp], edx
  00092	8b 45 e4	 mov	 eax, DWORD PTR tv71[ebp]
  00095	89 45 f0	 mov	 DWORD PTR tv74[ebp], eax
  00098	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  0009b	c1 e9 03	 shr	 ecx, 3
  0009e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000a4	88 55 fd	 mov	 BYTE PTR tv77[ebp], dl
  000a7	80 7d fd 00	 cmp	 BYTE PTR tv77[ebp], 0
  000ab	74 18		 je	 SHORT $LN3@exchange
  000ad	8a 45 f0	 mov	 al, BYTE PTR tv74[ebp]
  000b0	24 07		 and	 al, 7
  000b2	04 03		 add	 al, 3
  000b4	3a 45 fd	 cmp	 al, BYTE PTR tv77[ebp]
  000b7	7c 0c		 jl	 SHORT $LN3@exchange
  000b9	8b 4d f0	 mov	 ecx, DWORD PTR tv74[ebp]
  000bc	51		 push	 ecx
  000bd	e8 00 00 00 00	 call	 ___asan_report_store4
  000c2	83 c4 04	 add	 esp, 4
$LN3@exchange:
  000c5	8b 55 08	 mov	 edx, DWORD PTR __Val$[ebp]
  000c8	8b 45 0c	 mov	 eax, DWORD PTR __New_val$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 0a		 mov	 DWORD PTR [edx], ecx

; 618  :     return _Old_val;

  000cf	8b 45 e0	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 619  : }

  000d2	8b e5		 mov	 esp, ebp
  000d4	5d		 pop	 ebp
  000d5	c3		 ret	 0
??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Container_proxy *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>, COMDAT
; _this$ = ecx

; 829  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c2 04 00	 ret	 4
??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 998  : _CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 999  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 1000 :     using _Ty = typename _Alloc::value_type;
; 1001 :     _Ptr->~_Ty();
; 1002 :     _Deallocate_plain(_Al, _Ptr);

  0000d	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00010	50		 push	 eax
  00011	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00014	51		 push	 ecx
  00015	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0001a	83 c4 08	 add	 esp, 8

; 1003 : }

  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 03	 shl	 eax, 3
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXQAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___param0$ = 8						; size = 4
___param1$ = 12						; size = 4
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 0c	 mov	 eax, DWORD PTR ___param1$[ebp]
  0000a	50		 push	 eax
  0000b	8b 4d 08	 mov	 ecx, DWORD PTR ___param0$[ebp]
  0000e	51		 push	 ecx
  0000f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00012	e8 00 00 00 00	 call	 ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00017	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  0001a	8b e5		 mov	 esp, ebp
  0001c	5d		 pop	 ebp
  0001d	c2 08 00	 ret	 8
??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  0000a	50		 push	 eax
  0000b	6a 00		 push	 0
  0000d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00010	51		 push	 ecx
  00011	e8 00 00 00 00	 call	 ___asan_memset
  00016	83 c4 0c	 add	 esp, 12			; 0000000cH
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c2 04 00	 ret	 4
?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ
_TEXT	SEGMENT
tv128 = -24						; size = 4
tv130 = -20						; size = 4
_this$ = -16						; size = 4
tv162 = -12						; size = 4
__Cont$ = -8						; size = 4
tv165 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ PROC ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*, COMDAT
; _this$ = ecx

; 2329 :     _NODISCARD _CONSTEXPR20_CONTAINER reference operator*() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2330 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2331 :         const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());

  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 f8	 mov	 DWORD PTR __Cont$[ebp], eax
$LN4@operator:

; 2332 :         _STL_VERIFY(_Cont, "cannot dereference value-initialized vector<bool> iterator");

  0001e	83 7d f8 00	 cmp	 DWORD PTR __Cont$[ebp], 0
  00022	74 02		 je	 SHORT $LN7@operator
  00024	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00030	6a 00		 push	 0
  00032	68 1c 09 00 00	 push	 2332			; 0000091cH
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0003c	6a 02		 push	 2
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	83 f8 01	 cmp	 eax, 1
  0004a	75 01		 jne	 SHORT $LN19@operator
  0004c	cc		 int	 3
$LN19@operator:
  0004d	6a 00		 push	 0
  0004f	68 1c 09 00 00	 push	 2332			; 0000091cH
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	33 c9		 xor	 ecx, ecx
  0006e	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  00070	33 d2		 xor	 edx, edx
  00072	75 aa		 jne	 SHORT $LN4@operator
$LN10@operator:

; 2333 :         _STL_VERIFY(this->_Total_off(_Cont) < static_cast<_Difference_type>(_Cont->_Mysize),

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Cont$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
  00080	89 45 e8	 mov	 DWORD PTR tv128[ebp], eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Cont$[ebp]
  00086	83 c1 14	 add	 ecx, 20			; 00000014H
  00089	89 4d ec	 mov	 DWORD PTR tv130[ebp], ecx
  0008c	8b 55 ec	 mov	 edx, DWORD PTR tv130[ebp]
  0008f	89 55 f4	 mov	 DWORD PTR tv162[ebp], edx
  00092	8b 45 f4	 mov	 eax, DWORD PTR tv162[ebp]
  00095	c1 e8 03	 shr	 eax, 3
  00098	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0009e	88 4d ff	 mov	 BYTE PTR tv165[ebp], cl
  000a1	80 7d ff 00	 cmp	 BYTE PTR tv165[ebp], 0
  000a5	74 1a		 je	 SHORT $LN21@operator
  000a7	8a 55 f4	 mov	 dl, BYTE PTR tv162[ebp]
  000aa	80 e2 07	 and	 dl, 7
  000ad	80 c2 03	 add	 dl, 3
  000b0	3a 55 ff	 cmp	 dl, BYTE PTR tv165[ebp]
  000b3	7c 0c		 jl	 SHORT $LN21@operator
  000b5	8b 45 f4	 mov	 eax, DWORD PTR tv162[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ___asan_report_load4
  000be	83 c4 04	 add	 esp, 4
$LN21@operator:
  000c1	8b 4d ec	 mov	 ecx, DWORD PTR tv130[ebp]
  000c4	8b 55 e8	 mov	 edx, DWORD PTR tv128[ebp]
  000c7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000c9	7d 02		 jge	 SHORT $LN13@operator
  000cb	eb 4a		 jmp	 SHORT $LN8@operator
$LN13@operator:
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000d7	6a 00		 push	 0
  000d9	68 1e 09 00 00	 push	 2334			; 0000091eH
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000e3	6a 02		 push	 2
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	75 01		 jne	 SHORT $LN20@operator
  000f3	cc		 int	 3
$LN20@operator:
  000f4	6a 00		 push	 0
  000f6	68 1e 09 00 00	 push	 2334			; 0000091eH
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_1LK@OCBBIODL@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	33 c9		 xor	 ecx, ecx
  00115	75 b6		 jne	 SHORT $LN13@operator
$LN8@operator:
  00117	33 d2		 xor	 edx, edx
  00119	0f 85 55 ff ff
	ff		 jne	 $LN10@operator

; 2334 :             "vector<bool> iterator not dereferenceable");
; 2335 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2336 : 
; 2337 :         return _Reft(*this);

  0011f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00122	50		 push	 eax
  00123	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00126	e8 00 00 00 00	 call	 ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
  0012b	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2338 :     }

  0012e	8b e5		 mov	 esp, ebp
  00130	5d		 pop	 ebp
  00131	c2 04 00	 ret	 4
??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ENDP ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Mypvbool$ = 12					; size = 4
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z PROC ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2124 :     _CONSTEXPR20_CONTAINER _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2125 :         : _Mybase(_Ptr, 0, _Mypvbool) {}

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Mypvbool$[ebp]
  00014	50		 push	 eax
  00015	6a 00		 push	 0
  00017	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001e	e8 00 00 00 00	 call	 ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
  00023	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b e5		 mov	 esp, ebp
  00028	5d		 pop	 ebp
  00029	c2 08 00	 ret	 8
??0?$_Vb_const_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z ENDP ; std::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_const_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z PROC ; std::get<1,enum DIRDEP,enum DIRDEP>, COMDAT

; 816  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 817  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 818  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]

; 819  : }

  00010	5d		 pop	 ebp
  00011	c3		 ret	 0
??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ENDP ; std::get<1,enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\tuple
;	COMDAT ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z
_TEXT	SEGMENT
__Tuple$ = 8						; size = 4
??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z PROC ; std::get<0,enum DIRDEP,enum DIRDEP>, COMDAT

; 816  : _NODISCARD constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __C69F69CF_tuple
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 817  :     using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
; 818  :     return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;

  0000d	8b 45 08	 mov	 eax, DWORD PTR __Tuple$[ebp]
  00010	83 c0 04	 add	 eax, 4

; 819  : }

  00013	5d		 pop	 ebp
  00014	c3		 ret	 0
??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ENDP ; std::get<0,enum DIRDEP,enum DIRDEP>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv73 = -8						; size = 4
tv76 = -1						; size = 1
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask, COMDAT
; _this$ = ecx

; 2098 :     _CONSTEXPR20_CONTAINER _Vbase _Mask() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2099 :         return static_cast<_Vbase>(1) << this->_Myoff;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv73[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv76[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv76[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@Mask
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv73[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv76[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@Mask
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv73[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@Mask:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	ba 01 00 00 00	 mov	 edx, 1
  00059	8b 08		 mov	 ecx, DWORD PTR [eax]
  0005b	d3 e2		 shl	 edx, cl
  0005d	8b c2		 mov	 eax, edx

; 2100 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
tv128 = -32						; size = 4
tv152 = -28						; size = 4
tv130 = -24						; size = 4
tv162 = -20						; size = 4
_this$ = -16						; size = 4
tv172 = -12						; size = 4
__Cont$ = -8						; size = 4
tv165 = -2						; size = 1
tv175 = -1						; size = 1
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr, COMDAT
; _this$ = ecx

; 2080 :     _CONSTEXPR20_CONTAINER const _Vbase* _Getptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2081 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2082 :         const auto _Cont = static_cast<const _Mycont*>(this->_Getcont());

  00013	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 f8	 mov	 DWORD PTR __Cont$[ebp], eax
$LN4@Getptr:

; 2083 :         _STL_VERIFY(_Cont, "cannot dereference value-initialized vector<bool> iterator");

  0001e	83 7d f8 00	 cmp	 DWORD PTR __Cont$[ebp], 0
  00022	74 02		 je	 SHORT $LN7@Getptr
  00024	eb 4a		 jmp	 SHORT $LN2@Getptr
$LN7@Getptr:
  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0DL@EIIPGNKA@cannot?5dereference?5value?9initia@
  0002b	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00030	6a 00		 push	 0
  00032	68 23 08 00 00	 push	 2083			; 00000823H
  00037	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0003c	6a 02		 push	 2
  0003e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00044	83 c4 18	 add	 esp, 24			; 00000018H
  00047	83 f8 01	 cmp	 eax, 1
  0004a	75 01		 jne	 SHORT $LN19@Getptr
  0004c	cc		 int	 3
$LN19@Getptr:
  0004d	6a 00		 push	 0
  0004f	68 23 08 00 00	 push	 2083			; 00000823H
  00054	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00059	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_1HK@NLJEKNBE@?$AA?$CC?$AAc?$AAa?$AAn?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr@
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00069	83 c4 14	 add	 esp, 20			; 00000014H
  0006c	33 c9		 xor	 ecx, ecx
  0006e	75 b6		 jne	 SHORT $LN7@Getptr
$LN2@Getptr:
  00070	33 d2		 xor	 edx, edx
  00072	75 aa		 jne	 SHORT $LN4@Getptr
$LN10@Getptr:

; 2084 :         _STL_VERIFY(this->_Total_off(_Cont) <= static_cast<_Difference_type>(_Cont->_Mysize),

  00074	8b 45 f8	 mov	 eax, DWORD PTR __Cont$[ebp]
  00077	50		 push	 eax
  00078	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0007b	e8 00 00 00 00	 call	 ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
  00080	89 45 e0	 mov	 DWORD PTR tv128[ebp], eax
  00083	8b 4d f8	 mov	 ecx, DWORD PTR __Cont$[ebp]
  00086	83 c1 14	 add	 ecx, 20			; 00000014H
  00089	89 4d e8	 mov	 DWORD PTR tv130[ebp], ecx
  0008c	8b 55 e8	 mov	 edx, DWORD PTR tv130[ebp]
  0008f	89 55 f4	 mov	 DWORD PTR tv172[ebp], edx
  00092	8b 45 f4	 mov	 eax, DWORD PTR tv172[ebp]
  00095	c1 e8 03	 shr	 eax, 3
  00098	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0009e	88 4d ff	 mov	 BYTE PTR tv175[ebp], cl
  000a1	80 7d ff 00	 cmp	 BYTE PTR tv175[ebp], 0
  000a5	74 1a		 je	 SHORT $LN22@Getptr
  000a7	8a 55 f4	 mov	 dl, BYTE PTR tv172[ebp]
  000aa	80 e2 07	 and	 dl, 7
  000ad	80 c2 03	 add	 dl, 3
  000b0	3a 55 ff	 cmp	 dl, BYTE PTR tv175[ebp]
  000b3	7c 0c		 jl	 SHORT $LN22@Getptr
  000b5	8b 45 f4	 mov	 eax, DWORD PTR tv172[ebp]
  000b8	50		 push	 eax
  000b9	e8 00 00 00 00	 call	 ___asan_report_load4
  000be	83 c4 04	 add	 esp, 4
$LN22@Getptr:
  000c1	8b 4d e8	 mov	 ecx, DWORD PTR tv130[ebp]
  000c4	8b 55 e0	 mov	 edx, DWORD PTR tv128[ebp]
  000c7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000c9	7f 02		 jg	 SHORT $LN13@Getptr
  000cb	eb 4a		 jmp	 SHORT $LN8@Getptr
$LN13@Getptr:
  000cd	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@FLJLFEAD@vector?$DMbool?$DO?5iterator?5not?5deref@
  000d2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000d7	6a 00		 push	 0
  000d9	68 25 08 00 00	 push	 2085			; 00000825H
  000de	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000e3	6a 02		 push	 2
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000eb	83 c4 18	 add	 esp, 24			; 00000018H
  000ee	83 f8 01	 cmp	 eax, 1
  000f1	75 01		 jne	 SHORT $LN20@Getptr
  000f3	cc		 int	 3
$LN20@Getptr:
  000f4	6a 00		 push	 0
  000f6	68 25 08 00 00	 push	 2085			; 00000825H
  000fb	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_1LG@CHICOEJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAb?$AA_?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe@
  00105	68 00 00 00 00	 push	 OFFSET ??_C@_1FI@IBAHAGLP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAi@
  0010a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00110	83 c4 14	 add	 esp, 20			; 00000014H
  00113	33 c9		 xor	 ecx, ecx
  00115	75 b6		 jne	 SHORT $LN13@Getptr
$LN8@Getptr:
  00117	33 d2		 xor	 edx, edx
  00119	0f 85 55 ff ff
	ff		 jne	 $LN10@Getptr

; 2085 :             "vector<bool> iterator not dereferenceable");
; 2086 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2087 : 
; 2088 :         return this->_Myptr;

  0011f	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00122	83 c0 08	 add	 eax, 8
  00125	89 45 e4	 mov	 DWORD PTR tv152[ebp], eax
  00128	8b 4d e4	 mov	 ecx, DWORD PTR tv152[ebp]
  0012b	89 4d ec	 mov	 DWORD PTR tv162[ebp], ecx
  0012e	8b 55 ec	 mov	 edx, DWORD PTR tv162[ebp]
  00131	c1 ea 03	 shr	 edx, 3
  00134	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0013a	88 45 fe	 mov	 BYTE PTR tv165[ebp], al
  0013d	80 7d fe 00	 cmp	 BYTE PTR tv165[ebp], 0
  00141	74 1a		 je	 SHORT $LN21@Getptr
  00143	8a 4d ec	 mov	 cl, BYTE PTR tv162[ebp]
  00146	80 e1 07	 and	 cl, 7
  00149	80 c1 03	 add	 cl, 3
  0014c	3a 4d fe	 cmp	 cl, BYTE PTR tv165[ebp]
  0014f	7c 0c		 jl	 SHORT $LN21@Getptr
  00151	8b 55 ec	 mov	 edx, DWORD PTR tv162[ebp]
  00154	52		 push	 edx
  00155	e8 00 00 00 00	 call	 ___asan_report_load4
  0015a	83 c4 04	 add	 esp, 4
$LN21@Getptr:
  0015d	8b 45 e4	 mov	 eax, DWORD PTR tv152[ebp]
  00160	8b 00		 mov	 eax, DWORD PTR [eax]

; 2089 :     }

  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv67 = -24						; size = 4
tv70 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv75 = -8						; size = 4
tv78 = -1						; size = 1
??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool, COMDAT
; _this$ = ecx

; 2076 :     _CONSTEXPR20_CONTAINER operator bool() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2077 :         return (*_Getptr() & _Mask()) != 0;

  00013	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getptr@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEPBIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Getptr
  0001b	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  0001e	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00021	e8 00 00 00 00	 call	 ?_Mask@?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@IBEIXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Mask
  00026	89 45 e8	 mov	 DWORD PTR tv67[ebp], eax
  00029	8b 45 f0	 mov	 eax, DWORD PTR tv65[ebp]
  0002c	89 45 f8	 mov	 DWORD PTR tv75[ebp], eax
  0002f	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00032	c1 e9 03	 shr	 ecx, 3
  00035	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003b	88 55 ff	 mov	 BYTE PTR tv78[ebp], dl
  0003e	80 7d ff 00	 cmp	 BYTE PTR tv78[ebp], 0
  00042	74 18		 je	 SHORT $LN5@operator
  00044	8a 45 f8	 mov	 al, BYTE PTR tv75[ebp]
  00047	24 07		 and	 al, 7
  00049	04 03		 add	 al, 3
  0004b	3a 45 ff	 cmp	 al, BYTE PTR tv78[ebp]
  0004e	7c 0c		 jl	 SHORT $LN5@operator
  00050	8b 4d f8	 mov	 ecx, DWORD PTR tv75[ebp]
  00053	51		 push	 ecx
  00054	e8 00 00 00 00	 call	 ___asan_report_load4
  00059	83 c4 04	 add	 esp, 4
$LN5@operator:
  0005c	8b 55 f0	 mov	 edx, DWORD PTR tv65[ebp]
  0005f	8b 02		 mov	 eax, DWORD PTR [edx]
  00061	23 45 e8	 and	 eax, DWORD PTR tv67[ebp]
  00064	74 09		 je	 SHORT $LN3@operator
  00066	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR tv70[ebp], 1
  0006d	eb 07		 jmp	 SHORT $LN4@operator
$LN3@operator:
  0006f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv70[ebp], 0
$LN4@operator:
  00076	8a 45 ec	 mov	 al, BYTE PTR tv70[ebp]

; 2078 :     }

  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z
_TEXT	SEGMENT
tv82 = -36						; size = 4
tv86 = -32						; size = 4
tv84 = -28						; size = 4
_this$ = -24						; size = 4
tv79 = -20						; size = 4
tv77 = -16						; size = 4
tv128 = -12						; size = 4
tv138 = -8						; size = 4
tv131 = -2						; size = 1
tv141 = -1						; size = 1
__Right$ = 8						; size = 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z PROC ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2055 :     _CONSTEXPR20_CONTAINER _Vb_reference(const _Mybase& _Right) noexcept

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2056 :         : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

  00013	8b 4d 08	 mov	 ecx, DWORD PTR __Right$[ebp]
  00016	e8 00 00 00 00	 call	 ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
  0001b	89 45 e4	 mov	 DWORD PTR tv84[ebp], eax
  0001e	8b 45 08	 mov	 eax, DWORD PTR __Right$[ebp]
  00021	83 c0 0c	 add	 eax, 12			; 0000000cH
  00024	89 45 f0	 mov	 DWORD PTR tv77[ebp], eax
  00027	8b 4d f0	 mov	 ecx, DWORD PTR tv77[ebp]
  0002a	89 4d f8	 mov	 DWORD PTR tv138[ebp], ecx
  0002d	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  00030	c1 ea 03	 shr	 edx, 3
  00033	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00039	88 45 ff	 mov	 BYTE PTR tv141[ebp], al
  0003c	80 7d ff 00	 cmp	 BYTE PTR tv141[ebp], 0
  00040	74 1a		 je	 SHORT $LN4@Vb_referen
  00042	8a 4d f8	 mov	 cl, BYTE PTR tv138[ebp]
  00045	80 e1 07	 and	 cl, 7
  00048	80 c1 03	 add	 cl, 3
  0004b	3a 4d ff	 cmp	 cl, BYTE PTR tv141[ebp]
  0004e	7c 0c		 jl	 SHORT $LN4@Vb_referen
  00050	8b 55 f8	 mov	 edx, DWORD PTR tv138[ebp]
  00053	52		 push	 edx
  00054	e8 00 00 00 00	 call	 ___asan_report_load4
  00059	83 c4 04	 add	 esp, 4
$LN4@Vb_referen:
  0005c	8b 45 f0	 mov	 eax, DWORD PTR tv77[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	89 4d e0	 mov	 DWORD PTR tv86[ebp], ecx
  00064	8b 55 08	 mov	 edx, DWORD PTR __Right$[ebp]
  00067	83 c2 08	 add	 edx, 8
  0006a	89 55 ec	 mov	 DWORD PTR tv79[ebp], edx
  0006d	8b 45 ec	 mov	 eax, DWORD PTR tv79[ebp]
  00070	89 45 f4	 mov	 DWORD PTR tv128[ebp], eax
  00073	8b 4d f4	 mov	 ecx, DWORD PTR tv128[ebp]
  00076	c1 e9 03	 shr	 ecx, 3
  00079	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0007f	88 55 fe	 mov	 BYTE PTR tv131[ebp], dl
  00082	80 7d fe 00	 cmp	 BYTE PTR tv131[ebp], 0
  00086	74 18		 je	 SHORT $LN3@Vb_referen
  00088	8a 45 f4	 mov	 al, BYTE PTR tv128[ebp]
  0008b	24 07		 and	 al, 7
  0008d	04 03		 add	 al, 3
  0008f	3a 45 fe	 cmp	 al, BYTE PTR tv131[ebp]
  00092	7c 0c		 jl	 SHORT $LN3@Vb_referen
  00094	8b 4d f4	 mov	 ecx, DWORD PTR tv128[ebp]
  00097	51		 push	 ecx
  00098	e8 00 00 00 00	 call	 ___asan_report_load4
  0009d	83 c4 04	 add	 esp, 4
$LN3@Vb_referen:
  000a0	8b 55 ec	 mov	 edx, DWORD PTR tv79[ebp]
  000a3	8b 02		 mov	 eax, DWORD PTR [edx]
  000a5	89 45 dc	 mov	 DWORD PTR tv82[ebp], eax
  000a8	8b 4d e4	 mov	 ecx, DWORD PTR tv84[ebp]
  000ab	51		 push	 ecx
  000ac	8b 55 e0	 mov	 edx, DWORD PTR tv86[ebp]
  000af	52		 push	 edx
  000b0	8b 45 dc	 mov	 eax, DWORD PTR tv82[ebp]
  000b3	50		 push	 eax
  000b4	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b7	e8 00 00 00 00	 call	 ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
  000bc	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  000bf	8b e5		 mov	 esp, ebp
  000c1	5d		 pop	 ebp
  000c2	c2 04 00	 ret	 4
??0?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@ABV?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@@Z ENDP ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
;	COMDAT ??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0000a	e8 00 00 00 00	 call	 ??1_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::~_Iterator_base12
  0000f	8b e5		 mov	 esp, ebp
  00011	5d		 pop	 ebp
  00012	c3		 ret	 0
??1?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::~_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z
_TEXT	SEGMENT
tv74 = -32						; size = 4
tv71 = -28						; size = 4
tv75 = -24						; size = 4
_this$ = -20						; size = 4
tv64 = -16						; size = 4
tv82 = -12						; size = 4
tv92 = -8						; size = 4
tv85 = -2						; size = 1
tv95 = -1						; size = 1
__Cont$ = 8						; size = 4
?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off, COMDAT
; _this$ = ecx

; 2032 :     _CONSTEXPR20_CONTAINER _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2033 :         return static_cast<_Difference_type>(_VBITS * (_Myptr - _Cont->_Myvec.data()) + _Myoff);

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 08	 add	 eax, 8
  00019	89 45 f0	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d 08	 mov	 ecx, DWORD PTR __Cont$[ebp]
  0001f	83 c1 04	 add	 ecx, 4
  00022	e8 00 00 00 00	 call	 ?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
  00027	89 45 e4	 mov	 DWORD PTR tv71[ebp], eax
  0002a	8b 4d f0	 mov	 ecx, DWORD PTR tv64[ebp]
  0002d	89 4d f8	 mov	 DWORD PTR tv92[ebp], ecx
  00030	8b 55 f8	 mov	 edx, DWORD PTR tv92[ebp]
  00033	c1 ea 03	 shr	 edx, 3
  00036	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0003c	88 45 ff	 mov	 BYTE PTR tv95[ebp], al
  0003f	80 7d ff 00	 cmp	 BYTE PTR tv95[ebp], 0
  00043	74 1a		 je	 SHORT $LN4@Total_off
  00045	8a 4d f8	 mov	 cl, BYTE PTR tv92[ebp]
  00048	80 e1 07	 and	 cl, 7
  0004b	80 c1 03	 add	 cl, 3
  0004e	3a 4d ff	 cmp	 cl, BYTE PTR tv95[ebp]
  00051	7c 0c		 jl	 SHORT $LN4@Total_off
  00053	8b 55 f8	 mov	 edx, DWORD PTR tv92[ebp]
  00056	52		 push	 edx
  00057	e8 00 00 00 00	 call	 ___asan_report_load4
  0005c	83 c4 04	 add	 esp, 4
$LN4@Total_off:
  0005f	8b 45 f0	 mov	 eax, DWORD PTR tv64[ebp]
  00062	8b 08		 mov	 ecx, DWORD PTR [eax]
  00064	2b 4d e4	 sub	 ecx, DWORD PTR tv71[ebp]
  00067	c1 f9 02	 sar	 ecx, 2
  0006a	c1 e1 05	 shl	 ecx, 5
  0006d	89 4d e0	 mov	 DWORD PTR tv74[ebp], ecx
  00070	8b 55 ec	 mov	 edx, DWORD PTR _this$[ebp]
  00073	83 c2 0c	 add	 edx, 12			; 0000000cH
  00076	89 55 e8	 mov	 DWORD PTR tv75[ebp], edx
  00079	8b 45 e8	 mov	 eax, DWORD PTR tv75[ebp]
  0007c	89 45 f4	 mov	 DWORD PTR tv82[ebp], eax
  0007f	8b 4d f4	 mov	 ecx, DWORD PTR tv82[ebp]
  00082	c1 e9 03	 shr	 ecx, 3
  00085	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0008b	88 55 fe	 mov	 BYTE PTR tv85[ebp], dl
  0008e	80 7d fe 00	 cmp	 BYTE PTR tv85[ebp], 0
  00092	74 18		 je	 SHORT $LN3@Total_off
  00094	8a 45 f4	 mov	 al, BYTE PTR tv82[ebp]
  00097	24 07		 and	 al, 7
  00099	04 03		 add	 al, 3
  0009b	3a 45 fe	 cmp	 al, BYTE PTR tv85[ebp]
  0009e	7c 0c		 jl	 SHORT $LN3@Total_off
  000a0	8b 4d f4	 mov	 ecx, DWORD PTR tv82[ebp]
  000a3	51		 push	 ecx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load4
  000a9	83 c4 04	 add	 esp, 4
$LN3@Total_off:
  000ac	8b 55 e8	 mov	 edx, DWORD PTR tv75[ebp]
  000af	8b 45 e0	 mov	 eax, DWORD PTR tv74[ebp]
  000b2	03 02		 add	 eax, DWORD PTR [edx]

; 2034 :     }

  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 04 00	 ret	 4
?_Total_off@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBEHPBV?$vector@_NV?$allocator@_N@std@@@2@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Total_off
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv75 = -84						; size = 4
tv72 = -80						; size = 4
tv70 = -76						; size = 4
tv66 = -72						; size = 4
tv74 = -68						; size = 4
tv73 = -64						; size = 4
tv71 = -60						; size = 4
tv67 = -56						; size = 4
tv68 = -52						; size = 4
tv65 = -48						; size = 4
tv64 = -44						; size = 4
tv91 = -40						; size = 4
tv133 = -36						; size = 4
tv143 = -32						; size = 4
tv153 = -28						; size = 4
tv163 = -24						; size = 4
tv173 = -20						; size = 4
tv183 = -16						; size = 4
_this$ = -12						; size = 4
tv94 = -7						; size = 1
tv136 = -6						; size = 1
tv146 = -5						; size = 1
tv156 = -4						; size = 1
tv166 = -3						; size = 1
tv176 = -2						; size = 1
tv186 = -1						; size = 1
__Off$ = 8						; size = 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance, COMDAT
; _this$ = ecx

; 2025 :     _CONSTEXPR20_CONTAINER void _Advance(_Size_type _Off) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2026 :         _Myoff += _Off;

  00013	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 0c	 add	 eax, 12			; 0000000cH
  00019	89 45 d4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d d4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f0	 mov	 DWORD PTR tv183[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR tv183[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv186[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv186[ebp], 0
  00035	74 1a		 je	 SHORT $LN9@Advance
  00037	8a 4d f0	 mov	 cl, BYTE PTR tv183[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv186[ebp]
  00043	7c 0c		 jl	 SHORT $LN9@Advance
  00045	8b 55 f0	 mov	 edx, DWORD PTR tv183[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN9@Advance:
  00051	8b 45 d4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	03 4d 08	 add	 ecx, DWORD PTR __Off$[ebp]
  00059	89 4d b8	 mov	 DWORD PTR tv66[ebp], ecx
  0005c	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0005f	83 c2 0c	 add	 edx, 12			; 0000000cH
  00062	89 55 d0	 mov	 DWORD PTR tv65[ebp], edx
  00065	8b 45 d0	 mov	 eax, DWORD PTR tv65[ebp]
  00068	89 45 ec	 mov	 DWORD PTR tv173[ebp], eax
  0006b	8b 4d ec	 mov	 ecx, DWORD PTR tv173[ebp]
  0006e	c1 e9 03	 shr	 ecx, 3
  00071	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00077	88 55 fe	 mov	 BYTE PTR tv176[ebp], dl
  0007a	80 7d fe 00	 cmp	 BYTE PTR tv176[ebp], 0
  0007e	74 18		 je	 SHORT $LN8@Advance
  00080	8a 45 ec	 mov	 al, BYTE PTR tv173[ebp]
  00083	24 07		 and	 al, 7
  00085	04 03		 add	 al, 3
  00087	3a 45 fe	 cmp	 al, BYTE PTR tv176[ebp]
  0008a	7c 0c		 jl	 SHORT $LN8@Advance
  0008c	8b 4d ec	 mov	 ecx, DWORD PTR tv173[ebp]
  0008f	51		 push	 ecx
  00090	e8 00 00 00 00	 call	 ___asan_report_store4
  00095	83 c4 04	 add	 esp, 4
$LN8@Advance:
  00098	8b 55 d0	 mov	 edx, DWORD PTR tv65[ebp]
  0009b	8b 45 b8	 mov	 eax, DWORD PTR tv66[ebp]
  0009e	89 02		 mov	 DWORD PTR [edx], eax

; 2027 :         _Myptr += _Myoff / _VBITS;

  000a0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000a3	83 c1 0c	 add	 ecx, 12			; 0000000cH
  000a6	89 4d cc	 mov	 DWORD PTR tv68[ebp], ecx
  000a9	8b 55 cc	 mov	 edx, DWORD PTR tv68[ebp]
  000ac	89 55 e8	 mov	 DWORD PTR tv163[ebp], edx
  000af	8b 45 e8	 mov	 eax, DWORD PTR tv163[ebp]
  000b2	c1 e8 03	 shr	 eax, 3
  000b5	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000bb	88 4d fd	 mov	 BYTE PTR tv166[ebp], cl
  000be	80 7d fd 00	 cmp	 BYTE PTR tv166[ebp], 0
  000c2	74 1a		 je	 SHORT $LN7@Advance
  000c4	8a 55 e8	 mov	 dl, BYTE PTR tv163[ebp]
  000c7	80 e2 07	 and	 dl, 7
  000ca	80 c2 03	 add	 dl, 3
  000cd	3a 55 fd	 cmp	 dl, BYTE PTR tv166[ebp]
  000d0	7c 0c		 jl	 SHORT $LN7@Advance
  000d2	8b 45 e8	 mov	 eax, DWORD PTR tv163[ebp]
  000d5	50		 push	 eax
  000d6	e8 00 00 00 00	 call	 ___asan_report_load4
  000db	83 c4 04	 add	 esp, 4
$LN7@Advance:
  000de	8b 4d cc	 mov	 ecx, DWORD PTR tv68[ebp]
  000e1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000e3	c1 ea 05	 shr	 edx, 5
  000e6	c1 e2 02	 shl	 edx, 2
  000e9	89 55 b4	 mov	 DWORD PTR tv70[ebp], edx
  000ec	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  000ef	83 c0 08	 add	 eax, 8
  000f2	89 45 c8	 mov	 DWORD PTR tv67[ebp], eax
  000f5	8b 4d c8	 mov	 ecx, DWORD PTR tv67[ebp]
  000f8	89 4d e4	 mov	 DWORD PTR tv153[ebp], ecx
  000fb	8b 55 e4	 mov	 edx, DWORD PTR tv153[ebp]
  000fe	c1 ea 03	 shr	 edx, 3
  00101	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00107	88 45 fc	 mov	 BYTE PTR tv156[ebp], al
  0010a	80 7d fc 00	 cmp	 BYTE PTR tv156[ebp], 0
  0010e	74 1a		 je	 SHORT $LN6@Advance
  00110	8a 4d e4	 mov	 cl, BYTE PTR tv153[ebp]
  00113	80 e1 07	 and	 cl, 7
  00116	80 c1 03	 add	 cl, 3
  00119	3a 4d fc	 cmp	 cl, BYTE PTR tv156[ebp]
  0011c	7c 0c		 jl	 SHORT $LN6@Advance
  0011e	8b 55 e4	 mov	 edx, DWORD PTR tv153[ebp]
  00121	52		 push	 edx
  00122	e8 00 00 00 00	 call	 ___asan_report_load4
  00127	83 c4 04	 add	 esp, 4
$LN6@Advance:
  0012a	8b 45 c8	 mov	 eax, DWORD PTR tv67[ebp]
  0012d	8b 08		 mov	 ecx, DWORD PTR [eax]
  0012f	03 4d b4	 add	 ecx, DWORD PTR tv70[ebp]
  00132	89 4d b0	 mov	 DWORD PTR tv72[ebp], ecx
  00135	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  00138	83 c2 08	 add	 edx, 8
  0013b	89 55 c4	 mov	 DWORD PTR tv71[ebp], edx
  0013e	8b 45 c4	 mov	 eax, DWORD PTR tv71[ebp]
  00141	89 45 e0	 mov	 DWORD PTR tv143[ebp], eax
  00144	8b 4d e0	 mov	 ecx, DWORD PTR tv143[ebp]
  00147	c1 e9 03	 shr	 ecx, 3
  0014a	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00150	88 55 fb	 mov	 BYTE PTR tv146[ebp], dl
  00153	80 7d fb 00	 cmp	 BYTE PTR tv146[ebp], 0
  00157	74 18		 je	 SHORT $LN5@Advance
  00159	8a 45 e0	 mov	 al, BYTE PTR tv143[ebp]
  0015c	24 07		 and	 al, 7
  0015e	04 03		 add	 al, 3
  00160	3a 45 fb	 cmp	 al, BYTE PTR tv146[ebp]
  00163	7c 0c		 jl	 SHORT $LN5@Advance
  00165	8b 4d e0	 mov	 ecx, DWORD PTR tv143[ebp]
  00168	51		 push	 ecx
  00169	e8 00 00 00 00	 call	 ___asan_report_store4
  0016e	83 c4 04	 add	 esp, 4
$LN5@Advance:
  00171	8b 55 c4	 mov	 edx, DWORD PTR tv71[ebp]
  00174	8b 45 b0	 mov	 eax, DWORD PTR tv72[ebp]
  00177	89 02		 mov	 DWORD PTR [edx], eax

; 2028 :         _Myoff %= _VBITS;

  00179	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0017c	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0017f	89 4d c0	 mov	 DWORD PTR tv73[ebp], ecx
  00182	8b 55 c0	 mov	 edx, DWORD PTR tv73[ebp]
  00185	89 55 dc	 mov	 DWORD PTR tv133[ebp], edx
  00188	8b 45 dc	 mov	 eax, DWORD PTR tv133[ebp]
  0018b	c1 e8 03	 shr	 eax, 3
  0018e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00194	88 4d fa	 mov	 BYTE PTR tv136[ebp], cl
  00197	80 7d fa 00	 cmp	 BYTE PTR tv136[ebp], 0
  0019b	74 1a		 je	 SHORT $LN4@Advance
  0019d	8a 55 dc	 mov	 dl, BYTE PTR tv133[ebp]
  001a0	80 e2 07	 and	 dl, 7
  001a3	80 c2 03	 add	 dl, 3
  001a6	3a 55 fa	 cmp	 dl, BYTE PTR tv136[ebp]
  001a9	7c 0c		 jl	 SHORT $LN4@Advance
  001ab	8b 45 dc	 mov	 eax, DWORD PTR tv133[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 ___asan_report_load4
  001b4	83 c4 04	 add	 esp, 4
$LN4@Advance:
  001b7	8b 4d c0	 mov	 ecx, DWORD PTR tv73[ebp]
  001ba	8b 01		 mov	 eax, DWORD PTR [ecx]
  001bc	33 d2		 xor	 edx, edx
  001be	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001c3	f7 f1		 div	 ecx
  001c5	89 55 ac	 mov	 DWORD PTR tv75[ebp], edx
  001c8	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  001cb	83 c2 0c	 add	 edx, 12			; 0000000cH
  001ce	89 55 bc	 mov	 DWORD PTR tv74[ebp], edx
  001d1	8b 45 bc	 mov	 eax, DWORD PTR tv74[ebp]
  001d4	89 45 d8	 mov	 DWORD PTR tv91[ebp], eax
  001d7	8b 4d d8	 mov	 ecx, DWORD PTR tv91[ebp]
  001da	c1 e9 03	 shr	 ecx, 3
  001dd	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e3	88 55 f9	 mov	 BYTE PTR tv94[ebp], dl
  001e6	80 7d f9 00	 cmp	 BYTE PTR tv94[ebp], 0
  001ea	74 18		 je	 SHORT $LN3@Advance
  001ec	8a 45 d8	 mov	 al, BYTE PTR tv91[ebp]
  001ef	24 07		 and	 al, 7
  001f1	04 03		 add	 al, 3
  001f3	3a 45 f9	 cmp	 al, BYTE PTR tv94[ebp]
  001f6	7c 0c		 jl	 SHORT $LN3@Advance
  001f8	8b 4d d8	 mov	 ecx, DWORD PTR tv91[ebp]
  001fb	51		 push	 ecx
  001fc	e8 00 00 00 00	 call	 ___asan_report_store4
  00201	83 c4 04	 add	 esp, 4
$LN3@Advance:
  00204	8b 55 bc	 mov	 edx, DWORD PTR tv74[ebp]
  00207	8b 45 ac	 mov	 eax, DWORD PTR tv75[ebp]
  0020a	89 02		 mov	 DWORD PTR [edx], eax

; 2029 :     }

  0020c	8b e5		 mov	 esp, ebp
  0020e	5d		 pop	 ebp
  0020f	c2 04 00	 ret	 4
?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z
_TEXT	SEGMENT
tv76 = -24						; size = 4
tv75 = -20						; size = 4
tv87 = -16						; size = 4
tv129 = -12						; size = 4
_this$ = -8						; size = 4
tv90 = -2						; size = 1
tv132 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Mypvbool$ = 16					; size = 4
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z PROC ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >, COMDAT
; _this$ = ecx

; 2018 :         : _Myptr(_Ptr), _Myoff(_Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00013	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00016	e8 00 00 00 00	 call	 ??0_Iterator_base12@std@@QAE@XZ ; std::_Iterator_base12::_Iterator_base12
  0001b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0001e	83 c0 08	 add	 eax, 8
  00021	89 45 ec	 mov	 DWORD PTR tv75[ebp], eax
  00024	8b 4d ec	 mov	 ecx, DWORD PTR tv75[ebp]
  00027	89 4d f4	 mov	 DWORD PTR tv129[ebp], ecx
  0002a	8b 55 f4	 mov	 edx, DWORD PTR tv129[ebp]
  0002d	c1 ea 03	 shr	 edx, 3
  00030	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00036	88 45 ff	 mov	 BYTE PTR tv132[ebp], al
  00039	80 7d ff 00	 cmp	 BYTE PTR tv132[ebp], 0
  0003d	74 1a		 je	 SHORT $LN4@Vb_iter_ba
  0003f	8a 4d f4	 mov	 cl, BYTE PTR tv129[ebp]
  00042	80 e1 07	 and	 cl, 7
  00045	80 c1 03	 add	 cl, 3
  00048	3a 4d ff	 cmp	 cl, BYTE PTR tv132[ebp]
  0004b	7c 0c		 jl	 SHORT $LN4@Vb_iter_ba
  0004d	8b 55 f4	 mov	 edx, DWORD PTR tv129[ebp]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 ___asan_report_store4
  00056	83 c4 04	 add	 esp, 4
$LN4@Vb_iter_ba:
  00059	8b 45 ec	 mov	 eax, DWORD PTR tv75[ebp]
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0005f	89 08		 mov	 DWORD PTR [eax], ecx
  00061	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00064	83 c2 0c	 add	 edx, 12			; 0000000cH
  00067	89 55 e8	 mov	 DWORD PTR tv76[ebp], edx
  0006a	8b 45 e8	 mov	 eax, DWORD PTR tv76[ebp]
  0006d	89 45 f0	 mov	 DWORD PTR tv87[ebp], eax
  00070	8b 4d f0	 mov	 ecx, DWORD PTR tv87[ebp]
  00073	c1 e9 03	 shr	 ecx, 3
  00076	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0007c	88 55 fe	 mov	 BYTE PTR tv90[ebp], dl
  0007f	80 7d fe 00	 cmp	 BYTE PTR tv90[ebp], 0
  00083	74 18		 je	 SHORT $LN3@Vb_iter_ba
  00085	8a 45 f0	 mov	 al, BYTE PTR tv87[ebp]
  00088	24 07		 and	 al, 7
  0008a	04 03		 add	 al, 3
  0008c	3a 45 fe	 cmp	 al, BYTE PTR tv90[ebp]
  0008f	7c 0c		 jl	 SHORT $LN3@Vb_iter_ba
  00091	8b 4d f0	 mov	 ecx, DWORD PTR tv87[ebp]
  00094	51		 push	 ecx
  00095	e8 00 00 00 00	 call	 ___asan_report_store4
  0009a	83 c4 04	 add	 esp, 4
$LN3@Vb_iter_ba:
  0009d	8b 55 e8	 mov	 edx, DWORD PTR tv76[ebp]
  000a0	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  000a3	89 02		 mov	 DWORD PTR [edx], eax

; 2019 :         this->_Adopt(_Mypvbool);

  000a5	8b 4d 10	 mov	 ecx, DWORD PTR __Mypvbool$[ebp]
  000a8	51		 push	 ecx
  000a9	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ac	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 2020 :     }

  000b1	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000b4	8b e5		 mov	 esp, ebp
  000b6	5d		 pop	 ebp
  000b7	c2 0c 00	 ret	 12			; 0000000cH
??0?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIIPBU_Container_base12@1@@Z ENDP ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ PROC ; std::vector<bool,std::allocator<bool> >::_Xran, COMDAT
; _this$ = ecx

; 3096 :     [[noreturn]] void _Xran() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3097 :         _Xout_of_range("invalid vector<bool> subscript");

  00011	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@BKHLLOGL@invalid?5vector?$DMbool?$DO?5subscript@
  00016	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xran:

; 3098 :     }

  0001b	8b e5		 mov	 esp, ebp
  0001d	5d		 pop	 ebp
  0001e	c3		 ret	 0
?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ENDP ; std::vector<bool,std::allocator<bool> >::_Xran
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
__It$ = -88						; size = 16
tv149 = -33						; size = 1
tv139 = -32						; size = 4
tv146 = -28						; size = 4
tv64 = -24						; size = 4
_this$ = -20						; size = 4
tv137 = -16						; size = 4
tv142 = -12						; size = 4
tv89 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z PROC ; std::vector<bool,std::allocator<bool> >::operator[], COMDAT
; _this$ = ecx

; 2834 :     _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](size_type _Off) noexcept /* strengthened */ {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv137[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv137[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e0	 mov	 DWORD PTR tv139[ebp], ecx
  00053	8b 55 e0	 mov	 edx, DWORD PTR tv139[ebp]
  00056	c7 02 f1 f1 00
	00		 mov	 DWORD PTR [edx], 61937	; 0000f1f1H
  0005c	83 45 e0 04	 add	 DWORD PTR tv139[ebp], 4
  00060	8b 45 e0	 mov	 eax, DWORD PTR tv139[ebp]
  00063	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  00069	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0006e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@operator:

; 2835 : #if _CONTAINER_DEBUG_LEVEL > 0
; 2836 :         _STL_VERIFY(_Off < this->_Mysize, "vector<bool> subscript out of range");

  00073	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00076	83 c1 14	 add	 ecx, 20			; 00000014H
  00079	89 4d e8	 mov	 DWORD PTR tv64[ebp], ecx
  0007c	8b 55 e8	 mov	 edx, DWORD PTR tv64[ebp]
  0007f	89 55 e4	 mov	 DWORD PTR tv146[ebp], edx
  00082	8b 45 e4	 mov	 eax, DWORD PTR tv146[ebp]
  00085	c1 e8 03	 shr	 eax, 3
  00088	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0008e	88 4d df	 mov	 BYTE PTR tv149[ebp], cl
  00091	80 7d df 00	 cmp	 BYTE PTR tv149[ebp], 0
  00095	74 1a		 je	 SHORT $LN12@operator
  00097	8a 55 e4	 mov	 dl, BYTE PTR tv146[ebp]
  0009a	80 e2 07	 and	 dl, 7
  0009d	80 c2 03	 add	 dl, 3
  000a0	3a 55 df	 cmp	 dl, BYTE PTR tv149[ebp]
  000a3	7c 0c		 jl	 SHORT $LN12@operator
  000a5	8b 45 e4	 mov	 eax, DWORD PTR tv146[ebp]
  000a8	50		 push	 eax
  000a9	e8 00 00 00 00	 call	 ___asan_report_load4
  000ae	83 c4 04	 add	 esp, 4
$LN12@operator:
  000b1	8b 4d e8	 mov	 ecx, DWORD PTR tv64[ebp]
  000b4	8b 53 0c	 mov	 edx, DWORD PTR __Off$[ebx]
  000b7	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000b9	73 02		 jae	 SHORT $LN7@operator
  000bb	eb 4a		 jmp	 SHORT $LN2@operator
$LN7@operator:
  000bd	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@FFEOOBMH@vector?$DMbool?$DO?5subscript?5out?5of?5r@
  000c2	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000c7	6a 00		 push	 0
  000c9	68 14 0b 00 00	 push	 2836			; 00000b14H
  000ce	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@KMHDIFOI@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  000d3	6a 02		 push	 2
  000d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  000db	83 c4 18	 add	 esp, 24			; 00000018H
  000de	83 f8 01	 cmp	 eax, 1
  000e1	75 01		 jne	 SHORT $LN11@operator
  000e3	cc		 int	 3
$LN11@operator:
  000e4	6a 00		 push	 0
  000e6	68 14 0b 00 00	 push	 2836			; 00000b14H
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_1MO@NOHEJINP@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_1HG@KMENFMCO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo@
  000f5	68 00 00 00 00	 push	 OFFSET ??_C@_1EM@HCHFCCIP@?$AA?$CC?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?$DM?$AAb?$AAo?$AAo?$AAl?$AA?$DO?$AA?5?$AAs@
  000fa	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00100	83 c4 14	 add	 esp, 20			; 00000014H
  00103	33 c9		 xor	 ecx, ecx
  00105	75 b6		 jne	 SHORT $LN7@operator
$LN2@operator:
  00107	33 d2		 xor	 edx, edx
  00109	0f 85 64 ff ff
	ff		 jne	 $LN4@operator

; 2837 : #endif // _CONTAINER_DEBUG_LEVEL > 0
; 2838 : 
; 2839 :         iterator _It = begin();

  0010f	6a 10		 push	 16			; 00000010H
  00111	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  00114	e8 00 00 00 00	 call	 ?__autoclassinit2@?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z
  00119	8d 45 a8	 lea	 eax, DWORD PTR __It$[ebp]
  0011c	50		 push	 eax
  0011d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00120	e8 00 00 00 00	 call	 ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ; std::vector<bool,std::allocator<bool> >::begin

; 2840 :         _It._Advance(_Off);

  00125	8b 4b 0c	 mov	 ecx, DWORD PTR __Off$[ebx]
  00128	51		 push	 ecx
  00129	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  0012c	e8 00 00 00 00	 call	 ?_Advance@?$_Vb_iter_base@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAEXI@Z ; std::_Vb_iter_base<std::_Wrap_alloc<std::allocator<unsigned int> > >::_Advance

; 2841 :         return *_It;

  00131	8b 53 08	 mov	 edx, DWORD PTR ___$ReturnUdt$[ebx]
  00134	52		 push	 edx
  00135	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  00138	e8 00 00 00 00	 call	 ??D?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@XZ ; std::_Vb_iterator<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator*
  0013d	8d 4d a8	 lea	 ecx, DWORD PTR __It$[ebp]
  00140	e8 00 00 00 00	 call	 ??1?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00145	8b 43 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebx]
  00148	89 45 f8	 mov	 DWORD PTR tv89[ebp], eax
  0014b	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00152	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00155	c1 e9 03	 shr	 ecx, 3
  00158	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0015e	89 4d f4	 mov	 DWORD PTR tv142[ebp], ecx
  00161	6a 08		 push	 8
  00163	8b 55 f4	 mov	 edx, DWORD PTR tv142[ebp]
  00166	52		 push	 edx
  00167	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0016c	83 c4 08	 add	 esp, 8
  0016f	8b 45 f8	 mov	 eax, DWORD PTR tv89[ebp]

; 2842 :     }

  00172	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00175	33 cd		 xor	 ecx, ebp
  00177	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0017c	8b e5		 mov	 esp, ebp
  0017e	5d		 pop	 ebp
  0017f	8b e3		 mov	 esp, ebx
  00181	5b		 pop	 ebx
  00182	c2 08 00	 ret	 8
??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z PROC ; std::vector<bool,std::allocator<bool> >::at, COMDAT
; _this$ = ecx

; 2816 :     _NODISCARD _CONSTEXPR20_CONTAINER reference at(size_type _Off) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR $T1[ebp], 0
  00010	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00015	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2817 :         if (size() <= _Off) {

  0001a	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0001d	e8 00 00 00 00	 call	 ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ; std::vector<bool,std::allocator<bool> >::size
  00022	3b 45 0c	 cmp	 eax, DWORD PTR __Off$[ebp]
  00025	77 08		 ja	 SHORT $LN2@at

; 2818 :             _Xran();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Xran@?$vector@_NV?$allocator@_N@std@@@std@@QBEXXZ ; std::vector<bool,std::allocator<bool> >::_Xran
$LN2@at:

; 2819 :         }
; 2820 : 
; 2821 :         return (*this)[_Off];

  0002f	8b 45 0c	 mov	 eax, DWORD PTR __Off$[ebp]
  00032	50		 push	 eax
  00033	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00036	51		 push	 ecx
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0003a	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  0003f	8b 55 f8	 mov	 edx, DWORD PTR $T1[ebp]
  00042	83 ca 01	 or	 edx, 1
  00045	89 55 f8	 mov	 DWORD PTR $T1[ebp], edx
  00048	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN3@at:

; 2822 :     }

  0004b	8b e5		 mov	 esp, ebp
  0004d	5d		 pop	 ebp
  0004e	c2 08 00	 ret	 8
?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ENDP ; std::vector<bool,std::allocator<bool> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv64 = -12						; size = 4
tv72 = -8						; size = 4
tv75 = -1						; size = 1
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ PROC	; std::vector<bool,std::allocator<bool> >::size, COMDAT
; _this$ = ecx

; 2785 :     _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2786 :         return this->_Mysize;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 14	 add	 eax, 20			; 00000014H
  00019	89 45 f4	 mov	 DWORD PTR tv64[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@size
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv72[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv75[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@size
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@size:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv64[ebp]
  00054	8b 00		 mov	 eax, DWORD PTR [eax]

; 2787 :     }

  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
?size@?$vector@_NV?$allocator@_N@std@@@std@@QBEIXZ ENDP	; std::vector<bool,std::allocator<bool> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ PROC ; std::vector<bool,std::allocator<bool> >::begin, COMDAT
; _this$ = ecx

; 2697 :     _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2698 :         return iterator(this->_Myvec.data(), this);

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]
  00014	50		 push	 eax
  00015	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00018	83 c1 04	 add	 ecx, 4
  0001b	e8 00 00 00 00	 call	 ?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::data
  00020	50		 push	 eax
  00021	8b 4d 08	 mov	 ecx, DWORD PTR ___$ReturnUdt$[ebp]
  00024	e8 00 00 00 00	 call	 ??0?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@PBIPBU_Container_base12@1@@Z
  00029	8b 45 08	 mov	 eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2699 :     }

  0002c	8b e5		 mov	 esp, ebp
  0002e	5d		 pop	 ebp
  0002f	c2 04 00	 ret	 4
?begin@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_iterator@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@XZ ENDP ; std::vector<bool,std::allocator<bool> >::begin
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2649 :     _CONSTEXPR20_CONTAINER ~vector() noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ PROC ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1397 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1398 :         return *this;

  00011	8b 45 fc	 mov	 eax, DWORD PTR _this$[ebp]

; 1399 :     }

  00014	8b e5		 mov	 esp, ebp
  00016	5d		 pop	 ebp
  00017	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ENDP ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal, COMDAT
; _this$ = ecx

; 1817 :     _NODISCARD _CONSTEXPR20_CONTAINER _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1818 :         return _Mypair._Get_first();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@I@std@@V?$_Vector_val@U?$_Simple_types@I@std@@@2@$00@std@@QAEAAV?$allocator@I@2@XZ ; std::_Compressed_pair<std::allocator<unsigned int>,std::_Vector_val<std::_Simple_types<unsigned int> >,1>::_Get_first

; 1819 :     }

  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
_TEXT	SEGMENT
tv142 = -108						; size = 4
tv139 = -104						; size = 4
tv136 = -100						; size = 4
tv90 = -96						; size = 4
tv86 = -92						; size = 4
tv88 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv92 = -72						; size = 4
tv145 = -68						; size = 4
__Mylast$ = -64						; size = 4
tv155 = -60						; size = 4
tv165 = -56						; size = 4
tv175 = -52						; size = 4
tv185 = -48						; size = 4
tv195 = -44						; size = 4
_this$ = -40						; size = 4
tv205 = -36						; size = 4
__Myend$ = -32						; size = 4
__My_data$ = -28					; size = 4
__Myfirst$ = -24					; size = 4
tv148 = -19						; size = 1
tv158 = -18						; size = 1
tv168 = -17						; size = 1
tv178 = -16						; size = 1
tv188 = -15						; size = 1
tv198 = -14						; size = 1
tv208 = -13						; size = 1
__$EHRec$ = -12						; size = 12
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy, COMDAT
; _this$ = ecx

; 1755 :     _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	83 ec 60	 sub	 esp, 96			; 00000060H
  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00019	33 c5		 xor	 eax, ebp
  0001b	50		 push	 eax
  0001c	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0001f	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00025	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx
  00028	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0002d	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1756 :         auto& _My_data    = _Mypair._Myval2;

  00032	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	89 45 e4	 mov	 DWORD PTR __My_data$[ebp], eax

; 1757 :         pointer& _Myfirst = _My_data._Myfirst;

  00038	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0003b	83 c1 04	 add	 ecx, 4
  0003e	89 4d e8	 mov	 DWORD PTR __Myfirst$[ebp], ecx

; 1758 :         pointer& _Mylast  = _My_data._Mylast;

  00041	8b 55 e4	 mov	 edx, DWORD PTR __My_data$[ebp]
  00044	83 c2 08	 add	 edx, 8
  00047	89 55 c0	 mov	 DWORD PTR __Mylast$[ebp], edx

; 1759 :         pointer& _Myend   = _My_data._Myend;

  0004a	8b 45 e4	 mov	 eax, DWORD PTR __My_data$[ebp]
  0004d	83 c0 0c	 add	 eax, 12			; 0000000cH
  00050	89 45 e0	 mov	 DWORD PTR __Myend$[ebp], eax

; 1760 : 
; 1761 :         _My_data._Orphan_all();

  00053	8b 4d e4	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00056	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 1762 : 
; 1763 :         if (_Myfirst) { // destroy and deallocate old array

  0005b	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0005e	89 4d b8	 mov	 DWORD PTR tv92[ebp], ecx
  00061	8b 55 b8	 mov	 edx, DWORD PTR tv92[ebp]
  00064	89 55 dc	 mov	 DWORD PTR tv205[ebp], edx
  00067	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d f3	 mov	 BYTE PTR tv208[ebp], cl
  00076	80 7d f3 00	 cmp	 BYTE PTR tv208[ebp], 0
  0007a	74 1a		 je	 SHORT $LN10@Tidy
  0007c	8a 55 dc	 mov	 dl, BYTE PTR tv205[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 f3	 cmp	 dl, BYTE PTR tv208[ebp]
  00088	7c 0c		 jl	 SHORT $LN10@Tidy
  0008a	8b 45 dc	 mov	 eax, DWORD PTR tv205[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN10@Tidy:
  00096	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  00099	83 39 00	 cmp	 DWORD PTR [ecx], 0
  0009c	0f 84 c2 01 00
	00		 je	 $LN3@Tidy

; 1764 :             _Destroy(_Myfirst, _Mylast);

  000a2	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	50		 push	 eax
  000a8	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	52		 push	 edx
  000ae	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b1	e8 00 00 00 00	 call	 ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy

; 1765 :             _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

  000b6	8b 4d d8	 mov	 ecx, DWORD PTR _this$[ebp]
  000b9	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  000be	89 45 a0	 mov	 DWORD PTR tv90[ebp], eax
  000c1	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  000c4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000c7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000ca	89 4d d4	 mov	 DWORD PTR tv195[ebp], ecx
  000cd	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000d0	c1 ea 03	 shr	 edx, 3
  000d3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000d9	88 45 f2	 mov	 BYTE PTR tv198[ebp], al
  000dc	80 7d f2 00	 cmp	 BYTE PTR tv198[ebp], 0
  000e0	74 1a		 je	 SHORT $LN9@Tidy
  000e2	8a 4d d4	 mov	 cl, BYTE PTR tv195[ebp]
  000e5	80 e1 07	 and	 cl, 7
  000e8	80 c1 03	 add	 cl, 3
  000eb	3a 4d f2	 cmp	 cl, BYTE PTR tv198[ebp]
  000ee	7c 0c		 jl	 SHORT $LN9@Tidy
  000f0	8b 55 d4	 mov	 edx, DWORD PTR tv195[ebp]
  000f3	52		 push	 edx
  000f4	e8 00 00 00 00	 call	 ___asan_report_load4
  000f9	83 c4 04	 add	 esp, 4
$LN9@Tidy:
  000fc	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  000ff	89 45 b0	 mov	 DWORD PTR tv130[ebp], eax
  00102	8b 4d b0	 mov	 ecx, DWORD PTR tv130[ebp]
  00105	89 4d d0	 mov	 DWORD PTR tv185[ebp], ecx
  00108	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0010b	c1 ea 03	 shr	 edx, 3
  0010e	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00114	88 45 f1	 mov	 BYTE PTR tv188[ebp], al
  00117	80 7d f1 00	 cmp	 BYTE PTR tv188[ebp], 0
  0011b	74 1a		 je	 SHORT $LN8@Tidy
  0011d	8a 4d d0	 mov	 cl, BYTE PTR tv185[ebp]
  00120	80 e1 07	 and	 cl, 7
  00123	80 c1 03	 add	 cl, 3
  00126	3a 4d f1	 cmp	 cl, BYTE PTR tv188[ebp]
  00129	7c 0c		 jl	 SHORT $LN8@Tidy
  0012b	8b 55 d0	 mov	 edx, DWORD PTR tv185[ebp]
  0012e	52		 push	 edx
  0012f	e8 00 00 00 00	 call	 ___asan_report_load4
  00134	83 c4 04	 add	 esp, 4
$LN8@Tidy:
  00137	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0013a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0013d	8b 10		 mov	 edx, DWORD PTR [eax]
  0013f	2b 11		 sub	 edx, DWORD PTR [ecx]
  00141	c1 fa 02	 sar	 edx, 2
  00144	89 55 a8	 mov	 DWORD PTR tv88[ebp], edx
  00147	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  0014a	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  0014d	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00150	89 4d cc	 mov	 DWORD PTR tv175[ebp], ecx
  00153	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00156	c1 ea 03	 shr	 edx, 3
  00159	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0015f	88 45 f0	 mov	 BYTE PTR tv178[ebp], al
  00162	80 7d f0 00	 cmp	 BYTE PTR tv178[ebp], 0
  00166	74 1a		 je	 SHORT $LN7@Tidy
  00168	8a 4d cc	 mov	 cl, BYTE PTR tv175[ebp]
  0016b	80 e1 07	 and	 cl, 7
  0016e	80 c1 03	 add	 cl, 3
  00171	3a 4d f0	 cmp	 cl, BYTE PTR tv178[ebp]
  00174	7c 0c		 jl	 SHORT $LN7@Tidy
  00176	8b 55 cc	 mov	 edx, DWORD PTR tv175[ebp]
  00179	52		 push	 edx
  0017a	e8 00 00 00 00	 call	 ___asan_report_load4
  0017f	83 c4 04	 add	 esp, 4
$LN7@Tidy:
  00182	8b 45 e8	 mov	 eax, DWORD PTR __Myfirst$[ebp]
  00185	8b 08		 mov	 ecx, DWORD PTR [eax]
  00187	89 4d a4	 mov	 DWORD PTR tv86[ebp], ecx
  0018a	8b 55 a8	 mov	 edx, DWORD PTR tv88[ebp]
  0018d	52		 push	 edx
  0018e	8b 45 a4	 mov	 eax, DWORD PTR tv86[ebp]
  00191	50		 push	 eax
  00192	8b 4d a0	 mov	 ecx, DWORD PTR tv90[ebp]
  00195	e8 00 00 00 00	 call	 ?deallocate@?$allocator@I@std@@QAEXQAII@Z ; std::allocator<unsigned int>::deallocate

; 1766 : 
; 1767 :             _Myfirst = nullptr;

  0019a	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  0019d	89 4d 9c	 mov	 DWORD PTR tv136[ebp], ecx
  001a0	8b 55 9c	 mov	 edx, DWORD PTR tv136[ebp]
  001a3	89 55 c8	 mov	 DWORD PTR tv165[ebp], edx
  001a6	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001a9	c1 e8 03	 shr	 eax, 3
  001ac	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001b2	88 4d ef	 mov	 BYTE PTR tv168[ebp], cl
  001b5	80 7d ef 00	 cmp	 BYTE PTR tv168[ebp], 0
  001b9	74 1a		 je	 SHORT $LN6@Tidy
  001bb	8a 55 c8	 mov	 dl, BYTE PTR tv165[ebp]
  001be	80 e2 07	 and	 dl, 7
  001c1	80 c2 03	 add	 dl, 3
  001c4	3a 55 ef	 cmp	 dl, BYTE PTR tv168[ebp]
  001c7	7c 0c		 jl	 SHORT $LN6@Tidy
  001c9	8b 45 c8	 mov	 eax, DWORD PTR tv165[ebp]
  001cc	50		 push	 eax
  001cd	e8 00 00 00 00	 call	 ___asan_report_store4
  001d2	83 c4 04	 add	 esp, 4
$LN6@Tidy:
  001d5	8b 4d e8	 mov	 ecx, DWORD PTR __Myfirst$[ebp]
  001d8	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1768 :             _Mylast  = nullptr;

  001de	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  001e1	89 55 98	 mov	 DWORD PTR tv139[ebp], edx
  001e4	8b 45 98	 mov	 eax, DWORD PTR tv139[ebp]
  001e7	89 45 c4	 mov	 DWORD PTR tv155[ebp], eax
  001ea	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  001ed	c1 e9 03	 shr	 ecx, 3
  001f0	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001f6	88 55 ee	 mov	 BYTE PTR tv158[ebp], dl
  001f9	80 7d ee 00	 cmp	 BYTE PTR tv158[ebp], 0
  001fd	74 18		 je	 SHORT $LN5@Tidy
  001ff	8a 45 c4	 mov	 al, BYTE PTR tv155[ebp]
  00202	24 07		 and	 al, 7
  00204	04 03		 add	 al, 3
  00206	3a 45 ee	 cmp	 al, BYTE PTR tv158[ebp]
  00209	7c 0c		 jl	 SHORT $LN5@Tidy
  0020b	8b 4d c4	 mov	 ecx, DWORD PTR tv155[ebp]
  0020e	51		 push	 ecx
  0020f	e8 00 00 00 00	 call	 ___asan_report_store4
  00214	83 c4 04	 add	 esp, 4
$LN5@Tidy:
  00217	8b 55 c0	 mov	 edx, DWORD PTR __Mylast$[ebp]
  0021a	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 1769 :             _Myend   = nullptr;

  00220	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  00223	89 45 94	 mov	 DWORD PTR tv142[ebp], eax
  00226	8b 4d 94	 mov	 ecx, DWORD PTR tv142[ebp]
  00229	89 4d bc	 mov	 DWORD PTR tv145[ebp], ecx
  0022c	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  0022f	c1 ea 03	 shr	 edx, 3
  00232	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00238	88 45 ed	 mov	 BYTE PTR tv148[ebp], al
  0023b	80 7d ed 00	 cmp	 BYTE PTR tv148[ebp], 0
  0023f	74 1a		 je	 SHORT $LN4@Tidy
  00241	8a 4d bc	 mov	 cl, BYTE PTR tv145[ebp]
  00244	80 e1 07	 and	 cl, 7
  00247	80 c1 03	 add	 cl, 3
  0024a	3a 4d ed	 cmp	 cl, BYTE PTR tv148[ebp]
  0024d	7c 0c		 jl	 SHORT $LN4@Tidy
  0024f	8b 55 bc	 mov	 edx, DWORD PTR tv145[ebp]
  00252	52		 push	 edx
  00253	e8 00 00 00 00	 call	 ___asan_report_store4
  00258	83 c4 04	 add	 esp, 4
$LN4@Tidy:
  0025b	8b 45 e0	 mov	 eax, DWORD PTR __Myend$[ebp]
  0025e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN3@Tidy:

; 1770 :         }
; 1771 :     }

  00264	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00267	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0026e	59		 pop	 ecx
  0026f	8b e5		 mov	 esp, ebp
  00271	5d		 pop	 ebp
  00272	c3		 ret	 0
  00273	cc		 int	 3
  00274	cc		 int	 3
  00275	cc		 int	 3
  00276	cc		 int	 3
  00277	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 4a 9c	 mov	 ecx, DWORD PTR [edx-100]
  0000c	33 c8		 xor	 ecx, eax
  0000e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00013	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ
  00018	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z PROC ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy, COMDAT
; _this$ = ecx

; 1678 :     _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1679 :         // destroy [_First, _Last) using allocator
; 1680 :         _Destroy_range(_First, _Last, _Getal());

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  00019	50		 push	 eax
  0001a	8b 45 0c	 mov	 eax, DWORD PTR __Last$[ebp]
  0001d	50		 push	 eax
  0001e	8b 4d 08	 mov	 ecx, DWORD PTR __First$[ebp]
  00021	51		 push	 ecx
  00022	e8 00 00 00 00	 call	 ??$_Destroy_range@V?$allocator@I@std@@@std@@YAXPAIQAIAAV?$allocator@I@0@@Z ; std::_Destroy_range<std::allocator<unsigned int> >
  00027	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1681 :     }

  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c2 08 00	 ret	 8
?_Destroy@?$vector@IV?$allocator@I@std@@@std@@AAEXPAI0@Z ENDP ; std::vector<unsigned int,std::allocator<unsigned int> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv67 = -12						; size = 4
tv72 = -8						; size = 4
tv75 = -1						; size = 1
?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::data, COMDAT
; _this$ = ecx

; 1470 :     _NODISCARD _CONSTEXPR20_CONTAINER const _Ty* data() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1471 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@data
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv72[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv75[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@data
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@data:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ; std::_Unfancy_maybe_null<unsigned int>
  0005c	83 c4 04	 add	 esp, 4

; 1472 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?data@?$vector@IV?$allocator@I@std@@@std@@QBEPBIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
tv67 = -12						; size = 4
tv72 = -8						; size = 4
tv75 = -1						; size = 1
?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::data, COMDAT
; _this$ = ecx

; 1466 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty* data() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1467 :         return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	83 c0 04	 add	 eax, 4
  00019	89 45 f4	 mov	 DWORD PTR tv67[ebp], eax
  0001c	8b 4d f4	 mov	 ecx, DWORD PTR tv67[ebp]
  0001f	89 4d f8	 mov	 DWORD PTR tv72[ebp], ecx
  00022	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00025	c1 ea 03	 shr	 edx, 3
  00028	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002e	88 45 ff	 mov	 BYTE PTR tv75[ebp], al
  00031	80 7d ff 00	 cmp	 BYTE PTR tv75[ebp], 0
  00035	74 1a		 je	 SHORT $LN3@data
  00037	8a 4d f8	 mov	 cl, BYTE PTR tv72[ebp]
  0003a	80 e1 07	 and	 cl, 7
  0003d	80 c1 03	 add	 cl, 3
  00040	3a 4d ff	 cmp	 cl, BYTE PTR tv75[ebp]
  00043	7c 0c		 jl	 SHORT $LN3@data
  00045	8b 55 f8	 mov	 edx, DWORD PTR tv72[ebp]
  00048	52		 push	 edx
  00049	e8 00 00 00 00	 call	 ___asan_report_load4
  0004e	83 c4 04	 add	 esp, 4
$LN3@data:
  00051	8b 45 f4	 mov	 eax, DWORD PTR tv67[ebp]
  00054	8b 08		 mov	 ecx, DWORD PTR [eax]
  00056	51		 push	 ecx
  00057	e8 00 00 00 00	 call	 ??$_Unfancy_maybe_null@I@std@@YAPAIPAI@Z ; std::_Unfancy_maybe_null<unsigned int>
  0005c	83 c4 04	 add	 esp, 4

; 1468 :     }

  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?data@?$vector@IV?$allocator@I@std@@@std@@QAEPAIXZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S18$ = -88						; size = 1
$T2 = -72						; size = 4
tv134 = -29						; size = 1
tv86 = -28						; size = 4
tv131 = -24						; size = 4
_this$ = -20						; size = 4
tv84 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv95 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ PROC	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >, COMDAT
; _this$ = ecx

; 711  :     _CONSTEXPR20_CONTAINER ~vector() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv84[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv84[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv86[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv86[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv86[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv86[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv86[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 712  :         _Tidy();

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Tidy@?$vector@IV?$allocator@I@std@@@std@@AAEXXZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Tidy

; 713  : #if _ITERATOR_DEBUG_LEVEL != 0
; 714  :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  00092	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S18$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S18$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 715  :         _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d e8	 mov	 DWORD PTR tv131[ebp], ecx
  000af	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv134[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv134[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@vector
  000c4	8a 4d e8	 mov	 cl, BYTE PTR tv131[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv134[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@vector
  000d2	8b 55 e8	 mov	 edx, DWORD PTR tv131[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@vector:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 716  : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 717  :     }

  0010f	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00116	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00119	c1 e9 03	 shr	 ecx, 3
  0011c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00122	89 4d f8	 mov	 DWORD PTR tv95[ebp], ecx
  00125	6a 09		 push	 9
  00127	8b 55 f8	 mov	 edx, DWORD PTR tv95[ebp]
  0012a	52		 push	 edx
  0012b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00130	83 c4 08	 add	 esp, 8
  00133	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00136	33 cd		 xor	 ecx, ebp
  00138	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	8b e3		 mov	 esp, ebx
  00142	5b		 pop	 ebx
  00143	c3		 ret	 0
??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ENDP	; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ PROC ; std::_Vb_val<std::allocator<bool> >::_Getal, COMDAT
; _this$ = ecx

; 2464 :     _CONSTEXPR20_CONTAINER _Alvbase& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2465 :         return _Myvec._Getal();

  00011	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00014	83 c1 04	 add	 ecx, 4
  00017	e8 00 00 00 00	 call	 ?_Getal@?$vector@IV?$allocator@I@std@@@std@@AAEAAV?$allocator@I@2@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::_Getal

; 2466 :     }

  0001c	8b e5		 mov	 esp, ebp
  0001e	5d		 pop	 ebp
  0001f	c3		 ret	 0
?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ENDP ; std::_Vb_val<std::allocator<bool> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__asan_gen_0$ = -104					; size = 4
__asan_gen_1$ = -100					; size = 4
__asan_gen_2$ = -96					; size = 4
_$S15$ = -88						; size = 1
$T2 = -72						; size = 4
tv138 = -29						; size = 1
tv90 = -28						; size = 4
_this$ = -24						; size = 4
tv135 = -20						; size = 4
tv88 = -16						; size = 4
__Alproxy$ = -12					; size = 4
tv131 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ PROC	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >, COMDAT
; _this$ = ecx

; 2456 :     _CONSTEXPR20_CONTAINER ~_Vb_val() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 80 00 00
	00		 sub	 esp, 128		; 00000080H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00029	c7 45 98 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 45 9c 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ
  00037	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
  0003e	8d 45 98	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00041	89 45 f0	 mov	 DWORD PTR tv88[ebp], eax
  00044	8b 4d f0	 mov	 ecx, DWORD PTR tv88[ebp]
  00047	c1 e9 03	 shr	 ecx, 3
  0004a	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00050	89 4d e4	 mov	 DWORD PTR tv90[ebp], ecx
  00053	8b 55 e4	 mov	 edx, DWORD PTR tv90[ebp]
  00056	c7 02 f1 f1 01
	f2		 mov	 DWORD PTR [edx], -234753551 ; f201f1f1H
  0005c	83 45 e4 04	 add	 DWORD PTR tv90[ebp], 4
  00060	8b 45 e4	 mov	 eax, DWORD PTR tv90[ebp]
  00063	c7 00 f8 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116104 ; f3f3f3f8H
  00069	83 45 e4 04	 add	 DWORD PTR tv90[ebp], 4
  0006d	8b 4d e4	 mov	 ecx, DWORD PTR tv90[ebp]
  00070	c6 01 f3	 mov	 BYTE PTR [ecx], 243	; 000000f3H
  00073	8d 55 b8	 lea	 edx, DWORD PTR $T2[ebp]
  00076	c1 ea 03	 shr	 edx, 3
  00079	c6 82 00 00 00
	30 04		 mov	 BYTE PTR [edx+805306368], 4
  00080	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00085	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2457 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2458 :         this->_Orphan_all();

  0008a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 2459 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alvbase, this->_Getal());

  00092	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00095	e8 00 00 00 00	 call	 ?_Getal@?$_Vb_val@V?$allocator@_N@std@@@std@@QAEAAV?$allocator@I@2@XZ ; std::_Vb_val<std::allocator<bool> >::_Getal
  0009a	50		 push	 eax
  0009b	8d 4d a8	 lea	 ecx, DWORD PTR _$S15$[ebp]
  0009e	e8 00 00 00 00	 call	 ??$?0I@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@I@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><unsigned int>
  000a3	8d 45 a8	 lea	 eax, DWORD PTR _$S15$[ebp]
  000a6	89 45 f4	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 2460 :         _Delete_plain_internal(_Alproxy, _STD exchange(this->_Myproxy, nullptr));

  000a9	8d 4d b8	 lea	 ecx, DWORD PTR $T2[ebp]
  000ac	89 4d ec	 mov	 DWORD PTR tv135[ebp], ecx
  000af	8b 55 ec	 mov	 edx, DWORD PTR tv135[ebp]
  000b2	c1 ea 03	 shr	 edx, 3
  000b5	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000bb	88 45 e3	 mov	 BYTE PTR tv138[ebp], al
  000be	80 7d e3 00	 cmp	 BYTE PTR tv138[ebp], 0
  000c2	74 1a		 je	 SHORT $LN3@Vb_val
  000c4	8a 4d ec	 mov	 cl, BYTE PTR tv135[ebp]
  000c7	80 e1 07	 and	 cl, 7
  000ca	80 c1 03	 add	 cl, 3
  000cd	3a 4d e3	 cmp	 cl, BYTE PTR tv138[ebp]
  000d0	7c 0c		 jl	 SHORT $LN3@Vb_val
  000d2	8b 55 ec	 mov	 edx, DWORD PTR tv135[ebp]
  000d5	52		 push	 edx
  000d6	e8 00 00 00 00	 call	 ___asan_report_store4
  000db	83 c4 04	 add	 esp, 4
$LN3@Vb_val:
  000de	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR $T2[ebp], 0
  000e5	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  000e8	50		 push	 eax
  000e9	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  000ec	51		 push	 ecx
  000ed	e8 00 00 00 00	 call	 ??$exchange@PAU_Container_proxy@std@@$$T@std@@YAPAU_Container_proxy@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Container_proxy *,std::nullptr_t>
  000f2	83 c4 08	 add	 esp, 8
  000f5	50		 push	 eax
  000f6	8b 55 f4	 mov	 edx, DWORD PTR __Alproxy$[ebp]
  000f9	52		 push	 edx
  000fa	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  000ff	83 c4 08	 add	 esp, 8
  00102	8d 45 b8	 lea	 eax, DWORD PTR $T2[ebp]
  00105	c1 e8 03	 shr	 eax, 3
  00108	c6 80 00 00 00
	30 f8		 mov	 BYTE PTR [eax+805306368], 248 ; 000000f8H

; 2461 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2462 :     }

  0010f	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  00112	83 c1 04	 add	 ecx, 4
  00115	e8 00 00 00 00	 call	 ??1?$vector@IV?$allocator@I@std@@@std@@QAE@XZ ; std::vector<unsigned int,std::allocator<unsigned int> >::~vector<unsigned int,std::allocator<unsigned int> >
  0011a	c7 45 98 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00121	8d 4d 98	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  00124	c1 e9 03	 shr	 ecx, 3
  00127	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0012d	89 4d f8	 mov	 DWORD PTR tv131[ebp], ecx
  00130	6a 09		 push	 9
  00132	8b 55 f8	 mov	 edx, DWORD PTR tv131[ebp]
  00135	52		 push	 edx
  00136	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0013b	83 c4 08	 add	 esp, 8
  0013e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00141	33 cd		 xor	 ecx, ebp
  00143	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00148	8b e5		 mov	 esp, ebp
  0014a	5d		 pop	 ebp
  0014b	8b e3		 mov	 esp, ebx
  0014d	5b		 pop	 ebx
  0014e	c3		 ret	 0
??1?$_Vb_val@V?$allocator@_N@std@@@std@@QAE@XZ ENDP	; std::_Vb_val<std::allocator<bool> >::~_Vb_val<std::allocator<bool> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange, COMDAT

; 1777 :     [[noreturn]] static void _Xrange() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1778 :         _Xout_of_range("invalid vector subscript");

  0000d	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@DHFDPMIM@invalid?5vector?5subscript@
  00012	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN2@Xrange:

; 1779 :     }

  00017	5d		 pop	 ebp
  00018	c3		 ret	 0
?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\vector
;	COMDAT ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z
_TEXT	SEGMENT
tv72 = -40						; size = 4
_this$ = -36						; size = 4
tv71 = -32						; size = 4
tv67 = -28						; size = 4
tv66 = -24						; size = 4
tv81 = -20						; size = 4
__My_data$ = -16					; size = 4
tv91 = -12						; size = 4
tv133 = -8						; size = 4
tv84 = -3						; size = 1
tv94 = -2						; size = 1
tv136 = -1						; size = 1
__Pos$ = 8						; size = 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z PROC ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at, COMDAT
; _this$ = ecx

; 1582 :     _NODISCARD _CONSTEXPR20_CONTAINER _Ty& at(const size_type _Pos) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 28	 sub	 esp, 40			; 00000028H
  00006	89 4d dc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __324884E2_vector
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1583 :         auto& _My_data = _Mypair._Myval2;

  00013	8b 45 dc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 f0	 mov	 DWORD PTR __My_data$[ebp], eax

; 1584 :         if (static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos) {

  00019	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0001c	83 c1 08	 add	 ecx, 8
  0001f	89 4d e8	 mov	 DWORD PTR tv66[ebp], ecx
  00022	8b 55 f0	 mov	 edx, DWORD PTR __My_data$[ebp]
  00025	83 c2 04	 add	 edx, 4
  00028	89 55 e4	 mov	 DWORD PTR tv67[ebp], edx
  0002b	8b 45 e8	 mov	 eax, DWORD PTR tv66[ebp]
  0002e	89 45 f8	 mov	 DWORD PTR tv133[ebp], eax
  00031	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00034	c1 e9 03	 shr	 ecx, 3
  00037	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0003d	88 55 ff	 mov	 BYTE PTR tv136[ebp], dl
  00040	80 7d ff 00	 cmp	 BYTE PTR tv136[ebp], 0
  00044	74 18		 je	 SHORT $LN6@at
  00046	8a 45 f8	 mov	 al, BYTE PTR tv133[ebp]
  00049	24 07		 and	 al, 7
  0004b	04 03		 add	 al, 3
  0004d	3a 45 ff	 cmp	 al, BYTE PTR tv136[ebp]
  00050	7c 0c		 jl	 SHORT $LN6@at
  00052	8b 4d f8	 mov	 ecx, DWORD PTR tv133[ebp]
  00055	51		 push	 ecx
  00056	e8 00 00 00 00	 call	 ___asan_report_load4
  0005b	83 c4 04	 add	 esp, 4
$LN6@at:
  0005e	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00061	89 55 f4	 mov	 DWORD PTR tv91[ebp], edx
  00064	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  00067	c1 e8 03	 shr	 eax, 3
  0006a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00070	88 4d fe	 mov	 BYTE PTR tv94[ebp], cl
  00073	80 7d fe 00	 cmp	 BYTE PTR tv94[ebp], 0
  00077	74 1a		 je	 SHORT $LN5@at
  00079	8a 55 f4	 mov	 dl, BYTE PTR tv91[ebp]
  0007c	80 e2 07	 and	 dl, 7
  0007f	80 c2 03	 add	 dl, 3
  00082	3a 55 fe	 cmp	 dl, BYTE PTR tv94[ebp]
  00085	7c 0c		 jl	 SHORT $LN5@at
  00087	8b 45 f4	 mov	 eax, DWORD PTR tv91[ebp]
  0008a	50		 push	 eax
  0008b	e8 00 00 00 00	 call	 ___asan_report_load4
  00090	83 c4 04	 add	 esp, 4
$LN5@at:
  00093	8b 4d e8	 mov	 ecx, DWORD PTR tv66[ebp]
  00096	8b 55 e4	 mov	 edx, DWORD PTR tv67[ebp]
  00099	8b 01		 mov	 eax, DWORD PTR [ecx]
  0009b	2b 02		 sub	 eax, DWORD PTR [edx]
  0009d	c1 f8 02	 sar	 eax, 2
  000a0	3b 45 08	 cmp	 eax, DWORD PTR __Pos$[ebp]
  000a3	77 05		 ja	 SHORT $LN2@at

; 1585 :             _Xrange();

  000a5	e8 00 00 00 00	 call	 ?_Xrange@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@CAXXZ ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::_Xrange
$LN2@at:

; 1586 :         }
; 1587 : 
; 1588 :         return _My_data._Myfirst[_Pos];

  000aa	8b 4d f0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  000ad	83 c1 04	 add	 ecx, 4
  000b0	89 4d e0	 mov	 DWORD PTR tv71[ebp], ecx
  000b3	8b 55 08	 mov	 edx, DWORD PTR __Pos$[ebp]
  000b6	c1 e2 02	 shl	 edx, 2
  000b9	89 55 d8	 mov	 DWORD PTR tv72[ebp], edx
  000bc	8b 45 e0	 mov	 eax, DWORD PTR tv71[ebp]
  000bf	89 45 ec	 mov	 DWORD PTR tv81[ebp], eax
  000c2	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000c5	c1 e9 03	 shr	 ecx, 3
  000c8	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000ce	88 55 fd	 mov	 BYTE PTR tv84[ebp], dl
  000d1	80 7d fd 00	 cmp	 BYTE PTR tv84[ebp], 0
  000d5	74 18		 je	 SHORT $LN4@at
  000d7	8a 45 ec	 mov	 al, BYTE PTR tv81[ebp]
  000da	24 07		 and	 al, 7
  000dc	04 03		 add	 al, 3
  000de	3a 45 fd	 cmp	 al, BYTE PTR tv84[ebp]
  000e1	7c 0c		 jl	 SHORT $LN4@at
  000e3	8b 4d ec	 mov	 ecx, DWORD PTR tv81[ebp]
  000e6	51		 push	 ecx
  000e7	e8 00 00 00 00	 call	 ___asan_report_load4
  000ec	83 c4 04	 add	 esp, 4
$LN4@at:
  000ef	8b 55 e0	 mov	 edx, DWORD PTR tv71[ebp]
  000f2	8b 02		 mov	 eax, DWORD PTR [edx]
  000f4	03 45 d8	 add	 eax, DWORD PTR tv72[ebp]
$LN3@at:

; 1589 :     }

  000f7	8b e5		 mov	 esp, ebp
  000f9	5d		 pop	 ebp
  000fa	c2 04 00	 ret	 4
?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ENDP ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.cpp
_TEXT	SEGMENT
__asan_gen_0$ = -792					; size = 4
__asan_gen_1$ = -788					; size = 4
__asan_gen_2$ = -784					; size = 4
$T3 = -776						; size = 16
$T4 = -728						; size = 16
$T5 = -680						; size = 16
$T6 = -632						; size = 16
$T7 = -584						; size = 16
$T8 = -536						; size = 16
$T9 = -488						; size = 16
$T10 = -434						; size = 1
$T11 = -433						; size = 1
$T12 = -432						; size = 1
$T13 = -431						; size = 1
$T14 = -430						; size = 1
$T15 = -429						; size = 1
_this$ = -428						; size = 4
tv451 = -424						; size = 4
$T16 = -420						; size = 4
tv75 = -416						; size = 4
tv76 = -412						; size = 4
tv77 = -408						; size = 4
tv79 = -404						; size = 4
tv80 = -400						; size = 4
tv81 = -396						; size = 4
tv82 = -392						; size = 4
tv83 = -388						; size = 4
tv84 = -384						; size = 4
tv86 = -380						; size = 4
tv87 = -376						; size = 4
tv89 = -372						; size = 4
tv132 = -368						; size = 4
tv134 = -364						; size = 4
tv136 = -360						; size = 4
tv135 = -356						; size = 4
tv138 = -352						; size = 4
tv140 = -348						; size = 4
tv141 = -344						; size = 4
tv143 = -340						; size = 4
tv144 = -336						; size = 4
tv167 = -332						; size = 4
tv171 = -328						; size = 4
tv172 = -324						; size = 4
tv173 = -320						; size = 4
tv174 = -316						; size = 4
tv176 = -312						; size = 4
tv177 = -308						; size = 4
tv178 = -304						; size = 4
tv179 = -300						; size = 4
tv194 = -296						; size = 4
tv196 = -292						; size = 4
tv199 = -288						; size = 4
tv203 = -284						; size = 4
tv204 = -280						; size = 4
tv205 = -276						; size = 4
tv206 = -272						; size = 4
tv207 = -268						; size = 4
tv209 = -264						; size = 4
tv211 = -260						; size = 4
tv213 = -256						; size = 4
tv214 = -252						; size = 4
tv226 = -248						; size = 4
tv231 = -244						; size = 4
tv232 = -240						; size = 4
tv234 = -236						; size = 4
tv245 = -232						; size = 4
tv247 = -228						; size = 4
tv250 = -224						; size = 4
tv255 = -220						; size = 4
tv256 = -216						; size = 4
tv258 = -212						; size = 4
tv264 = -208						; size = 4
tv267 = -204						; size = 4
tv266 = -200						; size = 4
tv273 = -196						; size = 4
tv275 = -192						; size = 4
tv285 = -188						; size = 4
tv283 = -184						; size = 4
tv284 = -180						; size = 4
tv289 = -176						; size = 4
tv287 = -172						; size = 4
tv288 = -168						; size = 4
tv449 = -164						; size = 4
tv294 = -160						; size = 4
tv78 = -156						; size = 4
tv85 = -152						; size = 4
tv88 = -148						; size = 4
tv454 = -144						; size = 4
tv296 = -140						; size = 4
tv137 = -136						; size = 4
tv139 = -132						; size = 4
tv142 = -128						; size = 4
tv146 = -124						; size = 4
tv466 = -120						; size = 4
tv460 = -116						; size = 4
tv301 = -112						; size = 4
tv306 = -108						; size = 4
tv175 = -104						; size = 4
tv472 = -100						; size = 4
tv315 = -96						; size = 4
tv208 = -92						; size = 4
tv478 = -88						; size = 4
tv322 = -84						; size = 4
tv233 = -80						; size = 4
tv484 = -76						; size = 4
tv329 = -72						; size = 4
tv246 = -68						; size = 4
tv257 = -64						; size = 4
tv270 = -60						; size = 4
tv280 = -56						; size = 4
tv278 = -52						; size = 4
tv282 = -48						; size = 4
tv286 = -44						; size = 4
tv290 = -40						; size = 4
tv490 = -36						; size = 4
__$EHRec$ = -12						; size = 12
_dir$ = 8						; size = 8
_cols$ = 16						; size = 24
?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z PROC ; Character::move
; _this$ = ecx

; 4    : {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	6a ff		 push	 -1
  00018	68 00 00 00 00	 push	 __ehhandler$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z
  0001d	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00023	50		 push	 eax
  00024	53		 push	 ebx
  00025	81 c4 f0 fc ff
	ff		 add	 esp, -784		; fffffcf0H
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 8d 54 fe ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00042	c7 85 e8 fc ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0004c	c7 85 ec fc ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z
  00056	c7 85 f0 fc ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z ; Character::move
  00060	8d 85 e8 fc ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00066	89 85 5c ff ff
	ff		 mov	 DWORD PTR tv449[ebp], eax
  0006c	8b 8d 5c ff ff
	ff		 mov	 ecx, DWORD PTR tv449[ebp]
  00072	c1 e9 03	 shr	 ecx, 3
  00075	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0007b	89 8d 58 fe ff
	ff		 mov	 DWORD PTR tv451[ebp], ecx
  00081	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv451[ebp]
  00087	c7 02 f1 f1 00
	00		 mov	 DWORD PTR [edx], 61937	; 0000f1f1H
  0008d	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  00094	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  0009a	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  000a0	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  000a7	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv451[ebp]
  000ad	c7 01 f8 f8 f2
	f2		 mov	 DWORD PTR [ecx], -218957576 ; f2f2f8f8H
  000b3	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  000ba	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv451[ebp]
  000c0	c7 02 f2 f2 f8
	f8		 mov	 DWORD PTR [edx], -117902606 ; f8f8f2f2H
  000c6	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  000cd	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  000d3	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  000d9	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  000e0	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv451[ebp]
  000e6	c7 01 f8 f8 f2
	f2		 mov	 DWORD PTR [ecx], -218957576 ; f2f2f8f8H
  000ec	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  000f3	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv451[ebp]
  000f9	c7 02 f2 f2 f8
	f8		 mov	 DWORD PTR [edx], -117902606 ; f8f8f2f2H
  000ff	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  00106	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  0010c	c7 00 f2 f2 f2
	f2		 mov	 DWORD PTR [eax], -218959118 ; f2f2f2f2H
  00112	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  00119	8b 8d 58 fe ff
	ff		 mov	 ecx, DWORD PTR tv451[ebp]
  0011f	c7 01 f8 f8 f2
	f2		 mov	 DWORD PTR [ecx], -218957576 ; f2f2f8f8H
  00125	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  0012c	8b 95 58 fe ff
	ff		 mov	 edx, DWORD PTR tv451[ebp]
  00132	c7 02 f2 f2 f8
	f8		 mov	 DWORD PTR [edx], -117902606 ; f8f8f2f2H
  00138	83 85 58 fe ff
	ff 04		 add	 DWORD PTR tv451[ebp], 4
  0013f	8b 85 58 fe ff
	ff		 mov	 eax, DWORD PTR tv451[ebp]
  00145	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  0014b	c7 85 5c fe ff
	ff 00 00 00 00	 mov	 DWORD PTR $T16[ebp], 0
  00155	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0015c	b9 00 00 00 00	 mov	 ecx, OFFSET __BC01C4E9_Character@cpp
  00161	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5    : 	if (cols.at(COLDIR::BOTTOM)) { //On est sur le sol 

  00166	6a 01		 push	 1
  00168	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  0016e	51		 push	 ecx
  0016f	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00172	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00177	89 85 60 ff ff
	ff		 mov	 DWORD PTR tv294[ebp], eax
  0017d	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR tv294[ebp]
  00183	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  00188	88 85 4e fe ff
	ff		 mov	 BYTE PTR $T10[ebp], al
  0018e	8d 8d f8 fc ff
	ff		 lea	 ecx, DWORD PTR $T3[ebp]
  00194	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  00199	0f b6 95 4e fe
	ff ff		 movzx	 edx, BYTE PTR $T10[ebp]
  001a0	85 d2		 test	 edx, edx
  001a2	0f 84 10 01 00
	00		 je	 $LN6@move

; 6    : 		_accel = 0; // On verifie que l'accelration est bien nul

  001a8	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001ae	83 c0 14	 add	 eax, 20			; 00000014H
  001b1	89 85 60 fe ff
	ff		 mov	 DWORD PTR tv75[ebp], eax
  001b7	8b 8d 60 fe ff
	ff		 mov	 ecx, DWORD PTR tv75[ebp]
  001bd	51		 push	 ecx
  001be	e8 00 00 00 00	 call	 ___asan_store4
  001c3	83 c4 04	 add	 esp, 4
  001c6	8b 95 60 fe ff
	ff		 mov	 edx, DWORD PTR tv75[ebp]
  001cc	0f 57 c0	 xorps	 xmm0, xmm0
  001cf	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 7    : 		_y -= 0.1f; // On remonte lgrement vers le plafond pour eviter de fusionner avec le sol

  001d3	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  001d9	83 c0 04	 add	 eax, 4
  001dc	89 85 64 fe ff
	ff		 mov	 DWORD PTR tv76[ebp], eax
  001e2	8b 8d 64 fe ff
	ff		 mov	 ecx, DWORD PTR tv76[ebp]
  001e8	51		 push	 ecx
  001e9	e8 00 00 00 00	 call	 ___asan_load4
  001ee	83 c4 04	 add	 esp, 4
  001f1	8b 95 64 fe ff
	ff		 mov	 edx, DWORD PTR tv76[ebp]
  001f7	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  001fb	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3dcccccd
  00203	f3 0f 11 85 64
	ff ff ff	 movss	 DWORD PTR tv78[ebp], xmm0
  0020b	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00211	83 c0 04	 add	 eax, 4
  00214	89 85 68 fe ff
	ff		 mov	 DWORD PTR tv77[ebp], eax
  0021a	8b 8d 68 fe ff
	ff		 mov	 ecx, DWORD PTR tv77[ebp]
  00220	51		 push	 ecx
  00221	e8 00 00 00 00	 call	 ___asan_store4
  00226	83 c4 04	 add	 esp, 4
  00229	8b 95 68 fe ff
	ff		 mov	 edx, DWORD PTR tv77[ebp]
  0022f	f3 0f 10 85 64
	ff ff ff	 movss	 xmm0, DWORD PTR tv78[ebp]
  00237	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 8    : 		_place = DOWN;

  0023b	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00241	83 c0 1c	 add	 eax, 28			; 0000001cH
  00244	89 85 6c fe ff
	ff		 mov	 DWORD PTR tv79[ebp], eax
  0024a	8b 8d 6c fe ff
	ff		 mov	 ecx, DWORD PTR tv79[ebp]
  00250	51		 push	 ecx
  00251	e8 00 00 00 00	 call	 ___asan_store4
  00256	83 c4 04	 add	 esp, 4
  00259	8b 95 6c fe ff
	ff		 mov	 edx, DWORD PTR tv79[ebp]
  0025f	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3

; 9    : 		_hasJumped = false;

  00265	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0026b	83 c0 29	 add	 eax, 41			; 00000029H
  0026e	89 85 70 fe ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  00274	8b 8d 70 fe ff
	ff		 mov	 ecx, DWORD PTR tv80[ebp]
  0027a	51		 push	 ecx
  0027b	e8 00 00 00 00	 call	 ___asan_store1
  00280	83 c4 04	 add	 esp, 4
  00283	8b 95 70 fe ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  00289	c6 02 00	 mov	 BYTE PTR [edx], 0

; 10   : 		_hasDoubleJumped = false;

  0028c	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00292	83 c0 2a	 add	 eax, 42			; 0000002aH
  00295	89 85 74 fe ff
	ff		 mov	 DWORD PTR tv81[ebp], eax
  0029b	8b 8d 74 fe ff
	ff		 mov	 ecx, DWORD PTR tv81[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 ___asan_store1
  002a7	83 c4 04	 add	 esp, 4
  002aa	8b 95 74 fe ff
	ff		 mov	 edx, DWORD PTR tv81[ebp]
  002b0	c6 02 00	 mov	 BYTE PTR [edx], 0

; 11   : 	}

  002b3	e9 1a 01 00 00	 jmp	 $LN7@move
$LN6@move:

; 12   : 	else {
; 13   : 		_y += _accel; // sinon on accelere vers le sol

  002b8	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  002be	83 c0 14	 add	 eax, 20			; 00000014H
  002c1	89 85 7c fe ff
	ff		 mov	 DWORD PTR tv83[ebp], eax
  002c7	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002cd	83 c1 04	 add	 ecx, 4
  002d0	89 8d 78 fe ff
	ff		 mov	 DWORD PTR tv82[ebp], ecx
  002d6	8b 95 78 fe ff
	ff		 mov	 edx, DWORD PTR tv82[ebp]
  002dc	52		 push	 edx
  002dd	e8 00 00 00 00	 call	 ___asan_load4
  002e2	83 c4 04	 add	 esp, 4
  002e5	8b 85 7c fe ff
	ff		 mov	 eax, DWORD PTR tv83[ebp]
  002eb	50		 push	 eax
  002ec	e8 00 00 00 00	 call	 ___asan_load4
  002f1	83 c4 04	 add	 esp, 4
  002f4	8b 8d 78 fe ff
	ff		 mov	 ecx, DWORD PTR tv82[ebp]
  002fa	8b 95 7c fe ff
	ff		 mov	 edx, DWORD PTR tv83[ebp]
  00300	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00304	f3 0f 58 02	 addss	 xmm0, DWORD PTR [edx]
  00308	f3 0f 11 85 68
	ff ff ff	 movss	 DWORD PTR tv85[ebp], xmm0
  00310	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00316	83 c0 04	 add	 eax, 4
  00319	89 85 80 fe ff
	ff		 mov	 DWORD PTR tv84[ebp], eax
  0031f	8b 8d 80 fe ff
	ff		 mov	 ecx, DWORD PTR tv84[ebp]
  00325	51		 push	 ecx
  00326	e8 00 00 00 00	 call	 ___asan_store4
  0032b	83 c4 04	 add	 esp, 4
  0032e	8b 95 80 fe ff
	ff		 mov	 edx, DWORD PTR tv84[ebp]
  00334	f3 0f 10 85 68
	ff ff ff	 movss	 xmm0, DWORD PTR tv85[ebp]
  0033c	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 14   : 		_accel += DECEL;

  00340	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00346	83 c0 14	 add	 eax, 20			; 00000014H
  00349	89 85 84 fe ff
	ff		 mov	 DWORD PTR tv86[ebp], eax
  0034f	8b 8d 84 fe ff
	ff		 mov	 ecx, DWORD PTR tv86[ebp]
  00355	51		 push	 ecx
  00356	e8 00 00 00 00	 call	 ___asan_load4
  0035b	83 c4 04	 add	 esp, 4
  0035e	8b 95 84 fe ff
	ff		 mov	 edx, DWORD PTR tv86[ebp]
  00364	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00368	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3e4ccccd
  00370	f3 0f 11 85 6c
	ff ff ff	 movss	 DWORD PTR tv88[ebp], xmm0
  00378	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0037e	83 c0 14	 add	 eax, 20			; 00000014H
  00381	89 85 88 fe ff
	ff		 mov	 DWORD PTR tv87[ebp], eax
  00387	8b 8d 88 fe ff
	ff		 mov	 ecx, DWORD PTR tv87[ebp]
  0038d	51		 push	 ecx
  0038e	e8 00 00 00 00	 call	 ___asan_store4
  00393	83 c4 04	 add	 esp, 4
  00396	8b 95 88 fe ff
	ff		 mov	 edx, DWORD PTR tv87[ebp]
  0039c	f3 0f 10 85 6c
	ff ff ff	 movss	 xmm0, DWORD PTR tv88[ebp]
  003a4	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 15   : 		_place = DOWN;

  003a8	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  003ae	83 c0 1c	 add	 eax, 28			; 0000001cH
  003b1	89 85 8c fe ff
	ff		 mov	 DWORD PTR tv89[ebp], eax
  003b7	8b 8d 8c fe ff
	ff		 mov	 ecx, DWORD PTR tv89[ebp]
  003bd	51		 push	 ecx
  003be	e8 00 00 00 00	 call	 ___asan_store4
  003c3	83 c4 04	 add	 esp, 4
  003c6	8b 95 8c fe ff
	ff		 mov	 edx, DWORD PTR tv89[ebp]
  003cc	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3
$LN7@move:
  003d2	8d 85 28 fd ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  003d8	c1 e8 03	 shr	 eax, 3
  003db	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  003e0	89 85 70 ff ff
	ff		 mov	 DWORD PTR tv454[ebp], eax
  003e6	6a 02		 push	 2
  003e8	8b 8d 70 ff ff
	ff		 mov	 ecx, DWORD PTR tv454[ebp]
  003ee	51		 push	 ecx
  003ef	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  003f4	83 c4 08	 add	 esp, 8

; 16   : 
; 17   : 	}
; 18   : 	if (cols.at(COLDIR::TOP)) {

  003f7	6a 00		 push	 0
  003f9	8d 95 28 fd ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  003ff	52		 push	 edx
  00400	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00403	e8 00 00 00 00	 call	 ?at@?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@2@I@Z ; std::vector<bool,std::allocator<bool> >::at
  00408	89 85 74 ff ff
	ff		 mov	 DWORD PTR tv296[ebp], eax
  0040e	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR tv296[ebp]
  00414	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  00419	88 85 4f fe ff
	ff		 mov	 BYTE PTR $T11[ebp], al
  0041f	8d 8d 28 fd ff
	ff		 lea	 ecx, DWORD PTR $T4[ebp]
  00425	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
  0042a	0f b6 85 4f fe
	ff ff		 movzx	 eax, BYTE PTR $T11[ebp]
  00431	85 c0		 test	 eax, eax
  00433	0f 84 83 01 00
	00		 je	 $LN8@move

; 19   : 		if (_accel < 0) {

  00439	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0043f	83 c1 14	 add	 ecx, 20			; 00000014H
  00442	89 8d 90 fe ff
	ff		 mov	 DWORD PTR tv132[ebp], ecx
  00448	8b 95 90 fe ff
	ff		 mov	 edx, DWORD PTR tv132[ebp]
  0044e	52		 push	 edx
  0044f	e8 00 00 00 00	 call	 ___asan_load4
  00454	83 c4 04	 add	 esp, 4
  00457	8b 85 90 fe ff
	ff		 mov	 eax, DWORD PTR tv132[ebp]
  0045d	0f 57 c0	 xorps	 xmm0, xmm0
  00460	0f 2f 00	 comiss	 xmm0, DWORD PTR [eax]
  00463	76 2b		 jbe	 SHORT $LN9@move

; 20   : 			_accel = 0;

  00465	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0046b	83 c1 14	 add	 ecx, 20			; 00000014H
  0046e	89 8d 94 fe ff
	ff		 mov	 DWORD PTR tv134[ebp], ecx
  00474	8b 95 94 fe ff
	ff		 mov	 edx, DWORD PTR tv134[ebp]
  0047a	52		 push	 edx
  0047b	e8 00 00 00 00	 call	 ___asan_store4
  00480	83 c4 04	 add	 esp, 4
  00483	8b 85 94 fe ff
	ff		 mov	 eax, DWORD PTR tv134[ebp]
  00489	0f 57 c0	 xorps	 xmm0, xmm0
  0048c	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0
$LN9@move:

; 21   : 		}
; 22   : 		_y += _accel + 5; // si on se tape la tte dans le plafond

  00490	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00496	83 c1 14	 add	 ecx, 20			; 00000014H
  00499	89 8d 98 fe ff
	ff		 mov	 DWORD PTR tv136[ebp], ecx
  0049f	8b 95 98 fe ff
	ff		 mov	 edx, DWORD PTR tv136[ebp]
  004a5	52		 push	 edx
  004a6	e8 00 00 00 00	 call	 ___asan_load4
  004ab	83 c4 04	 add	 esp, 4
  004ae	8b 85 98 fe ff
	ff		 mov	 eax, DWORD PTR tv136[ebp]
  004b4	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004b8	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@40a00000
  004c0	f3 0f 11 85 78
	ff ff ff	 movss	 DWORD PTR tv137[ebp], xmm0
  004c8	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  004ce	83 c1 04	 add	 ecx, 4
  004d1	89 8d 9c fe ff
	ff		 mov	 DWORD PTR tv135[ebp], ecx
  004d7	8b 95 9c fe ff
	ff		 mov	 edx, DWORD PTR tv135[ebp]
  004dd	52		 push	 edx
  004de	e8 00 00 00 00	 call	 ___asan_load4
  004e3	83 c4 04	 add	 esp, 4
  004e6	8b 85 9c fe ff
	ff		 mov	 eax, DWORD PTR tv135[ebp]
  004ec	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  004f0	f3 0f 58 85 78
	ff ff ff	 addss	 xmm0, DWORD PTR tv137[ebp]
  004f8	f3 0f 11 85 7c
	ff ff ff	 movss	 DWORD PTR tv139[ebp], xmm0
  00500	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00506	83 c1 04	 add	 ecx, 4
  00509	89 8d a0 fe ff
	ff		 mov	 DWORD PTR tv138[ebp], ecx
  0050f	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR tv138[ebp]
  00515	52		 push	 edx
  00516	e8 00 00 00 00	 call	 ___asan_store4
  0051b	83 c4 04	 add	 esp, 4
  0051e	8b 85 a0 fe ff
	ff		 mov	 eax, DWORD PTR tv138[ebp]
  00524	f3 0f 10 85 7c
	ff ff ff	 movss	 xmm0, DWORD PTR tv139[ebp]
  0052c	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 23   : 		_accel += DECEL;

  00530	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00536	83 c1 14	 add	 ecx, 20			; 00000014H
  00539	89 8d a4 fe ff
	ff		 mov	 DWORD PTR tv140[ebp], ecx
  0053f	8b 95 a4 fe ff
	ff		 mov	 edx, DWORD PTR tv140[ebp]
  00545	52		 push	 edx
  00546	e8 00 00 00 00	 call	 ___asan_load4
  0054b	83 c4 04	 add	 esp, 4
  0054e	8b 85 a4 fe ff
	ff		 mov	 eax, DWORD PTR tv140[ebp]
  00554	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00558	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3e4ccccd
  00560	f3 0f 11 45 80	 movss	 DWORD PTR tv142[ebp], xmm0
  00565	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0056b	83 c1 14	 add	 ecx, 20			; 00000014H
  0056e	89 8d a8 fe ff
	ff		 mov	 DWORD PTR tv141[ebp], ecx
  00574	8b 95 a8 fe ff
	ff		 mov	 edx, DWORD PTR tv141[ebp]
  0057a	52		 push	 edx
  0057b	e8 00 00 00 00	 call	 ___asan_store4
  00580	83 c4 04	 add	 esp, 4
  00583	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv141[ebp]
  00589	f3 0f 10 45 80	 movss	 xmm0, DWORD PTR tv142[ebp]
  0058e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 24   : 		_place = UP;

  00592	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00598	83 c1 1c	 add	 ecx, 28			; 0000001cH
  0059b	89 8d ac fe ff
	ff		 mov	 DWORD PTR tv143[ebp], ecx
  005a1	8b 95 ac fe ff
	ff		 mov	 edx, DWORD PTR tv143[ebp]
  005a7	52		 push	 edx
  005a8	e8 00 00 00 00	 call	 ___asan_store4
  005ad	83 c4 04	 add	 esp, 4
  005b0	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR tv143[ebp]
  005b6	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2
$LN8@move:

; 25   : 	}
; 26   : 	switch (std::get<0>(dir)) {

  005bc	8d 4b 08	 lea	 ecx, DWORD PTR _dir$[ebx]
  005bf	51		 push	 ecx
  005c0	e8 00 00 00 00	 call	 ??$get@$0A@W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<0,enum DIRDEP,enum DIRDEP>
  005c5	83 c4 04	 add	 esp, 4
  005c8	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv144[ebp], eax
  005ce	8b 95 b0 fe ff
	ff		 mov	 edx, DWORD PTR tv144[ebp]
  005d4	52		 push	 edx
  005d5	e8 00 00 00 00	 call	 ___asan_load4
  005da	83 c4 04	 add	 esp, 4
  005dd	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv144[ebp]
  005e3	8b 08		 mov	 ecx, DWORD PTR [eax]
  005e5	89 4d 84	 mov	 DWORD PTR tv146[ebp], ecx
  005e8	83 7d 84 02	 cmp	 DWORD PTR tv146[ebp], 2
  005ec	74 05		 je	 SHORT $LN10@move
  005ee	e9 74 04 00 00	 jmp	 $LN2@move
$LN10@move:
  005f3	8d 95 58 fd ff
	ff		 lea	 edx, DWORD PTR $T5[ebp]
  005f9	c1 ea 03	 shr	 edx, 3
  005fc	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00602	89 55 88	 mov	 DWORD PTR tv466[ebp], edx
  00605	6a 02		 push	 2
  00607	8b 45 88	 mov	 eax, DWORD PTR tv466[ebp]
  0060a	50		 push	 eax
  0060b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00610	83 c4 08	 add	 esp, 8
  00613	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  00619	c1 e9 03	 shr	 ecx, 3
  0061c	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00622	89 4d 8c	 mov	 DWORD PTR tv460[ebp], ecx
  00625	6a 02		 push	 2
  00627	8b 55 8c	 mov	 edx, DWORD PTR tv460[ebp]
  0062a	52		 push	 edx
  0062b	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00630	83 c4 08	 add	 esp, 8

; 27   : 	case DIRDEP::UP:
; 28   : 		if (cols[COLDIR::BOTTOM] && !cols[COLDIR::TOP]) {//on est sur le sol et il n'y a pas de mur au dessus

  00633	6a 01		 push	 1
  00635	8d 85 58 fd ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0063b	50		 push	 eax
  0063c	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  0063f	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  00644	89 45 90	 mov	 DWORD PTR tv301[ebp], eax
  00647	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  0064d	83 c9 01	 or	 ecx, 1
  00650	89 8d 5c fe ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
  00656	8b 4d 90	 mov	 ecx, DWORD PTR tv301[ebp]
  00659	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  0065e	0f b6 d0	 movzx	 edx, al
  00661	85 d2		 test	 edx, edx
  00663	74 3e		 je	 SHORT $LN20@move
  00665	6a 00		 push	 0
  00667	8d 85 88 fd ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  0066d	50		 push	 eax
  0066e	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00671	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  00676	89 45 94	 mov	 DWORD PTR tv306[ebp], eax
  00679	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  0067f	83 c9 02	 or	 ecx, 2
  00682	89 8d 5c fe ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
  00688	8b 4d 94	 mov	 ecx, DWORD PTR tv306[ebp]
  0068b	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  00690	0f b6 d0	 movzx	 edx, al
  00693	85 d2		 test	 edx, edx
  00695	75 0c		 jne	 SHORT $LN20@move
  00697	c7 85 b4 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv167[ebp], 1
  006a1	eb 0a		 jmp	 SHORT $LN21@move
$LN20@move:
  006a3	c7 85 b4 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv167[ebp], 0
$LN21@move:
  006ad	8a 85 b4 fe ff
	ff		 mov	 al, BYTE PTR tv167[ebp]
  006b3	88 85 50 fe ff
	ff		 mov	 BYTE PTR $T12[ebp], al
  006b9	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  006bf	83 e1 02	 and	 ecx, 2
  006c2	74 12		 je	 SHORT $LN35@move
  006c4	83 a5 5c fe ff
	ff fd		 and	 DWORD PTR $T16[ebp], -3	; fffffffdH
  006cb	8d 8d 88 fd ff
	ff		 lea	 ecx, DWORD PTR $T6[ebp]
  006d1	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
$LN35@move:
  006d6	8b 95 5c fe ff
	ff		 mov	 edx, DWORD PTR $T16[ebp]
  006dc	83 e2 01	 and	 edx, 1
  006df	74 12		 je	 SHORT $LN36@move
  006e1	83 a5 5c fe ff
	ff fe		 and	 DWORD PTR $T16[ebp], -2	; fffffffeH
  006e8	8d 8d 58 fd ff
	ff		 lea	 ecx, DWORD PTR $T5[ebp]
  006ee	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
$LN36@move:
  006f3	0f b6 85 50 fe
	ff ff		 movzx	 eax, BYTE PTR $T12[ebp]
  006fa	85 c0		 test	 eax, eax
  006fc	0f 84 08 01 00
	00		 je	 $LN11@move

; 29   : 			_accel = -MAXACC;

  00702	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00708	83 c1 14	 add	 ecx, 20			; 00000014H
  0070b	89 8d b8 fe ff
	ff		 mov	 DWORD PTR tv171[ebp], ecx
  00711	8b 95 b8 fe ff
	ff		 mov	 edx, DWORD PTR tv171[ebp]
  00717	52		 push	 edx
  00718	e8 00 00 00 00	 call	 ___asan_store4
  0071d	83 c4 04	 add	 esp, 4
  00720	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR tv171[ebp]
  00726	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0a00000
  0072e	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 30   : 			_y += _accel;

  00732	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00738	83 c1 14	 add	 ecx, 20			; 00000014H
  0073b	89 8d c0 fe ff
	ff		 mov	 DWORD PTR tv173[ebp], ecx
  00741	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00747	83 c2 04	 add	 edx, 4
  0074a	89 95 bc fe ff
	ff		 mov	 DWORD PTR tv172[ebp], edx
  00750	8b 85 bc fe ff
	ff		 mov	 eax, DWORD PTR tv172[ebp]
  00756	50		 push	 eax
  00757	e8 00 00 00 00	 call	 ___asan_load4
  0075c	83 c4 04	 add	 esp, 4
  0075f	8b 8d c0 fe ff
	ff		 mov	 ecx, DWORD PTR tv173[ebp]
  00765	51		 push	 ecx
  00766	e8 00 00 00 00	 call	 ___asan_load4
  0076b	83 c4 04	 add	 esp, 4
  0076e	8b 95 bc fe ff
	ff		 mov	 edx, DWORD PTR tv172[ebp]
  00774	8b 85 c0 fe ff
	ff		 mov	 eax, DWORD PTR tv173[ebp]
  0077a	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  0077e	f3 0f 58 00	 addss	 xmm0, DWORD PTR [eax]
  00782	f3 0f 11 45 98	 movss	 DWORD PTR tv175[ebp], xmm0
  00787	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0078d	83 c1 04	 add	 ecx, 4
  00790	89 8d c4 fe ff
	ff		 mov	 DWORD PTR tv174[ebp], ecx
  00796	8b 95 c4 fe ff
	ff		 mov	 edx, DWORD PTR tv174[ebp]
  0079c	52		 push	 edx
  0079d	e8 00 00 00 00	 call	 ___asan_store4
  007a2	83 c4 04	 add	 esp, 4
  007a5	8b 85 c4 fe ff
	ff		 mov	 eax, DWORD PTR tv174[ebp]
  007ab	f3 0f 10 45 98	 movss	 xmm0, DWORD PTR tv175[ebp]
  007b0	f3 0f 11 00	 movss	 DWORD PTR [eax], xmm0

; 31   : 			_place = UP;

  007b4	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007ba	83 c1 1c	 add	 ecx, 28			; 0000001cH
  007bd	89 8d c8 fe ff
	ff		 mov	 DWORD PTR tv176[ebp], ecx
  007c3	8b 95 c8 fe ff
	ff		 mov	 edx, DWORD PTR tv176[ebp]
  007c9	52		 push	 edx
  007ca	e8 00 00 00 00	 call	 ___asan_store4
  007cf	83 c4 04	 add	 esp, 4
  007d2	8b 85 c8 fe ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  007d8	c7 00 02 00 00
	00		 mov	 DWORD PTR [eax], 2

; 32   : 			_hasJumped = true;

  007de	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  007e4	83 c1 29	 add	 ecx, 41			; 00000029H
  007e7	89 8d cc fe ff
	ff		 mov	 DWORD PTR tv177[ebp], ecx
  007ed	8b 95 cc fe ff
	ff		 mov	 edx, DWORD PTR tv177[ebp]
  007f3	52		 push	 edx
  007f4	e8 00 00 00 00	 call	 ___asan_store1
  007f9	83 c4 04	 add	 esp, 4
  007fc	8b 85 cc fe ff
	ff		 mov	 eax, DWORD PTR tv177[ebp]
  00802	c6 00 01	 mov	 BYTE PTR [eax], 1

; 33   : 
; 34   : 		}

  00805	e9 5d 02 00 00	 jmp	 $LN13@move
$LN11@move:
  0080a	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00810	c1 e9 03	 shr	 ecx, 3
  00813	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00819	89 4d 9c	 mov	 DWORD PTR tv472[ebp], ecx
  0081c	6a 02		 push	 2
  0081e	8b 55 9c	 mov	 edx, DWORD PTR tv472[ebp]
  00821	52		 push	 edx
  00822	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00827	83 c4 08	 add	 esp, 8

; 35   : 		else if (_hasJumped && _canDoubleJump && !cols[COLDIR::TOP] && _accel >= -1 && !_hasDoubleJumped) {

  0082a	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00830	83 c0 29	 add	 eax, 41			; 00000029H
  00833	89 85 d0 fe ff
	ff		 mov	 DWORD PTR tv178[ebp], eax
  00839	8b 8d d0 fe ff
	ff		 mov	 ecx, DWORD PTR tv178[ebp]
  0083f	51		 push	 ecx
  00840	e8 00 00 00 00	 call	 ___asan_load1
  00845	83 c4 04	 add	 esp, 4
  00848	8b 95 d0 fe ff
	ff		 mov	 edx, DWORD PTR tv178[ebp]
  0084e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00851	85 c0		 test	 eax, eax
  00853	0f 84 c9 00 00
	00		 je	 $LN22@move
  00859	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  0085f	83 c1 28	 add	 ecx, 40			; 00000028H
  00862	89 8d d4 fe ff
	ff		 mov	 DWORD PTR tv179[ebp], ecx
  00868	8b 95 d4 fe ff
	ff		 mov	 edx, DWORD PTR tv179[ebp]
  0086e	52		 push	 edx
  0086f	e8 00 00 00 00	 call	 ___asan_load1
  00874	83 c4 04	 add	 esp, 4
  00877	8b 85 d4 fe ff
	ff		 mov	 eax, DWORD PTR tv179[ebp]
  0087d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00880	85 c9		 test	 ecx, ecx
  00882	0f 84 9a 00 00
	00		 je	 $LN22@move
  00888	6a 00		 push	 0
  0088a	8d 95 b8 fd ff
	ff		 lea	 edx, DWORD PTR $T7[ebp]
  00890	52		 push	 edx
  00891	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00894	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  00899	89 45 a0	 mov	 DWORD PTR tv315[ebp], eax
  0089c	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  008a2	83 c8 04	 or	 eax, 4
  008a5	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
  008ab	8b 4d a0	 mov	 ecx, DWORD PTR tv315[ebp]
  008ae	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  008b3	0f b6 c8	 movzx	 ecx, al
  008b6	85 c9		 test	 ecx, ecx
  008b8	75 68		 jne	 SHORT $LN22@move
  008ba	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008c0	83 c2 14	 add	 edx, 20			; 00000014H
  008c3	89 95 d8 fe ff
	ff		 mov	 DWORD PTR tv194[ebp], edx
  008c9	8b 85 d8 fe ff
	ff		 mov	 eax, DWORD PTR tv194[ebp]
  008cf	50		 push	 eax
  008d0	e8 00 00 00 00	 call	 ___asan_load4
  008d5	83 c4 04	 add	 esp, 4
  008d8	8b 8d d8 fe ff
	ff		 mov	 ecx, DWORD PTR tv194[ebp]
  008de	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  008e2	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@bf800000
  008e9	72 37		 jb	 SHORT $LN22@move
  008eb	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  008f1	83 c2 2a	 add	 edx, 42			; 0000002aH
  008f4	89 95 dc fe ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  008fa	8b 85 dc fe ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00900	50		 push	 eax
  00901	e8 00 00 00 00	 call	 ___asan_load1
  00906	83 c4 04	 add	 esp, 4
  00909	8b 8d dc fe ff
	ff		 mov	 ecx, DWORD PTR tv196[ebp]
  0090f	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00912	85 d2		 test	 edx, edx
  00914	75 0c		 jne	 SHORT $LN22@move
  00916	c7 85 e0 fe ff
	ff 01 00 00 00	 mov	 DWORD PTR tv199[ebp], 1
  00920	eb 0a		 jmp	 SHORT $LN23@move
$LN22@move:
  00922	c7 85 e0 fe ff
	ff 00 00 00 00	 mov	 DWORD PTR tv199[ebp], 0
$LN23@move:
  0092c	8a 85 e0 fe ff
	ff		 mov	 al, BYTE PTR tv199[ebp]
  00932	88 85 51 fe ff
	ff		 mov	 BYTE PTR $T13[ebp], al
  00938	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  0093e	83 e1 04	 and	 ecx, 4
  00941	74 12		 je	 SHORT $LN39@move
  00943	83 a5 5c fe ff
	ff fb		 and	 DWORD PTR $T16[ebp], -5	; fffffffbH
  0094a	8d 8d b8 fd ff
	ff		 lea	 ecx, DWORD PTR $T7[ebp]
  00950	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
$LN39@move:
  00955	0f b6 95 51 fe
	ff ff		 movzx	 edx, BYTE PTR $T13[ebp]
  0095c	85 d2		 test	 edx, edx
  0095e	0f 84 03 01 00
	00		 je	 $LN13@move

; 36   : 			_hasDoubleJumped = true;

  00964	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  0096a	83 c0 2a	 add	 eax, 42			; 0000002aH
  0096d	89 85 e4 fe ff
	ff		 mov	 DWORD PTR tv203[ebp], eax
  00973	8b 8d e4 fe ff
	ff		 mov	 ecx, DWORD PTR tv203[ebp]
  00979	51		 push	 ecx
  0097a	e8 00 00 00 00	 call	 ___asan_store1
  0097f	83 c4 04	 add	 esp, 4
  00982	8b 95 e4 fe ff
	ff		 mov	 edx, DWORD PTR tv203[ebp]
  00988	c6 02 01	 mov	 BYTE PTR [edx], 1

; 37   : 			_accel = -MAXACC;

  0098b	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00991	83 c0 14	 add	 eax, 20			; 00000014H
  00994	89 85 e8 fe ff
	ff		 mov	 DWORD PTR tv204[ebp], eax
  0099a	8b 8d e8 fe ff
	ff		 mov	 ecx, DWORD PTR tv204[ebp]
  009a0	51		 push	 ecx
  009a1	e8 00 00 00 00	 call	 ___asan_store4
  009a6	83 c4 04	 add	 esp, 4
  009a9	8b 95 e8 fe ff
	ff		 mov	 edx, DWORD PTR tv204[ebp]
  009af	f3 0f 10 05 00
	00 00 00	 movss	 xmm0, DWORD PTR __real@c0a00000
  009b7	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 38   : 			_y += _accel;

  009bb	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  009c1	83 c0 14	 add	 eax, 20			; 00000014H
  009c4	89 85 f0 fe ff
	ff		 mov	 DWORD PTR tv206[ebp], eax
  009ca	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  009d0	83 c1 04	 add	 ecx, 4
  009d3	89 8d ec fe ff
	ff		 mov	 DWORD PTR tv205[ebp], ecx
  009d9	8b 95 ec fe ff
	ff		 mov	 edx, DWORD PTR tv205[ebp]
  009df	52		 push	 edx
  009e0	e8 00 00 00 00	 call	 ___asan_load4
  009e5	83 c4 04	 add	 esp, 4
  009e8	8b 85 f0 fe ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  009ee	50		 push	 eax
  009ef	e8 00 00 00 00	 call	 ___asan_load4
  009f4	83 c4 04	 add	 esp, 4
  009f7	8b 8d ec fe ff
	ff		 mov	 ecx, DWORD PTR tv205[ebp]
  009fd	8b 95 f0 fe ff
	ff		 mov	 edx, DWORD PTR tv206[ebp]
  00a03	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00a07	f3 0f 58 02	 addss	 xmm0, DWORD PTR [edx]
  00a0b	f3 0f 11 45 a4	 movss	 DWORD PTR tv208[ebp], xmm0
  00a10	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a16	83 c0 04	 add	 eax, 4
  00a19	89 85 f4 fe ff
	ff		 mov	 DWORD PTR tv207[ebp], eax
  00a1f	8b 8d f4 fe ff
	ff		 mov	 ecx, DWORD PTR tv207[ebp]
  00a25	51		 push	 ecx
  00a26	e8 00 00 00 00	 call	 ___asan_store4
  00a2b	83 c4 04	 add	 esp, 4
  00a2e	8b 95 f4 fe ff
	ff		 mov	 edx, DWORD PTR tv207[ebp]
  00a34	f3 0f 10 45 a4	 movss	 xmm0, DWORD PTR tv208[ebp]
  00a39	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 39   : 			_place = UP;

  00a3d	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00a43	83 c0 1c	 add	 eax, 28			; 0000001cH
  00a46	89 85 f8 fe ff
	ff		 mov	 DWORD PTR tv209[ebp], eax
  00a4c	8b 8d f8 fe ff
	ff		 mov	 ecx, DWORD PTR tv209[ebp]
  00a52	51		 push	 ecx
  00a53	e8 00 00 00 00	 call	 ___asan_store4
  00a58	83 c4 04	 add	 esp, 4
  00a5b	8b 95 f8 fe ff
	ff		 mov	 edx, DWORD PTR tv209[ebp]
  00a61	c7 02 02 00 00
	00		 mov	 DWORD PTR [edx], 2
$LN13@move:
$LN2@move:

; 40   : 		}
; 41   : 		break;
; 42   : 	case DIRDEP::DOWN:
; 43   : 		break;
; 44   : 
; 45   : 	}switch (std::get<1>(dir)) {

  00a67	8d 43 08	 lea	 eax, DWORD PTR _dir$[ebx]
  00a6a	50		 push	 eax
  00a6b	e8 00 00 00 00	 call	 ??$get@$00W4DIRDEP@@W41@@std@@YAAAW4DIRDEP@@AAV?$tuple@W4DIRDEP@@W41@@0@@Z ; std::get<1,enum DIRDEP,enum DIRDEP>
  00a70	83 c4 04	 add	 esp, 4
  00a73	89 85 fc fe ff
	ff		 mov	 DWORD PTR tv211[ebp], eax
  00a79	8b 8d fc fe ff
	ff		 mov	 ecx, DWORD PTR tv211[ebp]
  00a7f	51		 push	 ecx
  00a80	e8 00 00 00 00	 call	 ___asan_load4
  00a85	83 c4 04	 add	 esp, 4
  00a88	8b 95 fc fe ff
	ff		 mov	 edx, DWORD PTR tv211[ebp]
  00a8e	8b 02		 mov	 eax, DWORD PTR [edx]
  00a90	89 85 00 ff ff
	ff		 mov	 DWORD PTR tv213[ebp], eax
  00a96	83 bd 00 ff ff
	ff 00		 cmp	 DWORD PTR tv213[ebp], 0
  00a9d	74 12		 je	 SHORT $LN15@move
  00a9f	83 bd 00 ff ff
	ff 01		 cmp	 DWORD PTR tv213[ebp], 1
  00aa6	0f 84 5e 01 00
	00		 je	 $LN17@move
  00aac	e9 de 02 00 00	 jmp	 $LN4@move
$LN15@move:
  00ab1	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00ab7	c1 e9 03	 shr	 ecx, 3
  00aba	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00ac0	89 4d a8	 mov	 DWORD PTR tv478[ebp], ecx
  00ac3	6a 02		 push	 2
  00ac5	8b 55 a8	 mov	 edx, DWORD PTR tv478[ebp]
  00ac8	52		 push	 edx
  00ac9	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00ace	83 c4 08	 add	 esp, 8

; 46   : 	case DIRDEP::LEFT:
; 47   : 		if (_x > 0 && !cols[COLDIR::LEFT]) {

  00ad1	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00ad7	89 85 04 ff ff
	ff		 mov	 DWORD PTR tv214[ebp], eax
  00add	8b 8d 04 ff ff
	ff		 mov	 ecx, DWORD PTR tv214[ebp]
  00ae3	51		 push	 ecx
  00ae4	e8 00 00 00 00	 call	 ___asan_load4
  00ae9	83 c4 04	 add	 esp, 4
  00aec	8b 95 04 ff ff
	ff		 mov	 edx, DWORD PTR tv214[ebp]
  00af2	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00af6	0f 2f 05 00 00
	00 00		 comiss	 xmm0, DWORD PTR __real@00000000
  00afd	76 3e		 jbe	 SHORT $LN24@move
  00aff	6a 02		 push	 2
  00b01	8d 85 e8 fd ff
	ff		 lea	 eax, DWORD PTR $T8[ebp]
  00b07	50		 push	 eax
  00b08	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00b0b	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  00b10	89 45 ac	 mov	 DWORD PTR tv322[ebp], eax
  00b13	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  00b19	83 c9 08	 or	 ecx, 8
  00b1c	89 8d 5c fe ff
	ff		 mov	 DWORD PTR $T16[ebp], ecx
  00b22	8b 4d ac	 mov	 ecx, DWORD PTR tv322[ebp]
  00b25	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  00b2a	0f b6 d0	 movzx	 edx, al
  00b2d	85 d2		 test	 edx, edx
  00b2f	75 0c		 jne	 SHORT $LN24@move
  00b31	c7 85 08 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv226[ebp], 1
  00b3b	eb 0a		 jmp	 SHORT $LN25@move
$LN24@move:
  00b3d	c7 85 08 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv226[ebp], 0
$LN25@move:
  00b47	8a 85 08 ff ff
	ff		 mov	 al, BYTE PTR tv226[ebp]
  00b4d	88 85 52 fe ff
	ff		 mov	 BYTE PTR $T14[ebp], al
  00b53	8b 8d 5c fe ff
	ff		 mov	 ecx, DWORD PTR $T16[ebp]
  00b59	83 e1 08	 and	 ecx, 8
  00b5c	74 12		 je	 SHORT $LN42@move
  00b5e	83 a5 5c fe ff
	ff f7		 and	 DWORD PTR $T16[ebp], -9	; fffffff7H
  00b65	8d 8d e8 fd ff
	ff		 lea	 ecx, DWORD PTR $T8[ebp]
  00b6b	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
$LN42@move:
  00b70	0f b6 95 52 fe
	ff ff		 movzx	 edx, BYTE PTR $T14[ebp]
  00b77	85 d2		 test	 edx, edx
  00b79	0f 84 86 00 00
	00		 je	 $LN16@move

; 48   : 			_x--;

  00b7f	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00b85	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv231[ebp], eax
  00b8b	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv231[ebp]
  00b91	51		 push	 ecx
  00b92	e8 00 00 00 00	 call	 ___asan_load4
  00b97	83 c4 04	 add	 esp, 4
  00b9a	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv231[ebp]
  00ba0	f3 0f 10 02	 movss	 xmm0, DWORD PTR [edx]
  00ba4	f3 0f 5c 05 00
	00 00 00	 subss	 xmm0, DWORD PTR __real@3f800000
  00bac	f3 0f 11 45 b0	 movss	 DWORD PTR tv233[ebp], xmm0
  00bb1	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00bb7	89 85 10 ff ff
	ff		 mov	 DWORD PTR tv232[ebp], eax
  00bbd	8b 8d 10 ff ff
	ff		 mov	 ecx, DWORD PTR tv232[ebp]
  00bc3	51		 push	 ecx
  00bc4	e8 00 00 00 00	 call	 ___asan_store4
  00bc9	83 c4 04	 add	 esp, 4
  00bcc	8b 95 10 ff ff
	ff		 mov	 edx, DWORD PTR tv232[ebp]
  00bd2	f3 0f 10 45 b0	 movss	 xmm0, DWORD PTR tv233[ebp]
  00bd7	f3 0f 11 02	 movss	 DWORD PTR [edx], xmm0

; 49   : 			_place = LEFT;

  00bdb	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00be1	83 c0 1c	 add	 eax, 28			; 0000001cH
  00be4	89 85 14 ff ff
	ff		 mov	 DWORD PTR tv234[ebp], eax
  00bea	8b 8d 14 ff ff
	ff		 mov	 ecx, DWORD PTR tv234[ebp]
  00bf0	51		 push	 ecx
  00bf1	e8 00 00 00 00	 call	 ___asan_store4
  00bf6	83 c4 04	 add	 esp, 4
  00bf9	8b 95 14 ff ff
	ff		 mov	 edx, DWORD PTR tv234[ebp]
  00bff	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN16@move:

; 50   : 		}
; 51   : 		break;

  00c05	e9 85 01 00 00	 jmp	 $LN4@move
$LN17@move:
  00c0a	8d 85 18 fe ff
	ff		 lea	 eax, DWORD PTR $T9[ebp]
  00c10	c1 e8 03	 shr	 eax, 3
  00c13	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00c18	89 45 b4	 mov	 DWORD PTR tv484[ebp], eax
  00c1b	6a 02		 push	 2
  00c1d	8b 4d b4	 mov	 ecx, DWORD PTR tv484[ebp]
  00c20	51		 push	 ecx
  00c21	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00c26	83 c4 08	 add	 esp, 8

; 52   : 	case DIRDEP::RIGHT:
; 53   : 		if (!cols[COLDIR::RIGHT] && _x + BLOCKWIDTH < _maxX) { //TODO : Ajouter la vrification du max 

  00c29	6a 03		 push	 3
  00c2b	8d 95 18 fe ff
	ff		 lea	 edx, DWORD PTR $T9[ebp]
  00c31	52		 push	 edx
  00c32	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00c35	e8 00 00 00 00	 call	 ??A?$vector@_NV?$allocator@_N@std@@@std@@QAE?AV?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@1@I@Z ; std::vector<bool,std::allocator<bool> >::operator[]
  00c3a	89 45 b8	 mov	 DWORD PTR tv329[ebp], eax
  00c3d	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  00c43	83 c8 10	 or	 eax, 16			; 00000010H
  00c46	89 85 5c fe ff
	ff		 mov	 DWORD PTR $T16[ebp], eax
  00c4c	8b 4d b8	 mov	 ecx, DWORD PTR tv329[ebp]
  00c4f	e8 00 00 00 00	 call	 ??B?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QBE_NXZ ; std::_Vb_reference<std::_Wrap_alloc<std::allocator<unsigned int> > >::operator bool
  00c54	0f b6 c8	 movzx	 ecx, al
  00c57	85 c9		 test	 ecx, ecx
  00c59	75 6c		 jne	 SHORT $LN26@move
  00c5b	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c61	89 95 18 ff ff
	ff		 mov	 DWORD PTR tv245[ebp], edx
  00c67	8b 85 18 ff ff
	ff		 mov	 eax, DWORD PTR tv245[ebp]
  00c6d	50		 push	 eax
  00c6e	e8 00 00 00 00	 call	 ___asan_load4
  00c73	83 c4 04	 add	 esp, 4
  00c76	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv245[ebp]
  00c7c	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00c80	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@42480000
  00c88	f3 0f 11 45 bc	 movss	 DWORD PTR tv246[ebp], xmm0
  00c8d	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00c93	83 c2 18	 add	 edx, 24			; 00000018H
  00c96	89 95 1c ff ff
	ff		 mov	 DWORD PTR tv247[ebp], edx
  00c9c	8b 85 1c ff ff
	ff		 mov	 eax, DWORD PTR tv247[ebp]
  00ca2	50		 push	 eax
  00ca3	e8 00 00 00 00	 call	 ___asan_load4
  00ca8	83 c4 04	 add	 esp, 4
  00cab	8b 8d 1c ff ff
	ff		 mov	 ecx, DWORD PTR tv247[ebp]
  00cb1	f3 0f 2a 01	 cvtsi2ss xmm0, DWORD PTR [ecx]
  00cb5	0f 2f 45 bc	 comiss	 xmm0, DWORD PTR tv246[ebp]
  00cb9	76 0c		 jbe	 SHORT $LN26@move
  00cbb	c7 85 20 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv250[ebp], 1
  00cc5	eb 0a		 jmp	 SHORT $LN27@move
$LN26@move:
  00cc7	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv250[ebp], 0
$LN27@move:
  00cd1	8a 95 20 ff ff
	ff		 mov	 dl, BYTE PTR tv250[ebp]
  00cd7	88 95 53 fe ff
	ff		 mov	 BYTE PTR $T15[ebp], dl
  00cdd	8b 85 5c fe ff
	ff		 mov	 eax, DWORD PTR $T16[ebp]
  00ce3	83 e0 10	 and	 eax, 16			; 00000010H
  00ce6	74 12		 je	 SHORT $LN45@move
  00ce8	83 a5 5c fe ff
	ff ef		 and	 DWORD PTR $T16[ebp], -17 ; ffffffefH
  00cef	8d 8d 18 fe ff
	ff		 lea	 ecx, DWORD PTR $T9[ebp]
  00cf5	e8 00 00 00 00	 call	 ??1?$_Vb_reference@U?$_Wrap_alloc@V?$allocator@I@std@@@std@@@std@@QAE@XZ
$LN45@move:
  00cfa	0f b6 8d 53 fe
	ff ff		 movzx	 ecx, BYTE PTR $T15[ebp]
  00d01	85 c9		 test	 ecx, ecx
  00d03	0f 84 86 00 00
	00		 je	 $LN18@move

; 54   : 			_x++;

  00d09	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d0f	89 95 24 ff ff
	ff		 mov	 DWORD PTR tv255[ebp], edx
  00d15	8b 85 24 ff ff
	ff		 mov	 eax, DWORD PTR tv255[ebp]
  00d1b	50		 push	 eax
  00d1c	e8 00 00 00 00	 call	 ___asan_load4
  00d21	83 c4 04	 add	 esp, 4
  00d24	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv255[ebp]
  00d2a	f3 0f 10 01	 movss	 xmm0, DWORD PTR [ecx]
  00d2e	f3 0f 58 05 00
	00 00 00	 addss	 xmm0, DWORD PTR __real@3f800000
  00d36	f3 0f 11 45 c0	 movss	 DWORD PTR tv257[ebp], xmm0
  00d3b	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d41	89 95 28 ff ff
	ff		 mov	 DWORD PTR tv256[ebp], edx
  00d47	8b 85 28 ff ff
	ff		 mov	 eax, DWORD PTR tv256[ebp]
  00d4d	50		 push	 eax
  00d4e	e8 00 00 00 00	 call	 ___asan_store4
  00d53	83 c4 04	 add	 esp, 4
  00d56	8b 8d 28 ff ff
	ff		 mov	 ecx, DWORD PTR tv256[ebp]
  00d5c	f3 0f 10 45 c0	 movss	 xmm0, DWORD PTR tv257[ebp]
  00d61	f3 0f 11 01	 movss	 DWORD PTR [ecx], xmm0

; 55   : 			_place = RIGHT;

  00d65	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d6b	83 c2 1c	 add	 edx, 28			; 0000001cH
  00d6e	89 95 2c ff ff
	ff		 mov	 DWORD PTR tv258[ebp], edx
  00d74	8b 85 2c ff ff
	ff		 mov	 eax, DWORD PTR tv258[ebp]
  00d7a	50		 push	 eax
  00d7b	e8 00 00 00 00	 call	 ___asan_store4
  00d80	83 c4 04	 add	 esp, 4
  00d83	8b 8d 2c ff ff
	ff		 mov	 ecx, DWORD PTR tv258[ebp]
  00d89	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1
$LN18@move:
$LN4@move:

; 56   : 
; 57   : 		}
; 58   : 		break;
; 59   : 	}
; 60   : 	_sprite->at(_place)->setPosition(_x, _y);

  00d8f	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00d95	83 c2 0c	 add	 edx, 12			; 0000000cH
  00d98	89 95 30 ff ff
	ff		 mov	 DWORD PTR tv264[ebp], edx
  00d9e	8b 85 30 ff ff
	ff		 mov	 eax, DWORD PTR tv264[ebp]
  00da4	50		 push	 eax
  00da5	e8 00 00 00 00	 call	 ___asan_load4
  00daa	83 c4 04	 add	 esp, 4
  00dad	8b 8d 30 ff ff
	ff		 mov	 ecx, DWORD PTR tv264[ebp]
  00db3	8b 11		 mov	 edx, DWORD PTR [ecx]
  00db5	89 55 c4	 mov	 DWORD PTR tv270[ebp], edx
  00db8	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00dbe	83 c0 1c	 add	 eax, 28			; 0000001cH
  00dc1	89 85 34 ff ff
	ff		 mov	 DWORD PTR tv267[ebp], eax
  00dc7	8b 8d 34 ff ff
	ff		 mov	 ecx, DWORD PTR tv267[ebp]
  00dcd	51		 push	 ecx
  00dce	e8 00 00 00 00	 call	 ___asan_load4
  00dd3	83 c4 04	 add	 esp, 4
  00dd6	8b 95 34 ff ff
	ff		 mov	 edx, DWORD PTR tv267[ebp]
  00ddc	8b 02		 mov	 eax, DWORD PTR [edx]
  00dde	50		 push	 eax
  00ddf	8b 4d c4	 mov	 ecx, DWORD PTR tv270[ebp]
  00de2	e8 00 00 00 00	 call	 ?at@?$vector@PAVSprite@sf@@V?$allocator@PAVSprite@sf@@@std@@@std@@QAEAAPAVSprite@sf@@I@Z ; std::vector<sf::Sprite *,std::allocator<sf::Sprite *> >::at
  00de7	89 85 38 ff ff
	ff		 mov	 DWORD PTR tv266[ebp], eax
  00ded	8b 8d 38 ff ff
	ff		 mov	 ecx, DWORD PTR tv266[ebp]
  00df3	51		 push	 ecx
  00df4	e8 00 00 00 00	 call	 ___asan_load4
  00df9	83 c4 04	 add	 esp, 4
  00dfc	8b 95 38 ff ff
	ff		 mov	 edx, DWORD PTR tv266[ebp]
  00e02	8b 02		 mov	 eax, DWORD PTR [edx]
  00e04	83 c0 04	 add	 eax, 4
  00e07	89 45 d0	 mov	 DWORD PTR tv282[ebp], eax
  00e0a	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e10	83 c1 04	 add	 ecx, 4
  00e13	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv273[ebp], ecx
  00e19	8b 95 3c ff ff
	ff		 mov	 edx, DWORD PTR tv273[ebp]
  00e1f	52		 push	 edx
  00e20	e8 00 00 00 00	 call	 ___asan_load4
  00e25	83 c4 04	 add	 esp, 4
  00e28	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv273[ebp]
  00e2e	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00e32	f3 0f 11 45 c8	 movss	 DWORD PTR tv280[ebp], xmm0
  00e37	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e3d	89 8d 40 ff ff
	ff		 mov	 DWORD PTR tv275[ebp], ecx
  00e43	8b 95 40 ff ff
	ff		 mov	 edx, DWORD PTR tv275[ebp]
  00e49	52		 push	 edx
  00e4a	e8 00 00 00 00	 call	 ___asan_load4
  00e4f	83 c4 04	 add	 esp, 4
  00e52	8b 85 40 ff ff
	ff		 mov	 eax, DWORD PTR tv275[ebp]
  00e58	f3 0f 10 00	 movss	 xmm0, DWORD PTR [eax]
  00e5c	f3 0f 11 45 cc	 movss	 DWORD PTR tv278[ebp], xmm0
  00e61	51		 push	 ecx
  00e62	f3 0f 10 45 c8	 movss	 xmm0, DWORD PTR tv280[ebp]
  00e67	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e6c	51		 push	 ecx
  00e6d	f3 0f 10 45 cc	 movss	 xmm0, DWORD PTR tv278[ebp]
  00e72	f3 0f 11 04 24	 movss	 DWORD PTR [esp], xmm0
  00e77	8b 4d d0	 mov	 ecx, DWORD PTR tv282[ebp]
  00e7a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setPosition@Transformable@sf@@QAEXMM@Z

; 61   : 	_rect->top = _y;

  00e80	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00e86	83 c1 04	 add	 ecx, 4
  00e89	89 8d 44 ff ff
	ff		 mov	 DWORD PTR tv285[ebp], ecx
  00e8f	8b 95 44 ff ff
	ff		 mov	 edx, DWORD PTR tv285[ebp]
  00e95	52		 push	 edx
  00e96	e8 00 00 00 00	 call	 ___asan_load4
  00e9b	83 c4 04	 add	 esp, 4
  00e9e	8b 85 44 ff ff
	ff		 mov	 eax, DWORD PTR tv285[ebp]
  00ea4	f3 0f 2c 08	 cvttss2si ecx, DWORD PTR [eax]
  00ea8	89 4d d4	 mov	 DWORD PTR tv286[ebp], ecx
  00eab	8b 95 54 fe ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  00eb1	83 c2 08	 add	 edx, 8
  00eb4	89 95 48 ff ff
	ff		 mov	 DWORD PTR tv283[ebp], edx
  00eba	8b 85 48 ff ff
	ff		 mov	 eax, DWORD PTR tv283[ebp]
  00ec0	50		 push	 eax
  00ec1	e8 00 00 00 00	 call	 ___asan_load4
  00ec6	83 c4 04	 add	 esp, 4
  00ec9	8b 8d 48 ff ff
	ff		 mov	 ecx, DWORD PTR tv283[ebp]
  00ecf	8b 11		 mov	 edx, DWORD PTR [ecx]
  00ed1	83 c2 04	 add	 edx, 4
  00ed4	89 95 4c ff ff
	ff		 mov	 DWORD PTR tv284[ebp], edx
  00eda	8b 85 4c ff ff
	ff		 mov	 eax, DWORD PTR tv284[ebp]
  00ee0	50		 push	 eax
  00ee1	e8 00 00 00 00	 call	 ___asan_store4
  00ee6	83 c4 04	 add	 esp, 4
  00ee9	8b 8d 4c ff ff
	ff		 mov	 ecx, DWORD PTR tv284[ebp]
  00eef	8b 55 d4	 mov	 edx, DWORD PTR tv286[ebp]
  00ef2	89 11		 mov	 DWORD PTR [ecx], edx

; 62   : 	_rect->left = _x;

  00ef4	8b 85 54 fe ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00efa	89 85 50 ff ff
	ff		 mov	 DWORD PTR tv289[ebp], eax
  00f00	8b 8d 50 ff ff
	ff		 mov	 ecx, DWORD PTR tv289[ebp]
  00f06	51		 push	 ecx
  00f07	e8 00 00 00 00	 call	 ___asan_load4
  00f0c	83 c4 04	 add	 esp, 4
  00f0f	8b 95 50 ff ff
	ff		 mov	 edx, DWORD PTR tv289[ebp]
  00f15	f3 0f 2c 02	 cvttss2si eax, DWORD PTR [edx]
  00f19	89 45 d8	 mov	 DWORD PTR tv290[ebp], eax
  00f1c	8b 8d 54 fe ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00f22	83 c1 08	 add	 ecx, 8
  00f25	89 8d 54 ff ff
	ff		 mov	 DWORD PTR tv287[ebp], ecx
  00f2b	8b 95 54 ff ff
	ff		 mov	 edx, DWORD PTR tv287[ebp]
  00f31	52		 push	 edx
  00f32	e8 00 00 00 00	 call	 ___asan_load4
  00f37	83 c4 04	 add	 esp, 4
  00f3a	8b 85 54 ff ff
	ff		 mov	 eax, DWORD PTR tv287[ebp]
  00f40	8b 08		 mov	 ecx, DWORD PTR [eax]
  00f42	89 8d 58 ff ff
	ff		 mov	 DWORD PTR tv288[ebp], ecx
  00f48	8b 95 58 ff ff
	ff		 mov	 edx, DWORD PTR tv288[ebp]
  00f4e	52		 push	 edx
  00f4f	e8 00 00 00 00	 call	 ___asan_store4
  00f54	83 c4 04	 add	 esp, 4
  00f57	8b 85 58 ff ff
	ff		 mov	 eax, DWORD PTR tv288[ebp]
  00f5d	8b 4d d8	 mov	 ecx, DWORD PTR tv290[ebp]
  00f60	89 08		 mov	 DWORD PTR [eax], ecx

; 63   : 
; 64   : }

  00f62	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  00f69	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00f6c	e8 00 00 00 00	 call	 ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
  00f71	c7 85 e8 fc ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00f7b	8d 95 e8 fc ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00f81	c1 ea 03	 shr	 edx, 3
  00f84	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00f8a	89 55 dc	 mov	 DWORD PTR tv490[ebp], edx
  00f8d	6a 2c		 push	 44			; 0000002cH
  00f8f	8b 45 dc	 mov	 eax, DWORD PTR tv490[ebp]
  00f92	50		 push	 eax
  00f93	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00f98	83 c4 08	 add	 esp, 8
  00f9b	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00f9e	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00fa5	59		 pop	 ecx
  00fa6	8b e5		 mov	 esp, ebp
  00fa8	5d		 pop	 ebp
  00fa9	8b e3		 mov	 esp, ebx
  00fab	5b		 pop	 ebx
  00fac	c2 20 00	 ret	 32			; 00000020H
_TEXT	ENDS
text$x	SEGMENT
__unwindfunclet$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z$0:
  00000	8b 5d f0	 mov	 ebx, DWORD PTR [ebp-16]
  00003	8d 4b 10	 lea	 ecx, DWORD PTR _cols$[ebx]
  00006	e9 00 00 00 00	 jmp	 ??1?$vector@_NV?$allocator@_N@std@@@std@@QAE@XZ ; std::vector<bool,std::allocator<bool> >::~vector<bool,std::allocator<bool> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a e8 fc ff
	ff		 mov	 ecx, DWORD PTR [edx-792]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?move@Character@@QAEXV?$tuple@W4DIRDEP@@W41@@std@@V?$vector@_NV?$allocator@_N@std@@@3@@Z ENDP ; Character::move
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?deallocate@?$allocator@I@std@@QAEXQAII@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@I@std@@QAEXQAII@Z PROC		; std::allocator<unsigned int>::deallocate, COMDAT
; _this$ = ecx

; 833  :     _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 834  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 835  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00011	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  00014	c1 e0 02	 shl	 eax, 2
  00017	50		 push	 eax
  00018	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0001b	51		 push	 ecx
  0001c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00021	83 c4 08	 add	 esp, 8

; 836  :     }

  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c2 08 00	 ret	 8
?deallocate@?$allocator@I@std@@QAEXQAII@Z ENDP		; std::allocator<unsigned int>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@_WV?$istreambuf_iterator@_WU?$char_traits@_W@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xloctime
;	COMDAT ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -264					; size = 4
__asan_gen_1$ = -260					; size = 4
__asan_gen_2$ = -256					; size = 4
$T2 = -248						; size = 44
tv229 = -166						; size = 1
tv219 = -165						; size = 1
tv209 = -164						; size = 1
tv199 = -163						; size = 1
tv189 = -162						; size = 1
tv179 = -161						; size = 1
_this$ = -160						; size = 4
tv157 = -156						; size = 4
tv226 = -152						; size = 4
tv216 = -148						; size = 4
tv206 = -144						; size = 4
tv196 = -140						; size = 4
tv186 = -136						; size = 4
tv176 = -132						; size = 4
tv156 = -128						; size = 4
tv66 = -124						; size = 4
tv64 = -120						; size = 4
tv165 = -116						; size = 4
tv70 = -112						; size = 4
tv75 = -108						; size = 4
tv80 = -104						; size = 4
tv83 = -100						; size = 4
tv91 = -96						; size = 4
tv131 = -92						; size = 4
tv154 = -88						; size = 4
tv161 = -84						; size = 4
tv162 = -80						; size = 4
tv71 = -76						; size = 4
tv76 = -72						; size = 4
tv81 = -68						; size = 4
tv84 = -64						; size = 4
tv92 = -60						; size = 4
tv132 = -56						; size = 4
tv172 = -52						; size = 4
$T3 = -48						; size = 44
___formal$ = 8						; size = 2
__Lobj$ = 12						; size = 4
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z PROC ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>, COMDAT
; _this$ = ecx

; 173  :     void __CLR_OR_THIS_CALL _Getvals(_Elem2, const _Locinfo& _Lobj) { // get values

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec 18 01 00
	00		 sub	 esp, 280		; 00000118H
  0001c	56		 push	 esi
  0001d	57		 push	 edi
  0001e	89 8d 60 ff ff
	ff		 mov	 DWORD PTR _this$[ebp], ecx
  00024	c7 85 f8 fe ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002e	c7 85 fc fe ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z
  00038	c7 85 00 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
  00042	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  00048	89 45 a8	 mov	 DWORD PTR tv154[ebp], eax
  0004b	8b 4d a8	 mov	 ecx, DWORD PTR tv154[ebp]
  0004e	c1 e9 03	 shr	 ecx, 3
  00051	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00057	89 4d 80	 mov	 DWORD PTR tv156[ebp], ecx
  0005a	ba f1 f1 00 00	 mov	 edx, 61937		; 0000f1f1H
  0005f	8b 45 80	 mov	 eax, DWORD PTR tv156[ebp]
  00062	66 89 10	 mov	 WORD PTR [eax], dx
  00065	8b 4d 80	 mov	 ecx, DWORD PTR tv156[ebp]
  00068	83 c1 02	 add	 ecx, 2
  0006b	89 8d 64 ff ff
	ff		 mov	 DWORD PTR tv157[ebp], ecx
  00071	6a 05		 push	 5
  00073	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  00079	52		 push	 edx
  0007a	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  0007f	83 c4 08	 add	 esp, 8
  00082	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR tv157[ebp]
  00088	83 c0 05	 add	 eax, 5
  0008b	89 45 ac	 mov	 DWORD PTR tv161[ebp], eax
  0008e	8b 4d ac	 mov	 ecx, DWORD PTR tv161[ebp]
  00091	c6 01 04	 mov	 BYTE PTR [ecx], 4
  00094	8b 95 64 ff ff
	ff		 mov	 edx, DWORD PTR tv157[ebp]
  0009a	83 c2 06	 add	 edx, 6
  0009d	89 55 b0	 mov	 DWORD PTR tv162[ebp], edx
  000a0	8b 45 b0	 mov	 eax, DWORD PTR tv162[ebp]
  000a3	c7 00 f3 f3 f3
	f3		 mov	 DWORD PTR [eax], -202116109 ; f3f3f3f3H
  000a9	b9 00 00 00 00	 mov	 ecx, OFFSET __D96D2425_xloctime
  000ae	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 174  :         _Cvt = _Lobj._Getcvt();

  000b3	8d 8d 08 ff ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000b9	51		 push	 ecx
  000ba	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  000bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getcvt@_Locinfo@std@@QBE?AU_Cvtvec@@XZ
  000c3	89 45 84	 mov	 DWORD PTR tv66[ebp], eax
  000c6	6a 2c		 push	 44			; 0000002cH
  000c8	8b 55 84	 mov	 edx, DWORD PTR tv66[ebp]
  000cb	52		 push	 edx
  000cc	e8 00 00 00 00	 call	 ___asan_loadN
  000d1	83 c4 08	 add	 esp, 8
  000d4	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  000d9	8b 75 84	 mov	 esi, DWORD PTR tv66[ebp]
  000dc	8d 7d d0	 lea	 edi, DWORD PTR $T3[ebp]
  000df	f3 a5		 rep movsd
  000e1	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  000e7	83 c0 18	 add	 eax, 24			; 00000018H
  000ea	89 45 88	 mov	 DWORD PTR tv64[ebp], eax
  000ed	6a 2c		 push	 44			; 0000002cH
  000ef	8b 4d 88	 mov	 ecx, DWORD PTR tv64[ebp]
  000f2	51		 push	 ecx
  000f3	e8 00 00 00 00	 call	 ___asan_storeN
  000f8	83 c4 08	 add	 esp, 8
  000fb	b9 0b 00 00 00	 mov	 ecx, 11			; 0000000bH
  00100	8d 75 d0	 lea	 esi, DWORD PTR $T3[ebp]
  00103	8b 7d 88	 mov	 edi, DWORD PTR tv64[ebp]
  00106	f3 a5		 rep movsd
  00108	8d 95 08 ff ff
	ff		 lea	 edx, DWORD PTR $T2[ebp]
  0010e	c1 ea 03	 shr	 edx, 3
  00111	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00117	89 55 8c	 mov	 DWORD PTR tv165[ebp], edx
  0011a	6a 05		 push	 5
  0011c	8b 45 8c	 mov	 eax, DWORD PTR tv165[ebp]
  0011f	50		 push	 eax
  00120	e8 00 00 00 00	 call	 ___asan_set_shadow_f8
  00125	83 c4 08	 add	 esp, 8
  00128	8b 4d 8c	 mov	 ecx, DWORD PTR tv165[ebp]
  0012b	c6 41 05 f8	 mov	 BYTE PTR [ecx+5], 248	; 000000f8H

; 175  : 
; 176  :         if (is_same_v<_Elem2, wchar_t>) {

  0012f	ba 01 00 00 00	 mov	 edx, 1
  00134	85 d2		 test	 edx, edx
  00136	0f 84 57 01 00
	00		 je	 $LN2@Getvals

; 177  :             _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));

  0013c	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  0013f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getdays@_Locinfo@std@@QBEPBGXZ
  00145	50		 push	 eax
  00146	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0014b	83 c4 04	 add	 esp, 4
  0014e	89 45 b4	 mov	 DWORD PTR tv71[ebp], eax
  00151	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00157	83 c0 08	 add	 eax, 8
  0015a	89 45 90	 mov	 DWORD PTR tv70[ebp], eax
  0015d	8b 4d 90	 mov	 ecx, DWORD PTR tv70[ebp]
  00160	89 8d 68 ff ff
	ff		 mov	 DWORD PTR tv226[ebp], ecx
  00166	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0016c	c1 ea 03	 shr	 edx, 3
  0016f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00175	88 85 5a ff ff
	ff		 mov	 BYTE PTR tv229[ebp], al
  0017b	80 bd 5a ff ff
	ff 00		 cmp	 BYTE PTR tv229[ebp], 0
  00182	74 23		 je	 SHORT $LN10@Getvals
  00184	8a 8d 68 ff ff
	ff		 mov	 cl, BYTE PTR tv226[ebp]
  0018a	80 e1 07	 and	 cl, 7
  0018d	80 c1 03	 add	 cl, 3
  00190	3a 8d 5a ff ff
	ff		 cmp	 cl, BYTE PTR tv229[ebp]
  00196	7c 0f		 jl	 SHORT $LN10@Getvals
  00198	8b 95 68 ff ff
	ff		 mov	 edx, DWORD PTR tv226[ebp]
  0019e	52		 push	 edx
  0019f	e8 00 00 00 00	 call	 ___asan_report_store4
  001a4	83 c4 04	 add	 esp, 4
$LN10@Getvals:
  001a7	8b 45 90	 mov	 eax, DWORD PTR tv70[ebp]
  001aa	8b 4d b4	 mov	 ecx, DWORD PTR tv71[ebp]
  001ad	89 08		 mov	 DWORD PTR [eax], ecx

; 178  :             _Months =

  001af	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  001b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_W_Getmonths@_Locinfo@std@@QBEPBGXZ
  001b8	50		 push	 eax
  001b9	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  001be	83 c4 04	 add	 esp, 4
  001c1	89 45 b8	 mov	 DWORD PTR tv76[ebp], eax
  001c4	8b 95 60 ff ff
	ff		 mov	 edx, DWORD PTR _this$[ebp]
  001ca	83 c2 0c	 add	 edx, 12			; 0000000cH
  001cd	89 55 94	 mov	 DWORD PTR tv75[ebp], edx
  001d0	8b 45 94	 mov	 eax, DWORD PTR tv75[ebp]
  001d3	89 85 6c ff ff
	ff		 mov	 DWORD PTR tv216[ebp], eax
  001d9	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  001df	c1 e9 03	 shr	 ecx, 3
  001e2	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001e8	88 95 5b ff ff
	ff		 mov	 BYTE PTR tv219[ebp], dl
  001ee	80 bd 5b ff ff
	ff 00		 cmp	 BYTE PTR tv219[ebp], 0
  001f5	74 21		 je	 SHORT $LN9@Getvals
  001f7	8a 85 6c ff ff
	ff		 mov	 al, BYTE PTR tv216[ebp]
  001fd	24 07		 and	 al, 7
  001ff	04 03		 add	 al, 3
  00201	3a 85 5b ff ff
	ff		 cmp	 al, BYTE PTR tv219[ebp]
  00207	7c 0f		 jl	 SHORT $LN9@Getvals
  00209	8b 8d 6c ff ff
	ff		 mov	 ecx, DWORD PTR tv216[ebp]
  0020f	51		 push	 ecx
  00210	e8 00 00 00 00	 call	 ___asan_report_store4
  00215	83 c4 04	 add	 esp, 4
$LN9@Getvals:
  00218	8b 55 94	 mov	 edx, DWORD PTR tv75[ebp]
  0021b	8b 45 b8	 mov	 eax, DWORD PTR tv76[ebp]
  0021e	89 02		 mov	 DWORD PTR [edx], eax

; 179  :                 reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
; 180  :             _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));

  00220	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
  00225	e8 00 00 00 00	 call	 ?_Maklocwcs@std@@YAPA_WPB_W@Z ; std::_Maklocwcs
  0022a	83 c4 04	 add	 esp, 4
  0022d	89 45 bc	 mov	 DWORD PTR tv81[ebp], eax
  00230	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00236	83 c1 10	 add	 ecx, 16			; 00000010H
  00239	89 4d 98	 mov	 DWORD PTR tv80[ebp], ecx
  0023c	8b 55 98	 mov	 edx, DWORD PTR tv80[ebp]
  0023f	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv206[ebp], edx
  00245	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0024b	c1 e8 03	 shr	 eax, 3
  0024e	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00254	88 8d 5c ff ff
	ff		 mov	 BYTE PTR tv209[ebp], cl
  0025a	80 bd 5c ff ff
	ff 00		 cmp	 BYTE PTR tv209[ebp], 0
  00261	74 23		 je	 SHORT $LN8@Getvals
  00263	8a 95 70 ff ff
	ff		 mov	 dl, BYTE PTR tv206[ebp]
  00269	80 e2 07	 and	 dl, 7
  0026c	80 c2 03	 add	 dl, 3
  0026f	3a 95 5c ff ff
	ff		 cmp	 dl, BYTE PTR tv209[ebp]
  00275	7c 0f		 jl	 SHORT $LN8@Getvals
  00277	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR tv206[ebp]
  0027d	50		 push	 eax
  0027e	e8 00 00 00 00	 call	 ___asan_report_store4
  00283	83 c4 04	 add	 esp, 4
$LN8@Getvals:
  00286	8b 4d 98	 mov	 ecx, DWORD PTR tv80[ebp]
  00289	8b 55 bc	 mov	 edx, DWORD PTR tv81[ebp]
  0028c	89 11		 mov	 DWORD PTR [ecx], edx

; 181  :         } else {

  0028e	e9 78 01 00 00	 jmp	 $LN1@Getvals
$LN2@Getvals:

; 182  :             _Days   = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);

  00293	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00299	83 c0 18	 add	 eax, 24			; 00000018H
  0029c	50		 push	 eax
  0029d	6a 00		 push	 0
  0029f	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  002a2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getdays@_Locinfo@std@@QBEPBDXZ
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  002ae	83 c4 0c	 add	 esp, 12			; 0000000cH
  002b1	89 45 c0	 mov	 DWORD PTR tv84[ebp], eax
  002b4	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  002ba	83 c1 08	 add	 ecx, 8
  002bd	89 4d 9c	 mov	 DWORD PTR tv83[ebp], ecx
  002c0	8b 55 9c	 mov	 edx, DWORD PTR tv83[ebp]
  002c3	89 95 74 ff ff
	ff		 mov	 DWORD PTR tv196[ebp], edx
  002c9	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  002cf	c1 e8 03	 shr	 eax, 3
  002d2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002d8	88 8d 5d ff ff
	ff		 mov	 BYTE PTR tv199[ebp], cl
  002de	80 bd 5d ff ff
	ff 00		 cmp	 BYTE PTR tv199[ebp], 0
  002e5	74 23		 je	 SHORT $LN7@Getvals
  002e7	8a 95 74 ff ff
	ff		 mov	 dl, BYTE PTR tv196[ebp]
  002ed	80 e2 07	 and	 dl, 7
  002f0	80 c2 03	 add	 dl, 3
  002f3	3a 95 5d ff ff
	ff		 cmp	 dl, BYTE PTR tv199[ebp]
  002f9	7c 0f		 jl	 SHORT $LN7@Getvals
  002fb	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR tv196[ebp]
  00301	50		 push	 eax
  00302	e8 00 00 00 00	 call	 ___asan_report_store4
  00307	83 c4 04	 add	 esp, 4
$LN7@Getvals:
  0030a	8b 4d 9c	 mov	 ecx, DWORD PTR tv83[ebp]
  0030d	8b 55 c0	 mov	 edx, DWORD PTR tv84[ebp]
  00310	89 11		 mov	 DWORD PTR [ecx], edx

; 183  :             _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);

  00312	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00318	83 c0 18	 add	 eax, 24			; 00000018H
  0031b	50		 push	 eax
  0031c	6a 00		 push	 0
  0031e	8b 4b 0c	 mov	 ecx, DWORD PTR __Lobj$[ebx]
  00321	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Getmonths@_Locinfo@std@@QBEPBDXZ
  00327	50		 push	 eax
  00328	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  0032d	83 c4 0c	 add	 esp, 12			; 0000000cH
  00330	89 45 c4	 mov	 DWORD PTR tv92[ebp], eax
  00333	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  00339	83 c1 0c	 add	 ecx, 12			; 0000000cH
  0033c	89 4d a0	 mov	 DWORD PTR tv91[ebp], ecx
  0033f	8b 55 a0	 mov	 edx, DWORD PTR tv91[ebp]
  00342	89 95 78 ff ff
	ff		 mov	 DWORD PTR tv186[ebp], edx
  00348	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  0034e	c1 e8 03	 shr	 eax, 3
  00351	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00357	88 8d 5e ff ff
	ff		 mov	 BYTE PTR tv189[ebp], cl
  0035d	80 bd 5e ff ff
	ff 00		 cmp	 BYTE PTR tv189[ebp], 0
  00364	74 23		 je	 SHORT $LN6@Getvals
  00366	8a 95 78 ff ff
	ff		 mov	 dl, BYTE PTR tv186[ebp]
  0036c	80 e2 07	 and	 dl, 7
  0036f	80 c2 03	 add	 dl, 3
  00372	3a 95 5e ff ff
	ff		 cmp	 dl, BYTE PTR tv189[ebp]
  00378	7c 0f		 jl	 SHORT $LN6@Getvals
  0037a	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR tv186[ebp]
  00380	50		 push	 eax
  00381	e8 00 00 00 00	 call	 ___asan_report_store4
  00386	83 c4 04	 add	 esp, 4
$LN6@Getvals:
  00389	8b 4d a0	 mov	 ecx, DWORD PTR tv91[ebp]
  0038c	8b 55 c4	 mov	 edx, DWORD PTR tv92[ebp]
  0038f	89 11		 mov	 DWORD PTR [ecx], edx

; 184  :             _Ampm   = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);

  00391	8b 85 60 ff ff
	ff		 mov	 eax, DWORD PTR _this$[ebp]
  00397	83 c0 18	 add	 eax, 24			; 00000018H
  0039a	50		 push	 eax
  0039b	6a 00		 push	 0
  0039d	68 00 00 00 00	 push	 OFFSET ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
  003a2	e8 00 00 00 00	 call	 ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ; std::_Maklocstr<char>
  003a7	83 c4 0c	 add	 esp, 12			; 0000000cH
  003aa	89 45 c8	 mov	 DWORD PTR tv132[ebp], eax
  003ad	8b 8d 60 ff ff
	ff		 mov	 ecx, DWORD PTR _this$[ebp]
  003b3	83 c1 10	 add	 ecx, 16			; 00000010H
  003b6	89 4d a4	 mov	 DWORD PTR tv131[ebp], ecx
  003b9	8b 55 a4	 mov	 edx, DWORD PTR tv131[ebp]
  003bc	89 95 7c ff ff
	ff		 mov	 DWORD PTR tv176[ebp], edx
  003c2	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003c8	c1 e8 03	 shr	 eax, 3
  003cb	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  003d1	88 8d 5f ff ff
	ff		 mov	 BYTE PTR tv179[ebp], cl
  003d7	80 bd 5f ff ff
	ff 00		 cmp	 BYTE PTR tv179[ebp], 0
  003de	74 23		 je	 SHORT $LN5@Getvals
  003e0	8a 95 7c ff ff
	ff		 mov	 dl, BYTE PTR tv176[ebp]
  003e6	80 e2 07	 and	 dl, 7
  003e9	80 c2 03	 add	 dl, 3
  003ec	3a 95 5f ff ff
	ff		 cmp	 dl, BYTE PTR tv179[ebp]
  003f2	7c 0f		 jl	 SHORT $LN5@Getvals
  003f4	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR tv176[ebp]
  003fa	50		 push	 eax
  003fb	e8 00 00 00 00	 call	 ___asan_report_store4
  00400	83 c4 04	 add	 esp, 4
$LN5@Getvals:
  00403	8b 4d a4	 mov	 ecx, DWORD PTR tv131[ebp]
  00406	8b 55 c8	 mov	 edx, DWORD PTR tv132[ebp]
  00409	89 11		 mov	 DWORD PTR [ecx], edx
$LN1@Getvals:

; 185  :         }
; 186  :     }

  0040b	c7 85 f8 fe ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  00415	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0041b	c1 e8 03	 shr	 eax, 3
  0041e	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  00423	89 45 cc	 mov	 DWORD PTR tv172[ebp], eax
  00426	6a 0c		 push	 12			; 0000000cH
  00428	8b 4d cc	 mov	 ecx, DWORD PTR tv172[ebp]
  0042b	51		 push	 ecx
  0042c	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00431	83 c4 08	 add	 esp, 8
  00434	5f		 pop	 edi
  00435	5e		 pop	 esi
  00436	8b e5		 mov	 esp, ebp
  00438	5d		 pop	 ebp
  00439	8b e3		 mov	 esp, ebx
  0043b	5b		 pop	 ebx
  0043c	c2 08 00	 ret	 8
??$_Getvals@_W@?$time_get@DV?$istreambuf_iterator@DU?$char_traits@D@std@@@std@@@std@@IAEX_WABV_Locinfo@1@@Z ENDP ; std::time_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >::_Getvals<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z
_TEXT	SEGMENT
tv85 = -32						; size = 4
tv82 = -28						; size = 4
__Ptrdest$ = -24					; size = 4
tv88 = -20						; size = 4
tv130 = -16						; size = 4
__Ptrnext$1 = -12					; size = 4
__Count$ = -8						; size = 4
tv91 = -2						; size = 1
tv133 = -1						; size = 1
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z PROC	; std::_Maklocstr<char>, COMDAT

; 522  : _Elem* __CRTDECL _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 20	 sub	 esp, 32			; 00000020H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 523  :     // convert C string to _Elem sequence using _Cvtvec
; 524  :     size_t _Count = _CSTD strlen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 525  : 
; 526  :     _Elem* _Ptrdest = static_cast<_Elem*>(_calloc_dbg(_Count, sizeof(_Elem), _CRT_BLOCK, __FILE__, __LINE__));

  00022	68 0e 02 00 00	 push	 526			; 0000020eH
  00027	68 00 00 00 00	 push	 OFFSET $SG88167
  0002c	6a 02		 push	 2
  0002e	6a 01		 push	 1
  00030	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00033	51		 push	 ecx
  00034	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0003a	83 c4 14	 add	 esp, 20			; 00000014H
  0003d	89 45 e8	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 527  : 
; 528  :     if (!_Ptrdest) {

  00040	83 7d e8 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00044	75 05		 jne	 SHORT $LN5@Maklocstr

; 529  :         _Xbad_alloc();

  00046	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN5@Maklocstr:

; 530  :     }
; 531  : 
; 532  :     for (_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr) {

  0004b	8b 55 e8	 mov	 edx, DWORD PTR __Ptrdest$[ebp]
  0004e	89 55 f4	 mov	 DWORD PTR __Ptrnext$1[ebp], edx
  00051	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  00053	8b 45 f8	 mov	 eax, DWORD PTR __Count$[ebp]
  00056	83 e8 01	 sub	 eax, 1
  00059	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax
  0005c	8b 4d f4	 mov	 ecx, DWORD PTR __Ptrnext$1[ebp]
  0005f	83 c1 01	 add	 ecx, 1
  00062	89 4d f4	 mov	 DWORD PTR __Ptrnext$1[ebp], ecx
  00065	8b 55 08	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00068	83 c2 01	 add	 edx, 1
  0006b	89 55 08	 mov	 DWORD PTR __Ptr$[ebp], edx
$LN4@Maklocstr:
  0006e	83 7d f8 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00072	76 7f		 jbe	 SHORT $LN3@Maklocstr

; 533  :         *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));

  00074	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00077	89 45 e4	 mov	 DWORD PTR tv82[ebp], eax
  0007a	8b 4d e4	 mov	 ecx, DWORD PTR tv82[ebp]
  0007d	89 4d f0	 mov	 DWORD PTR tv130[ebp], ecx
  00080	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  00083	c1 ea 03	 shr	 edx, 3
  00086	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0008c	88 45 ff	 mov	 BYTE PTR tv133[ebp], al
  0008f	80 7d ff 00	 cmp	 BYTE PTR tv133[ebp], 0
  00093	74 17		 je	 SHORT $LN8@Maklocstr
  00095	8a 4d f0	 mov	 cl, BYTE PTR tv130[ebp]
  00098	80 e1 07	 and	 cl, 7
  0009b	3a 4d ff	 cmp	 cl, BYTE PTR tv133[ebp]
  0009e	7c 0c		 jl	 SHORT $LN8@Maklocstr
  000a0	8b 55 f0	 mov	 edx, DWORD PTR tv130[ebp]
  000a3	52		 push	 edx
  000a4	e8 00 00 00 00	 call	 ___asan_report_load1
  000a9	83 c4 04	 add	 esp, 4
$LN8@Maklocstr:
  000ac	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000af	89 45 e0	 mov	 DWORD PTR tv85[ebp], eax
  000b2	8b 4d e0	 mov	 ecx, DWORD PTR tv85[ebp]
  000b5	89 4d ec	 mov	 DWORD PTR tv88[ebp], ecx
  000b8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000bb	c1 ea 03	 shr	 edx, 3
  000be	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000c4	88 45 fe	 mov	 BYTE PTR tv91[ebp], al
  000c7	80 7d fe 00	 cmp	 BYTE PTR tv91[ebp], 0
  000cb	74 17		 je	 SHORT $LN7@Maklocstr
  000cd	8a 4d ec	 mov	 cl, BYTE PTR tv88[ebp]
  000d0	80 e1 07	 and	 cl, 7
  000d3	3a 4d fe	 cmp	 cl, BYTE PTR tv91[ebp]
  000d6	7c 0c		 jl	 SHORT $LN7@Maklocstr
  000d8	8b 55 ec	 mov	 edx, DWORD PTR tv88[ebp]
  000db	52		 push	 edx
  000dc	e8 00 00 00 00	 call	 ___asan_report_store1
  000e1	83 c4 04	 add	 esp, 4
$LN7@Maklocstr:
  000e4	8b 45 f4	 mov	 eax, DWORD PTR __Ptrnext$1[ebp]
  000e7	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000ea	8a 11		 mov	 dl, BYTE PTR [ecx]
  000ec	88 10		 mov	 BYTE PTR [eax], dl

; 534  :     }

  000ee	e9 60 ff ff ff	 jmp	 $LN2@Maklocstr
$LN3@Maklocstr:

; 535  : 
; 536  :     return _Ptrdest;

  000f3	8b 45 e8	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN6@Maklocstr:

; 537  : }

  000f6	8b e5		 mov	 esp, ebp
  000f8	5d		 pop	 ebp
  000f9	c3		 ret	 0
??$_Maklocstr@D@std@@YAPADPBDPADABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocnum
;	COMDAT ?_Maklocwcs@std@@YAPA_WPB_W@Z
_TEXT	SEGMENT
__Count$ = -8						; size = 4
__Ptrdest$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?_Maklocwcs@std@@YAPA_WPB_W@Z PROC			; std::_Maklocwcs, COMDAT

; 90   : inline wchar_t* _Maklocwcs(const wchar_t* _Ptr) { // copy NTWCS to allocated storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __4CB88277_xlocnum
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 91   :     const size_t _Count = _CSTD wcslen(_Ptr) + 1;

  00010	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00013	50		 push	 eax
  00014	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  0001a	83 c4 04	 add	 esp, 4
  0001d	83 c0 01	 add	 eax, 1
  00020	89 45 f8	 mov	 DWORD PTR __Count$[ebp], eax

; 92   : 
; 93   :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Count, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00023	6a 5d		 push	 93			; 0000005dH
  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@OGMNKBMN@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0002a	6a 02		 push	 2
  0002c	6a 02		 push	 2
  0002e	8b 4d f8	 mov	 ecx, DWORD PTR __Count$[ebp]
  00031	51		 push	 ecx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  00038	83 c4 14	 add	 esp, 20			; 00000014H
  0003b	89 45 fc	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 94   : 
; 95   :     if (!_Ptrdest) {

  0003e	83 7d fc 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00042	75 05		 jne	 SHORT $LN2@Maklocwcs

; 96   :         _Xbad_alloc();

  00044	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN2@Maklocwcs:

; 97   :     }
; 98   : 
; 99   :     _CSTD wmemcpy(_Ptrdest, _Ptr, _Count);

  00049	8b 55 f8	 mov	 edx, DWORD PTR __Count$[ebp]
  0004c	52		 push	 edx
  0004d	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00050	50		 push	 eax
  00051	8b 4d fc	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  00054	51		 push	 ecx
  00055	e8 00 00 00 00	 call	 _wmemcpy
  0005a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 100  :     return _Ptrdest;

  0005d	8b 45 fc	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
$LN3@Maklocwcs:

; 101  : }

  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
?_Maklocwcs@std@@YAPA_WPB_W@Z ENDP			; std::_Maklocwcs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xlocale
;	COMDAT ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -152					; size = 4
__asan_gen_1$ = -148					; size = 4
__asan_gen_2$ = -144					; size = 4
__Mbst1$ = -136						; size = 8
__Wc$ = -120						; size = 2
__Mbst2$ = -104						; size = 8
tv156 = -57						; size = 1
tv146 = -56						; size = 4
__Wchars$ = -52						; size = 4
__Bytes$ = -48						; size = 4
__Count$ = -44						; size = 4
__Ptrnext$ = -40					; size = 4
__Ptr1$ = -36						; size = 4
tv153 = -32						; size = 4
__Ptrdest$ = -28					; size = 4
__Count1$ = -24						; size = 4
tv144 = -20						; size = 4
tv141 = -16						; size = 4
tv149 = -12						; size = 4
tv140 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
__Cvt$ = 16						; size = 4
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z PROC	; std::_Maklocstr<wchar_t>, COMDAT

; 540  : inline wchar_t* __CRTDECL _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt) {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	81 ec a0 00 00
	00		 sub	 esp, 160		; 000000a0H
  0001c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00021	33 c5		 xor	 eax, ebp
  00023	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00026	c7 85 68 ff ff
	ff b3 8a b5 41	 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  00030	c7 85 6c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z
  0003a	c7 85 70 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ; std::_Maklocstr<wchar_t>
  00044	8d 85 68 ff ff
	ff		 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0004a	89 45 ec	 mov	 DWORD PTR tv144[ebp], eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR tv144[ebp]
  00050	c1 e9 03	 shr	 ecx, 3
  00053	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  00059	89 4d c8	 mov	 DWORD PTR tv146[ebp], ecx
  0005c	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0005f	c7 02 f1 f1 00
	f2		 mov	 DWORD PTR [edx], -234819087 ; f200f1f1H
  00065	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00069	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  0006c	c7 00 02 f2 00
	f3		 mov	 DWORD PTR [eax], -218041854 ; f300f202H
  00072	83 45 c8 04	 add	 DWORD PTR tv146[ebp], 4
  00076	b9 f3 f3 00 00	 mov	 ecx, 62451		; 0000f3f3H
  0007b	8b 55 c8	 mov	 edx, DWORD PTR tv146[ebp]
  0007e	66 89 0a	 mov	 WORD PTR [edx], cx
  00081	83 45 c8 02	 add	 DWORD PTR tv146[ebp], 2
  00085	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  00088	c6 00 f3	 mov	 BYTE PTR [eax], 243	; 000000f3H
  0008b	b9 00 00 00 00	 mov	 ecx, OFFSET __D23FE460_xlocale
  00090	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 541  :     // convert C string to wchar_t sequence using _Cvtvec
; 542  :     size_t _Count;
; 543  :     size_t _Count1;
; 544  :     size_t _Wchars;
; 545  :     const char* _Ptr1;
; 546  :     int _Bytes;
; 547  :     wchar_t _Wc;
; 548  :     mbstate_t _Mbst1 = {};

  00095	6a 08		 push	 8
  00097	6a 00		 push	 0
  00099	8d 8d 78 ff ff
	ff		 lea	 ecx, DWORD PTR __Mbst1$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ___asan_memset
  000a5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 549  : 
; 550  :     _Count1 = _CSTD strlen(_Ptr) + 1;

  000a8	8b 53 08	 mov	 edx, DWORD PTR __Ptr$[ebx]
  000ab	52		 push	 edx
  000ac	e8 00 00 00 00	 call	 _strlen
  000b1	83 c4 04	 add	 esp, 4
  000b4	83 c0 01	 add	 eax, 1
  000b7	89 45 e8	 mov	 DWORD PTR __Count1$[ebp], eax

; 551  :     for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars) {

  000ba	8b 45 e8	 mov	 eax, DWORD PTR __Count1$[ebp]
  000bd	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  000c0	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR __Wchars$[ebp], 0
  000c7	8b 4b 08	 mov	 ecx, DWORD PTR __Ptr$[ebx]
  000ca	89 4d dc	 mov	 DWORD PTR __Ptr1$[ebp], ecx
  000cd	eb 1b		 jmp	 SHORT $LN4@Maklocstr
$LN2@Maklocstr:
  000cf	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  000d2	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  000d5	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  000d8	8b 45 dc	 mov	 eax, DWORD PTR __Ptr1$[ebp]
  000db	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  000de	89 45 dc	 mov	 DWORD PTR __Ptr1$[ebp], eax
  000e1	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  000e4	83 c1 01	 add	 ecx, 1
  000e7	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
$LN4@Maklocstr:
  000ea	83 7d d4 00	 cmp	 DWORD PTR __Count$[ebp], 0
  000ee	76 2c		 jbe	 SHORT $LN3@Maklocstr

; 552  :         if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) {

  000f0	8b 53 10	 mov	 edx, DWORD PTR __Cvt$[ebx]
  000f3	52		 push	 edx
  000f4	8d 85 78 ff ff
	ff		 lea	 eax, DWORD PTR __Mbst1$[ebp]
  000fa	50		 push	 eax
  000fb	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  000fe	51		 push	 ecx
  000ff	8b 55 dc	 mov	 edx, DWORD PTR __Ptr1$[ebp]
  00102	52		 push	 edx
  00103	8d 45 88	 lea	 eax, DWORD PTR __Wc$[ebp]
  00106	50		 push	 eax
  00107	e8 00 00 00 00	 call	 __Mbrtowc
  0010c	83 c4 14	 add	 esp, 20			; 00000014H
  0010f	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  00112	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  00116	7f 02		 jg	 SHORT $LN8@Maklocstr

; 553  :             break;

  00118	eb 02		 jmp	 SHORT $LN3@Maklocstr
$LN8@Maklocstr:

; 554  :         }
; 555  :     }

  0011a	eb b3		 jmp	 SHORT $LN2@Maklocstr
$LN3@Maklocstr:

; 556  : 
; 557  :     ++_Wchars; // count terminating nul

  0011c	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx

; 558  : 
; 559  :     wchar_t* _Ptrdest = static_cast<wchar_t*>(_calloc_dbg(_Wchars, sizeof(wchar_t), _CRT_BLOCK, __FILE__, __LINE__));

  00125	68 2f 02 00 00	 push	 559			; 0000022fH
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@GFIAKDGM@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0012f	6a 02		 push	 2
  00131	6a 02		 push	 2
  00133	8b 55 cc	 mov	 edx, DWORD PTR __Wchars$[ebp]
  00136	52		 push	 edx
  00137	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___calloc_dbg
  0013d	83 c4 14	 add	 esp, 20			; 00000014H
  00140	89 45 e4	 mov	 DWORD PTR __Ptrdest$[ebp], eax

; 560  : 
; 561  :     if (!_Ptrdest) {

  00143	83 7d e4 00	 cmp	 DWORD PTR __Ptrdest$[ebp], 0
  00147	75 05		 jne	 SHORT $LN9@Maklocstr

; 562  :         _Xbad_alloc();

  00149	e8 00 00 00 00	 call	 ?_Xbad_alloc@std@@YAXXZ	; std::_Xbad_alloc
$LN9@Maklocstr:

; 563  :     }
; 564  : 
; 565  :     wchar_t* _Ptrnext = _Ptrdest;

  0014e	8b 45 e4	 mov	 eax, DWORD PTR __Ptrdest$[ebp]
  00151	89 45 d8	 mov	 DWORD PTR __Ptrnext$[ebp], eax

; 566  :     mbstate_t _Mbst2  = {};

  00154	6a 08		 push	 8
  00156	6a 00		 push	 0
  00158	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 ___asan_memset
  00161	83 c4 0c	 add	 esp, 12			; 0000000cH

; 567  : 
; 568  :     for (; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext) {

  00164	eb 24		 jmp	 SHORT $LN7@Maklocstr
$LN5@Maklocstr:
  00166	8b 55 d4	 mov	 edx, DWORD PTR __Count$[ebp]
  00169	2b 55 d0	 sub	 edx, DWORD PTR __Bytes$[ebp]
  0016c	89 55 d4	 mov	 DWORD PTR __Count$[ebp], edx
  0016f	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  00172	03 45 d0	 add	 eax, DWORD PTR __Bytes$[ebp]
  00175	89 43 08	 mov	 DWORD PTR __Ptr$[ebx], eax
  00178	8b 4d cc	 mov	 ecx, DWORD PTR __Wchars$[ebp]
  0017b	83 e9 01	 sub	 ecx, 1
  0017e	89 4d cc	 mov	 DWORD PTR __Wchars$[ebp], ecx
  00181	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  00184	83 c2 02	 add	 edx, 2
  00187	89 55 d8	 mov	 DWORD PTR __Ptrnext$[ebp], edx
$LN7@Maklocstr:
  0018a	83 7d cc 00	 cmp	 DWORD PTR __Wchars$[ebp], 0
  0018e	76 29		 jbe	 SHORT $LN6@Maklocstr

; 569  :         if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) {

  00190	8b 43 10	 mov	 eax, DWORD PTR __Cvt$[ebx]
  00193	50		 push	 eax
  00194	8d 4d 98	 lea	 ecx, DWORD PTR __Mbst2$[ebp]
  00197	51		 push	 ecx
  00198	8b 55 e8	 mov	 edx, DWORD PTR __Count1$[ebp]
  0019b	52		 push	 edx
  0019c	8b 43 08	 mov	 eax, DWORD PTR __Ptr$[ebx]
  0019f	50		 push	 eax
  001a0	8b 4d d8	 mov	 ecx, DWORD PTR __Ptrnext$[ebp]
  001a3	51		 push	 ecx
  001a4	e8 00 00 00 00	 call	 __Mbrtowc
  001a9	83 c4 14	 add	 esp, 20			; 00000014H
  001ac	89 45 d0	 mov	 DWORD PTR __Bytes$[ebp], eax
  001af	83 7d d0 00	 cmp	 DWORD PTR __Bytes$[ebp], 0
  001b3	7f 02		 jg	 SHORT $LN10@Maklocstr

; 570  :             break;

  001b5	eb 02		 jmp	 SHORT $LN6@Maklocstr
$LN10@Maklocstr:

; 571  :         }
; 572  :     }

  001b7	eb ad		 jmp	 SHORT $LN5@Maklocstr
$LN6@Maklocstr:

; 573  : 
; 574  :     *_Ptrnext = L'\0';

  001b9	8b 55 d8	 mov	 edx, DWORD PTR __Ptrnext$[ebp]
  001bc	89 55 f0	 mov	 DWORD PTR tv141[ebp], edx
  001bf	8b 45 f0	 mov	 eax, DWORD PTR tv141[ebp]
  001c2	89 45 e0	 mov	 DWORD PTR tv153[ebp], eax
  001c5	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001c8	c1 e9 03	 shr	 ecx, 3
  001cb	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001d1	88 55 c7	 mov	 BYTE PTR tv156[ebp], dl
  001d4	80 7d c7 00	 cmp	 BYTE PTR tv156[ebp], 0
  001d8	74 18		 je	 SHORT $LN12@Maklocstr
  001da	8a 45 e0	 mov	 al, BYTE PTR tv153[ebp]
  001dd	24 07		 and	 al, 7
  001df	04 01		 add	 al, 1
  001e1	3a 45 c7	 cmp	 al, BYTE PTR tv156[ebp]
  001e4	7c 0c		 jl	 SHORT $LN12@Maklocstr
  001e6	8b 4d e0	 mov	 ecx, DWORD PTR tv153[ebp]
  001e9	51		 push	 ecx
  001ea	e8 00 00 00 00	 call	 ___asan_report_store2
  001ef	83 c4 04	 add	 esp, 4
$LN12@Maklocstr:
  001f2	33 d2		 xor	 edx, edx
  001f4	8b 45 d8	 mov	 eax, DWORD PTR __Ptrnext$[ebp]
  001f7	66 89 10	 mov	 WORD PTR [eax], dx

; 575  : 
; 576  :     return _Ptrdest;

  001fa	8b 4d e4	 mov	 ecx, DWORD PTR __Ptrdest$[ebp]
  001fd	89 4d f8	 mov	 DWORD PTR tv140[ebp], ecx
  00200	c7 85 68 ff ff
	ff 0e 36 e0 45	 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0020a	8d 95 68 ff ff
	ff		 lea	 edx, DWORD PTR __asan_gen_0$[ebp]
  00210	c1 ea 03	 shr	 edx, 3
  00213	81 c2 00 00 00
	30		 add	 edx, 805306368		; 30000000H
  00219	89 55 f4	 mov	 DWORD PTR tv149[ebp], edx
  0021c	6a 0b		 push	 11			; 0000000bH
  0021e	8b 45 f4	 mov	 eax, DWORD PTR tv149[ebp]
  00221	50		 push	 eax
  00222	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  00227	83 c4 08	 add	 esp, 8
  0022a	8b 45 f8	 mov	 eax, DWORD PTR tv140[ebp]
$LN11@Maklocstr:

; 577  : }

  0022d	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00230	33 cd		 xor	 ecx, ebp
  00232	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00237	8b e5		 mov	 esp, ebp
  00239	5d		 pop	 ebp
  0023a	8b e3		 mov	 esp, ebx
  0023c	5b		 pop	 ebx
  0023d	c3		 ret	 0
??$_Maklocstr@_W@std@@YAPA_WPBDPA_WABU_Cvtvec@@@Z ENDP	; std::_Maklocstr<wchar_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ PROC	; std::_Iterator_base12::_Orphan_me_locked_v3, COMDAT
; _this$ = ecx

; 1229 :     void _Orphan_me_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1230 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1231 :         _Orphan_me_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1232 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ENDP	; std::_Iterator_base12::_Orphan_me_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv141 = -96						; size = 4
tv136 = -92						; size = 4
__Temp$1 = -88						; size = 4
tv133 = -84						; size = 4
tv130 = -80						; size = 4
tv95 = -76						; size = 4
tv89 = -72						; size = 4
tv88 = -68						; size = 4
tv66 = -64						; size = 4
tv64 = -60						; size = 4
tv146 = -56						; size = 4
tv156 = -52						; size = 4
tv166 = -48						; size = 4
tv176 = -44						; size = 4
tv186 = -40						; size = 4
tv196 = -36						; size = 4
tv206 = -32						; size = 4
tv216 = -28						; size = 4
tv226 = -24						; size = 4
_this$ = -20						; size = 4
__Pnext$ = -16						; size = 4
tv149 = -9						; size = 1
tv159 = -8						; size = 1
tv169 = -7						; size = 1
tv179 = -6						; size = 1
tv189 = -5						; size = 1
tv199 = -4						; size = 1
tv209 = -3						; size = 1
tv219 = -2						; size = 1
tv229 = -1						; size = 1
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ PROC ; std::_Iterator_base12::_Orphan_me_unlocked_v3, COMDAT
; _this$ = ecx

; 1212 :     _CONSTEXPR20_CONTAINER void _Orphan_me_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1213 :         if (!_Myproxy) { // already orphaned

  00013	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c4	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c4	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d e8	 mov	 DWORD PTR tv226[ebp], ecx
  0001f	8b 55 e8	 mov	 edx, DWORD PTR tv226[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv229[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv229[ebp], 0
  00032	74 1a		 je	 SHORT $LN23@Orphan_me_
  00034	8a 4d e8	 mov	 cl, BYTE PTR tv226[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv229[ebp]
  00040	7c 0c		 jl	 SHORT $LN23@Orphan_me_
  00042	8b 55 e8	 mov	 edx, DWORD PTR tv226[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN23@Orphan_me_:
  0004e	8b 45 c4	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN10@Orphan_me_

; 1214 :             return;

  00056	e9 81 02 00 00	 jmp	 $LN13@Orphan_me_
$LN10@Orphan_me_:

; 1215 :         }
; 1216 : 
; 1217 :         // adopted, remove self from list
; 1218 :         _Iterator_base12** _Pnext = &_Myproxy->_Myfirstiter;

  0005b	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d c0	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 c0	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e4	 mov	 DWORD PTR tv216[ebp], edx
  00067	8b 45 e4	 mov	 eax, DWORD PTR tv216[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv219[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv219[ebp], 0
  0007a	74 1a		 je	 SHORT $LN22@Orphan_me_
  0007c	8a 55 e4	 mov	 dl, BYTE PTR tv216[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv219[ebp]
  00088	7c 0c		 jl	 SHORT $LN22@Orphan_me_
  0008a	8b 45 e4	 mov	 eax, DWORD PTR tv216[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN22@Orphan_me_:
  00096	8b 4d c0	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$[ebp], edx
$LN2@Orphan_me_:

; 1219 :         while (*_Pnext && *_Pnext != this) {

  000a1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000a4	89 45 b4	 mov	 DWORD PTR tv95[ebp], eax
  000a7	8b 4d b4	 mov	 ecx, DWORD PTR tv95[ebp]
  000aa	89 4d e0	 mov	 DWORD PTR tv206[ebp], ecx
  000ad	8b 55 e0	 mov	 edx, DWORD PTR tv206[ebp]
  000b0	c1 ea 03	 shr	 edx, 3
  000b3	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000b9	88 45 fd	 mov	 BYTE PTR tv209[ebp], al
  000bc	80 7d fd 00	 cmp	 BYTE PTR tv209[ebp], 0
  000c0	74 1a		 je	 SHORT $LN21@Orphan_me_
  000c2	8a 4d e0	 mov	 cl, BYTE PTR tv206[ebp]
  000c5	80 e1 07	 and	 cl, 7
  000c8	80 c1 03	 add	 cl, 3
  000cb	3a 4d fd	 cmp	 cl, BYTE PTR tv209[ebp]
  000ce	7c 0c		 jl	 SHORT $LN21@Orphan_me_
  000d0	8b 55 e0	 mov	 edx, DWORD PTR tv206[ebp]
  000d3	52		 push	 edx
  000d4	e8 00 00 00 00	 call	 ___asan_report_load4
  000d9	83 c4 04	 add	 esp, 4
$LN21@Orphan_me_:
  000dc	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  000df	83 38 00	 cmp	 DWORD PTR [eax], 0
  000e2	0f 84 96 00 00
	00		 je	 $LN6@Orphan_me_
  000e8	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  000eb	89 4d b0	 mov	 DWORD PTR tv130[ebp], ecx
  000ee	8b 55 b0	 mov	 edx, DWORD PTR tv130[ebp]
  000f1	89 55 dc	 mov	 DWORD PTR tv196[ebp], edx
  000f4	8b 45 dc	 mov	 eax, DWORD PTR tv196[ebp]
  000f7	c1 e8 03	 shr	 eax, 3
  000fa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00100	88 4d fc	 mov	 BYTE PTR tv199[ebp], cl
  00103	80 7d fc 00	 cmp	 BYTE PTR tv199[ebp], 0
  00107	74 1a		 je	 SHORT $LN20@Orphan_me_
  00109	8a 55 dc	 mov	 dl, BYTE PTR tv196[ebp]
  0010c	80 e2 07	 and	 dl, 7
  0010f	80 c2 03	 add	 dl, 3
  00112	3a 55 fc	 cmp	 dl, BYTE PTR tv199[ebp]
  00115	7c 0c		 jl	 SHORT $LN20@Orphan_me_
  00117	8b 45 dc	 mov	 eax, DWORD PTR tv196[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 ___asan_report_load4
  00120	83 c4 04	 add	 esp, 4
$LN20@Orphan_me_:
  00123	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00126	8b 11		 mov	 edx, DWORD PTR [ecx]
  00128	3b 55 ec	 cmp	 edx, DWORD PTR _this$[ebp]
  0012b	74 51		 je	 SHORT $LN6@Orphan_me_

; 1220 :             const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037

  0012d	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00130	89 45 ac	 mov	 DWORD PTR tv133[ebp], eax
  00133	8b 4d ac	 mov	 ecx, DWORD PTR tv133[ebp]
  00136	89 4d d8	 mov	 DWORD PTR tv186[ebp], ecx
  00139	8b 55 d8	 mov	 edx, DWORD PTR tv186[ebp]
  0013c	c1 ea 03	 shr	 edx, 3
  0013f	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00145	88 45 fb	 mov	 BYTE PTR tv189[ebp], al
  00148	80 7d fb 00	 cmp	 BYTE PTR tv189[ebp], 0
  0014c	74 1a		 je	 SHORT $LN19@Orphan_me_
  0014e	8a 4d d8	 mov	 cl, BYTE PTR tv186[ebp]
  00151	80 e1 07	 and	 cl, 7
  00154	80 c1 03	 add	 cl, 3
  00157	3a 4d fb	 cmp	 cl, BYTE PTR tv189[ebp]
  0015a	7c 0c		 jl	 SHORT $LN19@Orphan_me_
  0015c	8b 55 d8	 mov	 edx, DWORD PTR tv186[ebp]
  0015f	52		 push	 edx
  00160	e8 00 00 00 00	 call	 ___asan_report_load4
  00165	83 c4 04	 add	 esp, 4
$LN19@Orphan_me_:
  00168	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  0016b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0016d	89 4d a8	 mov	 DWORD PTR __Temp$1[ebp], ecx

; 1221 :             _Pnext           = &_Temp->_Mynextiter;

  00170	8b 55 a8	 mov	 edx, DWORD PTR __Temp$1[ebp]
  00173	83 c2 04	 add	 edx, 4
  00176	89 55 f0	 mov	 DWORD PTR __Pnext$[ebp], edx

; 1222 :         }

  00179	e9 23 ff ff ff	 jmp	 $LN2@Orphan_me_
$LN6@Orphan_me_:

; 1223 : 
; 1224 :         _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");

  0017e	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  00181	89 45 a4	 mov	 DWORD PTR tv136[ebp], eax
  00184	8b 4d a4	 mov	 ecx, DWORD PTR tv136[ebp]
  00187	89 4d d4	 mov	 DWORD PTR tv176[ebp], ecx
  0018a	8b 55 d4	 mov	 edx, DWORD PTR tv176[ebp]
  0018d	c1 ea 03	 shr	 edx, 3
  00190	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00196	88 45 fa	 mov	 BYTE PTR tv179[ebp], al
  00199	80 7d fa 00	 cmp	 BYTE PTR tv179[ebp], 0
  0019d	74 1a		 je	 SHORT $LN18@Orphan_me_
  0019f	8a 4d d4	 mov	 cl, BYTE PTR tv176[ebp]
  001a2	80 e1 07	 and	 cl, 7
  001a5	80 c1 03	 add	 cl, 3
  001a8	3a 4d fa	 cmp	 cl, BYTE PTR tv179[ebp]
  001ab	7c 0c		 jl	 SHORT $LN18@Orphan_me_
  001ad	8b 55 d4	 mov	 edx, DWORD PTR tv176[ebp]
  001b0	52		 push	 edx
  001b1	e8 00 00 00 00	 call	 ___asan_report_load4
  001b6	83 c4 04	 add	 esp, 4
$LN18@Orphan_me_:
  001b9	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$[ebp]
  001bc	83 38 00	 cmp	 DWORD PTR [eax], 0
  001bf	74 02		 je	 SHORT $LN9@Orphan_me_
  001c1	eb 4a		 jmp	 SHORT $LN4@Orphan_me_
$LN9@Orphan_me_:
  001c3	68 00 00 00 00	 push	 OFFSET ??_C@_0BJ@LFDBABJJ@ITERATOR?5LIST?5CORRUPTED?$CB@
  001c8	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  001cd	6a 00		 push	 0
  001cf	68 c8 04 00 00	 push	 1224			; 000004c8H
  001d4	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  001d9	6a 02		 push	 2
  001db	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  001e1	83 c4 18	 add	 esp, 24			; 00000018H
  001e4	83 f8 01	 cmp	 eax, 1
  001e7	75 01		 jne	 SHORT $LN14@Orphan_me_
  001e9	cc		 int	 3
$LN14@Orphan_me_:
  001ea	6a 00		 push	 0
  001ec	68 c8 04 00 00	 push	 1224			; 000004c8H
  001f1	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001f6	68 00 00 00 00	 push	 OFFSET ??_C@_1FM@FOFDAEGI@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAI?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA_@
  001fb	68 00 00 00 00	 push	 OFFSET ??_C@_1DG@PLBPCAEM@?$AA?$CC?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5@
  00200	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00206	83 c4 14	 add	 esp, 20			; 00000014H
  00209	33 d2		 xor	 edx, edx
  0020b	75 b6		 jne	 SHORT $LN9@Orphan_me_
$LN4@Orphan_me_:
  0020d	33 c0		 xor	 eax, eax
  0020f	0f 85 69 ff ff
	ff		 jne	 $LN6@Orphan_me_

; 1225 :         *_Pnext  = _Mynextiter;

  00215	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00218	83 c1 04	 add	 ecx, 4
  0021b	89 4d bc	 mov	 DWORD PTR tv88[ebp], ecx
  0021e	8b 55 bc	 mov	 edx, DWORD PTR tv88[ebp]
  00221	89 55 d0	 mov	 DWORD PTR tv166[ebp], edx
  00224	8b 45 d0	 mov	 eax, DWORD PTR tv166[ebp]
  00227	c1 e8 03	 shr	 eax, 3
  0022a	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00230	88 4d f9	 mov	 BYTE PTR tv169[ebp], cl
  00233	80 7d f9 00	 cmp	 BYTE PTR tv169[ebp], 0
  00237	74 1a		 je	 SHORT $LN17@Orphan_me_
  00239	8a 55 d0	 mov	 dl, BYTE PTR tv166[ebp]
  0023c	80 e2 07	 and	 dl, 7
  0023f	80 c2 03	 add	 dl, 3
  00242	3a 55 f9	 cmp	 dl, BYTE PTR tv169[ebp]
  00245	7c 0c		 jl	 SHORT $LN17@Orphan_me_
  00247	8b 45 d0	 mov	 eax, DWORD PTR tv166[ebp]
  0024a	50		 push	 eax
  0024b	e8 00 00 00 00	 call	 ___asan_report_load4
  00250	83 c4 04	 add	 esp, 4
$LN17@Orphan_me_:
  00253	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00256	89 4d a0	 mov	 DWORD PTR tv141[ebp], ecx
  00259	8b 55 a0	 mov	 edx, DWORD PTR tv141[ebp]
  0025c	89 55 cc	 mov	 DWORD PTR tv156[ebp], edx
  0025f	8b 45 cc	 mov	 eax, DWORD PTR tv156[ebp]
  00262	c1 e8 03	 shr	 eax, 3
  00265	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0026b	88 4d f8	 mov	 BYTE PTR tv159[ebp], cl
  0026e	80 7d f8 00	 cmp	 BYTE PTR tv159[ebp], 0
  00272	74 1a		 je	 SHORT $LN16@Orphan_me_
  00274	8a 55 cc	 mov	 dl, BYTE PTR tv156[ebp]
  00277	80 e2 07	 and	 dl, 7
  0027a	80 c2 03	 add	 dl, 3
  0027d	3a 55 f8	 cmp	 dl, BYTE PTR tv159[ebp]
  00280	7c 0c		 jl	 SHORT $LN16@Orphan_me_
  00282	8b 45 cc	 mov	 eax, DWORD PTR tv156[ebp]
  00285	50		 push	 eax
  00286	e8 00 00 00 00	 call	 ___asan_report_store4
  0028b	83 c4 04	 add	 esp, 4
$LN16@Orphan_me_:
  0028e	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$[ebp]
  00291	8b 55 bc	 mov	 edx, DWORD PTR tv88[ebp]
  00294	8b 02		 mov	 eax, DWORD PTR [edx]
  00296	89 01		 mov	 DWORD PTR [ecx], eax

; 1226 :         _Myproxy = nullptr;

  00298	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0029b	89 4d b8	 mov	 DWORD PTR tv89[ebp], ecx
  0029e	8b 55 b8	 mov	 edx, DWORD PTR tv89[ebp]
  002a1	89 55 c8	 mov	 DWORD PTR tv146[ebp], edx
  002a4	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  002a7	c1 e8 03	 shr	 eax, 3
  002aa	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  002b0	88 4d f7	 mov	 BYTE PTR tv149[ebp], cl
  002b3	80 7d f7 00	 cmp	 BYTE PTR tv149[ebp], 0
  002b7	74 1a		 je	 SHORT $LN15@Orphan_me_
  002b9	8a 55 c8	 mov	 dl, BYTE PTR tv146[ebp]
  002bc	80 e2 07	 and	 dl, 7
  002bf	80 c2 03	 add	 dl, 3
  002c2	3a 55 f7	 cmp	 dl, BYTE PTR tv149[ebp]
  002c5	7c 0c		 jl	 SHORT $LN15@Orphan_me_
  002c7	8b 45 c8	 mov	 eax, DWORD PTR tv146[ebp]
  002ca	50		 push	 eax
  002cb	e8 00 00 00 00	 call	 ___asan_report_store4
  002d0	83 c4 04	 add	 esp, 4
$LN15@Orphan_me_:
  002d3	8b 4d b8	 mov	 ecx, DWORD PTR tv89[ebp]
  002d6	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0
$LN13@Orphan_me_:

; 1227 :     }

  002dc	8b e5		 mov	 esp, ebp
  002de	5d		 pop	 ebp
  002df	c3		 ret	 0
?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ENDP ; std::_Iterator_base12::_Orphan_me_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv72 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv75 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
__Parent$ = 8						; size = 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_locked, COMDAT
; _this$ = ecx

; 1207 :     void _Adopt_locked(const _Container_base12* _Parent) noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv72[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv72[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv72[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv72[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv72[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1208 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1209 :         _Adopt_unlocked(_Parent);

  00087	8b 43 08	 mov	 eax, DWORD PTR __Parent$[ebx]
  0008a	50		 push	 eax
  0008b	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008e	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1210 :     }

  00093	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00096	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0009c	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  000a3	8d 4d b0	 lea	 ecx, DWORD PTR __asan_gen_0$[ebp]
  000a6	c1 e9 03	 shr	 ecx, 3
  000a9	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  000af	89 4d f8	 mov	 DWORD PTR tv75[ebp], ecx
  000b2	6a 07		 push	 7
  000b4	8b 55 f8	 mov	 edx, DWORD PTR tv75[ebp]
  000b7	52		 push	 edx
  000b8	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000bd	83 c4 08	 add	 esp, 8
  000c0	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c3	33 cd		 xor	 ecx, ebp
  000c5	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	8b e3		 mov	 esp, ebx
  000cf	5b		 pop	 ebx
  000d0	c2 04 00	 ret	 4
?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_locked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
tv75 = -72						; size = 4
tv74 = -68						; size = 4
tv73 = -64						; size = 4
tv72 = -60						; size = 4
tv69 = -56						; size = 4
tv67 = -52						; size = 4
tv66 = -48						; size = 4
tv91 = -44						; size = 4
tv133 = -40						; size = 4
tv143 = -36						; size = 4
tv153 = -32						; size = 4
tv163 = -28						; size = 4
tv173 = -24						; size = 4
tv183 = -20						; size = 4
__Parent_proxy$ = -16					; size = 4
_this$ = -12						; size = 4
tv94 = -7						; size = 1
tv136 = -6						; size = 1
tv146 = -5						; size = 1
tv156 = -4						; size = 1
tv166 = -3						; size = 1
tv176 = -2						; size = 1
tv186 = -1						; size = 1
__Parent$ = 8						; size = 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt_unlocked, COMDAT
; _this$ = ecx

; 1190 :     _CONSTEXPR20_CONTAINER void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1191 :         if (!_Parent) {

  00013	83 7d 08 00	 cmp	 DWORD PTR __Parent$[ebp], 0
  00017	75 0d		 jne	 SHORT $LN2@Adopt_unlo

; 1192 :             _Orphan_me_unlocked_v3();

  00019	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0001c	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1193 :             return;

  00021	e9 e0 01 00 00	 jmp	 $LN5@Adopt_unlo
$LN2@Adopt_unlo:

; 1194 :         }
; 1195 : 
; 1196 :         _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

  00026	8b 45 08	 mov	 eax, DWORD PTR __Parent$[ebp]
  00029	89 45 d0	 mov	 DWORD PTR tv66[ebp], eax
  0002c	8b 4d d0	 mov	 ecx, DWORD PTR tv66[ebp]
  0002f	89 4d ec	 mov	 DWORD PTR tv183[ebp], ecx
  00032	8b 55 ec	 mov	 edx, DWORD PTR tv183[ebp]
  00035	c1 ea 03	 shr	 edx, 3
  00038	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0003e	88 45 ff	 mov	 BYTE PTR tv186[ebp], al
  00041	80 7d ff 00	 cmp	 BYTE PTR tv186[ebp], 0
  00045	74 1a		 je	 SHORT $LN12@Adopt_unlo
  00047	8a 4d ec	 mov	 cl, BYTE PTR tv183[ebp]
  0004a	80 e1 07	 and	 cl, 7
  0004d	80 c1 03	 add	 cl, 3
  00050	3a 4d ff	 cmp	 cl, BYTE PTR tv186[ebp]
  00053	7c 0c		 jl	 SHORT $LN12@Adopt_unlo
  00055	8b 55 ec	 mov	 edx, DWORD PTR tv183[ebp]
  00058	52		 push	 edx
  00059	e8 00 00 00 00	 call	 ___asan_report_load4
  0005e	83 c4 04	 add	 esp, 4
$LN12@Adopt_unlo:
  00061	8b 45 d0	 mov	 eax, DWORD PTR tv66[ebp]
  00064	8b 08		 mov	 ecx, DWORD PTR [eax]
  00066	89 4d f0	 mov	 DWORD PTR __Parent_proxy$[ebp], ecx

; 1197 :         if (_Myproxy != _Parent_proxy) { // change parentage

  00069	8b 55 f4	 mov	 edx, DWORD PTR _this$[ebp]
  0006c	89 55 cc	 mov	 DWORD PTR tv67[ebp], edx
  0006f	8b 45 cc	 mov	 eax, DWORD PTR tv67[ebp]
  00072	89 45 e8	 mov	 DWORD PTR tv173[ebp], eax
  00075	8b 4d e8	 mov	 ecx, DWORD PTR tv173[ebp]
  00078	c1 e9 03	 shr	 ecx, 3
  0007b	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00081	88 55 fe	 mov	 BYTE PTR tv176[ebp], dl
  00084	80 7d fe 00	 cmp	 BYTE PTR tv176[ebp], 0
  00088	74 18		 je	 SHORT $LN11@Adopt_unlo
  0008a	8a 45 e8	 mov	 al, BYTE PTR tv173[ebp]
  0008d	24 07		 and	 al, 7
  0008f	04 03		 add	 al, 3
  00091	3a 45 fe	 cmp	 al, BYTE PTR tv176[ebp]
  00094	7c 0c		 jl	 SHORT $LN11@Adopt_unlo
  00096	8b 4d e8	 mov	 ecx, DWORD PTR tv173[ebp]
  00099	51		 push	 ecx
  0009a	e8 00 00 00 00	 call	 ___asan_report_load4
  0009f	83 c4 04	 add	 esp, 4
$LN11@Adopt_unlo:
  000a2	8b 55 cc	 mov	 edx, DWORD PTR tv67[ebp]
  000a5	8b 02		 mov	 eax, DWORD PTR [edx]
  000a7	3b 45 f0	 cmp	 eax, DWORD PTR __Parent_proxy$[ebp]
  000aa	0f 84 56 01 00
	00		 je	 $LN5@Adopt_unlo

; 1198 :             if (_Myproxy) { // adopted, remove self from list

  000b0	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000b3	89 4d c8	 mov	 DWORD PTR tv69[ebp], ecx
  000b6	8b 55 c8	 mov	 edx, DWORD PTR tv69[ebp]
  000b9	89 55 e4	 mov	 DWORD PTR tv163[ebp], edx
  000bc	8b 45 e4	 mov	 eax, DWORD PTR tv163[ebp]
  000bf	c1 e8 03	 shr	 eax, 3
  000c2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000c8	88 4d fd	 mov	 BYTE PTR tv166[ebp], cl
  000cb	80 7d fd 00	 cmp	 BYTE PTR tv166[ebp], 0
  000cf	74 1a		 je	 SHORT $LN10@Adopt_unlo
  000d1	8a 55 e4	 mov	 dl, BYTE PTR tv163[ebp]
  000d4	80 e2 07	 and	 dl, 7
  000d7	80 c2 03	 add	 dl, 3
  000da	3a 55 fd	 cmp	 dl, BYTE PTR tv166[ebp]
  000dd	7c 0c		 jl	 SHORT $LN10@Adopt_unlo
  000df	8b 45 e4	 mov	 eax, DWORD PTR tv163[ebp]
  000e2	50		 push	 eax
  000e3	e8 00 00 00 00	 call	 ___asan_report_load4
  000e8	83 c4 04	 add	 esp, 4
$LN10@Adopt_unlo:
  000eb	8b 4d c8	 mov	 ecx, DWORD PTR tv69[ebp]
  000ee	83 39 00	 cmp	 DWORD PTR [ecx], 0
  000f1	74 08		 je	 SHORT $LN4@Adopt_unlo

; 1199 :                 _Orphan_me_unlocked_v3();

  000f3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  000f6	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3
$LN4@Adopt_unlo:

; 1200 :             }
; 1201 :             _Mynextiter                 = _Parent_proxy->_Myfirstiter;

  000fb	8b 55 f0	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  000fe	83 c2 04	 add	 edx, 4
  00101	89 55 c0	 mov	 DWORD PTR tv73[ebp], edx
  00104	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00107	83 c0 04	 add	 eax, 4
  0010a	89 45 c4	 mov	 DWORD PTR tv72[ebp], eax
  0010d	8b 4d c0	 mov	 ecx, DWORD PTR tv73[ebp]
  00110	89 4d e0	 mov	 DWORD PTR tv153[ebp], ecx
  00113	8b 55 e0	 mov	 edx, DWORD PTR tv153[ebp]
  00116	c1 ea 03	 shr	 edx, 3
  00119	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0011f	88 45 fc	 mov	 BYTE PTR tv156[ebp], al
  00122	80 7d fc 00	 cmp	 BYTE PTR tv156[ebp], 0
  00126	74 1a		 je	 SHORT $LN9@Adopt_unlo
  00128	8a 4d e0	 mov	 cl, BYTE PTR tv153[ebp]
  0012b	80 e1 07	 and	 cl, 7
  0012e	80 c1 03	 add	 cl, 3
  00131	3a 4d fc	 cmp	 cl, BYTE PTR tv156[ebp]
  00134	7c 0c		 jl	 SHORT $LN9@Adopt_unlo
  00136	8b 55 e0	 mov	 edx, DWORD PTR tv153[ebp]
  00139	52		 push	 edx
  0013a	e8 00 00 00 00	 call	 ___asan_report_load4
  0013f	83 c4 04	 add	 esp, 4
$LN9@Adopt_unlo:
  00142	8b 45 c4	 mov	 eax, DWORD PTR tv72[ebp]
  00145	89 45 dc	 mov	 DWORD PTR tv143[ebp], eax
  00148	8b 4d dc	 mov	 ecx, DWORD PTR tv143[ebp]
  0014b	c1 e9 03	 shr	 ecx, 3
  0014e	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00154	88 55 fb	 mov	 BYTE PTR tv146[ebp], dl
  00157	80 7d fb 00	 cmp	 BYTE PTR tv146[ebp], 0
  0015b	74 18		 je	 SHORT $LN8@Adopt_unlo
  0015d	8a 45 dc	 mov	 al, BYTE PTR tv143[ebp]
  00160	24 07		 and	 al, 7
  00162	04 03		 add	 al, 3
  00164	3a 45 fb	 cmp	 al, BYTE PTR tv146[ebp]
  00167	7c 0c		 jl	 SHORT $LN8@Adopt_unlo
  00169	8b 4d dc	 mov	 ecx, DWORD PTR tv143[ebp]
  0016c	51		 push	 ecx
  0016d	e8 00 00 00 00	 call	 ___asan_report_store4
  00172	83 c4 04	 add	 esp, 4
$LN8@Adopt_unlo:
  00175	8b 55 c4	 mov	 edx, DWORD PTR tv72[ebp]
  00178	8b 45 c0	 mov	 eax, DWORD PTR tv73[ebp]
  0017b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0017d	89 0a		 mov	 DWORD PTR [edx], ecx

; 1202 :             _Parent_proxy->_Myfirstiter = this;

  0017f	8b 55 f0	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  00182	83 c2 04	 add	 edx, 4
  00185	89 55 bc	 mov	 DWORD PTR tv74[ebp], edx
  00188	8b 45 bc	 mov	 eax, DWORD PTR tv74[ebp]
  0018b	89 45 d8	 mov	 DWORD PTR tv133[ebp], eax
  0018e	8b 4d d8	 mov	 ecx, DWORD PTR tv133[ebp]
  00191	c1 e9 03	 shr	 ecx, 3
  00194	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0019a	88 55 fa	 mov	 BYTE PTR tv136[ebp], dl
  0019d	80 7d fa 00	 cmp	 BYTE PTR tv136[ebp], 0
  001a1	74 18		 je	 SHORT $LN7@Adopt_unlo
  001a3	8a 45 d8	 mov	 al, BYTE PTR tv133[ebp]
  001a6	24 07		 and	 al, 7
  001a8	04 03		 add	 al, 3
  001aa	3a 45 fa	 cmp	 al, BYTE PTR tv136[ebp]
  001ad	7c 0c		 jl	 SHORT $LN7@Adopt_unlo
  001af	8b 4d d8	 mov	 ecx, DWORD PTR tv133[ebp]
  001b2	51		 push	 ecx
  001b3	e8 00 00 00 00	 call	 ___asan_report_store4
  001b8	83 c4 04	 add	 esp, 4
$LN7@Adopt_unlo:
  001bb	8b 55 bc	 mov	 edx, DWORD PTR tv74[ebp]
  001be	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  001c1	89 02		 mov	 DWORD PTR [edx], eax

; 1203 :             _Myproxy                    = _Parent_proxy;

  001c3	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  001c6	89 4d b8	 mov	 DWORD PTR tv75[ebp], ecx
  001c9	8b 55 b8	 mov	 edx, DWORD PTR tv75[ebp]
  001cc	89 55 d4	 mov	 DWORD PTR tv91[ebp], edx
  001cf	8b 45 d4	 mov	 eax, DWORD PTR tv91[ebp]
  001d2	c1 e8 03	 shr	 eax, 3
  001d5	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001db	88 4d f9	 mov	 BYTE PTR tv94[ebp], cl
  001de	80 7d f9 00	 cmp	 BYTE PTR tv94[ebp], 0
  001e2	74 1a		 je	 SHORT $LN6@Adopt_unlo
  001e4	8a 55 d4	 mov	 dl, BYTE PTR tv91[ebp]
  001e7	80 e2 07	 and	 dl, 7
  001ea	80 c2 03	 add	 dl, 3
  001ed	3a 55 f9	 cmp	 dl, BYTE PTR tv94[ebp]
  001f0	7c 0c		 jl	 SHORT $LN6@Adopt_unlo
  001f2	8b 45 d4	 mov	 eax, DWORD PTR tv91[ebp]
  001f5	50		 push	 eax
  001f6	e8 00 00 00 00	 call	 ___asan_report_store4
  001fb	83 c4 04	 add	 esp, 4
$LN6@Adopt_unlo:
  001fe	8b 4d b8	 mov	 ecx, DWORD PTR tv75[ebp]
  00201	8b 55 f0	 mov	 edx, DWORD PTR __Parent_proxy$[ebp]
  00204	89 11		 mov	 DWORD PTR [ecx], edx
$LN5@Adopt_unlo:

; 1204 :         }
; 1205 :     }

  00206	8b e5		 mov	 esp, ebp
  00208	5d		 pop	 ebp
  00209	c2 04 00	 ret	 4
?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt_unlocked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -36						; size = 4
tv66 = -32						; size = 4
tv65 = -28						; size = 4
_this$ = -24						; size = 4
tv64 = -20						; size = 4
tv76 = -16						; size = 4
tv86 = -12						; size = 4
tv128 = -8						; size = 4
tv79 = -3						; size = 1
tv89 = -2						; size = 1
tv131 = -1						; size = 1
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 24	 sub	 esp, 36			; 00000024H
  00006	89 4d e8	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;

  00013	8b 45 e8	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv128[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv131[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv131[ebp], 0
  00032	74 1a		 je	 SHORT $LN7@Getcont
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv128[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv131[ebp]
  00040	7c 0c		 jl	 SHORT $LN7@Getcont
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv128[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN7@Getcont:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	0f 84 80 00 00
	00		 je	 $LN3@Getcont
  0005a	8b 4d e8	 mov	 ecx, DWORD PTR _this$[ebp]
  0005d	89 4d e4	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e4	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f4	 mov	 DWORD PTR tv86[ebp], edx
  00066	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv89[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv89[ebp], 0
  00079	74 1a		 je	 SHORT $LN6@Getcont
  0007b	8a 55 f4	 mov	 dl, BYTE PTR tv86[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv89[ebp]
  00087	7c 0c		 jl	 SHORT $LN6@Getcont
  00089	8b 45 f4	 mov	 eax, DWORD PTR tv86[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_load4
  00092	83 c4 04	 add	 esp, 4
$LN6@Getcont:
  00095	8b 4d e4	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 55 e0	 mov	 DWORD PTR tv66[ebp], edx
  0009d	8b 45 e0	 mov	 eax, DWORD PTR tv66[ebp]
  000a0	89 45 f0	 mov	 DWORD PTR tv76[ebp], eax
  000a3	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  000a6	c1 e9 03	 shr	 ecx, 3
  000a9	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000af	88 55 fd	 mov	 BYTE PTR tv79[ebp], dl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv79[ebp], 0
  000b6	74 18		 je	 SHORT $LN5@Getcont
  000b8	8a 45 f0	 mov	 al, BYTE PTR tv76[ebp]
  000bb	24 07		 and	 al, 7
  000bd	04 03		 add	 al, 3
  000bf	3a 45 fd	 cmp	 al, BYTE PTR tv79[ebp]
  000c2	7c 0c		 jl	 SHORT $LN5@Getcont
  000c4	8b 4d f0	 mov	 ecx, DWORD PTR tv76[ebp]
  000c7	51		 push	 ecx
  000c8	e8 00 00 00 00	 call	 ___asan_report_load4
  000cd	83 c4 04	 add	 esp, 4
$LN5@Getcont:
  000d0	8b 55 e0	 mov	 edx, DWORD PTR tv66[ebp]
  000d3	8b 02		 mov	 eax, DWORD PTR [edx]
  000d5	89 45 dc	 mov	 DWORD PTR tv68[ebp], eax
  000d8	eb 07		 jmp	 SHORT $LN4@Getcont
$LN3@Getcont:
  000da	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR tv68[ebp], 0
$LN4@Getcont:
  000e1	8b 45 dc	 mov	 eax, DWORD PTR tv68[ebp]

; 1164 :     }

  000e4	8b e5		 mov	 esp, ebp
  000e6	5d		 pop	 ebp
  000e7	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0e		 je	 SHORT $LN2@Adopt

; 1145 :             _Adopt_unlocked(_Parent);

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR __Parent$[ebp]
  00020	51		 push	 ecx
  00021	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00024	e8 00 00 00 00	 call	 ?_Adopt_unlocked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_unlocked

; 1146 :         } else

  00029	eb 0c		 jmp	 SHORT $LN4@Adopt
$LN2@Adopt:

; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);

  0002b	8b 55 08	 mov	 edx, DWORD PTR __Parent$[ebp]
  0002e	52		 push	 edx
  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00032	e8 00 00 00 00	 call	 ?_Adopt_locked@_Iterator_base12@std@@AAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt_locked
$LN4@Adopt:

; 1150 :         }
; 1151 :     }

  00037	8b e5		 mov	 esp, ebp
  00039	5d		 pop	 ebp
  0003a	c2 04 00	 ret	 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Iterator_b

; 1134 :             _Orphan_me_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_me_unlocked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_unlocked_v3

; 1135 :         } else

  00025	eb 08		 jmp	 SHORT $LN4@Iterator_b
$LN2@Iterator_b:

; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_me_locked_v3@_Iterator_base12@std@@AAEXXZ ; std::_Iterator_base12::_Orphan_me_locked_v3
$LN4@Iterator_b:

; 1139 :         }
; 1140 :     }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
tv65 = -24						; size = 4
tv64 = -20						; size = 4
_this$ = -16						; size = 4
tv71 = -12						; size = 4
tv81 = -8						; size = 4
tv74 = -2						; size = 1
tv84 = -1						; size = 1
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 1108 :     _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 18	 sub	 esp, 24			; 00000018H
  00006	89 4d f0	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1109 : 
; 1110 :     _CONSTEXPR20_CONTAINER _Iterator_base12(const _Iterator_base12& _Right) noexcept {
; 1111 :         *this = _Right;
; 1112 :     }
; 1113 : 
; 1114 :     _CONSTEXPR20_CONTAINER _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept {
; 1115 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1116 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1117 :         if (_STD is_constant_evaluated()) {
; 1118 :             _Assign_unlocked(_Right);
; 1119 :         } else
; 1120 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1121 :         {
; 1122 :             _Assign_locked(_Right);
; 1123 :         }
; 1124 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1125 :         _Myproxy = _Right._Myproxy;
; 1126 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1127 :         return *this;
; 1128 :     }
; 1129 : 
; 1130 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1131 :     _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {
; 1132 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1133 :         if (_STD is_constant_evaluated()) {
; 1134 :             _Orphan_me_unlocked_v3();
; 1135 :         } else
; 1136 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1137 :         {
; 1138 :             _Orphan_me_locked_v3();
; 1139 :         }
; 1140 :     }
; 1141 : 
; 1142 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1143 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1144 :         if (_STD is_constant_evaluated()) {
; 1145 :             _Adopt_unlocked(_Parent);
; 1146 :         } else
; 1147 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1148 :         {
; 1149 :             _Adopt_locked(_Parent);
; 1150 :         }
; 1151 :     }
; 1152 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1153 :     _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
; 1154 :         if (_Parent) { // have a parent, do adoption
; 1155 :             _Myproxy = _Parent->_Myproxy;
; 1156 :         } else { // no future parent, just disown current parent
; 1157 :             _Myproxy = nullptr;
; 1158 :         }
; 1159 :     }
; 1160 : #endif // _ITERATOR_DEBUG_LEVEL != 2
; 1161 : 
; 1162 :     _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {
; 1163 :         return _Myproxy ? _Myproxy->_Mycont : nullptr;
; 1164 :     }
; 1165 : 
; 1166 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1167 : 
; 1168 :     mutable _Container_proxy* _Myproxy    = nullptr;

  00013	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 ec	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d ec	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d f8	 mov	 DWORD PTR tv81[ebp], ecx
  0001f	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv84[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv84[ebp], 0
  00032	74 1a		 je	 SHORT $LN4@Iterator_b
  00034	8a 4d f8	 mov	 cl, BYTE PTR tv81[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv84[ebp]
  00040	7c 0c		 jl	 SHORT $LN4@Iterator_b
  00042	8b 55 f8	 mov	 edx, DWORD PTR tv81[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_store4
  0004b	83 c4 04	 add	 esp, 4
$LN4@Iterator_b:
  0004e	8b 45 ec	 mov	 eax, DWORD PTR tv64[ebp]
  00051	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1169 :     mutable _Iterator_base12* _Mynextiter = nullptr;

  00057	8b 4d f0	 mov	 ecx, DWORD PTR _this$[ebp]
  0005a	83 c1 04	 add	 ecx, 4
  0005d	89 4d e8	 mov	 DWORD PTR tv65[ebp], ecx
  00060	8b 55 e8	 mov	 edx, DWORD PTR tv65[ebp]
  00063	89 55 f4	 mov	 DWORD PTR tv71[ebp], edx
  00066	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  00069	c1 e8 03	 shr	 eax, 3
  0006c	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00072	88 4d fe	 mov	 BYTE PTR tv74[ebp], cl
  00075	80 7d fe 00	 cmp	 BYTE PTR tv74[ebp], 0
  00079	74 1a		 je	 SHORT $LN3@Iterator_b
  0007b	8a 55 f4	 mov	 dl, BYTE PTR tv71[ebp]
  0007e	80 e2 07	 and	 dl, 7
  00081	80 c2 03	 add	 dl, 3
  00084	3a 55 fe	 cmp	 dl, BYTE PTR tv74[ebp]
  00087	7c 0c		 jl	 SHORT $LN3@Iterator_b
  00089	8b 45 f4	 mov	 eax, DWORD PTR tv71[ebp]
  0008c	50		 push	 eax
  0008d	e8 00 00 00 00	 call	 ___asan_report_store4
  00092	83 c4 04	 add	 esp, 4
$LN3@Iterator_b:
  00095	8b 4d e8	 mov	 ecx, DWORD PTR tv65[ebp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [ecx], 0

; 1108 :     _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator

  0009e	8b 45 f0	 mov	 eax, DWORD PTR _this$[ebp]
  000a1	8b e5		 mov	 esp, ebp
  000a3	5d		 pop	 ebp
  000a4	c3		 ret	 0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__asan_gen_0$ = -80					; size = 4
__asan_gen_1$ = -76					; size = 4
__asan_gen_2$ = -72					; size = 4
__Lock$ = -64						; size = 4
tv71 = -20						; size = 4
tv65 = -16						; size = 4
_this$ = -12						; size = 4
tv74 = -8						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1095 :     void _Orphan_all_locked_v3() noexcept {

  00000	53		 push	 ebx
  00001	8b dc		 mov	 ebx, esp
  00003	83 ec 08	 sub	 esp, 8
  00006	83 e4 e0	 and	 esp, -32		; ffffffe0H
  00009	83 c4 04	 add	 esp, 4
  0000c	55		 push	 ebp
  0000d	8b 6b 04	 mov	 ebp, DWORD PTR [ebx+4]
  00010	89 6c 24 04	 mov	 DWORD PTR [esp+4], ebp
  00014	8b ec		 mov	 ebp, esp
  00016	83 ec 60	 sub	 esp, 96			; 00000060H
  00019	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0001e	33 c5		 xor	 eax, ebp
  00020	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00023	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  00026	c7 45 b0 b3 8a
	b5 41		 mov	 DWORD PTR __asan_gen_0$[ebp], 1102416563 ; 41b58ab3H
  0002d	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR __asan_gen_1$[ebp], OFFSET __L__asan_gen_.?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
  00034	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR __asan_gen_2$[ebp], OFFSET ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
  0003b	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  0003e	89 45 f0	 mov	 DWORD PTR tv65[ebp], eax
  00041	8b 4d f0	 mov	 ecx, DWORD PTR tv65[ebp]
  00044	c1 e9 03	 shr	 ecx, 3
  00047	81 c1 00 00 00
	30		 add	 ecx, 805306368		; 30000000H
  0004d	89 4d ec	 mov	 DWORD PTR tv71[ebp], ecx
  00050	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  00053	c7 02 f1 f1 04
	f3		 mov	 DWORD PTR [edx], -217779727 ; f304f1f1H
  00059	83 45 ec 04	 add	 DWORD PTR tv71[ebp], 4
  0005d	b8 f3 f3 00 00	 mov	 eax, 62451		; 0000f3f3H
  00062	8b 4d ec	 mov	 ecx, DWORD PTR tv71[ebp]
  00065	66 89 01	 mov	 WORD PTR [ecx], ax
  00068	83 45 ec 02	 add	 DWORD PTR tv71[ebp], 2
  0006c	8b 55 ec	 mov	 edx, DWORD PTR tv71[ebp]
  0006f	c6 02 f3	 mov	 BYTE PTR [edx], 243	; 000000f3H
  00072	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  00077	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1096 :         _Lockit _Lock(_LOCK_DEBUG);

  0007c	6a 03		 push	 3
  0007e	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z

; 1097 :         _Orphan_all_unlocked_v3();

  00087	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0008a	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1098 :     }

  0008f	8d 4d c0	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00092	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  00098	c7 45 b0 0e 36
	e0 45		 mov	 DWORD PTR __asan_gen_0$[ebp], 1172321806 ; 45e0360eH
  0009f	8d 45 b0	 lea	 eax, DWORD PTR __asan_gen_0$[ebp]
  000a2	c1 e8 03	 shr	 eax, 3
  000a5	05 00 00 00 30	 add	 eax, 805306368		; 30000000H
  000aa	89 45 f8	 mov	 DWORD PTR tv74[ebp], eax
  000ad	6a 07		 push	 7
  000af	8b 4d f8	 mov	 ecx, DWORD PTR tv74[ebp]
  000b2	51		 push	 ecx
  000b3	e8 00 00 00 00	 call	 ___asan_set_shadow_00
  000b8	83 c4 08	 add	 esp, 8
  000bb	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000be	33 cd		 xor	 ecx, ebp
  000c0	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000c5	8b e5		 mov	 esp, ebp
  000c7	5d		 pop	 ebp
  000c8	8b e3		 mov	 esp, ebx
  000ca	5b		 pop	 ebx
  000cb	c3		 ret	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
tv89 = -100						; size = 4
tv86 = -96						; size = 4
tv83 = -92						; size = 4
tv78 = -88						; size = 4
tv72 = -84						; size = 4
tv71 = -80						; size = 4
tv70 = -76						; size = 4
tv68 = -72						; size = 4
tv66 = -68						; size = 4
tv64 = -64						; size = 4
tv130 = -60						; size = 4
tv140 = -56						; size = 4
_this$ = -52						; size = 4
tv150 = -48						; size = 4
tv160 = -44						; size = 4
tv170 = -40						; size = 4
tv180 = -36						; size = 4
tv190 = -32						; size = 4
tv200 = -28						; size = 4
tv210 = -24						; size = 4
tv220 = -20						; size = 4
__Pnext$1 = -16						; size = 4
tv133 = -10						; size = 1
tv143 = -9						; size = 1
tv153 = -8						; size = 1
tv163 = -7						; size = 1
tv173 = -6						; size = 1
tv183 = -5						; size = 1
tv193 = -4						; size = 1
tv203 = -3						; size = 1
tv213 = -2						; size = 1
tv223 = -1						; size = 1
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	89 4d cc	 mov	 DWORD PTR _this$[ebp], ecx
  00009	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000e	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 :     if (!_Myproxy) { // no proxy, already done

  00013	8b 45 cc	 mov	 eax, DWORD PTR _this$[ebp]
  00016	89 45 c0	 mov	 DWORD PTR tv64[ebp], eax
  00019	8b 4d c0	 mov	 ecx, DWORD PTR tv64[ebp]
  0001c	89 4d ec	 mov	 DWORD PTR tv220[ebp], ecx
  0001f	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00022	c1 ea 03	 shr	 edx, 3
  00025	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0002b	88 45 ff	 mov	 BYTE PTR tv223[ebp], al
  0002e	80 7d ff 00	 cmp	 BYTE PTR tv223[ebp], 0
  00032	74 1a		 je	 SHORT $LN16@Orphan_all
  00034	8a 4d ec	 mov	 cl, BYTE PTR tv220[ebp]
  00037	80 e1 07	 and	 cl, 7
  0003a	80 c1 03	 add	 cl, 3
  0003d	3a 4d ff	 cmp	 cl, BYTE PTR tv223[ebp]
  00040	7c 0c		 jl	 SHORT $LN16@Orphan_all
  00042	8b 55 ec	 mov	 edx, DWORD PTR tv220[ebp]
  00045	52		 push	 edx
  00046	e8 00 00 00 00	 call	 ___asan_report_load4
  0004b	83 c4 04	 add	 esp, 4
$LN16@Orphan_all:
  0004e	8b 45 c0	 mov	 eax, DWORD PTR tv64[ebp]
  00051	83 38 00	 cmp	 DWORD PTR [eax], 0
  00054	75 05		 jne	 SHORT $LN5@Orphan_all

; 1239 :         return;

  00056	e9 58 02 00 00	 jmp	 $LN6@Orphan_all
$LN5@Orphan_all:

; 1240 :     }
; 1241 : 
; 1242 :     // proxy allocated, drain it
; 1243 :     for (auto& _Pnext = _Myproxy->_Myfirstiter; _Pnext; _Pnext = _Pnext->_Mynextiter) { // TRANSITION, VSO-1269037

  0005b	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  0005e	89 4d bc	 mov	 DWORD PTR tv66[ebp], ecx
  00061	8b 55 bc	 mov	 edx, DWORD PTR tv66[ebp]
  00064	89 55 e8	 mov	 DWORD PTR tv210[ebp], edx
  00067	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0006a	c1 e8 03	 shr	 eax, 3
  0006d	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00073	88 4d fe	 mov	 BYTE PTR tv213[ebp], cl
  00076	80 7d fe 00	 cmp	 BYTE PTR tv213[ebp], 0
  0007a	74 1a		 je	 SHORT $LN15@Orphan_all
  0007c	8a 55 e8	 mov	 dl, BYTE PTR tv210[ebp]
  0007f	80 e2 07	 and	 dl, 7
  00082	80 c2 03	 add	 dl, 3
  00085	3a 55 fe	 cmp	 dl, BYTE PTR tv213[ebp]
  00088	7c 0c		 jl	 SHORT $LN15@Orphan_all
  0008a	8b 45 e8	 mov	 eax, DWORD PTR tv210[ebp]
  0008d	50		 push	 eax
  0008e	e8 00 00 00 00	 call	 ___asan_report_load4
  00093	83 c4 04	 add	 esp, 4
$LN15@Orphan_all:
  00096	8b 4d bc	 mov	 ecx, DWORD PTR tv66[ebp]
  00099	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009b	83 c2 04	 add	 edx, 4
  0009e	89 55 f0	 mov	 DWORD PTR __Pnext$1[ebp], edx
  000a1	e9 c0 00 00 00	 jmp	 $LN4@Orphan_all
$LN2@Orphan_all:
  000a6	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000a9	89 45 a8	 mov	 DWORD PTR tv78[ebp], eax
  000ac	8b 4d a8	 mov	 ecx, DWORD PTR tv78[ebp]
  000af	89 4d e4	 mov	 DWORD PTR tv200[ebp], ecx
  000b2	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000b5	c1 ea 03	 shr	 edx, 3
  000b8	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  000be	88 45 fd	 mov	 BYTE PTR tv203[ebp], al
  000c1	80 7d fd 00	 cmp	 BYTE PTR tv203[ebp], 0
  000c5	74 1a		 je	 SHORT $LN14@Orphan_all
  000c7	8a 4d e4	 mov	 cl, BYTE PTR tv200[ebp]
  000ca	80 e1 07	 and	 cl, 7
  000cd	80 c1 03	 add	 cl, 3
  000d0	3a 4d fd	 cmp	 cl, BYTE PTR tv203[ebp]
  000d3	7c 0c		 jl	 SHORT $LN14@Orphan_all
  000d5	8b 55 e4	 mov	 edx, DWORD PTR tv200[ebp]
  000d8	52		 push	 edx
  000d9	e8 00 00 00 00	 call	 ___asan_report_load4
  000de	83 c4 04	 add	 esp, 4
$LN14@Orphan_all:
  000e1	8b 45 f0	 mov	 eax, DWORD PTR __Pnext$1[ebp]
  000e4	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e6	83 c1 04	 add	 ecx, 4
  000e9	89 4d b8	 mov	 DWORD PTR tv68[ebp], ecx
  000ec	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  000ef	89 55 e0	 mov	 DWORD PTR tv190[ebp], edx
  000f2	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  000f5	c1 e8 03	 shr	 eax, 3
  000f8	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000fe	88 4d fc	 mov	 BYTE PTR tv193[ebp], cl
  00101	80 7d fc 00	 cmp	 BYTE PTR tv193[ebp], 0
  00105	74 1a		 je	 SHORT $LN13@Orphan_all
  00107	8a 55 e0	 mov	 dl, BYTE PTR tv190[ebp]
  0010a	80 e2 07	 and	 dl, 7
  0010d	80 c2 03	 add	 dl, 3
  00110	3a 55 fc	 cmp	 dl, BYTE PTR tv193[ebp]
  00113	7c 0c		 jl	 SHORT $LN13@Orphan_all
  00115	8b 45 e0	 mov	 eax, DWORD PTR tv190[ebp]
  00118	50		 push	 eax
  00119	e8 00 00 00 00	 call	 ___asan_report_load4
  0011e	83 c4 04	 add	 esp, 4
$LN13@Orphan_all:
  00121	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00124	89 4d a4	 mov	 DWORD PTR tv83[ebp], ecx
  00127	8b 55 a4	 mov	 edx, DWORD PTR tv83[ebp]
  0012a	89 55 dc	 mov	 DWORD PTR tv180[ebp], edx
  0012d	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00130	c1 e8 03	 shr	 eax, 3
  00133	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00139	88 4d fb	 mov	 BYTE PTR tv183[ebp], cl
  0013c	80 7d fb 00	 cmp	 BYTE PTR tv183[ebp], 0
  00140	74 1a		 je	 SHORT $LN12@Orphan_all
  00142	8a 55 dc	 mov	 dl, BYTE PTR tv180[ebp]
  00145	80 e2 07	 and	 dl, 7
  00148	80 c2 03	 add	 dl, 3
  0014b	3a 55 fb	 cmp	 dl, BYTE PTR tv183[ebp]
  0014e	7c 0c		 jl	 SHORT $LN12@Orphan_all
  00150	8b 45 dc	 mov	 eax, DWORD PTR tv180[ebp]
  00153	50		 push	 eax
  00154	e8 00 00 00 00	 call	 ___asan_report_store4
  00159	83 c4 04	 add	 esp, 4
$LN12@Orphan_all:
  0015c	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  0015f	8b 55 b8	 mov	 edx, DWORD PTR tv68[ebp]
  00162	8b 02		 mov	 eax, DWORD PTR [edx]
  00164	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@Orphan_all:
  00166	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  00169	89 4d a0	 mov	 DWORD PTR tv86[ebp], ecx
  0016c	8b 55 a0	 mov	 edx, DWORD PTR tv86[ebp]
  0016f	89 55 d8	 mov	 DWORD PTR tv170[ebp], edx
  00172	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00175	c1 e8 03	 shr	 eax, 3
  00178	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  0017e	88 4d fa	 mov	 BYTE PTR tv173[ebp], cl
  00181	80 7d fa 00	 cmp	 BYTE PTR tv173[ebp], 0
  00185	74 1a		 je	 SHORT $LN11@Orphan_all
  00187	8a 55 d8	 mov	 dl, BYTE PTR tv170[ebp]
  0018a	80 e2 07	 and	 dl, 7
  0018d	80 c2 03	 add	 dl, 3
  00190	3a 55 fa	 cmp	 dl, BYTE PTR tv173[ebp]
  00193	7c 0c		 jl	 SHORT $LN11@Orphan_all
  00195	8b 45 d8	 mov	 eax, DWORD PTR tv170[ebp]
  00198	50		 push	 eax
  00199	e8 00 00 00 00	 call	 ___asan_report_load4
  0019e	83 c4 04	 add	 esp, 4
$LN11@Orphan_all:
  001a1	8b 4d f0	 mov	 ecx, DWORD PTR __Pnext$1[ebp]
  001a4	83 39 00	 cmp	 DWORD PTR [ecx], 0
  001a7	0f 84 84 00 00
	00		 je	 $LN3@Orphan_all

; 1244 :         _Pnext->_Myproxy = nullptr;

  001ad	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001b0	89 55 9c	 mov	 DWORD PTR tv89[ebp], edx
  001b3	8b 45 9c	 mov	 eax, DWORD PTR tv89[ebp]
  001b6	89 45 d4	 mov	 DWORD PTR tv160[ebp], eax
  001b9	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001bc	c1 e9 03	 shr	 ecx, 3
  001bf	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  001c5	88 55 f9	 mov	 BYTE PTR tv163[ebp], dl
  001c8	80 7d f9 00	 cmp	 BYTE PTR tv163[ebp], 0
  001cc	74 18		 je	 SHORT $LN10@Orphan_all
  001ce	8a 45 d4	 mov	 al, BYTE PTR tv160[ebp]
  001d1	24 07		 and	 al, 7
  001d3	04 03		 add	 al, 3
  001d5	3a 45 f9	 cmp	 al, BYTE PTR tv163[ebp]
  001d8	7c 0c		 jl	 SHORT $LN10@Orphan_all
  001da	8b 4d d4	 mov	 ecx, DWORD PTR tv160[ebp]
  001dd	51		 push	 ecx
  001de	e8 00 00 00 00	 call	 ___asan_report_load4
  001e3	83 c4 04	 add	 esp, 4
$LN10@Orphan_all:
  001e6	8b 55 f0	 mov	 edx, DWORD PTR __Pnext$1[ebp]
  001e9	8b 02		 mov	 eax, DWORD PTR [edx]
  001eb	89 45 b4	 mov	 DWORD PTR tv70[ebp], eax
  001ee	8b 4d b4	 mov	 ecx, DWORD PTR tv70[ebp]
  001f1	89 4d d0	 mov	 DWORD PTR tv150[ebp], ecx
  001f4	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  001f7	c1 ea 03	 shr	 edx, 3
  001fa	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00200	88 45 f8	 mov	 BYTE PTR tv153[ebp], al
  00203	80 7d f8 00	 cmp	 BYTE PTR tv153[ebp], 0
  00207	74 1a		 je	 SHORT $LN9@Orphan_all
  00209	8a 4d d0	 mov	 cl, BYTE PTR tv150[ebp]
  0020c	80 e1 07	 and	 cl, 7
  0020f	80 c1 03	 add	 cl, 3
  00212	3a 4d f8	 cmp	 cl, BYTE PTR tv153[ebp]
  00215	7c 0c		 jl	 SHORT $LN9@Orphan_all
  00217	8b 55 d0	 mov	 edx, DWORD PTR tv150[ebp]
  0021a	52		 push	 edx
  0021b	e8 00 00 00 00	 call	 ___asan_report_store4
  00220	83 c4 04	 add	 esp, 4
$LN9@Orphan_all:
  00223	8b 45 b4	 mov	 eax, DWORD PTR tv70[ebp]
  00226	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1245 :     }

  0022c	e9 75 fe ff ff	 jmp	 $LN2@Orphan_all
$LN3@Orphan_all:

; 1246 :     _Myproxy->_Myfirstiter = nullptr;

  00231	8b 4d cc	 mov	 ecx, DWORD PTR _this$[ebp]
  00234	89 4d b0	 mov	 DWORD PTR tv71[ebp], ecx
  00237	8b 55 b0	 mov	 edx, DWORD PTR tv71[ebp]
  0023a	89 55 c8	 mov	 DWORD PTR tv140[ebp], edx
  0023d	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00240	c1 e8 03	 shr	 eax, 3
  00243	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  00249	88 4d f7	 mov	 BYTE PTR tv143[ebp], cl
  0024c	80 7d f7 00	 cmp	 BYTE PTR tv143[ebp], 0
  00250	74 1a		 je	 SHORT $LN8@Orphan_all
  00252	8a 55 c8	 mov	 dl, BYTE PTR tv140[ebp]
  00255	80 e2 07	 and	 dl, 7
  00258	80 c2 03	 add	 dl, 3
  0025b	3a 55 f7	 cmp	 dl, BYTE PTR tv143[ebp]
  0025e	7c 0c		 jl	 SHORT $LN8@Orphan_all
  00260	8b 45 c8	 mov	 eax, DWORD PTR tv140[ebp]
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ___asan_report_load4
  00269	83 c4 04	 add	 esp, 4
$LN8@Orphan_all:
  0026c	8b 4d b0	 mov	 ecx, DWORD PTR tv71[ebp]
  0026f	8b 11		 mov	 edx, DWORD PTR [ecx]
  00271	83 c2 04	 add	 edx, 4
  00274	89 55 ac	 mov	 DWORD PTR tv72[ebp], edx
  00277	8b 45 ac	 mov	 eax, DWORD PTR tv72[ebp]
  0027a	89 45 c4	 mov	 DWORD PTR tv130[ebp], eax
  0027d	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  00280	c1 e9 03	 shr	 ecx, 3
  00283	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  00289	88 55 f6	 mov	 BYTE PTR tv133[ebp], dl
  0028c	80 7d f6 00	 cmp	 BYTE PTR tv133[ebp], 0
  00290	74 18		 je	 SHORT $LN7@Orphan_all
  00292	8a 45 c4	 mov	 al, BYTE PTR tv130[ebp]
  00295	24 07		 and	 al, 7
  00297	04 03		 add	 al, 3
  00299	3a 45 f6	 cmp	 al, BYTE PTR tv133[ebp]
  0029c	7c 0c		 jl	 SHORT $LN7@Orphan_all
  0029e	8b 4d c4	 mov	 ecx, DWORD PTR tv130[ebp]
  002a1	51		 push	 ecx
  002a2	e8 00 00 00 00	 call	 ___asan_report_store4
  002a7	83 c4 04	 add	 esp, 4
$LN7@Orphan_all:
  002aa	8b 55 ac	 mov	 edx, DWORD PTR tv72[ebp]
  002ad	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0
$LN6@Orphan_all:

; 1247 : }

  002b3	8b e5		 mov	 esp, ebp
  002b5	5d		 pop	 ebp
  002b6	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1249 : _CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx
  00004	89 4d fc	 mov	 DWORD PTR _this$[ebp], ecx
  00007	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1250 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1251 : #ifdef __cpp_lib_constexpr_dynamic_alloc
; 1252 :     if (_STD is_constant_evaluated()) {

  00011	e8 00 00 00 00	 call	 ?is_constant_evaluated@std@@YA_NXZ ; std::is_constant_evaluated
  00016	0f b6 c0	 movzx	 eax, al
  00019	85 c0		 test	 eax, eax
  0001b	74 0a		 je	 SHORT $LN2@Orphan_all

; 1253 :         _Orphan_all_unlocked_v3();

  0001d	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  00020	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1254 :     } else

  00025	eb 08		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 1255 : #endif // __cpp_lib_constexpr_dynamic_alloc
; 1256 :     {
; 1257 :         _Orphan_all_locked_v3();

  00027	8b 4d fc	 mov	 ecx, DWORD PTR _this$[ebp]
  0002a	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
$LN4@Orphan_all:

; 1258 :     }
; 1259 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1260 : }

  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Min_back_shift$ = -84					; size = 4
tv154 = -80						; size = 4
tv151 = -76						; size = 4
tv144 = -72						; size = 4
tv64 = -68						; size = 4
tv141 = -64						; size = 4
tv138 = -60						; size = 4
__Ptr_container$ = -56					; size = 4
__Back_shift$ = -52					; size = 4
tv68 = -48						; size = 4
__Ptr_user$ = -44					; size = 4
tv66 = -40						; size = 4
tv157 = -36						; size = 4
tv167 = -32						; size = 4
tv177 = -28						; size = 4
tv187 = -24						; size = 4
tv197 = -20						; size = 4
tv207 = -16						; size = 4
tv217 = -12						; size = 4
tv160 = -7						; size = 1
tv170 = -6						; size = 1
tv180 = -5						; size = 1
tv190 = -4						; size = 1
tv200 = -3						; size = 1
tv210 = -2						; size = 1
tv220 = -1						; size = 1
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 153  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	b9 00 00 00 00	 mov	 ecx, OFFSET __79D216CD_xmemory
  0000b	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 154  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 155  :     _Bytes += _Non_user_size;

  00010	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00013	89 45 c4	 mov	 DWORD PTR tv138[ebp], eax
  00016	8b 4d c4	 mov	 ecx, DWORD PTR tv138[ebp]
  00019	89 4d f4	 mov	 DWORD PTR tv217[ebp], ecx
  0001c	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  0001f	c1 ea 03	 shr	 edx, 3
  00022	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00028	88 45 ff	 mov	 BYTE PTR tv220[ebp], al
  0002b	80 7d ff 00	 cmp	 BYTE PTR tv220[ebp], 0
  0002f	74 1a		 je	 SHORT $LN27@Adjust_man
  00031	8a 4d f4	 mov	 cl, BYTE PTR tv217[ebp]
  00034	80 e1 07	 and	 cl, 7
  00037	80 c1 03	 add	 cl, 3
  0003a	3a 4d ff	 cmp	 cl, BYTE PTR tv220[ebp]
  0003d	7c 0c		 jl	 SHORT $LN27@Adjust_man
  0003f	8b 55 f4	 mov	 edx, DWORD PTR tv217[ebp]
  00042	52		 push	 edx
  00043	e8 00 00 00 00	 call	 ___asan_report_load4
  00048	83 c4 04	 add	 esp, 4
$LN27@Adjust_man:
  0004b	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0004e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00050	83 c1 27	 add	 ecx, 39			; 00000027H
  00053	89 4d bc	 mov	 DWORD PTR tv64[ebp], ecx
  00056	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00059	89 55 c0	 mov	 DWORD PTR tv141[ebp], edx
  0005c	8b 45 c0	 mov	 eax, DWORD PTR tv141[ebp]
  0005f	89 45 f0	 mov	 DWORD PTR tv207[ebp], eax
  00062	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00065	c1 e9 03	 shr	 ecx, 3
  00068	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  0006e	88 55 fe	 mov	 BYTE PTR tv210[ebp], dl
  00071	80 7d fe 00	 cmp	 BYTE PTR tv210[ebp], 0
  00075	74 18		 je	 SHORT $LN26@Adjust_man
  00077	8a 45 f0	 mov	 al, BYTE PTR tv207[ebp]
  0007a	24 07		 and	 al, 7
  0007c	04 03		 add	 al, 3
  0007e	3a 45 fe	 cmp	 al, BYTE PTR tv210[ebp]
  00081	7c 0c		 jl	 SHORT $LN26@Adjust_man
  00083	8b 4d f0	 mov	 ecx, DWORD PTR tv207[ebp]
  00086	51		 push	 ecx
  00087	e8 00 00 00 00	 call	 ___asan_report_store4
  0008c	83 c4 04	 add	 esp, 4
$LN26@Adjust_man:
  0008f	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00092	8b 45 bc	 mov	 eax, DWORD PTR tv64[ebp]
  00095	89 02		 mov	 DWORD PTR [edx], eax

; 156  : 
; 157  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);

  00097	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009a	89 4d b8	 mov	 DWORD PTR tv144[ebp], ecx
  0009d	8b 55 b8	 mov	 edx, DWORD PTR tv144[ebp]
  000a0	89 55 ec	 mov	 DWORD PTR tv197[ebp], edx
  000a3	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000a6	c1 e8 03	 shr	 eax, 3
  000a9	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  000af	88 4d fd	 mov	 BYTE PTR tv200[ebp], cl
  000b2	80 7d fd 00	 cmp	 BYTE PTR tv200[ebp], 0
  000b6	74 1a		 je	 SHORT $LN25@Adjust_man
  000b8	8a 55 ec	 mov	 dl, BYTE PTR tv197[ebp]
  000bb	80 e2 07	 and	 dl, 7
  000be	80 c2 03	 add	 dl, 3
  000c1	3a 55 fd	 cmp	 dl, BYTE PTR tv200[ebp]
  000c4	7c 0c		 jl	 SHORT $LN25@Adjust_man
  000c6	8b 45 ec	 mov	 eax, DWORD PTR tv197[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 ___asan_report_load4
  000cf	83 c4 04	 add	 esp, 4
$LN25@Adjust_man:
  000d2	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  000d5	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d7	89 55 d4	 mov	 DWORD PTR __Ptr_user$[ebp], edx

; 158  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  000da	b8 04 00 00 00	 mov	 eax, 4
  000df	6b c8 ff	 imul	 ecx, eax, -1
  000e2	8b 55 d4	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  000e5	03 d1		 add	 edx, ecx
  000e7	89 55 d8	 mov	 DWORD PTR tv66[ebp], edx
  000ea	8b 45 d8	 mov	 eax, DWORD PTR tv66[ebp]
  000ed	89 45 e8	 mov	 DWORD PTR tv187[ebp], eax
  000f0	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  000f3	c1 e9 03	 shr	 ecx, 3
  000f6	8a 91 00 00 00
	30		 mov	 dl, BYTE PTR [ecx+805306368]
  000fc	88 55 fc	 mov	 BYTE PTR tv190[ebp], dl
  000ff	80 7d fc 00	 cmp	 BYTE PTR tv190[ebp], 0
  00103	74 18		 je	 SHORT $LN24@Adjust_man
  00105	8a 45 e8	 mov	 al, BYTE PTR tv187[ebp]
  00108	24 07		 and	 al, 7
  0010a	04 03		 add	 al, 3
  0010c	3a 45 fc	 cmp	 al, BYTE PTR tv190[ebp]
  0010f	7c 0c		 jl	 SHORT $LN24@Adjust_man
  00111	8b 4d e8	 mov	 ecx, DWORD PTR tv187[ebp]
  00114	51		 push	 ecx
  00115	e8 00 00 00 00	 call	 ___asan_report_load4
  0011a	83 c4 04	 add	 esp, 4
$LN24@Adjust_man:
  0011d	8b 55 d8	 mov	 edx, DWORD PTR tv66[ebp]
  00120	8b 02		 mov	 eax, DWORD PTR [edx]
  00122	89 45 c8	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 159  : 
; 160  :     // If the following asserts, it likely means that we are performing
; 161  :     // an aligned delete on memory coming from an unaligned allocation.
; 162  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  00125	b9 04 00 00 00	 mov	 ecx, 4
  0012a	6b d1 fe	 imul	 edx, ecx, -2
  0012d	8b 45 d4	 mov	 eax, DWORD PTR __Ptr_user$[ebp]
  00130	03 c2		 add	 eax, edx
  00132	89 45 d0	 mov	 DWORD PTR tv68[ebp], eax
  00135	8b 4d d0	 mov	 ecx, DWORD PTR tv68[ebp]
  00138	89 4d e4	 mov	 DWORD PTR tv177[ebp], ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  0013e	c1 ea 03	 shr	 edx, 3
  00141	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  00147	88 45 fb	 mov	 BYTE PTR tv180[ebp], al
  0014a	80 7d fb 00	 cmp	 BYTE PTR tv180[ebp], 0
  0014e	74 1a		 je	 SHORT $LN23@Adjust_man
  00150	8a 4d e4	 mov	 cl, BYTE PTR tv177[ebp]
  00153	80 e1 07	 and	 cl, 7
  00156	80 c1 03	 add	 cl, 3
  00159	3a 4d fb	 cmp	 cl, BYTE PTR tv180[ebp]
  0015c	7c 0c		 jl	 SHORT $LN23@Adjust_man
  0015e	8b 55 e4	 mov	 edx, DWORD PTR tv177[ebp]
  00161	52		 push	 edx
  00162	e8 00 00 00 00	 call	 ___asan_report_load4
  00167	83 c4 04	 add	 esp, 4
$LN23@Adjust_man:
  0016a	8b 45 d0	 mov	 eax, DWORD PTR tv68[ebp]
  0016d	81 38 fa fa fa
	fa		 cmp	 DWORD PTR [eax], -84215046 ; fafafafaH
  00173	75 02		 jne	 SHORT $LN7@Adjust_man
  00175	eb 4a		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00177	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  0017c	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00181	6a 00		 push	 0
  00183	68 a2 00 00 00	 push	 162			; 000000a2H
  00188	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0018d	6a 02		 push	 2
  0018f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00195	83 c4 18	 add	 esp, 24			; 00000018H
  00198	83 f8 01	 cmp	 eax, 1
  0019b	75 01		 jne	 SHORT $LN19@Adjust_man
  0019d	cc		 int	 3
$LN19@Adjust_man:
  0019e	6a 00		 push	 0
  001a0	68 a2 00 00 00	 push	 162			; 000000a2H
  001a5	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  001aa	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  001af	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  001b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  001ba	83 c4 14	 add	 esp, 20			; 00000014H
  001bd	33 d2		 xor	 edx, edx
  001bf	75 b6		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  001c1	33 c0		 xor	 eax, eax
  001c3	0f 85 5c ff ff
	ff		 jne	 $LN4@Adjust_man

; 163  : 
; 164  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 165  :     // in range [_Min_back_shift, _Non_user_size]
; 166  : #ifdef _DEBUG
; 167  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  001c9	c7 45 ac 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 168  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 169  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 170  : #endif // _DEBUG
; 171  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  001d0	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  001d3	89 4d b4	 mov	 DWORD PTR tv151[ebp], ecx
  001d6	8b 55 b4	 mov	 edx, DWORD PTR tv151[ebp]
  001d9	89 55 e0	 mov	 DWORD PTR tv167[ebp], edx
  001dc	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  001df	c1 e8 03	 shr	 eax, 3
  001e2	8a 88 00 00 00
	30		 mov	 cl, BYTE PTR [eax+805306368]
  001e8	88 4d fa	 mov	 BYTE PTR tv170[ebp], cl
  001eb	80 7d fa 00	 cmp	 BYTE PTR tv170[ebp], 0
  001ef	74 1a		 je	 SHORT $LN22@Adjust_man
  001f1	8a 55 e0	 mov	 dl, BYTE PTR tv167[ebp]
  001f4	80 e2 07	 and	 dl, 7
  001f7	80 c2 03	 add	 dl, 3
  001fa	3a 55 fa	 cmp	 dl, BYTE PTR tv170[ebp]
  001fd	7c 0c		 jl	 SHORT $LN22@Adjust_man
  001ff	8b 45 e0	 mov	 eax, DWORD PTR tv167[ebp]
  00202	50		 push	 eax
  00203	e8 00 00 00 00	 call	 ___asan_report_load4
  00208	83 c4 04	 add	 esp, 4
$LN22@Adjust_man:
  0020b	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0020e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00210	2b 55 c8	 sub	 edx, DWORD PTR __Ptr_container$[ebp]
  00213	89 55 cc	 mov	 DWORD PTR __Back_shift$[ebp], edx
$LN10@Adjust_man:

; 172  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  00216	83 7d cc 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  0021a	72 08		 jb	 SHORT $LN13@Adjust_man
  0021c	83 7d cc 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  00220	77 02		 ja	 SHORT $LN13@Adjust_man
  00222	eb 4a		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  00224	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00229	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0022e	6a 00		 push	 0
  00230	68 ac 00 00 00	 push	 172			; 000000acH
  00235	68 00 00 00 00	 push	 OFFSET ??_C@_0GI@MNEMJBML@C?3?2Program?5Files?5?$CIx86?$CJ?2Microsof@
  0023a	6a 02		 push	 2
  0023c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00242	83 c4 18	 add	 esp, 24			; 00000018H
  00245	83 f8 01	 cmp	 eax, 1
  00248	75 01		 jne	 SHORT $LN20@Adjust_man
  0024a	cc		 int	 3
$LN20@Adjust_man:
  0024b	6a 00		 push	 0
  0024d	68 ac 00 00 00	 push	 172			; 000000acH
  00252	68 00 00 00 00	 push	 OFFSET ??_C@_1NA@MJBOBEJL@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00257	68 00 00 00 00	 push	 OFFSET ??_C@_1EK@NIFDJFDG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAd?$AAj?$AAu?$AAs?$AAt?$AA_?$AAm?$AAa@
  0025c	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00261	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00267	83 c4 14	 add	 esp, 20			; 00000014H
  0026a	33 c9		 xor	 ecx, ecx
  0026c	75 b6		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0026e	33 d2		 xor	 edx, edx
  00270	75 a4		 jne	 SHORT $LN10@Adjust_man

; 173  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00272	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00275	89 45 b0	 mov	 DWORD PTR tv154[ebp], eax
  00278	8b 4d b0	 mov	 ecx, DWORD PTR tv154[ebp]
  0027b	89 4d dc	 mov	 DWORD PTR tv157[ebp], ecx
  0027e	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  00281	c1 ea 03	 shr	 edx, 3
  00284	8a 82 00 00 00
	30		 mov	 al, BYTE PTR [edx+805306368]
  0028a	88 45 f9	 mov	 BYTE PTR tv160[ebp], al
  0028d	80 7d f9 00	 cmp	 BYTE PTR tv160[ebp], 0
  00291	74 1a		 je	 SHORT $LN21@Adjust_man
  00293	8a 4d dc	 mov	 cl, BYTE PTR tv157[ebp]
  00296	80 e1 07	 and	 cl, 7
  00299	80 c1 03	 add	 cl, 3
  0029c	3a 4d f9	 cmp	 cl, BYTE PTR tv160[ebp]
  0029f	7c 0c		 jl	 SHORT $LN21@Adjust_man
  002a1	8b 55 dc	 mov	 edx, DWORD PTR tv157[ebp]
  002a4	52		 push	 edx
  002a5	e8 00 00 00 00	 call	 ___asan_report_store4
  002aa	83 c4 04	 add	 esp, 4
$LN21@Adjust_man:
  002ad	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  002b0	8b 4d c8	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  002b3	89 08		 mov	 DWORD PTR [eax], ecx

; 174  : }

  002b5	8b e5		 mov	 esp, ebp
  002b7	5d		 pop	 ebp
  002b8	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.29.30133\include\xtr1common
;	COMDAT ?is_constant_evaluated@std@@YA_NXZ
_TEXT	SEGMENT
?is_constant_evaluated@std@@YA_NXZ PROC			; std::is_constant_evaluated, COMDAT

; 180  : _NODISCARD constexpr bool is_constant_evaluated() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __47F37C5A_xtr1common
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 181  :     return __builtin_is_constant_evaluated();

  0000d	32 c0		 xor	 al, al

; 182  : }

  0000f	5d		 pop	 ebp
  00010	c3		 ret	 0
?is_constant_evaluated@std@@YA_NXZ ENDP			; std::is_constant_evaluated
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.19041.0\ucrt\wchar.h
;	COMDAT _wmemcpy
_TEXT	SEGMENT
__S1$ = 8						; size = 4
__S2$ = 12						; size = 4
__N$ = 16						; size = 4
_wmemcpy PROC						; COMDAT

; 234  :     {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __93DC0B45_wchar@h
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 235  :         #pragma warning(suppress: 6386) // Buffer overrun
; 236  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

  0000d	8b 45 10	 mov	 eax, DWORD PTR __N$[ebp]
  00010	d1 e0		 shl	 eax, 1
  00012	50		 push	 eax
  00013	8b 4d 0c	 mov	 ecx, DWORD PTR __S2$[ebp]
  00016	51		 push	 ecx
  00017	8b 55 08	 mov	 edx, DWORD PTR __S1$[ebp]
  0001a	52		 push	 edx
  0001b	e8 00 00 00 00	 call	 _memcpy
  00020	83 c4 0c	 add	 esp, 12			; 0000000cH

; 237  :     }

  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
_wmemcpy ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __BC01C4E9_Character@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXIW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z PROC ; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __BC01C4E9_Character@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXW4align_val_t@std@@@Z ENDP ; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __BC01C4E9_Character@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCu
; File C:\Users\theob\Documents\GitHub\as-pts1\rendu2\Character.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b9 00 00 00 00	 mov	 ecx, OFFSET __BC01C4E9_Character@cpp
  00008	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0000d	5d		 pop	 ebp
  0000e	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
